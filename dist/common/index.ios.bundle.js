var __BUNDLE_START_TIME__=this.nativePerformanceNow?nativePerformanceNow():Date.now(),__DEV__=false,process=this.process||{},__METRO_GLOBAL_PREFIX__='';process.env=process.env||{};process.env.NODE_ENV=process.env.NODE_ENV||"production";
(function (global) {
  "use strict";

  global.__r = metroRequire;
  global[__METRO_GLOBAL_PREFIX__ + "__d"] = define;
  global.__c = clear;
  global.__registerSegment = registerSegment;
  var modules = clear();
  var EMPTY = {};
  var _ref = {},
      hasOwnProperty = _ref.hasOwnProperty;

  function clear() {
    modules = Object.create(null);
    return modules;
  }

  function define(factory, moduleId, dependencyMap) {
    if (modules[moduleId] != null) {
      return;
    }

    var mod = {
      dependencyMap: dependencyMap,
      factory: factory,
      hasError: false,
      importedAll: EMPTY,
      importedDefault: EMPTY,
      isInitialized: false,
      publicModule: {
        exports: {}
      }
    };
    modules[moduleId] = mod;
  }

  function metroRequire(moduleId) {
    var moduleIdReallyIsNumber = moduleId;
    var module = modules[moduleIdReallyIsNumber];
    return module && module.isInitialized ? module.publicModule.exports : guardedLoadModule(moduleIdReallyIsNumber, module);
  }

  function metroImportDefault(moduleId) {
    var moduleIdReallyIsNumber = moduleId;

    if (modules[moduleIdReallyIsNumber] && modules[moduleIdReallyIsNumber].importedDefault !== EMPTY) {
      return modules[moduleIdReallyIsNumber].importedDefault;
    }

    var exports = metroRequire(moduleIdReallyIsNumber);
    var importedDefault = exports && exports.__esModule ? exports.default : exports;
    return modules[moduleIdReallyIsNumber].importedDefault = importedDefault;
  }

  metroRequire.importDefault = metroImportDefault;

  function metroImportAll(moduleId) {
    var moduleIdReallyIsNumber = moduleId;

    if (modules[moduleIdReallyIsNumber] && modules[moduleIdReallyIsNumber].importedAll !== EMPTY) {
      return modules[moduleIdReallyIsNumber].importedAll;
    }

    var exports = metroRequire(moduleIdReallyIsNumber);
    var importedAll;

    if (exports && exports.__esModule) {
      importedAll = exports;
    } else {
      importedAll = {};

      if (exports) {
        for (var key in exports) {
          if (hasOwnProperty.call(exports, key)) {
            importedAll[key] = exports[key];
          }
        }
      }

      importedAll.default = exports;
    }

    return modules[moduleIdReallyIsNumber].importedAll = importedAll;
  }

  metroRequire.importAll = metroImportAll;
  var inGuard = false;

  function guardedLoadModule(moduleId, module) {
    if (!inGuard && global.ErrorUtils) {
      inGuard = true;
      var returnValue;

      try {
        returnValue = loadModuleImplementation(moduleId, module);
      } catch (e) {
        global.ErrorUtils.reportFatalError(e);
      }

      inGuard = false;
      return returnValue;
    } else {
      return loadModuleImplementation(moduleId, module);
    }
  }

  var ID_MASK_SHIFT = 16;
  var LOCAL_ID_MASK = 65535;

  function unpackModuleId(moduleId) {
    var segmentId = moduleId >>> ID_MASK_SHIFT;
    var localId = moduleId & LOCAL_ID_MASK;
    return {
      segmentId: segmentId,
      localId: localId
    };
  }

  metroRequire.unpackModuleId = unpackModuleId;

  function packModuleId(value) {
    return (value.segmentId << ID_MASK_SHIFT) + value.localId;
  }

  metroRequire.packModuleId = packModuleId;
  var moduleDefinersBySegmentID = [];
  var definingSegmentByModuleID = new Map();

  function registerSegment(segmentId, moduleDefiner, moduleIds) {
    moduleDefinersBySegmentID[segmentId] = moduleDefiner;

    if (moduleIds) {
      moduleIds.forEach(function (moduleId) {
        if (!modules[moduleId] && !definingSegmentByModuleID.has(moduleId)) {
          definingSegmentByModuleID.set(moduleId, segmentId);
        }
      });
    }
  }

  function loadModuleImplementation(moduleId, module) {
    if (!module && moduleDefinersBySegmentID.length > 0) {
      var _definingSegmentByMod;

      var segmentId = (_definingSegmentByMod = definingSegmentByModuleID.get(moduleId)) !== null && _definingSegmentByMod !== undefined ? _definingSegmentByMod : 0;
      var definer = moduleDefinersBySegmentID[segmentId];

      if (definer != null) {
        definer(moduleId);
        module = modules[moduleId];
        definingSegmentByModuleID.delete(moduleId);
      }
    }

    var nativeRequire = global.nativeRequire;

    if (!module && nativeRequire) {
      var _unpackModuleId = unpackModuleId(moduleId),
          _segmentId = _unpackModuleId.segmentId,
          localId = _unpackModuleId.localId;

      nativeRequire(localId, _segmentId);
      module = modules[moduleId];
    }

    if (!module) {
      throw unknownModuleError(moduleId);
    }

    if (module.hasError) {
      throw moduleThrewError(moduleId, module.error);
    }

    module.isInitialized = true;
    var _module = module,
        factory = _module.factory,
        dependencyMap = _module.dependencyMap;

    try {
      var moduleObject = module.publicModule;
      moduleObject.id = moduleId;
      factory(global, metroRequire, metroImportDefault, metroImportAll, moduleObject, moduleObject.exports, dependencyMap);
      {
        module.factory = undefined;
        module.dependencyMap = undefined;
      }
      return moduleObject.exports;
    } catch (e) {
      module.hasError = true;
      module.error = e;
      module.isInitialized = false;
      module.publicModule.exports = undefined;
      throw e;
    } finally {}
  }

  function unknownModuleError(id) {
    var message = 'Requiring unknown module "' + id + '".';
    return Error(message);
  }

  function moduleThrewError(id, error) {
    var displayName = id;
    return Error('Requiring module "' + displayName + '", which threw an exception: ' + error);
  }
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  var inspect = function () {
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        formatValueCalls: 0,
        stylize: stylizeNoColor
      };
      return formatValue(ctx, obj, opts.depth);
    }

    function stylizeNoColor(str, styleType) {
      return str;
    }

    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }

    function formatValue(ctx, value, recurseTimes) {
      ctx.formatValueCalls++;

      if (ctx.formatValueCalls > 200) {
        return "[TOO BIG formatValueCalls " + ctx.formatValueCalls + " exceeded limit of 200]";
      }

      var primitive = formatPrimitive(ctx, value);

      if (primitive) {
        return primitive;
      }

      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }

        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }

        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }

        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '',
          array = false,
          braces = ['{', '}'];

      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }

      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);
      var output;

      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }

    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, 'string');
      }

      if (isNumber(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
      if (isNull(value)) return ctx.stylize('null', 'null');
    }

    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }

    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];

      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }

      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }

    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
      };

      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }

      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }

      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }

          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }

      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }

        name = JSON.stringify('' + key);

        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }

    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function (prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    function isArray(ar) {
      return Array.isArray(ar);
    }

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }

    function isNull(arg) {
      return arg === null;
    }

    function isNumber(arg) {
      return typeof arg === 'number';
    }

    function isString(arg) {
      return typeof arg === 'string';
    }

    function isUndefined(arg) {
      return arg === undefined;
    }

    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }

    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }

    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }

    function isFunction(arg) {
      return typeof arg === 'function';
    }

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }

    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    return inspect;
  }();

  var OBJECT_COLUMN_NAME = '(index)';
  var LOG_LEVELS = {
    trace: 0,
    info: 1,
    warn: 2,
    error: 3
  };
  var INSPECTOR_LEVELS = [];
  INSPECTOR_LEVELS[LOG_LEVELS.trace] = 'debug';
  INSPECTOR_LEVELS[LOG_LEVELS.info] = 'log';
  INSPECTOR_LEVELS[LOG_LEVELS.warn] = 'warning';
  INSPECTOR_LEVELS[LOG_LEVELS.error] = 'error';
  var INSPECTOR_FRAMES_TO_SKIP = 1;

  function getNativeLogFunction(level) {
    return function () {
      var str;

      if (arguments.length === 1 && typeof arguments[0] === 'string') {
        str = arguments[0];
      } else {
        str = Array.prototype.map.call(arguments, function (arg) {
          return inspect(arg, {
            depth: 10
          });
        }).join(', ');
      }

      var firstArg = arguments[0];
      var logLevel = level;

      if (typeof firstArg === 'string' && firstArg.slice(0, 9) === 'Warning: ' && logLevel >= LOG_LEVELS.error) {
        logLevel = LOG_LEVELS.warn;
      }

      if (global.__inspectorLog) {
        global.__inspectorLog(INSPECTOR_LEVELS[logLevel], str, [].slice.call(arguments), INSPECTOR_FRAMES_TO_SKIP);
      }

      if (groupStack.length) {
        str = groupFormat('', str);
      }

      global.nativeLoggingHook(str, logLevel);
    };
  }

  function repeat(element, n) {
    return Array.apply(null, Array(n)).map(function () {
      return element;
    });
  }

  function consoleTablePolyfill(rows) {
    if (!Array.isArray(rows)) {
      var data = rows;
      rows = [];

      for (var key in data) {
        if (data.hasOwnProperty(key)) {
          var row = data[key];
          row[OBJECT_COLUMN_NAME] = key;
          rows.push(row);
        }
      }
    }

    if (rows.length === 0) {
      global.nativeLoggingHook('', LOG_LEVELS.info);
      return;
    }

    var columns = Object.keys(rows[0]).sort();
    var stringRows = [];
    var columnWidths = [];
    columns.forEach(function (k, i) {
      columnWidths[i] = k.length;

      for (var j = 0; j < rows.length; j++) {
        var cellStr = (rows[j][k] || '?').toString();
        stringRows[j] = stringRows[j] || [];
        stringRows[j][i] = cellStr;
        columnWidths[i] = Math.max(columnWidths[i], cellStr.length);
      }
    });

    function joinRow(row, space) {
      var cells = row.map(function (cell, i) {
        var extraSpaces = repeat(' ', columnWidths[i] - cell.length).join('');
        return cell + extraSpaces;
      });
      space = space || ' ';
      return cells.join(space + '|' + space);
    }

    var separators = columnWidths.map(function (columnWidth) {
      return repeat('-', columnWidth).join('');
    });
    var separatorRow = joinRow(separators, '-');
    var header = joinRow(columns);
    var table = [header, separatorRow];

    for (var i = 0; i < rows.length; i++) {
      table.push(joinRow(stringRows[i]));
    }

    global.nativeLoggingHook('\n' + table.join('\n'), LOG_LEVELS.info);
  }

  var GROUP_PAD = "\u2502";
  var GROUP_OPEN = "\u2510";
  var GROUP_CLOSE = "\u2518";
  var groupStack = [];

  function groupFormat(prefix, msg) {
    return groupStack.join('') + prefix + ' ' + (msg || '');
  }

  function consoleGroupPolyfill(label) {
    global.nativeLoggingHook(groupFormat(GROUP_OPEN, label), LOG_LEVELS.info);
    groupStack.push(GROUP_PAD);
  }

  function consoleGroupCollapsedPolyfill(label) {
    global.nativeLoggingHook(groupFormat(GROUP_CLOSE, label), LOG_LEVELS.info);
    groupStack.push(GROUP_PAD);
  }

  function consoleGroupEndPolyfill() {
    groupStack.pop();
    global.nativeLoggingHook(groupFormat(GROUP_CLOSE), LOG_LEVELS.info);
  }

  function consoleAssertPolyfill(expression, label) {
    if (!expression) {
      global.nativeLoggingHook('Assertion failed: ' + label, LOG_LEVELS.error);
    }
  }

  if (global.nativeLoggingHook) {
    var originalConsole = global.console;
    global.console = {
      error: getNativeLogFunction(LOG_LEVELS.error),
      info: getNativeLogFunction(LOG_LEVELS.info),
      log: getNativeLogFunction(LOG_LEVELS.info),
      warn: getNativeLogFunction(LOG_LEVELS.warn),
      trace: getNativeLogFunction(LOG_LEVELS.trace),
      debug: getNativeLogFunction(LOG_LEVELS.trace),
      table: consoleTablePolyfill,
      group: consoleGroupPolyfill,
      groupEnd: consoleGroupEndPolyfill,
      groupCollapsed: consoleGroupCollapsedPolyfill,
      assert: consoleAssertPolyfill
    };
    Object.defineProperty(console, '_isPolyfilled', {
      value: true,
      enumerable: false
    });
  } else if (!global.console) {
    function stub() {}

    var log = global.print || stub;
    global.console = {
      debug: log,
      error: log,
      info: log,
      log: log,
      trace: log,
      warn: log,
      assert: function assert(expression, label) {
        if (!expression) {
          log('Assertion failed: ' + label);
        }
      },
      clear: stub,
      dir: stub,
      dirxml: stub,
      group: stub,
      groupCollapsed: stub,
      groupEnd: stub,
      profile: stub,
      profileEnd: stub,
      table: stub
    };
    Object.defineProperty(console, '_isPolyfilled', {
      value: true,
      enumerable: false
    });
  }
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  var _inGuard = 0;

  var _globalHandler = function onError(e, isFatal) {
    throw e;
  };

  var ErrorUtils = {
    setGlobalHandler: function setGlobalHandler(fun) {
      _globalHandler = fun;
    },
    getGlobalHandler: function getGlobalHandler() {
      return _globalHandler;
    },
    reportError: function reportError(error) {
      _globalHandler && _globalHandler(error, false);
    },
    reportFatalError: function reportFatalError(error) {
      _globalHandler && _globalHandler(error, true);
    },
    applyWithGuard: function applyWithGuard(fun, context, args, unused_onError, unused_name) {
      try {
        _inGuard++;
        return fun.apply(context, args);
      } catch (e) {
        ErrorUtils.reportError(e);
      } finally {
        _inGuard--;
      }

      return null;
    },
    applyWithGuardIfNeeded: function applyWithGuardIfNeeded(fun, context, args) {
      if (ErrorUtils.inGuard()) {
        return fun.apply(context, args);
      } else {
        ErrorUtils.applyWithGuard(fun, context, args);
      }

      return null;
    },
    inGuard: function inGuard() {
      return !!_inGuard;
    },
    guard: function guard(fun, name, context) {
      var _ref;

      if (typeof fun !== 'function') {
        console.warn('A function must be passed to ErrorUtils.guard, got ', fun);
        return null;
      }

      var guardName = (_ref = name != null ? name : fun.name) != null ? _ref : '<generated guard>';

      function guarded() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return ErrorUtils.applyWithGuard(fun, context != null ? context : this, args, null, guardName);
      }

      return guarded;
    }
  };
  global.ErrorUtils = ErrorUtils;
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  (function () {
    'use strict';

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    if (typeof Object.entries !== 'function') {
      Object.entries = function (object) {
        if (object == null) {
          throw new TypeError('Object.entries called on non-object');
        }

        var entries = [];

        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            entries.push([key, object[key]]);
          }
        }

        return entries;
      };
    }

    if (typeof Object.values !== 'function') {
      Object.values = function (object) {
        if (object == null) {
          throw new TypeError('Object.values called on non-object');
        }

        var values = [];

        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            values.push(object[key]);
          }
        }

        return values;
      };
    }
  })();
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  _$$_REQUIRE(_dependencyMap[0]);

  _$$_REQUIRE(_dependencyMap[1]);

  _$$_REQUIRE(_dependencyMap[2]);

  _$$_REQUIRE(_dependencyMap[3]);
},"common.bundle.js",["node_modules/react-native/index.js","node_modules/react/index.js","node_modules/@react-navigation/native/src/index.tsx","node_modules/@react-navigation/stack/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = {
    get AccessibilityInfo() {
      return _$$_REQUIRE(_dependencyMap[0]).default;
    },

    get ActivityIndicator() {
      return _$$_REQUIRE(_dependencyMap[1]);
    },

    get Button() {
      return _$$_REQUIRE(_dependencyMap[2]);
    },

    get DatePickerIOS() {
      _$$_REQUIRE(_dependencyMap[3])('DatePickerIOS-merged', "DatePickerIOS has been merged with DatePickerAndroid and will be removed in a future release. It can now be installed and imported from '@react-native-community/datetimepicker' instead of 'react-native'. See https://github.com/react-native-datetimepicker/datetimepicker");

      return _$$_REQUIRE(_dependencyMap[4]);
    },

    get DrawerLayoutAndroid() {
      return _$$_REQUIRE(_dependencyMap[5]);
    },

    get FlatList() {
      return _$$_REQUIRE(_dependencyMap[6]);
    },

    get Image() {
      return _$$_REQUIRE(_dependencyMap[7]);
    },

    get ImageBackground() {
      return _$$_REQUIRE(_dependencyMap[8]);
    },

    get InputAccessoryView() {
      return _$$_REQUIRE(_dependencyMap[9]);
    },

    get KeyboardAvoidingView() {
      return _$$_REQUIRE(_dependencyMap[10]).default;
    },

    get MaskedViewIOS() {
      _$$_REQUIRE(_dependencyMap[3])('maskedviewios-moved', "MaskedViewIOS has been extracted from react-native core and will be removed in a future release. It can now be installed and imported from '@react-native-masked-view/masked-view' instead of 'react-native'. See https://github.com/react-native-masked-view/masked-view");

      return _$$_REQUIRE(_dependencyMap[11]);
    },

    get Modal() {
      return _$$_REQUIRE(_dependencyMap[12]);
    },

    get Pressable() {
      return _$$_REQUIRE(_dependencyMap[13]).default;
    },

    get ProgressBarAndroid() {
      _$$_REQUIRE(_dependencyMap[3])('progress-bar-android-moved', "ProgressBarAndroid has been extracted from react-native core and will be removed in a future release. It can now be installed and imported from '@react-native-community/progress-bar-android' instead of 'react-native'. See https://github.com/react-native-progress-view/progress-bar-android");

      return _$$_REQUIRE(_dependencyMap[14]);
    },

    get ProgressViewIOS() {
      _$$_REQUIRE(_dependencyMap[3])('progress-view-ios-moved', "ProgressViewIOS has been extracted from react-native core and will be removed in a future release. It can now be installed and imported from '@react-native-community/progress-view' instead of 'react-native'. See https://github.com/react-native-progress-view/progress-view");

      return _$$_REQUIRE(_dependencyMap[15]);
    },

    get RefreshControl() {
      return _$$_REQUIRE(_dependencyMap[16]);
    },

    get SafeAreaView() {
      return _$$_REQUIRE(_dependencyMap[17]).default;
    },

    get ScrollView() {
      return _$$_REQUIRE(_dependencyMap[18]);
    },

    get SectionList() {
      return _$$_REQUIRE(_dependencyMap[19]).default;
    },

    get SegmentedControlIOS() {
      _$$_REQUIRE(_dependencyMap[3])('segmented-control-ios-moved', "SegmentedControlIOS has been extracted from react-native core and will be removed in a future release. It can now be installed and imported from '@react-native-segmented-control/segmented-control' instead of 'react-native'. See https://github.com/react-native-segmented-control/segmented-control");

      return _$$_REQUIRE(_dependencyMap[20]);
    },

    get Slider() {
      _$$_REQUIRE(_dependencyMap[3])('slider-moved', "Slider has been extracted from react-native core and will be removed in a future release. It can now be installed and imported from '@react-native-community/slider' instead of 'react-native'. See https://github.com/callstack/react-native-slider");

      return _$$_REQUIRE(_dependencyMap[21]);
    },

    get StatusBar() {
      return _$$_REQUIRE(_dependencyMap[22]);
    },

    get Switch() {
      return _$$_REQUIRE(_dependencyMap[23]).default;
    },

    get Text() {
      return _$$_REQUIRE(_dependencyMap[24]);
    },

    get TextInput() {
      return _$$_REQUIRE(_dependencyMap[25]);
    },

    get Touchable() {
      return _$$_REQUIRE(_dependencyMap[26]);
    },

    get TouchableHighlight() {
      return _$$_REQUIRE(_dependencyMap[27]);
    },

    get TouchableNativeFeedback() {
      return _$$_REQUIRE(_dependencyMap[28]);
    },

    get TouchableOpacity() {
      return _$$_REQUIRE(_dependencyMap[29]);
    },

    get TouchableWithoutFeedback() {
      return _$$_REQUIRE(_dependencyMap[30]);
    },

    get View() {
      return _$$_REQUIRE(_dependencyMap[31]);
    },

    get VirtualizedList() {
      return _$$_REQUIRE(_dependencyMap[32]);
    },

    get VirtualizedSectionList() {
      return _$$_REQUIRE(_dependencyMap[33]);
    },

    get ActionSheetIOS() {
      return _$$_REQUIRE(_dependencyMap[34]);
    },

    get Alert() {
      return _$$_REQUIRE(_dependencyMap[35]);
    },

    get Animated() {
      return _$$_REQUIRE(_dependencyMap[36]);
    },

    get Appearance() {
      return _$$_REQUIRE(_dependencyMap[37]);
    },

    get AppRegistry() {
      return _$$_REQUIRE(_dependencyMap[38]);
    },

    get AppState() {
      return _$$_REQUIRE(_dependencyMap[39]);
    },

    get AsyncStorage() {
      _$$_REQUIRE(_dependencyMap[3])('async-storage-moved', "AsyncStorage has been extracted from react-native core and will be removed in a future release. It can now be installed and imported from '@react-native-async-storage/async-storage' instead of 'react-native'. See https://github.com/react-native-async-storage/async-storage");

      return _$$_REQUIRE(_dependencyMap[40]);
    },

    get BackHandler() {
      return _$$_REQUIRE(_dependencyMap[41]);
    },

    get Clipboard() {
      _$$_REQUIRE(_dependencyMap[3])('clipboard-moved', "Clipboard has been extracted from react-native core and will be removed in a future release. It can now be installed and imported from '@react-native-clipboard/clipboard' instead of 'react-native'. See https://github.com/react-native-clipboard/clipboard");

      return _$$_REQUIRE(_dependencyMap[42]);
    },

    get DeviceInfo() {
      return _$$_REQUIRE(_dependencyMap[43]);
    },

    get DevSettings() {
      return _$$_REQUIRE(_dependencyMap[44]);
    },

    get Dimensions() {
      return _$$_REQUIRE(_dependencyMap[45]);
    },

    get Easing() {
      return _$$_REQUIRE(_dependencyMap[46]);
    },

    get findNodeHandle() {
      return _$$_REQUIRE(_dependencyMap[47]).findNodeHandle;
    },

    get I18nManager() {
      return _$$_REQUIRE(_dependencyMap[48]);
    },

    get ImagePickerIOS() {
      _$$_REQUIRE(_dependencyMap[3])('imagePickerIOS-moved', "ImagePickerIOS has been extracted from react-native core and will be removed in a future release. Please upgrade to use either '@react-native-community/react-native-image-picker' or 'expo-image-picker'. If you cannot upgrade to a different library, please install the deprecated '@react-native-community/image-picker-ios' package. See https://github.com/rnc-archive/react-native-image-picker-ios");

      return _$$_REQUIRE(_dependencyMap[49]);
    },

    get InteractionManager() {
      return _$$_REQUIRE(_dependencyMap[50]);
    },

    get Keyboard() {
      return _$$_REQUIRE(_dependencyMap[51]);
    },

    get LayoutAnimation() {
      return _$$_REQUIRE(_dependencyMap[52]);
    },

    get Linking() {
      return _$$_REQUIRE(_dependencyMap[53]);
    },

    get LogBox() {
      return _$$_REQUIRE(_dependencyMap[54]);
    },

    get NativeDialogManagerAndroid() {
      return _$$_REQUIRE(_dependencyMap[55]).default;
    },

    get NativeEventEmitter() {
      return _$$_REQUIRE(_dependencyMap[56]).default;
    },

    get Networking() {
      return _$$_REQUIRE(_dependencyMap[57]);
    },

    get PanResponder() {
      return _$$_REQUIRE(_dependencyMap[58]);
    },

    get PermissionsAndroid() {
      return _$$_REQUIRE(_dependencyMap[59]);
    },

    get PixelRatio() {
      return _$$_REQUIRE(_dependencyMap[60]);
    },

    get PushNotificationIOS() {
      _$$_REQUIRE(_dependencyMap[3])('pushNotificationIOS-moved', "PushNotificationIOS has been extracted from react-native core and will be removed in a future release. It can now be installed and imported from '@react-native-community/push-notification-ios' instead of 'react-native'. See https://github.com/react-native-push-notification-ios/push-notification-ios");

      return _$$_REQUIRE(_dependencyMap[61]);
    },

    get Settings() {
      return _$$_REQUIRE(_dependencyMap[62]);
    },

    get Share() {
      return _$$_REQUIRE(_dependencyMap[63]);
    },

    get StyleSheet() {
      return _$$_REQUIRE(_dependencyMap[64]);
    },

    get Systrace() {
      return _$$_REQUIRE(_dependencyMap[65]);
    },

    get ToastAndroid() {
      return _$$_REQUIRE(_dependencyMap[66]);
    },

    get TurboModuleRegistry() {
      return _$$_REQUIRE(_dependencyMap[67]);
    },

    get UIManager() {
      return _$$_REQUIRE(_dependencyMap[68]);
    },

    get unstable_batchedUpdates() {
      return _$$_REQUIRE(_dependencyMap[47]).unstable_batchedUpdates;
    },

    get useColorScheme() {
      return _$$_REQUIRE(_dependencyMap[69]).default;
    },

    get useWindowDimensions() {
      return _$$_REQUIRE(_dependencyMap[70]).default;
    },

    get UTFSequence() {
      return _$$_REQUIRE(_dependencyMap[71]);
    },

    get Vibration() {
      return _$$_REQUIRE(_dependencyMap[72]);
    },

    get YellowBox() {
      return _$$_REQUIRE(_dependencyMap[73]);
    },

    get DeviceEventEmitter() {
      return _$$_REQUIRE(_dependencyMap[74]).default;
    },

    get DynamicColorIOS() {
      return _$$_REQUIRE(_dependencyMap[75]).DynamicColorIOS;
    },

    get NativeAppEventEmitter() {
      return _$$_REQUIRE(_dependencyMap[76]);
    },

    get NativeModules() {
      return _$$_REQUIRE(_dependencyMap[77]);
    },

    get Platform() {
      return _$$_REQUIRE(_dependencyMap[78]);
    },

    get PlatformColor() {
      return _$$_REQUIRE(_dependencyMap[79]).PlatformColor;
    },

    get processColor() {
      return _$$_REQUIRE(_dependencyMap[80]);
    },

    get requireNativeComponent() {
      return _$$_REQUIRE(_dependencyMap[81]);
    },

    get RootTagContext() {
      return _$$_REQUIRE(_dependencyMap[82]).RootTagContext;
    },

    get unstable_enableLogBox() {
      return function () {
        return console.warn('LogBox is enabled by default so there is no need to call unstable_enableLogBox() anymore. This is a no op and will be removed in the next version.');
      };
    },

    get ColorPropType() {
      console.warn("ColorPropType will be removed from React Native. Migrate to ColorPropType exported from 'deprecated-react-native-prop-types'.");
      return _$$_REQUIRE(_dependencyMap[83]).ColorPropType;
    },

    get EdgeInsetsPropType() {
      console.warn("EdgeInsetsPropType will be removed from React Native. Migrate to EdgeInsetsPropType exported from 'deprecated-react-native-prop-types'.");
      return _$$_REQUIRE(_dependencyMap[83]).EdgeInsetsPropType;
    },

    get PointPropType() {
      console.warn("PointPropType will be removed from React Native. Migrate to PointPropType exported from 'deprecated-react-native-prop-types'.");
      return _$$_REQUIRE(_dependencyMap[83]).PointPropType;
    },

    get ViewPropTypes() {
      console.warn("ViewPropTypes will be removed from React Native. Migrate to ViewPropTypes exported from 'deprecated-react-native-prop-types'.");
      return _$$_REQUIRE(_dependencyMap[83]).ViewPropTypes;
    }

  };
},"node_modules/react-native/index.js",["node_modules/react-native/Libraries/Components/AccessibilityInfo/AccessibilityInfo.js","node_modules/react-native/Libraries/Components/ActivityIndicator/ActivityIndicator.js","node_modules/react-native/Libraries/Components/Button.js","node_modules/react-native/Libraries/Utilities/warnOnce.js","node_modules/react-native/Libraries/Components/DatePicker/DatePickerIOS.ios.js","node_modules/react-native/Libraries/Components/DrawerAndroid/DrawerLayoutAndroid.ios.js","node_modules/react-native/Libraries/Lists/FlatList.js","node_modules/react-native/Libraries/Image/Image.ios.js","node_modules/react-native/Libraries/Image/ImageBackground.js","node_modules/react-native/Libraries/Components/TextInput/InputAccessoryView.js","node_modules/react-native/Libraries/Components/Keyboard/KeyboardAvoidingView.js","node_modules/react-native/Libraries/Components/MaskedView/MaskedViewIOS.ios.js","node_modules/react-native/Libraries/Modal/Modal.js","node_modules/react-native/Libraries/Components/Pressable/Pressable.js","node_modules/react-native/Libraries/Components/ProgressBarAndroid/ProgressBarAndroid.ios.js","node_modules/react-native/Libraries/Components/ProgressViewIOS/ProgressViewIOS.ios.js","node_modules/react-native/Libraries/Components/RefreshControl/RefreshControl.js","node_modules/react-native/Libraries/Components/SafeAreaView/SafeAreaView.js","node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js","node_modules/react-native/Libraries/Lists/SectionList.js","node_modules/react-native/Libraries/Components/SegmentedControlIOS/SegmentedControlIOS.ios.js","node_modules/react-native/Libraries/Components/Slider/Slider.js","node_modules/react-native/Libraries/Components/StatusBar/StatusBar.js","node_modules/react-native/Libraries/Components/Switch/Switch.js","node_modules/react-native/Libraries/Text/Text.js","node_modules/react-native/Libraries/Components/TextInput/TextInput.js","node_modules/react-native/Libraries/Components/Touchable/Touchable.js","node_modules/react-native/Libraries/Components/Touchable/TouchableHighlight.js","node_modules/react-native/Libraries/Components/Touchable/TouchableNativeFeedback.js","node_modules/react-native/Libraries/Components/Touchable/TouchableOpacity.js","node_modules/react-native/Libraries/Components/Touchable/TouchableWithoutFeedback.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/react-native/Libraries/Lists/VirtualizedList.js","node_modules/react-native/Libraries/Lists/VirtualizedSectionList.js","node_modules/react-native/Libraries/ActionSheetIOS/ActionSheetIOS.js","node_modules/react-native/Libraries/Alert/Alert.js","node_modules/react-native/Libraries/Animated/Animated.js","node_modules/react-native/Libraries/Utilities/Appearance.js","node_modules/react-native/Libraries/ReactNative/AppRegistry.js","node_modules/react-native/Libraries/AppState/AppState.js","node_modules/react-native/Libraries/Storage/AsyncStorage.js","node_modules/react-native/Libraries/Utilities/BackHandler.ios.js","node_modules/react-native/Libraries/Components/Clipboard/Clipboard.js","node_modules/react-native/Libraries/Utilities/DeviceInfo.js","node_modules/react-native/Libraries/Utilities/DevSettings.js","node_modules/react-native/Libraries/Utilities/Dimensions.js","node_modules/react-native/Libraries/Animated/Easing.js","node_modules/react-native/Libraries/Renderer/shims/ReactNative.js","node_modules/react-native/Libraries/ReactNative/I18nManager.js","node_modules/react-native/Libraries/Image/ImagePickerIOS.js","node_modules/react-native/Libraries/Interaction/InteractionManager.js","node_modules/react-native/Libraries/Components/Keyboard/Keyboard.js","node_modules/react-native/Libraries/LayoutAnimation/LayoutAnimation.js","node_modules/react-native/Libraries/Linking/Linking.js","node_modules/react-native/Libraries/LogBox/LogBox.js","node_modules/react-native/Libraries/NativeModules/specs/NativeDialogManagerAndroid.js","node_modules/react-native/Libraries/EventEmitter/NativeEventEmitter.js","node_modules/react-native/Libraries/Network/RCTNetworking.ios.js","node_modules/react-native/Libraries/Interaction/PanResponder.js","node_modules/react-native/Libraries/PermissionsAndroid/PermissionsAndroid.js","node_modules/react-native/Libraries/Utilities/PixelRatio.js","node_modules/react-native/Libraries/PushNotificationIOS/PushNotificationIOS.js","node_modules/react-native/Libraries/Settings/Settings.ios.js","node_modules/react-native/Libraries/Share/Share.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Performance/Systrace.js","node_modules/react-native/Libraries/Components/ToastAndroid/ToastAndroid.ios.js","node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js","node_modules/react-native/Libraries/ReactNative/UIManager.js","node_modules/react-native/Libraries/Utilities/useColorScheme.js","node_modules/react-native/Libraries/Utilities/useWindowDimensions.js","node_modules/react-native/Libraries/UTFSequence.js","node_modules/react-native/Libraries/Vibration/Vibration.js","node_modules/react-native/Libraries/YellowBox/YellowBoxDeprecated.js","node_modules/react-native/Libraries/EventEmitter/RCTDeviceEventEmitter.js","node_modules/react-native/Libraries/StyleSheet/PlatformColorValueTypesIOS.ios.js","node_modules/react-native/Libraries/EventEmitter/RCTNativeAppEventEmitter.js","node_modules/react-native/Libraries/BatchedBridge/NativeModules.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/StyleSheet/PlatformColorValueTypes.ios.js","node_modules/react-native/Libraries/StyleSheet/processColor.js","node_modules/react-native/Libraries/ReactNative/requireNativeComponent.js","node_modules/react-native/Libraries/ReactNative/RootTag.js","node_modules/deprecated-react-native-prop-types/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _RCTDeviceEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _NativeAccessibilityInfo = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _NativeAccessibilityManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _legacySendAccessibilityEvent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var EventNames = _Platform.default.OS === 'android' ? new Map([['change', 'touchExplorationDidChange'], ['reduceMotionChanged', 'reduceMotionDidChange'], ['screenReaderChanged', 'touchExplorationDidChange'], ['accessibilityServiceChanged', 'accessibilityServiceDidChange']]) : new Map([['announcementFinished', 'announcementFinished'], ['boldTextChanged', 'boldTextChanged'], ['change', 'screenReaderChanged'], ['grayscaleChanged', 'grayscaleChanged'], ['invertColorsChanged', 'invertColorsChanged'], ['reduceMotionChanged', 'reduceMotionChanged'], ['reduceTransparencyChanged', 'reduceTransparencyChanged'], ['screenReaderChanged', 'screenReaderChanged']]);
  var AccessibilityInfo = {
    isBoldTextEnabled: function isBoldTextEnabled() {
      if (_Platform.default.OS === 'android') {
        return Promise.resolve(false);
      } else {
        return new Promise(function (resolve, reject) {
          if (_NativeAccessibilityManager.default != null) {
            _NativeAccessibilityManager.default.getCurrentBoldTextState(resolve, reject);
          } else {
            reject(null);
          }
        });
      }
    },
    isGrayscaleEnabled: function isGrayscaleEnabled() {
      if (_Platform.default.OS === 'android') {
        return Promise.resolve(false);
      } else {
        return new Promise(function (resolve, reject) {
          if (_NativeAccessibilityManager.default != null) {
            _NativeAccessibilityManager.default.getCurrentGrayscaleState(resolve, reject);
          } else {
            reject(null);
          }
        });
      }
    },
    isInvertColorsEnabled: function isInvertColorsEnabled() {
      if (_Platform.default.OS === 'android') {
        return Promise.resolve(false);
      } else {
        return new Promise(function (resolve, reject) {
          if (_NativeAccessibilityManager.default != null) {
            _NativeAccessibilityManager.default.getCurrentInvertColorsState(resolve, reject);
          } else {
            reject(null);
          }
        });
      }
    },
    isReduceMotionEnabled: function isReduceMotionEnabled() {
      return new Promise(function (resolve, reject) {
        if (_Platform.default.OS === 'android') {
          if (_NativeAccessibilityInfo.default != null) {
            _NativeAccessibilityInfo.default.isReduceMotionEnabled(resolve);
          } else {
            reject(null);
          }
        } else {
          if (_NativeAccessibilityManager.default != null) {
            _NativeAccessibilityManager.default.getCurrentReduceMotionState(resolve, reject);
          } else {
            reject(null);
          }
        }
      });
    },
    isReduceTransparencyEnabled: function isReduceTransparencyEnabled() {
      if (_Platform.default.OS === 'android') {
        return Promise.resolve(false);
      } else {
        return new Promise(function (resolve, reject) {
          if (_NativeAccessibilityManager.default != null) {
            _NativeAccessibilityManager.default.getCurrentReduceTransparencyState(resolve, reject);
          } else {
            reject(null);
          }
        });
      }
    },
    isScreenReaderEnabled: function isScreenReaderEnabled() {
      return new Promise(function (resolve, reject) {
        if (_Platform.default.OS === 'android') {
          if (_NativeAccessibilityInfo.default != null) {
            _NativeAccessibilityInfo.default.isTouchExplorationEnabled(resolve);
          } else {
            reject(null);
          }
        } else {
          if (_NativeAccessibilityManager.default != null) {
            _NativeAccessibilityManager.default.getCurrentVoiceOverState(resolve, reject);
          } else {
            reject(null);
          }
        }
      });
    },
    isAccessibilityServiceEnabled: function isAccessibilityServiceEnabled() {
      return new Promise(function (resolve, reject) {
        if (_Platform.default.OS === 'android') {
          if (_NativeAccessibilityInfo.default != null && _NativeAccessibilityInfo.default.isAccessibilityServiceEnabled != null) {
            _NativeAccessibilityInfo.default.isAccessibilityServiceEnabled(resolve);
          } else {
            reject(null);
          }
        } else {
          reject(null);
        }
      });
    },
    addEventListener: function addEventListener(eventName, handler) {
      var deviceEventName = EventNames.get(eventName);
      return deviceEventName == null ? {
        remove: function remove() {}
      } : _RCTDeviceEventEmitter.default.addListener(deviceEventName, handler);
    },
    setAccessibilityFocus: function setAccessibilityFocus(reactTag) {
      (0, _legacySendAccessibilityEvent.default)(reactTag, 'focus');
    },
    sendAccessibilityEvent_unstable: function sendAccessibilityEvent_unstable(handle, eventType) {
      if (_Platform.default.OS === 'ios' && eventType === 'click') {
        return;
      }

      (0, _$$_REQUIRE(_dependencyMap[6]).sendAccessibilityEvent)(handle, eventType);
    },
    announceForAccessibility: function announceForAccessibility(announcement) {
      if (_Platform.default.OS === 'android') {
        _NativeAccessibilityInfo.default == null ? undefined : _NativeAccessibilityInfo.default.announceForAccessibility(announcement);
      } else {
        _NativeAccessibilityManager.default == null ? undefined : _NativeAccessibilityManager.default.announceForAccessibility(announcement);
      }
    },
    announceForAccessibilityWithOptions: function announceForAccessibilityWithOptions(announcement, options) {
      if (_Platform.default.OS === 'android') {
        _NativeAccessibilityInfo.default == null ? undefined : _NativeAccessibilityInfo.default.announceForAccessibility(announcement);
      } else {
        if (_NativeAccessibilityManager.default != null && _NativeAccessibilityManager.default.announceForAccessibilityWithOptions) {
          _NativeAccessibilityManager.default == null ? undefined : _NativeAccessibilityManager.default.announceForAccessibilityWithOptions(announcement, options);
        } else {
          _NativeAccessibilityManager.default == null ? undefined : _NativeAccessibilityManager.default.announceForAccessibility(announcement);
        }
      }
    },
    removeEventListener: function removeEventListener(eventName, handler) {
      var deviceEventName = EventNames.get(eventName);

      if (deviceEventName != null) {
        _RCTDeviceEventEmitter.default.removeListener('deviceEventName', handler);
      }
    },
    getRecommendedTimeoutMillis: function getRecommendedTimeoutMillis(originalTimeout) {
      if (_Platform.default.OS === 'android') {
        return new Promise(function (resolve, reject) {
          if (_NativeAccessibilityInfo.default != null && _NativeAccessibilityInfo.default.getRecommendedTimeoutMillis) {
            _NativeAccessibilityInfo.default.getRecommendedTimeoutMillis(originalTimeout, resolve);
          } else {
            resolve(originalTimeout);
          }
        });
      } else {
        return Promise.resolve(originalTimeout);
      }
    }
  };
  var _default = AccessibilityInfo;
  exports.default = _default;
},"node_modules/react-native/Libraries/Components/AccessibilityInfo/AccessibilityInfo.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/EventEmitter/RCTDeviceEventEmitter.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/Components/AccessibilityInfo/NativeAccessibilityInfo.js","node_modules/react-native/Libraries/Components/AccessibilityInfo/NativeAccessibilityManager.js","node_modules/react-native/Libraries/Components/AccessibilityInfo/legacySendAccessibilityEvent.ios.js","node_modules/react-native/Libraries/Renderer/shims/ReactNative.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/interopRequireDefault.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _EventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _default = new _EventEmitter.default();

  exports.default = _default;
},"node_modules/react-native/Libraries/EventEmitter/RCTDeviceEventEmitter.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/vendor/emitter/EventEmitter.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.default = _$$_REQUIRE(_dependencyMap[0]);
},"node_modules/react-native/Libraries/vendor/emitter/EventEmitter.js",["node_modules/react-native/Libraries/vendor/emitter/_EventEmitter.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _EmitterSubscription = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _EventSubscriptionVendor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var sparseFilterPredicate = function sparseFilterPredicate() {
    return true;
  };

  var EventEmitter = function () {
    function EventEmitter(subscriber) {
      (0, _classCallCheck2.default)(this, EventEmitter);
      this._subscriber = new _EventSubscriptionVendor.default();

      if (subscriber != null) {
        console.warn('EventEmitter(...): Constructor argument is deprecated.');
        this._subscriber = subscriber;
      }
    }

    (0, _createClass2.default)(EventEmitter, [{
      key: "addListener",
      value: function addListener(eventType, listener, context) {
        return this._subscriber.addSubscription(eventType, new _EmitterSubscription.default(this, this._subscriber, listener, context));
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners(eventType) {
        this._subscriber.removeAllSubscriptions(eventType);
      }
    }, {
      key: "removeSubscription",
      value: function removeSubscription(subscription) {
        console.warn("EventEmitter.removeSubscription(...): Method has been deprecated. Please instead use `remove()` on the subscription itself.");

        this.__removeSubscription(subscription);
      }
    }, {
      key: "__removeSubscription",
      value: function __removeSubscription(subscription) {
        _$$_REQUIRE(_dependencyMap[5])(subscription.emitter === this, 'Subscription does not belong to this emitter.');

        this._subscriber.removeSubscription(subscription);
      }
    }, {
      key: "listenerCount",
      value: function listenerCount(eventType) {
        var subscriptions = this._subscriber.getSubscriptionsForType(eventType);

        return subscriptions ? subscriptions.filter(sparseFilterPredicate).length : 0;
      }
    }, {
      key: "emit",
      value: function emit(eventType) {
        var subscriptions = this._subscriber.getSubscriptionsForType(eventType);

        if (subscriptions) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          for (var i = 0, l = subscriptions.length; i < l; i++) {
            var subscription = subscriptions[i];

            if (subscription && subscription.listener) {
              subscription.listener.apply(subscription.context, args);
            }
          }
        }
      }
    }, {
      key: "removeListener",
      value: function removeListener(eventType, listener) {
        console.warn("EventEmitter.removeListener('" + eventType + "', ...): Method has been " + 'deprecated. Please instead use `remove()` on the subscription ' + 'returned by `EventEmitter.addListener`.');

        var subscriptions = this._subscriber.getSubscriptionsForType(eventType);

        if (subscriptions) {
          for (var i = 0, l = subscriptions.length; i < l; i++) {
            var subscription = subscriptions[i];

            if (subscription && subscription.listener === listener) {
              subscription.remove();
            }
          }
        }
      }
    }]);
    return EventEmitter;
  }();

  module.exports = EventEmitter;
},"node_modules/react-native/Libraries/vendor/emitter/_EventEmitter.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/vendor/emitter/_EmitterSubscription.js","node_modules/react-native/Libraries/vendor/emitter/_EventSubscriptionVendor.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/classCallCheck.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/createClass.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _EventSubscription3 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var EmitterSubscription = function (_EventSubscription2) {
    (0, _inherits2.default)(EmitterSubscription, _EventSubscription2);

    var _super = _createSuper(EmitterSubscription);

    function EmitterSubscription(emitter, subscriber, listener, context) {
      var _this;

      (0, _classCallCheck2.default)(this, EmitterSubscription);
      _this = _super.call(this, subscriber);
      _this.emitter = emitter;
      _this.listener = listener;
      _this.context = context;
      return _this;
    }

    (0, _createClass2.default)(EmitterSubscription, [{
      key: "remove",
      value: function remove() {
        this.emitter.__removeSubscription(this);
      }
    }]);
    return EmitterSubscription;
  }(_EventSubscription3.default);

  module.exports = EmitterSubscription;
},"node_modules/react-native/Libraries/vendor/emitter/_EmitterSubscription.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/vendor/emitter/_EventSubscription.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _$$_REQUIRE(_dependencyMap[0])(subClass, superClass);
  }

  module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/inherits.js",["node_modules/@babel/runtime/helpers/setPrototypeOf.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _setPrototypeOf(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _setPrototypeOf(o, p);
  }

  module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/setPrototypeOf.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _possibleConstructorReturn(self, call) {
    if (call && (_$$_REQUIRE(_dependencyMap[0])["default"](call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== undefined) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _$$_REQUIRE(_dependencyMap[1])(self);
  }

  module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/possibleConstructorReturn.js",["node_modules/@babel/runtime/helpers/typeof.js","node_modules/@babel/runtime/helpers/assertThisInitialized.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _typeof(obj) {
    "@babel/helpers - typeof";

    return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
  }

  module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/typeof.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _assertThisInitialized(self) {
    if (self === undefined) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/assertThisInitialized.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _getPrototypeOf(o) {
    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _getPrototypeOf(o);
  }

  module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/getPrototypeOf.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _EventSubscription = function () {
    function _EventSubscription(subscriber) {
      (0, _classCallCheck2.default)(this, _EventSubscription);
      this.subscriber = subscriber;
    }

    (0, _createClass2.default)(_EventSubscription, [{
      key: "remove",
      value: function remove() {
        this.subscriber.removeSubscription(this);
      }
    }]);
    return _EventSubscription;
  }();

  module.exports = _EventSubscription;
},"node_modules/react-native/Libraries/vendor/emitter/_EventSubscription.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var EventSubscriptionVendor = function () {
    function EventSubscriptionVendor() {
      _$$_REQUIRE(_dependencyMap[0])(this, EventSubscriptionVendor);

      this._subscriptionsForType = {};
    }

    _$$_REQUIRE(_dependencyMap[1])(EventSubscriptionVendor, [{
      key: "addSubscription",
      value: function addSubscription(eventType, subscription) {
        _$$_REQUIRE(_dependencyMap[2])(subscription.subscriber === this, 'The subscriber of the subscription is incorrectly set.');

        if (!this._subscriptionsForType[eventType]) {
          this._subscriptionsForType[eventType] = [];
        }

        var key = this._subscriptionsForType[eventType].length;

        this._subscriptionsForType[eventType].push(subscription);

        subscription.eventType = eventType;
        subscription.key = key;
        return subscription;
      }
    }, {
      key: "removeAllSubscriptions",
      value: function removeAllSubscriptions(eventType) {
        if (eventType == null) {
          this._subscriptionsForType = {};
        } else {
          delete this._subscriptionsForType[eventType];
        }
      }
    }, {
      key: "removeSubscription",
      value: function removeSubscription(subscription) {
        var eventType = subscription.eventType;
        var key = subscription.key;
        var subscriptionsForType = this._subscriptionsForType[eventType];

        if (subscriptionsForType) {
          delete subscriptionsForType[key];
        }
      }
    }, {
      key: "getSubscriptionsForType",
      value: function getSubscriptionsForType(eventType) {
        return this._subscriptionsForType[eventType];
      }
    }]);

    return EventSubscriptionVendor;
  }();

  module.exports = EventSubscriptionVendor;
},"node_modules/react-native/Libraries/vendor/emitter/_EventSubscriptionVendor.js",["node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var invariant = function invariant(condition, format, a, b, c, d, e, f) {
    if (!condition) {
      var error;

      if (format === undefined) {
        error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1;
      throw error;
    }
  };

  module.exports = invariant;
},"node_modules/invariant/browser.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _NativePlatformConstantsIOS = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var Platform = {
    __constants: null,
    OS: 'ios',

    get Version() {
      return this.constants.osVersion;
    },

    get constants() {
      if (this.__constants == null) {
        this.__constants = _NativePlatformConstantsIOS.default.getConstants();
      }

      return this.__constants;
    },

    get isPad() {
      return this.constants.interfaceIdiom === 'pad';
    },

    get isTVOS() {
      return Platform.isTV;
    },

    get isTV() {
      return this.constants.interfaceIdiom === 'tv';
    },

    get isTesting() {
      return false;
    },

    select: function select(spec) {
      return 'ios' in spec ? spec.ios : 'native' in spec ? spec.native : spec.default;
    }
  };
  module.exports = Platform;
},"node_modules/react-native/Libraries/Utilities/Platform.ios.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/NativePlatformConstantsIOS.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.getEnforcing('PlatformConstants');

  exports.default = _default;
},"node_modules/react-native/Libraries/Utilities/NativePlatformConstantsIOS.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.get = get;
  exports.getEnforcing = getEnforcing;

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var turboModuleProxy = global.__turboModuleProxy;

  function requireModule(name) {
    if (global.RN$Bridgeless !== true) {
      var legacyModule = _$$_REQUIRE(_dependencyMap[2])[name];

      if (legacyModule != null) {
        return legacyModule;
      }
    }

    if (turboModuleProxy != null) {
      var module = turboModuleProxy(name);
      return module;
    }

    return null;
  }

  function get(name) {
    return requireModule(name);
  }

  function getEnforcing(name) {
    var module = requireModule(name);
    (0, _invariant.default)(module != null, "TurboModuleRegistry.getEnforcing(...): '" + name + "' could not be found. " + 'Verify that a module by this name is registered in the native binary.');
    return module;
  }
},"node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/BatchedBridge/NativeModules.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function genModule(config, moduleID) {
    if (!config) {
      return null;
    }

    var _config = _$$_REQUIRE(_dependencyMap[0])(config, 5),
        moduleName = _config[0],
        constants = _config[1],
        methods = _config[2],
        promiseMethods = _config[3],
        syncMethods = _config[4];

    _$$_REQUIRE(_dependencyMap[1])(!moduleName.startsWith('RCT') && !moduleName.startsWith('RK'), "Module name prefixes should've been stripped by the native side but wasn't for " + moduleName);

    if (!constants && !methods) {
      return {
        name: moduleName
      };
    }

    var module = {};
    methods && methods.forEach(function (methodName, methodID) {
      var isPromise = promiseMethods && arrayContains(promiseMethods, methodID) || false;
      var isSync = syncMethods && arrayContains(syncMethods, methodID) || false;

      _$$_REQUIRE(_dependencyMap[1])(!isPromise || !isSync, 'Cannot have a method that is both async and a sync hook');

      var methodType = isPromise ? 'promise' : isSync ? 'sync' : 'async';
      module[methodName] = genMethod(moduleID, methodID, methodType);
    });

    _$$_REQUIRE(_dependencyMap[2])(module, constants);

    if (module.getConstants == null) {
      module.getConstants = function () {
        return constants || Object.freeze({});
      };
    } else {
      console.warn("Unable to define method 'getConstants()' on NativeModule '" + moduleName + "'. NativeModule '" + moduleName + "' already has a constant or method called 'getConstants'. Please remove it.");
    }

    return {
      name: moduleName,
      module: module
    };
  }

  global.__fbGenNativeModule = genModule;

  function loadModule(name, moduleID) {
    _$$_REQUIRE(_dependencyMap[1])(global.nativeRequireModuleConfig, "Can't lazily create module without nativeRequireModuleConfig");

    var config = global.nativeRequireModuleConfig(name);
    var info = genModule(config, moduleID);
    return info && info.module;
  }

  function genMethod(moduleID, methodID, type) {
    var fn = null;

    if (type === 'promise') {
      fn = function promiseMethodWrapper() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var enqueueingFrameError = new Error();
        return new Promise(function (resolve, reject) {
          _$$_REQUIRE(_dependencyMap[3]).enqueueNativeCall(moduleID, methodID, args, function (data) {
            return resolve(data);
          }, function (errorData) {
            return reject(updateErrorWithErrorData(errorData, enqueueingFrameError));
          });
        });
      };
    } else {
      fn = function nonPromiseMethodWrapper() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        var lastArg = args.length > 0 ? args[args.length - 1] : null;
        var secondLastArg = args.length > 1 ? args[args.length - 2] : null;
        var hasSuccessCallback = typeof lastArg === 'function';
        var hasErrorCallback = typeof secondLastArg === 'function';
        hasErrorCallback && _$$_REQUIRE(_dependencyMap[1])(hasSuccessCallback, 'Cannot have a non-function arg after a function arg.');
        var onSuccess = hasSuccessCallback ? lastArg : null;
        var onFail = hasErrorCallback ? secondLastArg : null;
        var callbackCount = hasSuccessCallback + hasErrorCallback;
        var newArgs = args.slice(0, args.length - callbackCount);

        if (type === 'sync') {
          return _$$_REQUIRE(_dependencyMap[3]).callNativeSyncHook(moduleID, methodID, newArgs, onFail, onSuccess);
        } else {
          _$$_REQUIRE(_dependencyMap[3]).enqueueNativeCall(moduleID, methodID, newArgs, onFail, onSuccess);
        }
      };
    }

    fn.type = type;
    return fn;
  }

  function arrayContains(array, value) {
    return array.indexOf(value) !== -1;
  }

  function updateErrorWithErrorData(errorData, error) {
    return _$$_REQUIRE(_dependencyMap[2])(error, errorData || {});
  }

  var NativeModules = {};

  if (global.nativeModuleProxy) {
    NativeModules = global.nativeModuleProxy;
  } else if (!global.nativeExtensions) {
    var bridgeConfig = global.__fbBatchedBridgeConfig;

    _$$_REQUIRE(_dependencyMap[1])(bridgeConfig, '__fbBatchedBridgeConfig is not set, cannot invoke native modules');

    var defineLazyObjectProperty = _$$_REQUIRE(_dependencyMap[4]);

    (bridgeConfig.remoteModuleConfig || []).forEach(function (config, moduleID) {
      var info = genModule(config, moduleID);

      if (!info) {
        return;
      }

      if (info.module) {
        NativeModules[info.name] = info.module;
      } else {
        defineLazyObjectProperty(NativeModules, info.name, {
          get: function get() {
            return loadModule(info.name, moduleID);
          }
        });
      }
    });
  }

  module.exports = NativeModules;
},"node_modules/react-native/Libraries/BatchedBridge/NativeModules.js",["node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/invariant/browser.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/BatchedBridge/BatchedBridge.js","node_modules/react-native/Libraries/Utilities/defineLazyObjectProperty.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _slicedToArray(arr, i) {
    return _$$_REQUIRE(_dependencyMap[0])(arr) || _$$_REQUIRE(_dependencyMap[1])(arr, i) || _$$_REQUIRE(_dependencyMap[2])(arr, i) || _$$_REQUIRE(_dependencyMap[3])();
  }

  module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/slicedToArray.js",["node_modules/@babel/runtime/helpers/arrayWithHoles.js","node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","node_modules/@babel/runtime/helpers/nonIterableRest.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/arrayWithHoles.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/iterableToArrayLimit.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _$$_REQUIRE(_dependencyMap[0])(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _$$_REQUIRE(_dependencyMap[0])(o, minLen);
  }

  module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js",["node_modules/@babel/runtime/helpers/arrayLikeToArray.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/arrayLikeToArray.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/nonIterableRest.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _extends() {
    module.exports = _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _extends.apply(this, arguments);
  }

  module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/extends.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var BatchedBridge = new (_$$_REQUIRE(_dependencyMap[0]))();
  Object.defineProperty(global, '__fbBatchedBridge', {
    configurable: true,
    value: BatchedBridge
  });
  module.exports = BatchedBridge;
},"node_modules/react-native/Libraries/BatchedBridge/BatchedBridge.js",["node_modules/react-native/Libraries/BatchedBridge/MessageQueue.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var TO_JS = 0;
  var TO_NATIVE = 1;
  var MODULE_IDS = 0;
  var METHOD_IDS = 1;
  var PARAMS = 2;
  var MIN_TIME_BETWEEN_FLUSHES_MS = 5;
  var TRACE_TAG_REACT_APPS = 131072;
  var DEBUG_INFO_LIMIT = 32;

  var MessageQueue = function () {
    function MessageQueue() {
      _$$_REQUIRE(_dependencyMap[0])(this, MessageQueue);

      this._lazyCallableModules = {};
      this._queue = [[], [], [], 0];
      this._successCallbacks = new Map();
      this._failureCallbacks = new Map();
      this._callID = 0;
      this._lastFlush = 0;
      this._eventLoopStartTime = Date.now();
      this._reactNativeMicrotasksCallback = null;
      this.callFunctionReturnFlushedQueue = this.callFunctionReturnFlushedQueue.bind(this);
      this.flushedQueue = this.flushedQueue.bind(this);
      this.invokeCallbackAndReturnFlushedQueue = this.invokeCallbackAndReturnFlushedQueue.bind(this);
    }

    _$$_REQUIRE(_dependencyMap[1])(MessageQueue, [{
      key: "callFunctionReturnFlushedQueue",
      value: function callFunctionReturnFlushedQueue(module, method, args) {
        var _this = this;

        this.__guard(function () {
          _this.__callFunction(module, method, args);
        });

        return this.flushedQueue();
      }
    }, {
      key: "invokeCallbackAndReturnFlushedQueue",
      value: function invokeCallbackAndReturnFlushedQueue(cbID, args) {
        var _this2 = this;

        this.__guard(function () {
          _this2.__invokeCallback(cbID, args);
        });

        return this.flushedQueue();
      }
    }, {
      key: "flushedQueue",
      value: function flushedQueue() {
        var _this3 = this;

        this.__guard(function () {
          _this3.__callReactNativeMicrotasks();
        });

        var queue = this._queue;
        this._queue = [[], [], [], this._callID];
        return queue[0].length ? queue : null;
      }
    }, {
      key: "getEventLoopRunningTime",
      value: function getEventLoopRunningTime() {
        return Date.now() - this._eventLoopStartTime;
      }
    }, {
      key: "registerCallableModule",
      value: function registerCallableModule(name, module) {
        this._lazyCallableModules[name] = function () {
          return module;
        };
      }
    }, {
      key: "registerLazyCallableModule",
      value: function registerLazyCallableModule(name, factory) {
        var module;
        var getValue = factory;

        this._lazyCallableModules[name] = function () {
          if (getValue) {
            module = getValue();
            getValue = null;
          }

          return module;
        };
      }
    }, {
      key: "getCallableModule",
      value: function getCallableModule(name) {
        var getValue = this._lazyCallableModules[name];
        return getValue ? getValue() : null;
      }
    }, {
      key: "callNativeSyncHook",
      value: function callNativeSyncHook(moduleID, methodID, params, onFail, onSucc) {
        this.processCallbacks(moduleID, methodID, params, onFail, onSucc);
        return global.nativeCallSyncHook(moduleID, methodID, params);
      }
    }, {
      key: "processCallbacks",
      value: function processCallbacks(moduleID, methodID, params, onFail, onSucc) {
        var _this4 = this;

        if (onFail || onSucc) {
          onFail && params.push(this._callID << 1);
          onSucc && params.push(this._callID << 1 | 1);

          this._successCallbacks.set(this._callID, onSucc);

          this._failureCallbacks.set(this._callID, onFail);
        }

        this._callID++;
      }
    }, {
      key: "enqueueNativeCall",
      value: function enqueueNativeCall(moduleID, methodID, params, onFail, onSucc) {
        this.processCallbacks(moduleID, methodID, params, onFail, onSucc);

        this._queue[MODULE_IDS].push(moduleID);

        this._queue[METHOD_IDS].push(methodID);

        this._queue[PARAMS].push(params);

        var now = Date.now();

        if (global.nativeFlushQueueImmediate && now - this._lastFlush >= MIN_TIME_BETWEEN_FLUSHES_MS) {
          var queue = this._queue;
          this._queue = [[], [], [], this._callID];
          this._lastFlush = now;
          global.nativeFlushQueueImmediate(queue);
        }

        _$$_REQUIRE(_dependencyMap[2]).counterEvent('pending_js_to_native_queue', this._queue[0].length);

        if (this.__spy) {
          this.__spy({
            type: TO_NATIVE,
            module: moduleID + '',
            method: methodID,
            args: params
          });
        }
      }
    }, {
      key: "createDebugLookup",
      value: function createDebugLookup(moduleID, name, methods) {}
    }, {
      key: "setReactNativeMicrotasksCallback",
      value: function setReactNativeMicrotasksCallback(fn) {
        this._reactNativeMicrotasksCallback = fn;
      }
    }, {
      key: "__guard",
      value: function __guard(fn) {
        if (this.__shouldPauseOnThrow()) {
          fn();
        } else {
          try {
            fn();
          } catch (error) {
            _$$_REQUIRE(_dependencyMap[3]).reportFatalError(error);
          }
        }
      }
    }, {
      key: "__shouldPauseOnThrow",
      value: function __shouldPauseOnThrow() {
        return typeof DebuggerInternal !== 'undefined' && DebuggerInternal.shouldPauseOnThrow === true;
      }
    }, {
      key: "__callReactNativeMicrotasks",
      value: function __callReactNativeMicrotasks() {
        _$$_REQUIRE(_dependencyMap[2]).beginEvent('JSTimers.callReactNativeMicrotasks()');

        if (this._reactNativeMicrotasksCallback != null) {
          this._reactNativeMicrotasksCallback();
        }

        _$$_REQUIRE(_dependencyMap[2]).endEvent();
      }
    }, {
      key: "__callFunction",
      value: function __callFunction(module, method, args) {
        this._lastFlush = Date.now();
        this._eventLoopStartTime = this._lastFlush;

        if (this.__spy) {
          _$$_REQUIRE(_dependencyMap[2]).beginEvent(module + "." + method + "(" + _$$_REQUIRE(_dependencyMap[4]).default(args) + ")");
        } else {
          _$$_REQUIRE(_dependencyMap[2]).beginEvent(module + "." + method + "(...)");
        }

        if (this.__spy) {
          this.__spy({
            type: TO_JS,
            module: module,
            method: method,
            args: args
          });
        }

        var moduleMethods = this.getCallableModule(module);

        _$$_REQUIRE(_dependencyMap[5])(!!moduleMethods, "Module " + module + " is not a registered callable module (calling " + method + "). A frequent cause of the error is that the application entry file path is incorrect.\n      This can also happen when the JS bundle is corrupt or there is an early initialization error when loading React Native.");

        _$$_REQUIRE(_dependencyMap[5])(!!moduleMethods[method], "Method " + method + " does not exist on module " + module);

        moduleMethods[method].apply(moduleMethods, args);

        _$$_REQUIRE(_dependencyMap[2]).endEvent();
      }
    }, {
      key: "__invokeCallback",
      value: function __invokeCallback(cbID, args) {
        this._lastFlush = Date.now();
        this._eventLoopStartTime = this._lastFlush;
        var callID = cbID >>> 1;
        var isSuccess = cbID & 1;
        var callback = isSuccess ? this._successCallbacks.get(callID) : this._failureCallbacks.get(callID);

        if (!callback) {
          return;
        }

        this._successCallbacks.delete(callID);

        this._failureCallbacks.delete(callID);

        callback.apply(undefined, _$$_REQUIRE(_dependencyMap[6])(args));
      }
    }], [{
      key: "spy",
      value: function spy(spyOrToggle) {
        if (spyOrToggle === true) {
          MessageQueue.prototype.__spy = function (info) {
            console.log((info.type === TO_JS ? 'N->JS' : 'JS->N') + " : " + ("" + (info.module != null ? info.module + '.' : '') + info.method) + ("(" + JSON.stringify(info.args) + ")"));
          };
        } else if (spyOrToggle === false) {
          MessageQueue.prototype.__spy = null;
        } else {
          MessageQueue.prototype.__spy = spyOrToggle;
        }
      }
    }]);

    return MessageQueue;
  }();

  module.exports = MessageQueue;
},"node_modules/react-native/Libraries/BatchedBridge/MessageQueue.js",["node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Performance/Systrace.js","node_modules/react-native/Libraries/vendor/core/ErrorUtils.js","node_modules/react-native/Libraries/Utilities/stringifySafe.js","node_modules/invariant/browser.js","node_modules/@babel/runtime/helpers/toConsumableArray.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var TRACE_TAG_REACT_APPS = 131072;
  var TRACE_TAG_JS_VM_CALLS = 134217728;
  var _enabled = false;
  var _asyncCookie = 0;
  var _markStack = [];

  var _markStackIndex = -1;

  var _canInstallReactHook = false;
  var REACT_MARKER = "\u269B";
  var userTimingPolyfill = null;
  var Systrace = {
    installReactHook: function installReactHook() {
      if (_enabled) {}

      _canInstallReactHook = true;
    },
    setEnabled: function setEnabled(enabled) {
      if (_enabled !== enabled) {
        _enabled = enabled;
      }
    },
    isEnabled: function isEnabled() {
      return _enabled;
    },
    beginEvent: function beginEvent(profileName, args) {
      if (_enabled) {
        var profileNameString = typeof profileName === 'function' ? profileName() : profileName;
        global.nativeTraceBeginSection(TRACE_TAG_REACT_APPS, profileNameString, args);
      }
    },
    endEvent: function endEvent() {
      if (_enabled) {
        global.nativeTraceEndSection(TRACE_TAG_REACT_APPS);
      }
    },
    beginAsyncEvent: function beginAsyncEvent(profileName) {
      var cookie = _asyncCookie;

      if (_enabled) {
        _asyncCookie++;
        var profileNameString = typeof profileName === 'function' ? profileName() : profileName;
        global.nativeTraceBeginAsyncSection(TRACE_TAG_REACT_APPS, profileNameString, cookie);
      }

      return cookie;
    },
    endAsyncEvent: function endAsyncEvent(profileName, cookie) {
      if (_enabled) {
        var profileNameString = typeof profileName === 'function' ? profileName() : profileName;
        global.nativeTraceEndAsyncSection(TRACE_TAG_REACT_APPS, profileNameString, cookie);
      }
    },
    counterEvent: function counterEvent(profileName, value) {
      if (_enabled) {
        var profileNameString = typeof profileName === 'function' ? profileName() : profileName;
        global.nativeTraceCounter && global.nativeTraceCounter(TRACE_TAG_REACT_APPS, profileNameString, value);
      }
    }
  };
  module.exports = Systrace;
},"node_modules/react-native/Libraries/Performance/Systrace.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = global.ErrorUtils;
},"node_modules/react-native/Libraries/vendor/core/ErrorUtils.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createStringifySafeWithLimits = createStringifySafeWithLimits;
  exports.default = undefined;

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function createStringifySafeWithLimits(limits) {
    var _limits$maxDepth = limits.maxDepth,
        maxDepth = _limits$maxDepth === undefined ? Number.POSITIVE_INFINITY : _limits$maxDepth,
        _limits$maxStringLimi = limits.maxStringLimit,
        maxStringLimit = _limits$maxStringLimi === undefined ? Number.POSITIVE_INFINITY : _limits$maxStringLimi,
        _limits$maxArrayLimit = limits.maxArrayLimit,
        maxArrayLimit = _limits$maxArrayLimit === undefined ? Number.POSITIVE_INFINITY : _limits$maxArrayLimit,
        _limits$maxObjectKeys = limits.maxObjectKeysLimit,
        maxObjectKeysLimit = _limits$maxObjectKeys === undefined ? Number.POSITIVE_INFINITY : _limits$maxObjectKeys;
    var stack = [];

    function replacer(key, value) {
      while (stack.length && this !== stack[0]) {
        stack.shift();
      }

      if (typeof value === 'string') {
        var truncatedString = '...(truncated)...';

        if (value.length > maxStringLimit + truncatedString.length) {
          return value.substring(0, maxStringLimit) + truncatedString;
        }

        return value;
      }

      if (typeof value !== 'object' || value === null) {
        return value;
      }

      var retval = value;

      if (Array.isArray(value)) {
        if (stack.length >= maxDepth) {
          retval = "[ ... array with " + value.length + " values ... ]";
        } else if (value.length > maxArrayLimit) {
          retval = value.slice(0, maxArrayLimit).concat(["... extra " + (value.length - maxArrayLimit) + " values truncated ..."]);
        }
      } else {
        (0, _invariant.default)(typeof value === 'object', 'This was already found earlier');
        var keys = Object.keys(value);

        if (stack.length >= maxDepth) {
          retval = "{ ... object with " + keys.length + " keys ... }";
        } else if (keys.length > maxObjectKeysLimit) {
          retval = {};

          for (var _iterator = _createForOfIteratorHelperLoose(keys.slice(0, maxObjectKeysLimit)), _step; !(_step = _iterator()).done;) {
            var k = _step.value;
            retval[k] = value[k];
          }

          var truncatedKey = '...(truncated keys)...';
          retval[truncatedKey] = keys.length - maxObjectKeysLimit;
        }
      }

      stack.unshift(retval);
      return retval;
    }

    return function stringifySafe(arg) {
      if (arg === undefined) {
        return 'undefined';
      } else if (arg === null) {
        return 'null';
      } else if (typeof arg === 'function') {
        try {
          return arg.toString();
        } catch (e) {
          return '[function unknown]';
        }
      } else if (arg instanceof Error) {
        return arg.name + ': ' + arg.message;
      } else {
        try {
          var ret = JSON.stringify(arg, replacer);

          if (ret === undefined) {
            return '["' + typeof arg + '" failed to stringify]';
          }

          return ret;
        } catch (e) {
          if (typeof arg.toString === 'function') {
            try {
              return arg.toString();
            } catch (E) {}
          }
        }
      }

      return '["' + typeof arg + '" failed to stringify]';
    };
  }

  var stringifySafe = createStringifySafeWithLimits({
    maxDepth: 10,
    maxStringLimit: 100,
    maxArrayLimit: 50,
    maxObjectKeysLimit: 50
  });
  var _default = stringifySafe;
  exports.default = _default;
},"node_modules/react-native/Libraries/Utilities/stringifySafe.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _toConsumableArray(arr) {
    return _$$_REQUIRE(_dependencyMap[0])(arr) || _$$_REQUIRE(_dependencyMap[1])(arr) || _$$_REQUIRE(_dependencyMap[2])(arr) || _$$_REQUIRE(_dependencyMap[3])();
  }

  module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/toConsumableArray.js",["node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","node_modules/@babel/runtime/helpers/iterableToArray.js","node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","node_modules/@babel/runtime/helpers/nonIterableSpread.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _$$_REQUIRE(_dependencyMap[0])(arr);
  }

  module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/arrayWithoutHoles.js",["node_modules/@babel/runtime/helpers/arrayLikeToArray.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/iterableToArray.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/nonIterableSpread.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function defineLazyObjectProperty(object, name, descriptor) {
    var get = descriptor.get;
    var enumerable = descriptor.enumerable !== false;
    var writable = descriptor.writable !== false;
    var value;
    var valueSet = false;

    function getValue() {
      if (!valueSet) {
        valueSet = true;
        setValue(get());
      }

      return value;
    }

    function setValue(newValue) {
      value = newValue;
      valueSet = true;
      Object.defineProperty(object, name, {
        value: newValue,
        configurable: true,
        enumerable: enumerable,
        writable: writable
      });
    }

    Object.defineProperty(object, name, {
      get: getValue,
      set: setValue,
      configurable: true,
      enumerable: enumerable
    });
  }

  module.exports = defineLazyObjectProperty;
},"node_modules/react-native/Libraries/Utilities/defineLazyObjectProperty.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('AccessibilityInfo');

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/AccessibilityInfo/NativeAccessibilityInfo.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('AccessibilityManager');

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/AccessibilityInfo/NativeAccessibilityManager.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _NativeAccessibilityManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  function legacySendAccessibilityEvent(reactTag, eventType) {
    if (eventType === 'focus' && _NativeAccessibilityManager.default) {
      _NativeAccessibilityManager.default.setAccessibilityFocus(reactTag);
    }
  }

  module.exports = legacySendAccessibilityEvent;
},"node_modules/react-native/Libraries/Components/AccessibilityInfo/legacySendAccessibilityEvent.ios.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Components/AccessibilityInfo/NativeAccessibilityManager.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ReactNative;
  {
    ReactNative = _$$_REQUIRE(_dependencyMap[0]);
  }
  module.exports = ReactNative;
},"node_modules/react-native/Libraries/Renderer/shims/ReactNative.js",["node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-prod.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  _$$_REQUIRE(_dependencyMap[0]);

  var React = _$$_REQUIRE(_dependencyMap[1]);

  function invokeGuardedCallbackImpl(name, func, context, a, b, c, d, e, f) {
    var funcArgs = Array.prototype.slice.call(arguments, 3);

    try {
      func.apply(context, funcArgs);
    } catch (error) {
      this.onError(error);
    }
  }

  var hasError = false,
      caughtError = null,
      hasRethrowError = false,
      rethrowError = null,
      reporter = {
    onError: function onError(error) {
      hasError = true;
      caughtError = error;
    }
  };

  function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
    hasError = false;
    caughtError = null;
    invokeGuardedCallbackImpl.apply(reporter, arguments);
  }

  function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
    invokeGuardedCallback.apply(this, arguments);

    if (hasError) {
      if (hasError) {
        var error = caughtError;
        hasError = false;
        caughtError = null;
      } else throw Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");

      hasRethrowError || (hasRethrowError = true, rethrowError = error);
    }
  }

  var isArrayImpl = Array.isArray,
      getFiberCurrentPropsFromNode = null,
      getInstanceFromNode = null,
      getNodeFromInstance = null;

  function executeDispatch(event, listener, inst) {
    var type = event.type || "unknown-event";
    event.currentTarget = getNodeFromInstance(inst);
    invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
    event.currentTarget = null;
  }

  function executeDirectDispatch(event) {
    var dispatchListener = event._dispatchListeners,
        dispatchInstance = event._dispatchInstances;
    if (isArrayImpl(dispatchListener)) throw Error("executeDirectDispatch(...): Invalid `event`.");
    event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;
    dispatchListener = dispatchListener ? dispatchListener(event) : null;
    event.currentTarget = null;
    event._dispatchListeners = null;
    event._dispatchInstances = null;
    return dispatchListener;
  }

  function functionThatReturnsTrue() {
    return true;
  }

  function functionThatReturnsFalse() {
    return false;
  }

  function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
    this.dispatchConfig = dispatchConfig;
    this._targetInst = targetInst;
    this.nativeEvent = nativeEvent;
    this._dispatchInstances = this._dispatchListeners = null;
    dispatchConfig = this.constructor.Interface;

    for (var propName in dispatchConfig) {
      dispatchConfig.hasOwnProperty(propName) && ((targetInst = dispatchConfig[propName]) ? this[propName] = targetInst(nativeEvent) : "target" === propName ? this.target = nativeEventTarget : this[propName] = nativeEvent[propName]);
    }

    this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }

  _$$_REQUIRE(_dependencyMap[2])(SyntheticEvent.prototype, {
    preventDefault: function preventDefault() {
      this.defaultPrevented = true;
      var event = this.nativeEvent;
      event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
    },
    stopPropagation: function stopPropagation() {
      var event = this.nativeEvent;
      event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
    },
    persist: function persist() {
      this.isPersistent = functionThatReturnsTrue;
    },
    isPersistent: functionThatReturnsFalse,
    destructor: function destructor() {
      var Interface = this.constructor.Interface,
          propName;

      for (propName in Interface) {
        this[propName] = null;
      }

      this.nativeEvent = this._targetInst = this.dispatchConfig = null;
      this.isPropagationStopped = this.isDefaultPrevented = functionThatReturnsFalse;
      this._dispatchInstances = this._dispatchListeners = null;
    }
  });

  SyntheticEvent.Interface = {
    type: null,
    target: null,
    currentTarget: function currentTarget() {
      return null;
    },
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function timeStamp(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: null,
    isTrusted: null
  };

  SyntheticEvent.extend = function (Interface) {
    function E() {}

    function Class() {
      return Super.apply(this, arguments);
    }

    var Super = this;
    E.prototype = Super.prototype;
    var prototype = new E();

    _$$_REQUIRE(_dependencyMap[2])(prototype, Class.prototype);

    Class.prototype = prototype;
    Class.prototype.constructor = Class;
    Class.Interface = _$$_REQUIRE(_dependencyMap[2])({}, Super.Interface, Interface);
    Class.extend = Super.extend;
    addEventPoolingTo(Class);
    return Class;
  };

  addEventPoolingTo(SyntheticEvent);

  function createOrGetPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
    if (this.eventPool.length) {
      var instance = this.eventPool.pop();
      this.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
      return instance;
    }

    return new this(dispatchConfig, targetInst, nativeEvent, nativeInst);
  }

  function releasePooledEvent(event) {
    if (!(event instanceof this)) throw Error("Trying to release an event instance into a pool of a different type.");
    event.destructor();
    10 > this.eventPool.length && this.eventPool.push(event);
  }

  function addEventPoolingTo(EventConstructor) {
    EventConstructor.getPooled = createOrGetPooledEvent;
    EventConstructor.eventPool = [];
    EventConstructor.release = releasePooledEvent;
  }

  var ResponderSyntheticEvent = SyntheticEvent.extend({
    touchHistory: function touchHistory() {
      return null;
    }
  });

  function isStartish(topLevelType) {
    return "topTouchStart" === topLevelType;
  }

  function isMoveish(topLevelType) {
    return "topTouchMove" === topLevelType;
  }

  var startDependencies = ["topTouchStart"],
      moveDependencies = ["topTouchMove"],
      endDependencies = ["topTouchCancel", "topTouchEnd"],
      touchBank = [],
      touchHistory = {
    touchBank: touchBank,
    numberActiveTouches: 0,
    indexOfSingleActiveTouch: -1,
    mostRecentTimeStamp: 0
  };

  function timestampForTouch(touch) {
    return touch.timeStamp || touch.timestamp;
  }

  function getTouchIdentifier(_ref) {
    _ref = _ref.identifier;
    if (null == _ref) throw Error("Touch object is missing identifier.");
    return _ref;
  }

  function recordTouchStart(touch) {
    var identifier = getTouchIdentifier(touch),
        touchRecord = touchBank[identifier];
    touchRecord ? (touchRecord.touchActive = true, touchRecord.startPageX = touch.pageX, touchRecord.startPageY = touch.pageY, touchRecord.startTimeStamp = timestampForTouch(touch), touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchRecord.previousPageX = touch.pageX, touchRecord.previousPageY = touch.pageY, touchRecord.previousTimeStamp = timestampForTouch(touch)) : (touchRecord = {
      touchActive: true,
      startPageX: touch.pageX,
      startPageY: touch.pageY,
      startTimeStamp: timestampForTouch(touch),
      currentPageX: touch.pageX,
      currentPageY: touch.pageY,
      currentTimeStamp: timestampForTouch(touch),
      previousPageX: touch.pageX,
      previousPageY: touch.pageY,
      previousTimeStamp: timestampForTouch(touch)
    }, touchBank[identifier] = touchRecord);
    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
  }

  function recordTouchMove(touch) {
    var touchRecord = touchBank[getTouchIdentifier(touch)];
    touchRecord && (touchRecord.touchActive = true, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch));
  }

  function recordTouchEnd(touch) {
    var touchRecord = touchBank[getTouchIdentifier(touch)];
    touchRecord && (touchRecord.touchActive = false, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch));
  }

  var instrumentationCallback,
      ResponderTouchHistoryStore = {
    instrument: function instrument(callback) {
      instrumentationCallback = callback;
    },
    recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {
      null != instrumentationCallback && instrumentationCallback(topLevelType, nativeEvent);
      if (isMoveish(topLevelType)) nativeEvent.changedTouches.forEach(recordTouchMove);else if (isStartish(topLevelType)) nativeEvent.changedTouches.forEach(recordTouchStart), touchHistory.numberActiveTouches = nativeEvent.touches.length, 1 === touchHistory.numberActiveTouches && (touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier);else if ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType) if (nativeEvent.changedTouches.forEach(recordTouchEnd), touchHistory.numberActiveTouches = nativeEvent.touches.length, 1 === touchHistory.numberActiveTouches) for (topLevelType = 0; topLevelType < touchBank.length; topLevelType++) {
        if (nativeEvent = touchBank[topLevelType], null != nativeEvent && nativeEvent.touchActive) {
          touchHistory.indexOfSingleActiveTouch = topLevelType;
          break;
        }
      }
    },
    touchHistory: touchHistory
  };

  function accumulate(current, next) {
    if (null == next) throw Error("accumulate(...): Accumulated items must not be null or undefined.");
    return null == current ? next : isArrayImpl(current) ? current.concat(next) : isArrayImpl(next) ? [current].concat(next) : [current, next];
  }

  function accumulateInto(current, next) {
    if (null == next) throw Error("accumulateInto(...): Accumulated items must not be null or undefined.");
    if (null == current) return next;

    if (isArrayImpl(current)) {
      if (isArrayImpl(next)) return current.push.apply(current, next), current;
      current.push(next);
      return current;
    }

    return isArrayImpl(next) ? [current].concat(next) : [current, next];
  }

  function forEachAccumulated(arr, cb, scope) {
    Array.isArray(arr) ? arr.forEach(cb, scope) : arr && cb.call(scope, arr);
  }

  var responderInst = null,
      trackedTouchCount = 0;

  function changeResponder(nextResponderInst, blockHostResponder) {
    var oldResponderInst = responderInst;
    responderInst = nextResponderInst;
    if (null !== ResponderEventPlugin.GlobalResponderHandler) ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);
  }

  var eventTypes = {
    startShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onStartShouldSetResponder",
        captured: "onStartShouldSetResponderCapture"
      },
      dependencies: startDependencies
    },
    scrollShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onScrollShouldSetResponder",
        captured: "onScrollShouldSetResponderCapture"
      },
      dependencies: ["topScroll"]
    },
    selectionChangeShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onSelectionChangeShouldSetResponder",
        captured: "onSelectionChangeShouldSetResponderCapture"
      },
      dependencies: ["topSelectionChange"]
    },
    moveShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onMoveShouldSetResponder",
        captured: "onMoveShouldSetResponderCapture"
      },
      dependencies: moveDependencies
    },
    responderStart: {
      registrationName: "onResponderStart",
      dependencies: startDependencies
    },
    responderMove: {
      registrationName: "onResponderMove",
      dependencies: moveDependencies
    },
    responderEnd: {
      registrationName: "onResponderEnd",
      dependencies: endDependencies
    },
    responderRelease: {
      registrationName: "onResponderRelease",
      dependencies: endDependencies
    },
    responderTerminationRequest: {
      registrationName: "onResponderTerminationRequest",
      dependencies: []
    },
    responderGrant: {
      registrationName: "onResponderGrant",
      dependencies: []
    },
    responderReject: {
      registrationName: "onResponderReject",
      dependencies: []
    },
    responderTerminate: {
      registrationName: "onResponderTerminate",
      dependencies: []
    }
  };

  function getParent(inst) {
    do {
      inst = inst.return;
    } while (inst && 5 !== inst.tag);

    return inst ? inst : null;
  }

  function traverseTwoPhase(inst, fn, arg) {
    for (var path = []; inst;) {
      path.push(inst), inst = getParent(inst);
    }

    for (inst = path.length; 0 < inst--;) {
      fn(path[inst], "captured", arg);
    }

    for (inst = 0; inst < path.length; inst++) {
      fn(path[inst], "bubbled", arg);
    }
  }

  function getListener(inst, registrationName) {
    inst = inst.stateNode;
    if (null === inst) return null;
    inst = getFiberCurrentPropsFromNode(inst);
    if (null === inst) return null;
    if ((inst = inst[registrationName]) && "function" !== typeof inst) throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof inst + "` type.");
    return inst;
  }

  function accumulateDirectionalDispatches(inst, phase, event) {
    if (phase = getListener(inst, event.dispatchConfig.phasedRegistrationNames[phase])) event._dispatchListeners = accumulateInto(event._dispatchListeners, phase), event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }

  function accumulateDirectDispatchesSingle(event) {
    if (event && event.dispatchConfig.registrationName) {
      var inst = event._targetInst;

      if (inst && event && event.dispatchConfig.registrationName) {
        var listener = getListener(inst, event.dispatchConfig.registrationName);
        listener && (event._dispatchListeners = accumulateInto(event._dispatchListeners, listener), event._dispatchInstances = accumulateInto(event._dispatchInstances, inst));
      }
    }
  }

  function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
    if (event && event.dispatchConfig.phasedRegistrationNames) {
      var targetInst = event._targetInst;
      targetInst = targetInst ? getParent(targetInst) : null;
      traverseTwoPhase(targetInst, accumulateDirectionalDispatches, event);
    }
  }

  function accumulateTwoPhaseDispatchesSingle(event) {
    event && event.dispatchConfig.phasedRegistrationNames && traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }

  var ResponderEventPlugin = {
    _getResponder: function _getResponder() {
      return responderInst;
    },
    eventTypes: eventTypes,
    extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (isStartish(topLevelType)) trackedTouchCount += 1;else if ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType) if (0 <= trackedTouchCount) --trackedTouchCount;else return null;
      ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);

      if (targetInst && ("topScroll" === topLevelType && !nativeEvent.responderIgnoreScroll || 0 < trackedTouchCount && "topSelectionChange" === topLevelType || isStartish(topLevelType) || isMoveish(topLevelType))) {
        var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : "topSelectionChange" === topLevelType ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder;
        if (responderInst) b: {
          var JSCompiler_temp = responderInst;

          for (var depthA = 0, tempA = JSCompiler_temp; tempA; tempA = getParent(tempA)) {
            depthA++;
          }

          tempA = 0;

          for (var tempB = targetInst; tempB; tempB = getParent(tempB)) {
            tempA++;
          }

          for (; 0 < depthA - tempA;) {
            JSCompiler_temp = getParent(JSCompiler_temp), depthA--;
          }

          for (; 0 < tempA - depthA;) {
            targetInst = getParent(targetInst), tempA--;
          }

          for (; depthA--;) {
            if (JSCompiler_temp === targetInst || JSCompiler_temp === targetInst.alternate) break b;
            JSCompiler_temp = getParent(JSCompiler_temp);
            targetInst = getParent(targetInst);
          }

          JSCompiler_temp = null;
        } else JSCompiler_temp = targetInst;
        targetInst = JSCompiler_temp;
        JSCompiler_temp = targetInst === responderInst;
        shouldSetEventType = ResponderSyntheticEvent.getPooled(shouldSetEventType, targetInst, nativeEvent, nativeEventTarget);
        shouldSetEventType.touchHistory = ResponderTouchHistoryStore.touchHistory;
        JSCompiler_temp ? forEachAccumulated(shouldSetEventType, accumulateTwoPhaseDispatchesSingleSkipTarget) : forEachAccumulated(shouldSetEventType, accumulateTwoPhaseDispatchesSingle);

        b: {
          JSCompiler_temp = shouldSetEventType._dispatchListeners;
          targetInst = shouldSetEventType._dispatchInstances;
          if (isArrayImpl(JSCompiler_temp)) for (depthA = 0; depthA < JSCompiler_temp.length && !shouldSetEventType.isPropagationStopped(); depthA++) {
            if (JSCompiler_temp[depthA](shouldSetEventType, targetInst[depthA])) {
              JSCompiler_temp = targetInst[depthA];
              break b;
            }
          } else if (JSCompiler_temp && JSCompiler_temp(shouldSetEventType, targetInst)) {
            JSCompiler_temp = targetInst;
            break b;
          }
          JSCompiler_temp = null;
        }

        shouldSetEventType._dispatchInstances = null;
        shouldSetEventType._dispatchListeners = null;
        shouldSetEventType.isPersistent() || shouldSetEventType.constructor.release(shouldSetEventType);
        if (JSCompiler_temp && JSCompiler_temp !== responderInst) {
          if (shouldSetEventType = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, JSCompiler_temp, nativeEvent, nativeEventTarget), shouldSetEventType.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(shouldSetEventType, accumulateDirectDispatchesSingle), targetInst = true === executeDirectDispatch(shouldSetEventType), responderInst) {
            if (depthA = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget), depthA.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(depthA, accumulateDirectDispatchesSingle), tempA = !depthA._dispatchListeners || executeDirectDispatch(depthA), depthA.isPersistent() || depthA.constructor.release(depthA), tempA) {
              depthA = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminate, responderInst, nativeEvent, nativeEventTarget);
              depthA.touchHistory = ResponderTouchHistoryStore.touchHistory;
              forEachAccumulated(depthA, accumulateDirectDispatchesSingle);
              var JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, [shouldSetEventType, depthA]);
              changeResponder(JSCompiler_temp, targetInst);
            } else shouldSetEventType = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, JSCompiler_temp, nativeEvent, nativeEventTarget), shouldSetEventType.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(shouldSetEventType, accumulateDirectDispatchesSingle), JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, shouldSetEventType);
          } else JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, shouldSetEventType), changeResponder(JSCompiler_temp, targetInst);
        } else JSCompiler_temp$jscomp$0 = null;
      } else JSCompiler_temp$jscomp$0 = null;

      shouldSetEventType = responderInst && isStartish(topLevelType);
      JSCompiler_temp = responderInst && isMoveish(topLevelType);
      targetInst = responderInst && ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType);
      if (shouldSetEventType = shouldSetEventType ? eventTypes.responderStart : JSCompiler_temp ? eventTypes.responderMove : targetInst ? eventTypes.responderEnd : null) shouldSetEventType = ResponderSyntheticEvent.getPooled(shouldSetEventType, responderInst, nativeEvent, nativeEventTarget), shouldSetEventType.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(shouldSetEventType, accumulateDirectDispatchesSingle), JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, shouldSetEventType);
      shouldSetEventType = responderInst && "topTouchCancel" === topLevelType;
      if (topLevelType = responderInst && !shouldSetEventType && ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType)) a: {
        if ((topLevelType = nativeEvent.touches) && 0 !== topLevelType.length) for (JSCompiler_temp = 0; JSCompiler_temp < topLevelType.length; JSCompiler_temp++) {
          if (targetInst = topLevelType[JSCompiler_temp].target, null !== targetInst && undefined !== targetInst && 0 !== targetInst) {
            depthA = getInstanceFromNode(targetInst);

            b: {
              for (targetInst = responderInst; depthA;) {
                if (targetInst === depthA || targetInst === depthA.alternate) {
                  targetInst = true;
                  break b;
                }

                depthA = getParent(depthA);
              }

              targetInst = false;
            }

            if (targetInst) {
              topLevelType = false;
              break a;
            }
          }
        }
        topLevelType = true;
      }
      if (topLevelType = shouldSetEventType ? eventTypes.responderTerminate : topLevelType ? eventTypes.responderRelease : null) nativeEvent = ResponderSyntheticEvent.getPooled(topLevelType, responderInst, nativeEvent, nativeEventTarget), nativeEvent.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(nativeEvent, accumulateDirectDispatchesSingle), JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, nativeEvent), changeResponder(null);
      return JSCompiler_temp$jscomp$0;
    },
    GlobalResponderHandler: null,
    injection: {
      injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {
        ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
      }
    }
  },
      eventPluginOrder = null,
      namesToPlugins = {};

  function recomputePluginOrdering() {
    if (eventPluginOrder) for (var pluginName in namesToPlugins) {
      var pluginModule = namesToPlugins[pluginName],
          pluginIndex = eventPluginOrder.indexOf(pluginName);
      if (!(-1 < pluginIndex)) throw Error("EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `" + pluginName + "`.");

      if (!plugins[pluginIndex]) {
        if (!pluginModule.extractEvents) throw Error("EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `" + pluginName + "` does not.");
        plugins[pluginIndex] = pluginModule;
        pluginIndex = pluginModule.eventTypes;

        for (var eventName in pluginIndex) {
          var JSCompiler_inline_result = undefined;
          var dispatchConfig = pluginIndex[eventName],
              eventName$jscomp$0 = eventName;
          if (eventNameDispatchConfigs.hasOwnProperty(eventName$jscomp$0)) throw Error("EventPluginRegistry: More than one plugin attempted to publish the same event name, `" + eventName$jscomp$0 + "`.");
          eventNameDispatchConfigs[eventName$jscomp$0] = dispatchConfig;
          var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

          if (phasedRegistrationNames) {
            for (JSCompiler_inline_result in phasedRegistrationNames) {
              phasedRegistrationNames.hasOwnProperty(JSCompiler_inline_result) && publishRegistrationName(phasedRegistrationNames[JSCompiler_inline_result], pluginModule, eventName$jscomp$0);
            }

            JSCompiler_inline_result = true;
          } else dispatchConfig.registrationName ? (publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName$jscomp$0), JSCompiler_inline_result = true) : JSCompiler_inline_result = false;

          if (!JSCompiler_inline_result) throw Error("EventPluginRegistry: Failed to publish event `" + eventName + "` for plugin `" + pluginName + "`.");
        }
      }
    }
  }

  function publishRegistrationName(registrationName, pluginModule) {
    if (registrationNameModules[registrationName]) throw Error("EventPluginRegistry: More than one plugin attempted to publish the same registration name, `" + registrationName + "`.");
    registrationNameModules[registrationName] = pluginModule;
  }

  var plugins = [],
      eventNameDispatchConfigs = {},
      registrationNameModules = {};

  function getListener$1(inst, registrationName) {
    inst = inst.stateNode;
    if (null === inst) return null;
    inst = getFiberCurrentPropsFromNode(inst);
    if (null === inst) return null;
    if ((inst = inst[registrationName]) && "function" !== typeof inst) throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof inst + "` type.");
    return inst;
  }

  var customBubblingEventTypes = _$$_REQUIRE(_dependencyMap[3]).ReactNativeViewConfigRegistry.customBubblingEventTypes,
      customDirectEventTypes = _$$_REQUIRE(_dependencyMap[3]).ReactNativeViewConfigRegistry.customDirectEventTypes;

  function accumulateDirectionalDispatches$1(inst, phase, event) {
    if (phase = getListener$1(inst, event.dispatchConfig.phasedRegistrationNames[phase])) event._dispatchListeners = accumulateInto(event._dispatchListeners, phase), event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }

  function accumulateTwoPhaseDispatchesSingle$1(event) {
    if (event && event.dispatchConfig.phasedRegistrationNames) {
      for (var inst = event._targetInst, path = []; inst;) {
        path.push(inst);

        do {
          inst = inst.return;
        } while (inst && 5 !== inst.tag);

        inst = inst ? inst : null;
      }

      for (inst = path.length; 0 < inst--;) {
        accumulateDirectionalDispatches$1(path[inst], "captured", event);
      }

      for (inst = 0; inst < path.length; inst++) {
        accumulateDirectionalDispatches$1(path[inst], "bubbled", event);
      }
    }
  }

  function accumulateDirectDispatchesSingle$1(event) {
    if (event && event.dispatchConfig.registrationName) {
      var inst = event._targetInst;

      if (inst && event && event.dispatchConfig.registrationName) {
        var listener = getListener$1(inst, event.dispatchConfig.registrationName);
        listener && (event._dispatchListeners = accumulateInto(event._dispatchListeners, listener), event._dispatchInstances = accumulateInto(event._dispatchInstances, inst));
      }
    }
  }

  if (eventPluginOrder) throw Error("EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.");
  eventPluginOrder = Array.prototype.slice.call(["ResponderEventPlugin", "ReactNativeBridgeEventPlugin"]);
  recomputePluginOrdering();
  var injectedNamesToPlugins$jscomp$inline_219 = {
    ResponderEventPlugin: ResponderEventPlugin,
    ReactNativeBridgeEventPlugin: {
      eventTypes: {},
      extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        if (null == targetInst) return null;
        var bubbleDispatchConfig = customBubblingEventTypes[topLevelType],
            directDispatchConfig = customDirectEventTypes[topLevelType];
        if (!bubbleDispatchConfig && !directDispatchConfig) throw Error('Unsupported top level event type "' + topLevelType + '" dispatched');
        topLevelType = SyntheticEvent.getPooled(bubbleDispatchConfig || directDispatchConfig, targetInst, nativeEvent, nativeEventTarget);
        if (bubbleDispatchConfig) forEachAccumulated(topLevelType, accumulateTwoPhaseDispatchesSingle$1);else if (directDispatchConfig) forEachAccumulated(topLevelType, accumulateDirectDispatchesSingle$1);else return null;
        return topLevelType;
      }
    }
  },
      isOrderingDirty$jscomp$inline_220 = false,
      pluginName$jscomp$inline_221;

  for (pluginName$jscomp$inline_221 in injectedNamesToPlugins$jscomp$inline_219) {
    if (injectedNamesToPlugins$jscomp$inline_219.hasOwnProperty(pluginName$jscomp$inline_221)) {
      var pluginModule$jscomp$inline_222 = injectedNamesToPlugins$jscomp$inline_219[pluginName$jscomp$inline_221];

      if (!namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_221) || namesToPlugins[pluginName$jscomp$inline_221] !== pluginModule$jscomp$inline_222) {
        if (namesToPlugins[pluginName$jscomp$inline_221]) throw Error("EventPluginRegistry: Cannot inject two different event plugins using the same name, `" + pluginName$jscomp$inline_221 + "`.");
        namesToPlugins[pluginName$jscomp$inline_221] = pluginModule$jscomp$inline_222;
        isOrderingDirty$jscomp$inline_220 = true;
      }
    }
  }

  isOrderingDirty$jscomp$inline_220 && recomputePluginOrdering();
  var instanceCache = new Map(),
      instanceProps = new Map();

  function getInstanceFromTag(tag) {
    return instanceCache.get(tag) || null;
  }

  function batchedUpdatesImpl(fn, bookkeeping) {
    return fn(bookkeeping);
  }

  var isInsideEventHandler = false;

  function batchedUpdates(fn, bookkeeping) {
    if (isInsideEventHandler) return fn(bookkeeping);
    isInsideEventHandler = true;

    try {
      return batchedUpdatesImpl(fn, bookkeeping);
    } finally {
      isInsideEventHandler = false;
    }
  }

  var eventQueue = null;

  function executeDispatchesAndReleaseTopLevel(e) {
    if (e) {
      var dispatchListeners = e._dispatchListeners,
          dispatchInstances = e._dispatchInstances;
      if (isArrayImpl(dispatchListeners)) for (var i = 0; i < dispatchListeners.length && !e.isPropagationStopped(); i++) {
        executeDispatch(e, dispatchListeners[i], dispatchInstances[i]);
      } else dispatchListeners && executeDispatch(e, dispatchListeners, dispatchInstances);
      e._dispatchListeners = null;
      e._dispatchInstances = null;
      e.isPersistent() || e.constructor.release(e);
    }
  }

  var EMPTY_NATIVE_EVENT = {};

  function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {
    var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT,
        inst = getInstanceFromTag(rootNodeID),
        target = null;
    null != inst && (target = inst.stateNode);
    batchedUpdates(function () {
      var JSCompiler_inline_result = target;

      for (var events = null, legacyPlugins = plugins, i = 0; i < legacyPlugins.length; i++) {
        var possiblePlugin = legacyPlugins[i];
        possiblePlugin && (possiblePlugin = possiblePlugin.extractEvents(topLevelType, inst, nativeEvent, JSCompiler_inline_result)) && (events = accumulateInto(events, possiblePlugin));
      }

      JSCompiler_inline_result = events;
      null !== JSCompiler_inline_result && (eventQueue = accumulateInto(eventQueue, JSCompiler_inline_result));
      JSCompiler_inline_result = eventQueue;
      eventQueue = null;

      if (JSCompiler_inline_result) {
        forEachAccumulated(JSCompiler_inline_result, executeDispatchesAndReleaseTopLevel);
        if (eventQueue) throw Error("processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.");
        if (hasRethrowError) throw JSCompiler_inline_result = rethrowError, hasRethrowError = false, rethrowError = null, JSCompiler_inline_result;
      }
    });
  }

  _$$_REQUIRE(_dependencyMap[3]).RCTEventEmitter.register({
    receiveEvent: function receiveEvent(rootNodeID, topLevelType, nativeEventParam) {
      _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);
    },
    receiveTouches: function receiveTouches(eventTopLevelType, touches, changedIndices) {
      if ("topTouchEnd" === eventTopLevelType || "topTouchCancel" === eventTopLevelType) {
        var JSCompiler_temp = [];

        for (var i = 0; i < changedIndices.length; i++) {
          var index$0 = changedIndices[i];
          JSCompiler_temp.push(touches[index$0]);
          touches[index$0] = null;
        }

        for (i = changedIndices = 0; i < touches.length; i++) {
          index$0 = touches[i], null !== index$0 && (touches[changedIndices++] = index$0);
        }

        touches.length = changedIndices;
      } else for (JSCompiler_temp = [], i = 0; i < changedIndices.length; i++) {
        JSCompiler_temp.push(touches[changedIndices[i]]);
      }

      for (changedIndices = 0; changedIndices < JSCompiler_temp.length; changedIndices++) {
        i = JSCompiler_temp[changedIndices];
        i.changedTouches = JSCompiler_temp;
        i.touches = touches;
        index$0 = null;
        var target = i.target;
        null === target || undefined === target || 1 > target || (index$0 = target);

        _receiveRootNodeIDEvent(index$0, eventTopLevelType, i);
      }
    }
  });

  getFiberCurrentPropsFromNode = function getFiberCurrentPropsFromNode(stateNode) {
    return instanceProps.get(stateNode._nativeTag) || null;
  };

  getInstanceFromNode = getInstanceFromTag;

  getNodeFromInstance = function getNodeFromInstance(inst) {
    inst = inst.stateNode;
    var tag = inst._nativeTag;
    undefined === tag && (inst = inst.canonical, tag = inst._nativeTag);
    if (!tag) throw Error("All native instances should have a tag.");
    return inst;
  };

  ResponderEventPlugin.injection.injectGlobalResponderHandler({
    onChange: function onChange(from, to, blockNativeResponder) {
      null !== to ? _$$_REQUIRE(_dependencyMap[3]).UIManager.setJSResponder(to.stateNode._nativeTag, blockNativeResponder) : _$$_REQUIRE(_dependencyMap[3]).UIManager.clearJSResponder();
    }
  });
  var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
      REACT_ELEMENT_TYPE = 60103,
      REACT_PORTAL_TYPE = 60106,
      REACT_FRAGMENT_TYPE = 60107,
      REACT_STRICT_MODE_TYPE = 60108,
      REACT_PROFILER_TYPE = 60114,
      REACT_PROVIDER_TYPE = 60109,
      REACT_CONTEXT_TYPE = 60110,
      REACT_FORWARD_REF_TYPE = 60112,
      REACT_SUSPENSE_TYPE = 60113,
      REACT_SUSPENSE_LIST_TYPE = 60120,
      REACT_MEMO_TYPE = 60115,
      REACT_LAZY_TYPE = 60116,
      REACT_DEBUG_TRACING_MODE_TYPE = 60129,
      REACT_OFFSCREEN_TYPE = 60130,
      REACT_LEGACY_HIDDEN_TYPE = 60131,
      REACT_CACHE_TYPE = 60132;

  if ("function" === typeof Symbol && Symbol.for) {
    var symbolFor = Symbol.for;
    REACT_ELEMENT_TYPE = symbolFor("react.element");
    REACT_PORTAL_TYPE = symbolFor("react.portal");
    REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
    REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
    REACT_PROFILER_TYPE = symbolFor("react.profiler");
    REACT_PROVIDER_TYPE = symbolFor("react.provider");
    REACT_CONTEXT_TYPE = symbolFor("react.context");
    REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
    REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
    REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
    REACT_MEMO_TYPE = symbolFor("react.memo");
    REACT_LAZY_TYPE = symbolFor("react.lazy");
    symbolFor("react.scope");
    REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
    REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
    REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
    REACT_CACHE_TYPE = symbolFor("react.cache");
  }

  var MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && Symbol.iterator;

  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }

  function getComponentNameFromType(type) {
    if (null == type) return null;
    if ("function" === typeof type) return type.displayName || type.name || null;
    if ("string" === typeof type) return type;

    switch (type) {
      case REACT_FRAGMENT_TYPE:
        return "Fragment";

      case REACT_PORTAL_TYPE:
        return "Portal";

      case REACT_PROFILER_TYPE:
        return "Profiler";

      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";

      case REACT_SUSPENSE_TYPE:
        return "Suspense";

      case REACT_SUSPENSE_LIST_TYPE:
        return "SuspenseList";

      case REACT_CACHE_TYPE:
        return "Cache";
    }

    if ("object" === typeof type) switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return (type.displayName || "Context") + ".Consumer";

      case REACT_PROVIDER_TYPE:
        return (type._context.displayName || "Context") + ".Provider";

      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        type = type.displayName;
        type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
        return type;

      case REACT_MEMO_TYPE:
        return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";

      case REACT_LAZY_TYPE:
        innerType = type._payload;
        type = type._init;

        try {
          return getComponentNameFromType(type(innerType));
        } catch (x) {}

    }
    return null;
  }

  function getComponentNameFromFiber(fiber) {
    var type = fiber.type;

    switch (fiber.tag) {
      case 24:
        return "Cache";

      case 9:
        return (type.displayName || "Context") + ".Consumer";

      case 10:
        return (type._context.displayName || "Context") + ".Provider";

      case 18:
        return "DehydratedFragment";

      case 11:
        return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");

      case 7:
        return "Fragment";

      case 5:
        return type;

      case 4:
        return "Portal";

      case 3:
        return "Root";

      case 6:
        return "Text";

      case 16:
        return getComponentNameFromType(type);

      case 23:
        return "LegacyHidden";

      case 8:
        return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";

      case 22:
        return "Offscreen";

      case 12:
        return "Profiler";

      case 21:
        return "Scope";

      case 13:
        return "Suspense";

      case 19:
        return "SuspenseList";

      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof type) return type.displayName || type.name || null;
        if ("string" === typeof type) return type;
    }

    return null;
  }

  function getNearestMountedFiber(fiber) {
    var node = fiber,
        nearestMounted = fiber;
    if (fiber.alternate) for (; node.return;) {
      node = node.return;
    } else {
      fiber = node;

      do {
        node = fiber, 0 !== (node.flags & 2050) && (nearestMounted = node.return), fiber = node.return;
      } while (fiber);
    }
    return 3 === node.tag ? nearestMounted : null;
  }

  function assertIsMounted(fiber) {
    if (getNearestMountedFiber(fiber) !== fiber) throw Error("Unable to find node on an unmounted component.");
  }

  function findCurrentFiberUsingSlowPath(fiber) {
    var alternate = fiber.alternate;

    if (!alternate) {
      alternate = getNearestMountedFiber(fiber);
      if (null === alternate) throw Error("Unable to find node on an unmounted component.");
      return alternate !== fiber ? null : fiber;
    }

    for (var a = fiber, b = alternate;;) {
      var parentA = a.return;
      if (null === parentA) break;
      var parentB = parentA.alternate;

      if (null === parentB) {
        b = parentA.return;

        if (null !== b) {
          a = b;
          continue;
        }

        break;
      }

      if (parentA.child === parentB.child) {
        for (parentB = parentA.child; parentB;) {
          if (parentB === a) return assertIsMounted(parentA), fiber;
          if (parentB === b) return assertIsMounted(parentA), alternate;
          parentB = parentB.sibling;
        }

        throw Error("Unable to find node on an unmounted component.");
      }

      if (a.return !== b.return) a = parentA, b = parentB;else {
        for (var didFindChild = false, child$1 = parentA.child; child$1;) {
          if (child$1 === a) {
            didFindChild = true;
            a = parentA;
            b = parentB;
            break;
          }

          if (child$1 === b) {
            didFindChild = true;
            b = parentA;
            a = parentB;
            break;
          }

          child$1 = child$1.sibling;
        }

        if (!didFindChild) {
          for (child$1 = parentB.child; child$1;) {
            if (child$1 === a) {
              didFindChild = true;
              a = parentB;
              b = parentA;
              break;
            }

            if (child$1 === b) {
              didFindChild = true;
              b = parentB;
              a = parentA;
              break;
            }

            child$1 = child$1.sibling;
          }

          if (!didFindChild) throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
        }
      }
      if (a.alternate !== b) throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
    }

    if (3 !== a.tag) throw Error("Unable to find node on an unmounted component.");
    return a.stateNode.current === a ? fiber : alternate;
  }

  function findCurrentHostFiber(parent) {
    parent = findCurrentFiberUsingSlowPath(parent);
    return null !== parent ? findCurrentHostFiberImpl(parent) : null;
  }

  function findCurrentHostFiberImpl(node) {
    if (5 === node.tag || 6 === node.tag) return node;

    for (node = node.child; null !== node;) {
      var match = findCurrentHostFiberImpl(node);
      if (null !== match) return match;
      node = node.sibling;
    }

    return null;
  }

  var emptyObject = {},
      removedKeys = null,
      removedKeyCount = 0,
      deepDifferOptions = {
    unsafelyIgnoreFunctions: true
  };

  function defaultDiffer(prevProp, nextProp) {
    return "object" !== typeof nextProp || null === nextProp ? true : _$$_REQUIRE(_dependencyMap[3]).deepDiffer(prevProp, nextProp, deepDifferOptions);
  }

  function restoreDeletedValuesInNestedArray(updatePayload, node, validAttributes) {
    if (isArrayImpl(node)) for (var i = node.length; i-- && 0 < removedKeyCount;) {
      restoreDeletedValuesInNestedArray(updatePayload, node[i], validAttributes);
    } else if (node && 0 < removedKeyCount) for (i in removedKeys) {
      if (removedKeys[i]) {
        var nextProp = node[i];

        if (undefined !== nextProp) {
          var attributeConfig = validAttributes[i];

          if (attributeConfig) {
            "function" === typeof nextProp && (nextProp = true);
            "undefined" === typeof nextProp && (nextProp = null);
            if ("object" !== typeof attributeConfig) updatePayload[i] = nextProp;else if ("function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process) nextProp = "function" === typeof attributeConfig.process ? attributeConfig.process(nextProp) : nextProp, updatePayload[i] = nextProp;
            removedKeys[i] = false;
            removedKeyCount--;
          }
        }
      }
    }
  }

  function diffNestedProperty(updatePayload, prevProp, nextProp, validAttributes) {
    if (!updatePayload && prevProp === nextProp) return updatePayload;
    if (!prevProp || !nextProp) return nextProp ? addNestedProperty(updatePayload, nextProp, validAttributes) : prevProp ? clearNestedProperty(updatePayload, prevProp, validAttributes) : updatePayload;
    if (!isArrayImpl(prevProp) && !isArrayImpl(nextProp)) return diffProperties(updatePayload, prevProp, nextProp, validAttributes);

    if (isArrayImpl(prevProp) && isArrayImpl(nextProp)) {
      var minLength = prevProp.length < nextProp.length ? prevProp.length : nextProp.length,
          i;

      for (i = 0; i < minLength; i++) {
        updatePayload = diffNestedProperty(updatePayload, prevProp[i], nextProp[i], validAttributes);
      }

      for (; i < prevProp.length; i++) {
        updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
      }

      for (; i < nextProp.length; i++) {
        updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
      }

      return updatePayload;
    }

    return isArrayImpl(prevProp) ? diffProperties(updatePayload, _$$_REQUIRE(_dependencyMap[3]).flattenStyle(prevProp), nextProp, validAttributes) : diffProperties(updatePayload, prevProp, _$$_REQUIRE(_dependencyMap[3]).flattenStyle(nextProp), validAttributes);
  }

  function addNestedProperty(updatePayload, nextProp, validAttributes) {
    if (!nextProp) return updatePayload;
    if (!isArrayImpl(nextProp)) return diffProperties(updatePayload, emptyObject, nextProp, validAttributes);

    for (var i = 0; i < nextProp.length; i++) {
      updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
    }

    return updatePayload;
  }

  function clearNestedProperty(updatePayload, prevProp, validAttributes) {
    if (!prevProp) return updatePayload;
    if (!isArrayImpl(prevProp)) return diffProperties(updatePayload, prevProp, emptyObject, validAttributes);

    for (var i = 0; i < prevProp.length; i++) {
      updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
    }

    return updatePayload;
  }

  function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {
    var attributeConfig, propKey;

    for (propKey in nextProps) {
      if (attributeConfig = validAttributes[propKey]) {
        var prevProp = prevProps[propKey];
        var nextProp = nextProps[propKey];
        "function" === typeof nextProp && (nextProp = true, "function" === typeof prevProp && (prevProp = true));
        "undefined" === typeof nextProp && (nextProp = null, "undefined" === typeof prevProp && (prevProp = null));
        removedKeys && (removedKeys[propKey] = false);
        if (updatePayload && undefined !== updatePayload[propKey]) {
          if ("object" !== typeof attributeConfig) updatePayload[propKey] = nextProp;else {
            if ("function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process) attributeConfig = "function" === typeof attributeConfig.process ? attributeConfig.process(nextProp) : nextProp, updatePayload[propKey] = attributeConfig;
          }
        } else if (prevProp !== nextProp) if ("object" !== typeof attributeConfig) defaultDiffer(prevProp, nextProp) && ((updatePayload || (updatePayload = {}))[propKey] = nextProp);else if ("function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process) {
          if (undefined === prevProp || ("function" === typeof attributeConfig.diff ? attributeConfig.diff(prevProp, nextProp) : defaultDiffer(prevProp, nextProp))) attributeConfig = "function" === typeof attributeConfig.process ? attributeConfig.process(nextProp) : nextProp, (updatePayload || (updatePayload = {}))[propKey] = attributeConfig;
        } else removedKeys = null, removedKeyCount = 0, updatePayload = diffNestedProperty(updatePayload, prevProp, nextProp, attributeConfig), 0 < removedKeyCount && updatePayload && (restoreDeletedValuesInNestedArray(updatePayload, nextProp, attributeConfig), removedKeys = null);
      }
    }

    for (var propKey$3 in prevProps) {
      undefined === nextProps[propKey$3] && (!(attributeConfig = validAttributes[propKey$3]) || updatePayload && undefined !== updatePayload[propKey$3] || (prevProp = prevProps[propKey$3], undefined !== prevProp && ("object" !== typeof attributeConfig || "function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process ? ((updatePayload || (updatePayload = {}))[propKey$3] = null, removedKeys || (removedKeys = {}), removedKeys[propKey$3] || (removedKeys[propKey$3] = true, removedKeyCount++)) : updatePayload = clearNestedProperty(updatePayload, prevProp, attributeConfig))));
    }

    return updatePayload;
  }

  function mountSafeCallback_NOT_REALLY_SAFE(context, callback) {
    return function () {
      if (callback && ("boolean" !== typeof context.__isMounted || context.__isMounted)) return callback.apply(context, arguments);
    };
  }

  var ReactNativeFiberHostComponent = function () {
    function ReactNativeFiberHostComponent(tag, viewConfig) {
      this._nativeTag = tag;
      this._children = [];
      this.viewConfig = viewConfig;
    }

    var _proto = ReactNativeFiberHostComponent.prototype;

    _proto.blur = function () {
      _$$_REQUIRE(_dependencyMap[3]).TextInputState.blurTextInput(this);
    };

    _proto.focus = function () {
      _$$_REQUIRE(_dependencyMap[3]).TextInputState.focusTextInput(this);
    };

    _proto.measure = function (callback) {
      _$$_REQUIRE(_dependencyMap[3]).UIManager.measure(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
    };

    _proto.measureInWindow = function (callback) {
      _$$_REQUIRE(_dependencyMap[3]).UIManager.measureInWindow(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
    };

    _proto.measureLayout = function (relativeToNativeNode, onSuccess, onFail) {
      if ("number" === typeof relativeToNativeNode) var relativeNode = relativeToNativeNode;else relativeToNativeNode._nativeTag && (relativeNode = relativeToNativeNode._nativeTag);
      null != relativeNode && _$$_REQUIRE(_dependencyMap[3]).UIManager.measureLayout(this._nativeTag, relativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
    };

    _proto.setNativeProps = function (nativeProps) {
      nativeProps = diffProperties(null, emptyObject, nativeProps, this.viewConfig.validAttributes);
      null != nativeProps && _$$_REQUIRE(_dependencyMap[3]).UIManager.updateView(this._nativeTag, this.viewConfig.uiViewClassName, nativeProps);
    };

    return ReactNativeFiberHostComponent;
  }(),
      rendererID = null,
      injectedHook = null;

  function onCommitRoot(root) {
    if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot) try {
      injectedHook.onCommitFiberRoot(rendererID, root, undefined, 128 === (root.current.flags & 128));
    } catch (err) {}
  }

  var nextTransitionLane = 64,
      nextRetryLane = 4194304;

  function getHighestPriorityLanes(lanes) {
    switch (lanes & -lanes) {
      case 1:
        return 1;

      case 2:
        return 2;

      case 4:
        return 4;

      case 8:
        return 8;

      case 16:
        return 16;

      case 32:
        return 32;

      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return lanes & 4194240;

      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return lanes & 130023424;

      case 134217728:
        return 134217728;

      case 268435456:
        return 268435456;

      case 536870912:
        return 536870912;

      case 1073741824:
        return 1073741824;

      default:
        return lanes;
    }
  }

  function getNextLanes(root, wipLanes) {
    var pendingLanes = root.pendingLanes;
    if (0 === pendingLanes) return 0;
    var nextLanes = 0,
        suspendedLanes = root.suspendedLanes,
        pingedLanes = root.pingedLanes,
        nonIdlePendingLanes = pendingLanes & 268435455;

    if (0 !== nonIdlePendingLanes) {
      var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
      0 !== nonIdleUnblockedLanes ? nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes && (nextLanes = getHighestPriorityLanes(pingedLanes)));
    } else nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes && (nextLanes = getHighestPriorityLanes(pingedLanes));

    if (0 === nextLanes) return 0;
    if (0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, pingedLanes = wipLanes & -wipLanes, suspendedLanes >= pingedLanes || 16 === suspendedLanes && 0 !== (pingedLanes & 4194240))) return wipLanes;
    0 !== (nextLanes & 4) && (nextLanes |= pendingLanes & 16);
    wipLanes = root.entangledLanes;
    if (0 !== wipLanes) for (root = root.entanglements, wipLanes &= nextLanes; 0 < wipLanes;) {
      pendingLanes = 31 - clz32(wipLanes), suspendedLanes = 1 << pendingLanes, nextLanes |= root[pendingLanes], wipLanes &= ~suspendedLanes;
    }
    return nextLanes;
  }

  function computeExpirationTime(lane, currentTime) {
    switch (lane) {
      case 1:
      case 2:
      case 4:
        return currentTime + 250;

      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return currentTime + 5e3;

      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;

      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;

      default:
        return -1;
    }
  }

  function getLanesToRetrySynchronouslyOnError(root) {
    root = root.pendingLanes & -1073741825;
    return 0 !== root ? root : root & 1073741824 ? 1073741824 : 0;
  }

  function createLaneMap(initial) {
    for (var laneMap = [], i = 0; 31 > i; i++) {
      laneMap.push(initial);
    }

    return laneMap;
  }

  function markRootUpdated(root, updateLane, eventTime) {
    root.pendingLanes |= updateLane;
    536870912 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0);
    root = root.eventTimes;
    updateLane = 31 - clz32(updateLane);
    root[updateLane] = eventTime;
  }

  function markRootFinished(root, remainingLanes) {
    var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
    root.pendingLanes = remainingLanes;
    root.suspendedLanes = 0;
    root.pingedLanes = 0;
    root.expiredLanes &= remainingLanes;
    root.mutableReadLanes &= remainingLanes;
    root.entangledLanes &= remainingLanes;
    remainingLanes = root.entanglements;
    var eventTimes = root.eventTimes;

    for (root = root.expirationTimes; 0 < noLongerPendingLanes;) {
      var index$8 = 31 - clz32(noLongerPendingLanes),
          lane = 1 << index$8;
      remainingLanes[index$8] = 0;
      eventTimes[index$8] = -1;
      root[index$8] = -1;
      noLongerPendingLanes &= ~lane;
    }
  }

  function markRootEntangled(root, entangledLanes) {
    var rootEntangledLanes = root.entangledLanes |= entangledLanes;

    for (root = root.entanglements; rootEntangledLanes;) {
      var index$9 = 31 - clz32(rootEntangledLanes),
          lane = 1 << index$9;
      lane & entangledLanes | root[index$9] & entangledLanes && (root[index$9] |= entangledLanes);
      rootEntangledLanes &= ~lane;
    }
  }

  var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
      log = Math.log,
      LN2 = Math.LN2;

  function clz32Fallback(lanes) {
    return 0 === lanes ? 32 : 31 - (log(lanes) / LN2 | 0) | 0;
  }

  var currentUpdatePriority = 0;

  function lanesToEventPriority(lanes) {
    lanes &= -lanes;
    return 1 < lanes ? 4 < lanes ? 0 !== (lanes & 268435455) ? 16 : 536870912 : 4 : 1;
  }

  function shim() {
    throw Error("The current renderer does not support hydration. This error is likely caused by a bug in React. Please file an issue.");
  }

  var getViewConfigForType = _$$_REQUIRE(_dependencyMap[3]).ReactNativeViewConfigRegistry.get,
      UPDATE_SIGNAL = {},
      nextReactTag = 3;

  function allocateTag() {
    var tag = nextReactTag;
    1 === tag % 10 && (tag += 2);
    nextReactTag = tag + 2;
    return tag;
  }

  function recursivelyUncacheFiberNode(node) {
    if ("number" === typeof node) instanceCache.delete(node), instanceProps.delete(node);else {
      var tag = node._nativeTag;
      instanceCache.delete(tag);
      instanceProps.delete(tag);

      node._children.forEach(recursivelyUncacheFiberNode);
    }
  }

  function finalizeInitialChildren(parentInstance) {
    if (0 === parentInstance._children.length) return false;

    var nativeTags = parentInstance._children.map(function (child) {
      return "number" === typeof child ? child : child._nativeTag;
    });

    _$$_REQUIRE(_dependencyMap[3]).UIManager.setChildren(parentInstance._nativeTag, nativeTags);

    return false;
  }

  var scheduleTimeout = setTimeout,
      cancelTimeout = clearTimeout;

  function describeComponentFrame(name, source, ownerName) {
    source = "";
    ownerName && (source = " (created by " + ownerName + ")");
    return "\n    in " + (name || "Unknown") + source;
  }

  function describeFunctionComponentFrame(fn, source) {
    return fn ? describeComponentFrame(fn.displayName || fn.name || null, source, null) : "";
  }

  var hasOwnProperty = Object.prototype.hasOwnProperty,
      valueStack = [],
      index = -1;

  function createCursor(defaultValue) {
    return {
      current: defaultValue
    };
  }

  function pop(cursor) {
    0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
  }

  function push(cursor, value) {
    index++;
    valueStack[index] = cursor.current;
    cursor.current = value;
  }

  var emptyContextObject = {},
      contextStackCursor = createCursor(emptyContextObject),
      didPerformWorkStackCursor = createCursor(false),
      previousContext = emptyContextObject;

  function getMaskedContext(workInProgress, unmaskedContext) {
    var contextTypes = workInProgress.type.contextTypes;
    if (!contextTypes) return emptyContextObject;
    var instance = workInProgress.stateNode;
    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) return instance.__reactInternalMemoizedMaskedChildContext;
    var context = {},
        key;

    for (key in contextTypes) {
      context[key] = unmaskedContext[key];
    }

    instance && (workInProgress = workInProgress.stateNode, workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext, workInProgress.__reactInternalMemoizedMaskedChildContext = context);
    return context;
  }

  function isContextProvider(type) {
    type = type.childContextTypes;
    return null !== type && undefined !== type;
  }

  function popContext() {
    pop(didPerformWorkStackCursor);
    pop(contextStackCursor);
  }

  function pushTopLevelContextObject(fiber, context, didChange) {
    if (contextStackCursor.current !== emptyContextObject) throw Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
    push(contextStackCursor, context);
    push(didPerformWorkStackCursor, didChange);
  }

  function processChildContext(fiber, type, parentContext) {
    var instance = fiber.stateNode;
    type = type.childContextTypes;
    if ("function" !== typeof instance.getChildContext) return parentContext;
    instance = instance.getChildContext();

    for (var contextKey in instance) {
      if (!(contextKey in type)) throw Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
    }

    return _$$_REQUIRE(_dependencyMap[2])({}, parentContext, instance);
  }

  function pushContextProvider(workInProgress) {
    workInProgress = (workInProgress = workInProgress.stateNode) && workInProgress.__reactInternalMemoizedMergedChildContext || emptyContextObject;
    previousContext = contextStackCursor.current;
    push(contextStackCursor, workInProgress);
    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current);
    return true;
  }

  function invalidateContextProvider(workInProgress, type, didChange) {
    var instance = workInProgress.stateNode;
    if (!instance) throw Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
    didChange ? (workInProgress = processChildContext(workInProgress, type, previousContext), instance.__reactInternalMemoizedMergedChildContext = workInProgress, pop(didPerformWorkStackCursor), pop(contextStackCursor), push(contextStackCursor, workInProgress)) : pop(didPerformWorkStackCursor);
    push(didPerformWorkStackCursor, didChange);
  }

  var syncQueue = null,
      includesLegacySyncCallbacks = false,
      isFlushingSyncQueue = false;

  function flushSyncCallbacks() {
    if (!isFlushingSyncQueue && null !== syncQueue) {
      isFlushingSyncQueue = true;
      var i = 0,
          previousUpdatePriority = currentUpdatePriority;

      try {
        var queue = syncQueue;

        for (currentUpdatePriority = 1; i < queue.length; i++) {
          var callback = queue[i];

          do {
            callback = callback(true);
          } while (null !== callback);
        }

        syncQueue = null;
        includesLegacySyncCallbacks = false;
      } catch (error) {
        throw null !== syncQueue && (syncQueue = syncQueue.slice(i + 1)), _$$_REQUIRE(_dependencyMap[4]).unstable_scheduleCallback(_$$_REQUIRE(_dependencyMap[4]).unstable_ImmediatePriority, flushSyncCallbacks), error;
      } finally {
        currentUpdatePriority = previousUpdatePriority, isFlushingSyncQueue = false;
      }
    }

    return null;
  }

  var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;

  function is(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
  }

  var objectIs = "function" === typeof Object.is ? Object.is : is;

  function shallowEqual(objA, objB) {
    if (objectIs(objA, objB)) return true;
    if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB) return false;
    var keysA = Object.keys(objA),
        keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;

    for (keysB = 0; keysB < keysA.length; keysB++) {
      if (!hasOwnProperty.call(objB, keysA[keysB]) || !objectIs(objA[keysA[keysB]], objB[keysA[keysB]])) return false;
    }

    return true;
  }

  function describeFiber(fiber) {
    switch (fiber.tag) {
      case 5:
        return describeComponentFrame(fiber.type, null, null);

      case 16:
        return describeComponentFrame("Lazy", null, null);

      case 13:
        return describeComponentFrame("Suspense", null, null);

      case 19:
        return describeComponentFrame("SuspenseList", null, null);

      case 0:
      case 2:
      case 15:
        return describeFunctionComponentFrame(fiber.type, null);

      case 11:
        return describeFunctionComponentFrame(fiber.type.render, null);

      case 1:
        return fiber = describeFunctionComponentFrame(fiber.type, null), fiber;

      default:
        return "";
    }
  }

  function getStackByFiberInDevAndProd(workInProgress) {
    try {
      var info = "";

      do {
        info += describeFiber(workInProgress), workInProgress = workInProgress.return;
      } while (workInProgress);

      return info;
    } catch (x) {
      return "\nError generating stack: " + x.message + "\n" + x.stack;
    }
  }

  function resolveDefaultProps(Component, baseProps) {
    if (Component && Component.defaultProps) {
      baseProps = _$$_REQUIRE(_dependencyMap[2])({}, baseProps);
      Component = Component.defaultProps;

      for (var propName in Component) {
        undefined === baseProps[propName] && (baseProps[propName] = Component[propName]);
      }

      return baseProps;
    }

    return baseProps;
  }

  var valueCursor = createCursor(null),
      currentlyRenderingFiber = null,
      lastContextDependency = null,
      lastFullyObservedContext = null;

  function resetContextDependencies() {
    lastFullyObservedContext = lastContextDependency = currentlyRenderingFiber = null;
  }

  function popProvider(context) {
    var currentValue = valueCursor.current;
    pop(valueCursor);
    context._currentValue = currentValue;
  }

  function scheduleWorkOnParentPath(parent, renderLanes) {
    for (; null !== parent;) {
      var alternate = parent.alternate;
      if ((parent.childLanes & renderLanes) === renderLanes) {
        if (null === alternate || (alternate.childLanes & renderLanes) === renderLanes) break;else alternate.childLanes |= renderLanes;
      } else parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes);
      parent = parent.return;
    }
  }

  function prepareToReadContext(workInProgress, renderLanes) {
    currentlyRenderingFiber = workInProgress;
    lastFullyObservedContext = lastContextDependency = null;
    workInProgress = workInProgress.dependencies;
    null !== workInProgress && null !== workInProgress.firstContext && (0 !== (workInProgress.lanes & renderLanes) && (didReceiveUpdate = true), workInProgress.firstContext = null);
  }

  function readContext(context) {
    var value = context._currentValue;
    if (lastFullyObservedContext !== context) if (context = {
      context: context,
      memoizedValue: value,
      next: null
    }, null === lastContextDependency) {
      if (null === currentlyRenderingFiber) throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      lastContextDependency = context;
      currentlyRenderingFiber.dependencies = {
        lanes: 0,
        firstContext: context
      };
    } else lastContextDependency = lastContextDependency.next = context;
    return value;
  }

  var interleavedQueues = null,
      hasForceUpdate = false;

  function initializeUpdateQueue(fiber) {
    fiber.updateQueue = {
      baseState: fiber.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
        pending: null,
        interleaved: null,
        lanes: 0
      },
      effects: null
    };
  }

  function cloneUpdateQueue(current, workInProgress) {
    current = current.updateQueue;
    workInProgress.updateQueue === current && (workInProgress.updateQueue = {
      baseState: current.baseState,
      firstBaseUpdate: current.firstBaseUpdate,
      lastBaseUpdate: current.lastBaseUpdate,
      shared: current.shared,
      effects: current.effects
    });
  }

  function createUpdate(eventTime, lane) {
    return {
      eventTime: eventTime,
      lane: lane,
      tag: 0,
      payload: null,
      callback: null,
      next: null
    };
  }

  function enqueueUpdate(fiber, update) {
    var updateQueue = fiber.updateQueue;
    null !== updateQueue && (updateQueue = updateQueue.shared, null !== workInProgressRoot && 0 !== (fiber.mode & 1) && 0 === (executionContext & 8) ? (fiber = updateQueue.interleaved, null === fiber ? (update.next = update, null === interleavedQueues ? interleavedQueues = [updateQueue] : interleavedQueues.push(updateQueue)) : (update.next = fiber.next, fiber.next = update), updateQueue.interleaved = update) : (fiber = updateQueue.pending, null === fiber ? update.next = update : (update.next = fiber.next, fiber.next = update), updateQueue.pending = update));
  }

  function entangleTransitions(root, fiber, lane) {
    fiber = fiber.updateQueue;

    if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194240))) {
      var queueLanes = fiber.lanes;
      queueLanes &= root.pendingLanes;
      lane |= queueLanes;
      fiber.lanes = lane;
      markRootEntangled(root, lane);
    }
  }

  function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
    var queue = workInProgress.updateQueue,
        current = workInProgress.alternate;

    if (null !== current && (current = current.updateQueue, queue === current)) {
      var newFirst = null,
          newLast = null;
      queue = queue.firstBaseUpdate;

      if (null !== queue) {
        do {
          var clone = {
            eventTime: queue.eventTime,
            lane: queue.lane,
            tag: queue.tag,
            payload: queue.payload,
            callback: queue.callback,
            next: null
          };
          null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
          queue = queue.next;
        } while (null !== queue);

        null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
      } else newFirst = newLast = capturedUpdate;

      queue = {
        baseState: current.baseState,
        firstBaseUpdate: newFirst,
        lastBaseUpdate: newLast,
        shared: current.shared,
        effects: current.effects
      };
      workInProgress.updateQueue = queue;
      return;
    }

    workInProgress = queue.lastBaseUpdate;
    null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;
    queue.lastBaseUpdate = capturedUpdate;
  }

  function processUpdateQueue(workInProgress$jscomp$0, props, instance, renderLanes) {
    var queue = workInProgress$jscomp$0.updateQueue;
    hasForceUpdate = false;
    var firstBaseUpdate = queue.firstBaseUpdate,
        lastBaseUpdate = queue.lastBaseUpdate,
        pendingQueue = queue.shared.pending;

    if (null !== pendingQueue) {
      queue.shared.pending = null;
      var lastPendingUpdate = pendingQueue,
          firstPendingUpdate = lastPendingUpdate.next;
      lastPendingUpdate.next = null;
      null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
      lastBaseUpdate = lastPendingUpdate;
      var current = workInProgress$jscomp$0.alternate;
      null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
    }

    if (null !== firstBaseUpdate) {
      var newState = queue.baseState;
      lastBaseUpdate = 0;
      current = firstPendingUpdate = lastPendingUpdate = null;
      pendingQueue = firstBaseUpdate;

      do {
        var updateLane = pendingQueue.lane,
            updateEventTime = pendingQueue.eventTime;

        if ((renderLanes & updateLane) === updateLane) {
          null !== current && (current = current.next = {
            eventTime: updateEventTime,
            lane: 0,
            tag: pendingQueue.tag,
            payload: pendingQueue.payload,
            callback: pendingQueue.callback,
            next: null
          });

          a: {
            var workInProgress = workInProgress$jscomp$0,
                update = pendingQueue;
            updateLane = props;
            updateEventTime = instance;

            switch (update.tag) {
              case 1:
                workInProgress = update.payload;

                if ("function" === typeof workInProgress) {
                  newState = workInProgress.call(updateEventTime, newState, updateLane);
                  break a;
                }

                newState = workInProgress;
                break a;

              case 3:
                workInProgress.flags = workInProgress.flags & -16385 | 128;

              case 0:
                workInProgress = update.payload;
                updateLane = "function" === typeof workInProgress ? workInProgress.call(updateEventTime, newState, updateLane) : workInProgress;
                if (null === updateLane || undefined === updateLane) break a;
                newState = _$$_REQUIRE(_dependencyMap[2])({}, newState, updateLane);
                break a;

              case 2:
                hasForceUpdate = true;
            }
          }

          null !== pendingQueue.callback && 0 !== pendingQueue.lane && (workInProgress$jscomp$0.flags |= 64, updateLane = queue.effects, null === updateLane ? queue.effects = [pendingQueue] : updateLane.push(pendingQueue));
        } else updateEventTime = {
          eventTime: updateEventTime,
          lane: updateLane,
          tag: pendingQueue.tag,
          payload: pendingQueue.payload,
          callback: pendingQueue.callback,
          next: null
        }, null === current ? (firstPendingUpdate = current = updateEventTime, lastPendingUpdate = newState) : current = current.next = updateEventTime, lastBaseUpdate |= updateLane;

        pendingQueue = pendingQueue.next;
        if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;else updateLane = pendingQueue, pendingQueue = updateLane.next, updateLane.next = null, queue.lastBaseUpdate = updateLane, queue.shared.pending = null;
      } while (1);

      null === current && (lastPendingUpdate = newState);
      queue.baseState = lastPendingUpdate;
      queue.firstBaseUpdate = firstPendingUpdate;
      queue.lastBaseUpdate = current;
      props = queue.shared.interleaved;

      if (null !== props) {
        queue = props;

        do {
          lastBaseUpdate |= queue.lane, queue = queue.next;
        } while (queue !== props);
      } else null === firstBaseUpdate && (queue.shared.lanes = 0);

      workInProgressRootSkippedLanes |= lastBaseUpdate;
      workInProgress$jscomp$0.lanes = lastBaseUpdate;
      workInProgress$jscomp$0.memoizedState = newState;
    }
  }

  function commitUpdateQueue(finishedWork, finishedQueue, instance) {
    finishedWork = finishedQueue.effects;
    finishedQueue.effects = null;
    if (null !== finishedWork) for (finishedQueue = 0; finishedQueue < finishedWork.length; finishedQueue++) {
      var effect = finishedWork[finishedQueue],
          callback = effect.callback;

      if (null !== callback) {
        effect.callback = null;
        if ("function" !== typeof callback) throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
        callback.call(instance);
      }
    }
  }

  var emptyRefsObject = new React.Component().refs;

  function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
    ctor = workInProgress.memoizedState;
    getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
    getDerivedStateFromProps = null === getDerivedStateFromProps || undefined === getDerivedStateFromProps ? ctor : _$$_REQUIRE(_dependencyMap[2])({}, ctor, getDerivedStateFromProps);
    workInProgress.memoizedState = getDerivedStateFromProps;
    0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
  }

  var classComponentUpdater = {
    isMounted: function isMounted(component) {
      return (component = component._reactInternals) ? getNearestMountedFiber(component) === component : false;
    },
    enqueueSetState: function enqueueSetState(inst, payload, callback) {
      inst = inst._reactInternals;
      var eventTime = requestEventTime(),
          lane = requestUpdateLane(inst),
          update = createUpdate(eventTime, lane);
      update.payload = payload;
      undefined !== callback && null !== callback && (update.callback = callback);
      enqueueUpdate(inst, update);
      payload = scheduleUpdateOnFiber(inst, lane, eventTime);
      null !== payload && entangleTransitions(payload, inst, lane);
    },
    enqueueReplaceState: function enqueueReplaceState(inst, payload, callback) {
      inst = inst._reactInternals;
      var eventTime = requestEventTime(),
          lane = requestUpdateLane(inst),
          update = createUpdate(eventTime, lane);
      update.tag = 1;
      update.payload = payload;
      undefined !== callback && null !== callback && (update.callback = callback);
      enqueueUpdate(inst, update);
      payload = scheduleUpdateOnFiber(inst, lane, eventTime);
      null !== payload && entangleTransitions(payload, inst, lane);
    },
    enqueueForceUpdate: function enqueueForceUpdate(inst, callback) {
      inst = inst._reactInternals;
      var eventTime = requestEventTime(),
          lane = requestUpdateLane(inst),
          update = createUpdate(eventTime, lane);
      update.tag = 2;
      undefined !== callback && null !== callback && (update.callback = callback);
      enqueueUpdate(inst, update);
      callback = scheduleUpdateOnFiber(inst, lane, eventTime);
      null !== callback && entangleTransitions(callback, inst, lane);
    }
  };

  function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
    workInProgress = workInProgress.stateNode;
    return "function" === typeof workInProgress.shouldComponentUpdate ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
  }

  function constructClassInstance(workInProgress, ctor, props) {
    var isLegacyContextConsumer = false,
        unmaskedContext = emptyContextObject;
    var context = ctor.contextType;
    "object" === typeof context && null !== context ? context = readContext(context) : (unmaskedContext = isContextProvider(ctor) ? previousContext : contextStackCursor.current, isLegacyContextConsumer = ctor.contextTypes, context = (isLegacyContextConsumer = null !== isLegacyContextConsumer && undefined !== isLegacyContextConsumer) ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject);
    ctor = new ctor(props, context);
    workInProgress.memoizedState = null !== ctor.state && undefined !== ctor.state ? ctor.state : null;
    ctor.updater = classComponentUpdater;
    workInProgress.stateNode = ctor;
    ctor._reactInternals = workInProgress;
    isLegacyContextConsumer && (workInProgress = workInProgress.stateNode, workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext, workInProgress.__reactInternalMemoizedMaskedChildContext = context);
    return ctor;
  }

  function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
    workInProgress = instance.state;
    "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
    "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
    instance.state !== workInProgress && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }

  function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
    var instance = workInProgress.stateNode;
    instance.props = newProps;
    instance.state = workInProgress.memoizedState;
    instance.refs = emptyRefsObject;
    initializeUpdateQueue(workInProgress);
    var contextType = ctor.contextType;
    "object" === typeof contextType && null !== contextType ? instance.context = readContext(contextType) : (contextType = isContextProvider(ctor) ? previousContext : contextStackCursor.current, instance.context = getMaskedContext(workInProgress, contextType));
    instance.state = workInProgress.memoizedState;
    contextType = ctor.getDerivedStateFromProps;
    "function" === typeof contextType && (applyDerivedStateFromProps(workInProgress, ctor, contextType, newProps), instance.state = workInProgress.memoizedState);
    "function" === typeof ctor.getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate || "function" !== typeof instance.UNSAFE_componentWillMount && "function" !== typeof instance.componentWillMount || (ctor = instance.state, "function" === typeof instance.componentWillMount && instance.componentWillMount(), "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount(), ctor !== instance.state && classComponentUpdater.enqueueReplaceState(instance, instance.state, null), processUpdateQueue(workInProgress, newProps, instance, renderLanes), instance.state = workInProgress.memoizedState);
    "function" === typeof instance.componentDidMount && (workInProgress.flags |= 4);
  }

  function coerceRef(returnFiber, current, element) {
    returnFiber = element.ref;

    if (null !== returnFiber && "function" !== typeof returnFiber && "object" !== typeof returnFiber) {
      if (element._owner) {
        element = element._owner;

        if (element) {
          if (1 !== element.tag) throw Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
          var inst = element.stateNode;
        }

        if (!inst) throw Error("Missing owner for string ref " + returnFiber + ". This error is likely caused by a bug in React. Please file an issue.");
        var stringRef = "" + returnFiber;
        if (null !== current && null !== current.ref && "function" === typeof current.ref && current.ref._stringRef === stringRef) return current.ref;

        current = function current(value) {
          var refs = inst.refs;
          refs === emptyRefsObject && (refs = inst.refs = {});
          null === value ? delete refs[stringRef] : refs[stringRef] = value;
        };

        current._stringRef = stringRef;
        return current;
      }

      if ("string" !== typeof returnFiber) throw Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
      if (!element._owner) throw Error("Element ref was specified as a string (" + returnFiber + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
    }

    return returnFiber;
  }

  function throwOnInvalidObjectType(returnFiber, newChild) {
    returnFiber = Object.prototype.toString.call(newChild);
    throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead.");
  }

  function ChildReconciler(shouldTrackSideEffects) {
    function deleteChild(returnFiber, childToDelete) {
      if (shouldTrackSideEffects) {
        var deletions = returnFiber.deletions;
        null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
      }
    }

    function deleteRemainingChildren(returnFiber, currentFirstChild) {
      if (!shouldTrackSideEffects) return null;

      for (; null !== currentFirstChild;) {
        deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      }

      return null;
    }

    function mapRemainingChildren(returnFiber, currentFirstChild) {
      for (returnFiber = new Map(); null !== currentFirstChild;) {
        null !== currentFirstChild.key ? returnFiber.set(currentFirstChild.key, currentFirstChild) : returnFiber.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      }

      return returnFiber;
    }

    function useFiber(fiber, pendingProps) {
      fiber = createWorkInProgress(fiber, pendingProps);
      fiber.index = 0;
      fiber.sibling = null;
      return fiber;
    }

    function placeChild(newFiber, lastPlacedIndex, newIndex) {
      newFiber.index = newIndex;
      if (!shouldTrackSideEffects) return lastPlacedIndex;
      newIndex = newFiber.alternate;
      if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 2, lastPlacedIndex) : newIndex;
      newFiber.flags |= 2;
      return lastPlacedIndex;
    }

    function placeSingleChild(newFiber) {
      shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 2);
      return newFiber;
    }

    function updateTextNode(returnFiber, current, textContent, lanes) {
      if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
      current = useFiber(current, textContent);
      current.return = returnFiber;
      return current;
    }

    function updateElement(returnFiber, current, element, lanes) {
      var elementType = element.type;
      if (elementType === REACT_FRAGMENT_TYPE) return updateFragment(returnFiber, current, element.props.children, lanes, element.key);
      if (null !== current && current.elementType === elementType) return lanes = useFiber(current, element.props), lanes.ref = coerceRef(returnFiber, current, element), lanes.return = returnFiber, lanes;
      lanes = createFiberFromTypeAndProps(element.type, element.key, element.props, null, returnFiber.mode, lanes);
      lanes.ref = coerceRef(returnFiber, current, element);
      lanes.return = returnFiber;
      return lanes;
    }

    function updatePortal(returnFiber, current, portal, lanes) {
      if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
      current = useFiber(current, portal.children || []);
      current.return = returnFiber;
      return current;
    }

    function updateFragment(returnFiber, current, fragment, lanes, key) {
      if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current;
      current = useFiber(current, fragment);
      current.return = returnFiber;
      return current;
    }

    function createChild(returnFiber, newChild, lanes) {
      if ("string" === typeof newChild || "number" === typeof newChild) return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes), lanes.ref = coerceRef(returnFiber, null, newChild), lanes.return = returnFiber, lanes;

          case REACT_PORTAL_TYPE:
            return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;
        }

        if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newChild = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), newChild.return = returnFiber, newChild;
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      return null;
    }

    function updateSlot(returnFiber, oldFiber, newChild, lanes) {
      var key = null !== oldFiber ? oldFiber.key : null;
      if ("string" === typeof newChild || "number" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;

          case REACT_PORTAL_TYPE:
            return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
        }

        if (isArrayImpl(newChild) || getIteratorFn(newChild)) return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      return null;
    }

    function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
      if ("string" === typeof newChild || "number" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updateElement(returnFiber, existingChildren, newChild, lanes);

          case REACT_PORTAL_TYPE:
            return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
        }

        if (isArrayImpl(newChild) || getIteratorFn(newChild)) return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      return null;
    }

    function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
      for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);

        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }

        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }

      if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), resultingFirstChild;

      if (null === oldFiber) {
        for (; newIdx < newChildren.length; newIdx++) {
          oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
        }

        return resultingFirstChild;
      }

      for (oldFiber = mapRemainingChildren(returnFiber, oldFiber); newIdx < newChildren.length; newIdx++) {
        nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
      }

      shouldTrackSideEffects && oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
      return resultingFirstChild;
    }

    function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
      var iteratorFn = getIteratorFn(newChildrenIterable);
      if ("function" !== typeof iteratorFn) throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
      newChildrenIterable = iteratorFn.call(newChildrenIterable);
      if (null == newChildrenIterable) throw Error("An iterable object provided no iterator.");

      for (var previousNewFiber = iteratorFn = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildrenIterable.next(); null !== oldFiber && !step.done; newIdx++, step = newChildrenIterable.next()) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);

        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }

        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? iteratorFn = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }

      if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), iteratorFn;

      if (null === oldFiber) {
        for (; !step.done; newIdx++, step = newChildrenIterable.next()) {
          step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? iteratorFn = step : previousNewFiber.sibling = step, previousNewFiber = step);
        }

        return iteratorFn;
      }

      for (oldFiber = mapRemainingChildren(returnFiber, oldFiber); !step.done; newIdx++, step = newChildrenIterable.next()) {
        step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? iteratorFn = step : previousNewFiber.sibling = step, previousNewFiber = step);
      }

      shouldTrackSideEffects && oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
      return iteratorFn;
    }

    return function (returnFiber, currentFirstChild, newChild, lanes) {
      var isUnkeyedTopLevelFragment = "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key;
      isUnkeyedTopLevelFragment && (newChild = newChild.props.children);

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            a: {
              var key = newChild.key;

              for (isUnkeyedTopLevelFragment = currentFirstChild; null !== isUnkeyedTopLevelFragment;) {
                if (isUnkeyedTopLevelFragment.key === key) {
                  key = newChild.type;

                  if (key === REACT_FRAGMENT_TYPE) {
                    if (7 === isUnkeyedTopLevelFragment.tag) {
                      deleteRemainingChildren(returnFiber, isUnkeyedTopLevelFragment.sibling);
                      currentFirstChild = useFiber(isUnkeyedTopLevelFragment, newChild.props.children);
                      currentFirstChild.return = returnFiber;
                      returnFiber = currentFirstChild;
                      break a;
                    }
                  } else if (isUnkeyedTopLevelFragment.elementType === key) {
                    deleteRemainingChildren(returnFiber, isUnkeyedTopLevelFragment.sibling);
                    currentFirstChild = useFiber(isUnkeyedTopLevelFragment, newChild.props);
                    currentFirstChild.ref = coerceRef(returnFiber, isUnkeyedTopLevelFragment, newChild);
                    currentFirstChild.return = returnFiber;
                    returnFiber = currentFirstChild;
                    break a;
                  }

                  deleteRemainingChildren(returnFiber, isUnkeyedTopLevelFragment);
                  break;
                } else deleteChild(returnFiber, isUnkeyedTopLevelFragment);

                isUnkeyedTopLevelFragment = isUnkeyedTopLevelFragment.sibling;
              }

              newChild.type === REACT_FRAGMENT_TYPE ? (currentFirstChild = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), currentFirstChild.return = returnFiber, returnFiber = currentFirstChild) : (lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes), lanes.ref = coerceRef(returnFiber, currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes);
            }

            return placeSingleChild(returnFiber);

          case REACT_PORTAL_TYPE:
            a: {
              for (isUnkeyedTopLevelFragment = newChild.key; null !== currentFirstChild;) {
                if (currentFirstChild.key === isUnkeyedTopLevelFragment) {
                  if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                    currentFirstChild = useFiber(currentFirstChild, newChild.children || []);
                    currentFirstChild.return = returnFiber;
                    returnFiber = currentFirstChild;
                    break a;
                  } else {
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  }
                } else deleteChild(returnFiber, currentFirstChild);
                currentFirstChild = currentFirstChild.sibling;
              }

              currentFirstChild = createFiberFromPortal(newChild, returnFiber.mode, lanes);
              currentFirstChild.return = returnFiber;
              returnFiber = currentFirstChild;
            }

            return placeSingleChild(returnFiber);
        }

        if (isArrayImpl(newChild)) return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
        if (getIteratorFn(newChild)) return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      if ("string" === typeof newChild || "number" === typeof newChild) return newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), currentFirstChild = useFiber(currentFirstChild, newChild), currentFirstChild.return = returnFiber, returnFiber = currentFirstChild) : (deleteRemainingChildren(returnFiber, currentFirstChild), currentFirstChild = createFiberFromText(newChild, returnFiber.mode, lanes), currentFirstChild.return = returnFiber, returnFiber = currentFirstChild), placeSingleChild(returnFiber);
      if ("undefined" === typeof newChild && !isUnkeyedTopLevelFragment) switch (returnFiber.tag) {
        case 1:
        case 0:
        case 11:
        case 15:
          throw Error((getComponentNameFromFiber(returnFiber) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
      }
      return deleteRemainingChildren(returnFiber, currentFirstChild);
    };
  }

  var reconcileChildFibers = ChildReconciler(true),
      mountChildFibers = ChildReconciler(false),
      NO_CONTEXT = {},
      contextStackCursor$1 = createCursor(NO_CONTEXT),
      contextFiberStackCursor = createCursor(NO_CONTEXT),
      rootInstanceStackCursor = createCursor(NO_CONTEXT);

  function requiredContext(c) {
    if (c === NO_CONTEXT) throw Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
    return c;
  }

  function pushHostContainer(fiber, nextRootInstance) {
    push(rootInstanceStackCursor, nextRootInstance);
    push(contextFiberStackCursor, fiber);
    push(contextStackCursor$1, NO_CONTEXT);
    pop(contextStackCursor$1);
    push(contextStackCursor$1, {
      isInAParentText: false
    });
  }

  function popHostContainer() {
    pop(contextStackCursor$1);
    pop(contextFiberStackCursor);
    pop(rootInstanceStackCursor);
  }

  function pushHostContext(fiber) {
    requiredContext(rootInstanceStackCursor.current);
    var context = requiredContext(contextStackCursor$1.current);
    var JSCompiler_inline_result = fiber.type;
    JSCompiler_inline_result = "AndroidTextInput" === JSCompiler_inline_result || "RCTMultilineTextInputView" === JSCompiler_inline_result || "RCTSinglelineTextInputView" === JSCompiler_inline_result || "RCTText" === JSCompiler_inline_result || "RCTVirtualText" === JSCompiler_inline_result;
    JSCompiler_inline_result = context.isInAParentText !== JSCompiler_inline_result ? {
      isInAParentText: JSCompiler_inline_result
    } : context;
    context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor$1, JSCompiler_inline_result));
  }

  function popHostContext(fiber) {
    contextFiberStackCursor.current === fiber && (pop(contextStackCursor$1), pop(contextFiberStackCursor));
  }

  var suspenseStackCursor = createCursor(0);

  function findFirstSuspended(row) {
    for (var node = row; null !== node;) {
      if (13 === node.tag) {
        var state = node.memoizedState;
        if (null !== state && (null === state.dehydrated || shim() || shim())) return node;
      } else if (19 === node.tag && undefined !== node.memoizedProps.revealOrder) {
        if (0 !== (node.flags & 128)) return node;
      } else if (null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === row) break;

      for (; null === node.sibling;) {
        if (null === node.return || node.return === row) return null;
        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }

    return null;
  }

  var workInProgressSources = [];

  function resetWorkInProgressVersions() {
    for (var i = 0; i < workInProgressSources.length; i++) {
      workInProgressSources[i]._workInProgressVersionPrimary = null;
    }

    workInProgressSources.length = 0;
  }

  var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
      ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig,
      renderLanes = 0,
      currentlyRenderingFiber$1 = null,
      currentHook = null,
      workInProgressHook = null,
      didScheduleRenderPhaseUpdate = false,
      didScheduleRenderPhaseUpdateDuringThisPass = false;

  function throwInvalidHookError() {
    throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
  }

  function areHookInputsEqual(nextDeps, prevDeps) {
    if (null === prevDeps) return false;

    for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
      if (!objectIs(nextDeps[i], prevDeps[i])) return false;
    }

    return true;
  }

  function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
    renderLanes = nextRenderLanes;
    currentlyRenderingFiber$1 = workInProgress;
    workInProgress.memoizedState = null;
    workInProgress.updateQueue = null;
    workInProgress.lanes = 0;
    ReactCurrentDispatcher$1.current = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
    current = Component(props, secondArg);

    if (didScheduleRenderPhaseUpdateDuringThisPass) {
      nextRenderLanes = 0;

      do {
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        if (!(25 > nextRenderLanes)) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        nextRenderLanes += 1;
        workInProgressHook = currentHook = null;
        workInProgress.updateQueue = null;
        ReactCurrentDispatcher$1.current = HooksDispatcherOnRerender;
        current = Component(props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
    }

    ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
    workInProgress = null !== currentHook && null !== currentHook.next;
    renderLanes = 0;
    workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
    didScheduleRenderPhaseUpdate = false;
    if (workInProgress) throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
    return current;
  }

  function mountWorkInProgressHook() {
    var hook = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
    return workInProgressHook;
  }

  function updateWorkInProgressHook() {
    if (null === currentHook) {
      var nextCurrentHook = currentlyRenderingFiber$1.alternate;
      nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
    } else nextCurrentHook = currentHook.next;

    var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next;
    if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;else {
      if (null === nextCurrentHook) throw Error("Rendered more hooks than during the previous render.");
      currentHook = nextCurrentHook;
      nextCurrentHook = {
        memoizedState: currentHook.memoizedState,
        baseState: currentHook.baseState,
        baseQueue: currentHook.baseQueue,
        queue: currentHook.queue,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
    }
    return workInProgressHook;
  }

  function basicStateReducer(state, action) {
    return "function" === typeof action ? action(state) : action;
  }

  function updateReducer(reducer) {
    var hook = updateWorkInProgressHook(),
        queue = hook.queue;
    if (null === queue) throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
    queue.lastRenderedReducer = reducer;
    var current = currentHook,
        baseQueue = current.baseQueue,
        pendingQueue = queue.pending;

    if (null !== pendingQueue) {
      if (null !== baseQueue) {
        var baseFirst = baseQueue.next;
        baseQueue.next = pendingQueue.next;
        pendingQueue.next = baseFirst;
      }

      current.baseQueue = baseQueue = pendingQueue;
      queue.pending = null;
    }

    if (null !== baseQueue) {
      pendingQueue = baseQueue.next;
      current = current.baseState;
      var newBaseQueueFirst = baseFirst = null,
          newBaseQueueLast = null,
          update = pendingQueue;

      do {
        var updateLane = update.lane;
        if ((renderLanes & updateLane) === updateLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
          lane: 0,
          action: update.action,
          eagerReducer: update.eagerReducer,
          eagerState: update.eagerState,
          next: null
        }), current = update.eagerReducer === reducer ? update.eagerState : reducer(current, update.action);else {
          var clone = {
            lane: updateLane,
            action: update.action,
            eagerReducer: update.eagerReducer,
            eagerState: update.eagerState,
            next: null
          };
          null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = clone, baseFirst = current) : newBaseQueueLast = newBaseQueueLast.next = clone;
          currentlyRenderingFiber$1.lanes |= updateLane;
          workInProgressRootSkippedLanes |= updateLane;
        }
        update = update.next;
      } while (null !== update && update !== pendingQueue);

      null === newBaseQueueLast ? baseFirst = current : newBaseQueueLast.next = newBaseQueueFirst;
      objectIs(current, hook.memoizedState) || (didReceiveUpdate = true);
      hook.memoizedState = current;
      hook.baseState = baseFirst;
      hook.baseQueue = newBaseQueueLast;
      queue.lastRenderedState = current;
    }

    reducer = queue.interleaved;

    if (null !== reducer) {
      baseQueue = reducer;

      do {
        pendingQueue = baseQueue.lane, currentlyRenderingFiber$1.lanes |= pendingQueue, workInProgressRootSkippedLanes |= pendingQueue, baseQueue = baseQueue.next;
      } while (baseQueue !== reducer);
    } else null === baseQueue && (queue.lanes = 0);

    return [hook.memoizedState, queue.dispatch];
  }

  function rerenderReducer(reducer) {
    var hook = updateWorkInProgressHook(),
        queue = hook.queue;
    if (null === queue) throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
    queue.lastRenderedReducer = reducer;
    var dispatch = queue.dispatch,
        lastRenderPhaseUpdate = queue.pending,
        newState = hook.memoizedState;

    if (null !== lastRenderPhaseUpdate) {
      queue.pending = null;
      var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;

      do {
        newState = reducer(newState, update.action), update = update.next;
      } while (update !== lastRenderPhaseUpdate);

      objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
      hook.memoizedState = newState;
      null === hook.baseQueue && (hook.baseState = newState);
      queue.lastRenderedState = newState;
    }

    return [newState, dispatch];
  }

  function readFromUnsubcribedMutableSource(root, source, getSnapshot) {
    var getVersion = source._getVersion;
    getVersion = getVersion(source._source);
    var JSCompiler_inline_result = source._workInProgressVersionPrimary;
    if (null !== JSCompiler_inline_result) root = JSCompiler_inline_result === getVersion;else if (root = root.mutableReadLanes, root = (renderLanes & root) === root) source._workInProgressVersionPrimary = getVersion, workInProgressSources.push(source);
    if (root) return getSnapshot(source._source);
    workInProgressSources.push(source);
    throw Error("Cannot read from mutable source during the current render without tearing. This may be a bug in React. Please file an issue.");
  }

  function _useMutableSource(hook, source, getSnapshot, subscribe) {
    var root = workInProgressRoot;
    if (null === root) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");

    var getVersion = source._getVersion,
        version = getVersion(source._source),
        dispatcher = ReactCurrentDispatcher$1.current,
        _dispatcher$useState = dispatcher.useState(function () {
      return readFromUnsubcribedMutableSource(root, source, getSnapshot);
    }),
        setSnapshot = _dispatcher$useState[1],
        snapshot = _dispatcher$useState[0];

    _dispatcher$useState = workInProgressHook;
    var memoizedState = hook.memoizedState,
        refs = memoizedState.refs,
        prevGetSnapshot = refs.getSnapshot,
        prevSource = memoizedState.source;
    memoizedState = memoizedState.subscribe;
    var fiber = currentlyRenderingFiber$1;
    hook.memoizedState = {
      refs: refs,
      source: source,
      subscribe: subscribe
    };
    dispatcher.useEffect(function () {
      refs.getSnapshot = getSnapshot;
      refs.setSnapshot = setSnapshot;
      var maybeNewVersion = getVersion(source._source);
      objectIs(version, maybeNewVersion) || (maybeNewVersion = getSnapshot(source._source), objectIs(snapshot, maybeNewVersion) || (setSnapshot(maybeNewVersion), maybeNewVersion = requestUpdateLane(fiber), root.mutableReadLanes |= maybeNewVersion & root.pendingLanes), markRootEntangled(root, root.mutableReadLanes));
    }, [getSnapshot, source, subscribe]);
    dispatcher.useEffect(function () {
      return subscribe(source._source, function () {
        var latestGetSnapshot = refs.getSnapshot,
            latestSetSnapshot = refs.setSnapshot;

        try {
          latestSetSnapshot(latestGetSnapshot(source._source));
          var lane = requestUpdateLane(fiber);
          root.mutableReadLanes |= lane & root.pendingLanes;
        } catch (error) {
          latestSetSnapshot(function () {
            throw error;
          });
        }
      });
    }, [source, subscribe]);
    objectIs(prevGetSnapshot, getSnapshot) && objectIs(prevSource, source) && objectIs(memoizedState, subscribe) || (hook = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: snapshot
    }, hook.dispatch = setSnapshot = dispatchAction.bind(null, currentlyRenderingFiber$1, hook), _dispatcher$useState.queue = hook, _dispatcher$useState.baseQueue = null, snapshot = readFromUnsubcribedMutableSource(root, source, getSnapshot), _dispatcher$useState.memoizedState = _dispatcher$useState.baseState = snapshot);
    return snapshot;
  }

  function updateMutableSource(source, getSnapshot, subscribe) {
    var hook = updateWorkInProgressHook();
    return _useMutableSource(hook, source, getSnapshot, subscribe);
  }

  function mountState(initialState) {
    var hook = mountWorkInProgressHook();
    "function" === typeof initialState && (initialState = initialState());
    hook.memoizedState = hook.baseState = initialState;
    initialState = hook.queue = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: initialState
    };
    initialState = initialState.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, initialState);
    return [hook.memoizedState, initialState];
  }

  function pushEffect(tag, create, destroy, deps) {
    tag = {
      tag: tag,
      create: create,
      destroy: destroy,
      deps: deps,
      next: null
    };
    create = currentlyRenderingFiber$1.updateQueue;
    null === create ? (create = {
      lastEffect: null
    }, currentlyRenderingFiber$1.updateQueue = create, create.lastEffect = tag.next = tag) : (destroy = create.lastEffect, null === destroy ? create.lastEffect = tag.next = tag : (deps = destroy.next, destroy.next = tag, tag.next = deps, create.lastEffect = tag));
    return tag;
  }

  function updateRef() {
    return updateWorkInProgressHook().memoizedState;
  }

  function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
    var hook = mountWorkInProgressHook();
    currentlyRenderingFiber$1.flags |= fiberFlags;
    hook.memoizedState = pushEffect(1 | hookFlags, create, undefined, undefined === deps ? null : deps);
  }

  function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
    var hook = updateWorkInProgressHook();
    deps = undefined === deps ? null : deps;
    var destroy = undefined;

    if (null !== currentHook) {
      var prevEffect = currentHook.memoizedState;
      destroy = prevEffect.destroy;

      if (null !== deps && areHookInputsEqual(deps, prevEffect.deps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, deps);
        return;
      }
    }

    currentlyRenderingFiber$1.flags |= fiberFlags;
    hook.memoizedState = pushEffect(1 | hookFlags, create, destroy, deps);
  }

  function mountEffect(create, deps) {
    return mountEffectImpl(1049600, 4, create, deps);
  }

  function updateEffect(create, deps) {
    return updateEffectImpl(1024, 4, create, deps);
  }

  function updateLayoutEffect(create, deps) {
    return updateEffectImpl(4, 2, create, deps);
  }

  function imperativeHandleEffect(create, ref) {
    if ("function" === typeof ref) return create = create(), ref(create), function () {
      ref(null);
    };
    if (null !== ref && undefined !== ref) return create = create(), ref.current = create, function () {
      ref.current = null;
    };
  }

  function updateImperativeHandle(ref, create, deps) {
    deps = null !== deps && undefined !== deps ? deps.concat([ref]) : null;
    return updateEffectImpl(4, 2, imperativeHandleEffect.bind(null, create, ref), deps);
  }

  function mountDebugValue() {}

  function updateCallback(callback, deps) {
    var hook = updateWorkInProgressHook();
    deps = undefined === deps ? null : deps;
    var prevState = hook.memoizedState;
    if (null !== prevState && null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
    hook.memoizedState = [callback, deps];
    return callback;
  }

  function updateMemo(nextCreate, deps) {
    var hook = updateWorkInProgressHook();
    deps = undefined === deps ? null : deps;
    var prevState = hook.memoizedState;
    if (null !== prevState && null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
    nextCreate = nextCreate();
    hook.memoizedState = [nextCreate, deps];
    return nextCreate;
  }

  function startTransition(setPending, callback) {
    var previousPriority = currentUpdatePriority;
    currentUpdatePriority = 0 !== previousPriority && 4 > previousPriority ? previousPriority : 4;
    setPending(true);
    var prevTransition = ReactCurrentBatchConfig$1.transition;
    ReactCurrentBatchConfig$1.transition = 1;

    try {
      setPending(false), callback();
    } finally {
      currentUpdatePriority = previousPriority, ReactCurrentBatchConfig$1.transition = prevTransition;
    }
  }

  function dispatchAction(fiber, queue, action) {
    var eventTime = requestEventTime(),
        lane = requestUpdateLane(fiber),
        update = {
      lane: lane,
      action: action,
      eagerReducer: null,
      eagerState: null,
      next: null
    },
        alternate = fiber.alternate;
    if (fiber === currentlyRenderingFiber$1 || null !== alternate && alternate === currentlyRenderingFiber$1) didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true, lane = queue.pending, null === lane ? update.next = update : (update.next = lane.next, lane.next = update), queue.pending = update;else {
      if (null !== workInProgressRoot && 0 !== (fiber.mode & 1) && 0 === (executionContext & 8)) {
        var interleaved = queue.interleaved;
        null === interleaved ? (update.next = update, null === interleavedQueues ? interleavedQueues = [queue] : interleavedQueues.push(queue)) : (update.next = interleaved.next, interleaved.next = update);
        queue.interleaved = update;
      } else interleaved = queue.pending, null === interleaved ? update.next = update : (update.next = interleaved.next, interleaved.next = update), queue.pending = update;

      if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) try {
        var currentState = queue.lastRenderedState,
            eagerState = alternate(currentState, action);
        update.eagerReducer = alternate;
        update.eagerState = eagerState;
        if (objectIs(eagerState, currentState)) return;
      } catch (error) {} finally {}
      update = scheduleUpdateOnFiber(fiber, lane, eventTime);
      0 !== (lane & 4194240) && null !== update && (fiber = queue.lanes, fiber &= update.pendingLanes, lane |= fiber, queue.lanes = lane, markRootEntangled(update, lane));
    }
  }

  var ContextOnlyDispatcher = {
    readContext: readContext,
    useCallback: throwInvalidHookError,
    useContext: throwInvalidHookError,
    useEffect: throwInvalidHookError,
    useImperativeHandle: throwInvalidHookError,
    useLayoutEffect: throwInvalidHookError,
    useMemo: throwInvalidHookError,
    useReducer: throwInvalidHookError,
    useRef: throwInvalidHookError,
    useState: throwInvalidHookError,
    useDebugValue: throwInvalidHookError,
    useDeferredValue: throwInvalidHookError,
    useTransition: throwInvalidHookError,
    useMutableSource: throwInvalidHookError,
    useOpaqueIdentifier: throwInvalidHookError,
    unstable_isNewReconciler: false
  },
      HooksDispatcherOnMount = {
    readContext: readContext,
    useCallback: function useCallback(callback, deps) {
      mountWorkInProgressHook().memoizedState = [callback, undefined === deps ? null : deps];
      return callback;
    },
    useContext: readContext,
    useEffect: mountEffect,
    useImperativeHandle: function useImperativeHandle(ref, create, deps) {
      deps = null !== deps && undefined !== deps ? deps.concat([ref]) : null;
      return mountEffectImpl(4, 2, imperativeHandleEffect.bind(null, create, ref), deps);
    },
    useLayoutEffect: function useLayoutEffect(create, deps) {
      return mountEffectImpl(4, 2, create, deps);
    },
    useMemo: function useMemo(nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = undefined === deps ? null : deps;
      nextCreate = nextCreate();
      hook.memoizedState = [nextCreate, deps];
      return nextCreate;
    },
    useReducer: function useReducer(reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      initialArg = undefined !== init ? init(initialArg) : initialArg;
      hook.memoizedState = hook.baseState = initialArg;
      reducer = hook.queue = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialArg
      };
      reducer = reducer.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, reducer);
      return [hook.memoizedState, reducer];
    },
    useRef: function useRef(initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = {
        current: initialValue
      };
      return hook.memoizedState = initialValue;
    },
    useState: mountState,
    useDebugValue: mountDebugValue,
    useDeferredValue: function useDeferredValue(value) {
      var _mountState = mountState(value),
          prevValue = _mountState[0],
          setValue = _mountState[1];

      mountEffect(function () {
        var prevTransition = ReactCurrentBatchConfig$1.transition;
        ReactCurrentBatchConfig$1.transition = 1;

        try {
          setValue(value);
        } finally {
          ReactCurrentBatchConfig$1.transition = prevTransition;
        }
      }, [value]);
      return prevValue;
    },
    useTransition: function useTransition() {
      var _mountState2 = mountState(false),
          isPending = _mountState2[0];

      _mountState2 = startTransition.bind(null, _mountState2[1]);
      mountWorkInProgressHook().memoizedState = _mountState2;
      return [isPending, _mountState2];
    },
    useMutableSource: function useMutableSource(source, getSnapshot, subscribe) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = {
        refs: {
          getSnapshot: getSnapshot,
          setSnapshot: null
        },
        source: source,
        subscribe: subscribe
      };
      return _useMutableSource(hook, source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function useOpaqueIdentifier() {
      throw Error("Not yet implemented");
    },
    unstable_isNewReconciler: false
  },
      HooksDispatcherOnUpdate = {
    readContext: readContext,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: updateReducer,
    useRef: updateRef,
    useState: function useState() {
      return updateReducer(basicStateReducer);
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function useDeferredValue(value) {
      var _updateState = updateReducer(basicStateReducer),
          prevValue = _updateState[0],
          setValue = _updateState[1];

      updateEffect(function () {
        var prevTransition = ReactCurrentBatchConfig$1.transition;
        ReactCurrentBatchConfig$1.transition = 1;

        try {
          setValue(value);
        } finally {
          ReactCurrentBatchConfig$1.transition = prevTransition;
        }
      }, [value]);
      return prevValue;
    },
    useTransition: function useTransition() {
      var isPending = updateReducer(basicStateReducer)[0],
          start = updateWorkInProgressHook().memoizedState;
      return [isPending, start];
    },
    useMutableSource: updateMutableSource,
    useOpaqueIdentifier: function useOpaqueIdentifier() {
      return updateReducer(basicStateReducer)[0];
    },
    unstable_isNewReconciler: false
  },
      HooksDispatcherOnRerender = {
    readContext: readContext,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: rerenderReducer,
    useRef: updateRef,
    useState: function useState() {
      return rerenderReducer(basicStateReducer);
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function useDeferredValue(value) {
      var _rerenderState = rerenderReducer(basicStateReducer),
          prevValue = _rerenderState[0],
          setValue = _rerenderState[1];

      updateEffect(function () {
        var prevTransition = ReactCurrentBatchConfig$1.transition;
        ReactCurrentBatchConfig$1.transition = 1;

        try {
          setValue(value);
        } finally {
          ReactCurrentBatchConfig$1.transition = prevTransition;
        }
      }, [value]);
      return prevValue;
    },
    useTransition: function useTransition() {
      var isPending = rerenderReducer(basicStateReducer)[0],
          start = updateWorkInProgressHook().memoizedState;
      return [isPending, start];
    },
    useMutableSource: updateMutableSource,
    useOpaqueIdentifier: function useOpaqueIdentifier() {
      return rerenderReducer(basicStateReducer)[0];
    },
    unstable_isNewReconciler: false
  };

  function createCapturedValue(value, source) {
    return {
      value: value,
      source: source,
      stack: getStackByFiberInDevAndProd(source)
    };
  }

  if ("function" !== typeof _$$_REQUIRE(_dependencyMap[3]).ReactFiberErrorDialog.showErrorDialog) throw Error("Expected ReactFiberErrorDialog.showErrorDialog to be a function.");

  function logCapturedError(boundary, errorInfo) {
    try {
      false !== _$$_REQUIRE(_dependencyMap[3]).ReactFiberErrorDialog.showErrorDialog({
        componentStack: null !== errorInfo.stack ? errorInfo.stack : "",
        error: errorInfo.value,
        errorBoundary: null !== boundary && 1 === boundary.tag ? boundary.stateNode : null
      }) && console.error(errorInfo.value);
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }

  var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;

  function createRootErrorUpdate(fiber, errorInfo, lane) {
    lane = createUpdate(-1, lane);
    lane.tag = 3;
    lane.payload = {
      element: null
    };
    var error = errorInfo.value;

    lane.callback = function () {
      hasUncaughtError || (hasUncaughtError = true, firstUncaughtError = error);
      logCapturedError(fiber, errorInfo);
    };

    return lane;
  }

  function createClassErrorUpdate(fiber, errorInfo, lane) {
    lane = createUpdate(-1, lane);
    lane.tag = 3;
    var getDerivedStateFromError = fiber.type.getDerivedStateFromError;

    if ("function" === typeof getDerivedStateFromError) {
      var error = errorInfo.value;

      lane.payload = function () {
        logCapturedError(fiber, errorInfo);
        return getDerivedStateFromError(error);
      };
    }

    var inst = fiber.stateNode;
    null !== inst && "function" === typeof inst.componentDidCatch && (lane.callback = function () {
      "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this), logCapturedError(fiber, errorInfo));
      var stack = errorInfo.stack;
      this.componentDidCatch(errorInfo.value, {
        componentStack: null !== stack ? stack : ""
      });
    });
    return lane;
  }

  var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner,
      didReceiveUpdate = false;

  function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
    workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
  }

  function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
    Component = Component.render;
    var ref = workInProgress.ref;
    prepareToReadContext(workInProgress, renderLanes);
    nextProps = renderWithHooks(current, workInProgress, Component, nextProps, ref, renderLanes);
    if (null !== current && !didReceiveUpdate) return workInProgress.updateQueue = current.updateQueue, workInProgress.flags &= -1029, current.lanes &= ~renderLanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    workInProgress.flags |= 1;
    reconcileChildren(current, workInProgress, nextProps, renderLanes);
    return workInProgress.child;
  }

  function updateMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {
    if (null === current) {
      var type = Component.type;
      if ("function" === typeof type && !shouldConstruct(type) && undefined === type.defaultProps && null === Component.compare && undefined === Component.defaultProps) return workInProgress.tag = 15, workInProgress.type = type, updateSimpleMemoComponent(current, workInProgress, type, nextProps, updateLanes, renderLanes);
      current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
      current.ref = workInProgress.ref;
      current.return = workInProgress;
      return workInProgress.child = current;
    }

    type = current.child;
    if (0 === (updateLanes & renderLanes) && (updateLanes = type.memoizedProps, Component = Component.compare, Component = null !== Component ? Component : shallowEqual, Component(updateLanes, nextProps) && current.ref === workInProgress.ref)) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    workInProgress.flags |= 1;
    current = createWorkInProgress(type, nextProps);
    current.ref = workInProgress.ref;
    current.return = workInProgress;
    return workInProgress.child = current;
  }

  function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {
    if (null !== current && shallowEqual(current.memoizedProps, nextProps) && current.ref === workInProgress.ref) {
      didReceiveUpdate = false;
      if (0 === (renderLanes & updateLanes)) return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      0 !== (current.flags & 32768) && (didReceiveUpdate = true);
    }

    return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
  }

  function updateOffscreenComponent(current, workInProgress, renderLanes) {
    var nextProps = workInProgress.pendingProps,
        nextChildren = nextProps.children,
        prevState = null !== current ? current.memoizedState : null;
    if ("hidden" === nextProps.mode || "unstable-defer-without-hiding" === nextProps.mode) {
      if (0 === (workInProgress.mode & 1)) workInProgress.memoizedState = {
        baseLanes: 0,
        cachePool: null
      }, push(subtreeRenderLanesCursor, subtreeRenderLanes), subtreeRenderLanes |= renderLanes;else {
        if (0 === (renderLanes & 1073741824)) return current = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, workInProgress.lanes = workInProgress.childLanes = 1073741824, workInProgress.memoizedState = {
          baseLanes: current,
          cachePool: null
        }, workInProgress.updateQueue = null, push(subtreeRenderLanesCursor, subtreeRenderLanes), subtreeRenderLanes |= current, null;
        workInProgress.memoizedState = {
          baseLanes: 0,
          cachePool: null
        };
        nextProps = null !== prevState ? prevState.baseLanes : renderLanes;
        push(subtreeRenderLanesCursor, subtreeRenderLanes);
        subtreeRenderLanes |= nextProps;
      }
    } else null !== prevState ? (nextProps = prevState.baseLanes | renderLanes, workInProgress.memoizedState = null) : nextProps = renderLanes, push(subtreeRenderLanesCursor, subtreeRenderLanes), subtreeRenderLanes |= nextProps;
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    return workInProgress.child;
  }

  function markRef(current, workInProgress) {
    var ref = workInProgress.ref;
    if (null === current && null !== ref || null !== current && current.ref !== ref) workInProgress.flags |= 256;
  }

  function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
    var context = isContextProvider(Component) ? previousContext : contextStackCursor.current;
    context = getMaskedContext(workInProgress, context);
    prepareToReadContext(workInProgress, renderLanes);
    Component = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);
    if (null !== current && !didReceiveUpdate) return workInProgress.updateQueue = current.updateQueue, workInProgress.flags &= -1029, current.lanes &= ~renderLanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    workInProgress.flags |= 1;
    reconcileChildren(current, workInProgress, Component, renderLanes);
    return workInProgress.child;
  }

  function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
    if (isContextProvider(Component)) {
      var hasContext = true;
      pushContextProvider(workInProgress);
    } else hasContext = false;

    prepareToReadContext(workInProgress, renderLanes);
    if (null === workInProgress.stateNode) null !== current && (current.alternate = null, workInProgress.alternate = null, workInProgress.flags |= 2), constructClassInstance(workInProgress, Component, nextProps), mountClassInstance(workInProgress, Component, nextProps, renderLanes), nextProps = true;else if (null === current) {
      var instance = workInProgress.stateNode,
          oldProps = workInProgress.memoizedProps;
      instance.props = oldProps;
      var oldContext = instance.context,
          contextType = Component.contextType;
      "object" === typeof contextType && null !== contextType ? contextType = readContext(contextType) : (contextType = isContextProvider(Component) ? previousContext : contextStackCursor.current, contextType = getMaskedContext(workInProgress, contextType));
      var getDerivedStateFromProps = Component.getDerivedStateFromProps,
          hasNewLifecycles = "function" === typeof getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate;
      hasNewLifecycles || "function" !== typeof instance.UNSAFE_componentWillReceiveProps && "function" !== typeof instance.componentWillReceiveProps || (oldProps !== nextProps || oldContext !== contextType) && callComponentWillReceiveProps(workInProgress, instance, nextProps, contextType);
      hasForceUpdate = false;
      var oldState = workInProgress.memoizedState;
      instance.state = oldState;
      processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
      oldContext = workInProgress.memoizedState;
      oldProps !== nextProps || oldState !== oldContext || didPerformWorkStackCursor.current || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, nextProps), oldContext = workInProgress.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, oldProps, nextProps, oldState, oldContext, contextType)) ? (hasNewLifecycles || "function" !== typeof instance.UNSAFE_componentWillMount && "function" !== typeof instance.componentWillMount || ("function" === typeof instance.componentWillMount && instance.componentWillMount(), "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount()), "function" === typeof instance.componentDidMount && (workInProgress.flags |= 4)) : ("function" === typeof instance.componentDidMount && (workInProgress.flags |= 4), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), instance.props = nextProps, instance.state = oldContext, instance.context = contextType, nextProps = oldProps) : ("function" === typeof instance.componentDidMount && (workInProgress.flags |= 4), nextProps = false);
    } else {
      instance = workInProgress.stateNode;
      cloneUpdateQueue(current, workInProgress);
      oldProps = workInProgress.memoizedProps;
      contextType = workInProgress.type === workInProgress.elementType ? oldProps : resolveDefaultProps(workInProgress.type, oldProps);
      instance.props = contextType;
      hasNewLifecycles = workInProgress.pendingProps;
      oldState = instance.context;
      oldContext = Component.contextType;
      "object" === typeof oldContext && null !== oldContext ? oldContext = readContext(oldContext) : (oldContext = isContextProvider(Component) ? previousContext : contextStackCursor.current, oldContext = getMaskedContext(workInProgress, oldContext));
      var getDerivedStateFromProps$jscomp$0 = Component.getDerivedStateFromProps;
      (getDerivedStateFromProps = "function" === typeof getDerivedStateFromProps$jscomp$0 || "function" === typeof instance.getSnapshotBeforeUpdate) || "function" !== typeof instance.UNSAFE_componentWillReceiveProps && "function" !== typeof instance.componentWillReceiveProps || (oldProps !== hasNewLifecycles || oldState !== oldContext) && callComponentWillReceiveProps(workInProgress, instance, nextProps, oldContext);
      hasForceUpdate = false;
      oldState = workInProgress.memoizedState;
      instance.state = oldState;
      processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
      var newState = workInProgress.memoizedState;
      oldProps !== hasNewLifecycles || oldState !== newState || didPerformWorkStackCursor.current || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps$jscomp$0 && (applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps$jscomp$0, nextProps), newState = workInProgress.memoizedState), (contextType = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, contextType, nextProps, oldState, newState, oldContext) || false) ? (getDerivedStateFromProps || "function" !== typeof instance.UNSAFE_componentWillUpdate && "function" !== typeof instance.componentWillUpdate || ("function" === typeof instance.componentWillUpdate && instance.componentWillUpdate(nextProps, newState, oldContext), "function" === typeof instance.UNSAFE_componentWillUpdate && instance.UNSAFE_componentWillUpdate(nextProps, newState, oldContext)), "function" === typeof instance.componentDidUpdate && (workInProgress.flags |= 4), "function" === typeof instance.getSnapshotBeforeUpdate && (workInProgress.flags |= 512)) : ("function" !== typeof instance.componentDidUpdate || oldProps === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), "function" !== typeof instance.getSnapshotBeforeUpdate || oldProps === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 512), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), instance.props = nextProps, instance.state = newState, instance.context = oldContext, nextProps = contextType) : ("function" !== typeof instance.componentDidUpdate || oldProps === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), "function" !== typeof instance.getSnapshotBeforeUpdate || oldProps === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 512), nextProps = false);
    }
    return finishClassComponent(current, workInProgress, Component, nextProps, hasContext, renderLanes);
  }

  function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {
    markRef(current, workInProgress);
    var didCaptureError = 0 !== (workInProgress.flags & 128);
    if (!shouldUpdate && !didCaptureError) return hasContext && invalidateContextProvider(workInProgress, Component, false), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    shouldUpdate = workInProgress.stateNode;
    ReactCurrentOwner$1.current = workInProgress;
    var nextChildren = didCaptureError && "function" !== typeof Component.getDerivedStateFromError ? null : shouldUpdate.render();
    workInProgress.flags |= 1;
    null !== current && didCaptureError ? (workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes)) : reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    workInProgress.memoizedState = shouldUpdate.state;
    hasContext && invalidateContextProvider(workInProgress, Component, true);
    return workInProgress.child;
  }

  function pushHostRootContext(workInProgress) {
    var root = workInProgress.stateNode;
    root.pendingContext ? pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context) : root.context && pushTopLevelContextObject(workInProgress, root.context, false);
    pushHostContainer(workInProgress, root.containerInfo);
  }

  var SUSPENDED_MARKER = {
    dehydrated: null,
    retryLane: 0
  };

  function mountSuspenseOffscreenState(renderLanes) {
    return {
      baseLanes: renderLanes,
      cachePool: null
    };
  }

  function updateSuspenseComponent(current, workInProgress, renderLanes) {
    var nextProps = workInProgress.pendingProps,
        suspenseContext = suspenseStackCursor.current,
        showFallback = false,
        JSCompiler_temp;
    (JSCompiler_temp = 0 !== (workInProgress.flags & 128)) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseContext & 2));
    JSCompiler_temp ? (showFallback = true, workInProgress.flags &= -129) : null !== current && null === current.memoizedState || undefined === nextProps.fallback || true === nextProps.unstable_avoidThisFallback || (suspenseContext |= 1);
    push(suspenseStackCursor, suspenseContext & 1);

    if (null === current) {
      current = nextProps.children;
      suspenseContext = nextProps.fallback;
      if (showFallback) return current = mountSuspenseFallbackChildren(workInProgress, current, suspenseContext, renderLanes), workInProgress.child.memoizedState = mountSuspenseOffscreenState(renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, current;
      if ("number" === typeof nextProps.unstable_expectedLoadTime) return current = mountSuspenseFallbackChildren(workInProgress, current, suspenseContext, renderLanes), workInProgress.child.memoizedState = mountSuspenseOffscreenState(renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress.lanes = 4194304, current;
      renderLanes = createFiberFromOffscreen({
        mode: "visible",
        children: current
      }, workInProgress.mode, renderLanes, null);
      renderLanes.return = workInProgress;
      return workInProgress.child = renderLanes;
    }

    if (null !== current.memoizedState) {
      if (showFallback) return nextProps = updateSuspenseFallbackChildren(current, workInProgress, nextProps.children, nextProps.fallback, renderLanes), showFallback = workInProgress.child, suspenseContext = current.child.memoizedState, showFallback.memoizedState = null === suspenseContext ? mountSuspenseOffscreenState(renderLanes) : {
        baseLanes: suspenseContext.baseLanes | renderLanes,
        cachePool: null
      }, showFallback.childLanes = current.childLanes & ~renderLanes, workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;
      renderLanes = updateSuspensePrimaryChildren(current, workInProgress, nextProps.children, renderLanes);
      workInProgress.memoizedState = null;
      return renderLanes;
    }

    if (showFallback) return nextProps = updateSuspenseFallbackChildren(current, workInProgress, nextProps.children, nextProps.fallback, renderLanes), showFallback = workInProgress.child, suspenseContext = current.child.memoizedState, showFallback.memoizedState = null === suspenseContext ? mountSuspenseOffscreenState(renderLanes) : {
      baseLanes: suspenseContext.baseLanes | renderLanes,
      cachePool: null
    }, showFallback.childLanes = current.childLanes & ~renderLanes, workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;
    renderLanes = updateSuspensePrimaryChildren(current, workInProgress, nextProps.children, renderLanes);
    workInProgress.memoizedState = null;
    return renderLanes;
  }

  function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {
    var mode = workInProgress.mode,
        progressedPrimaryFragment = workInProgress.child;
    primaryChildren = {
      mode: "hidden",
      children: primaryChildren
    };
    0 === (mode & 1) && null !== progressedPrimaryFragment ? (progressedPrimaryFragment.childLanes = 0, progressedPrimaryFragment.pendingProps = primaryChildren) : progressedPrimaryFragment = createFiberFromOffscreen(primaryChildren, mode, 0, null);
    fallbackChildren = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
    progressedPrimaryFragment.return = workInProgress;
    fallbackChildren.return = workInProgress;
    progressedPrimaryFragment.sibling = fallbackChildren;
    workInProgress.child = progressedPrimaryFragment;
    return fallbackChildren;
  }

  function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {
    var currentPrimaryChildFragment = current.child;
    current = currentPrimaryChildFragment.sibling;
    primaryChildren = createWorkInProgress(currentPrimaryChildFragment, {
      mode: "visible",
      children: primaryChildren
    });
    0 === (workInProgress.mode & 1) && (primaryChildren.lanes = renderLanes);
    primaryChildren.return = workInProgress;
    primaryChildren.sibling = null;
    null !== current && (renderLanes = workInProgress.deletions, null === renderLanes ? (workInProgress.deletions = [current], workInProgress.flags |= 16) : renderLanes.push(current));
    return workInProgress.child = primaryChildren;
  }

  function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {
    var mode = workInProgress.mode;
    current = current.child;
    var currentFallbackChildFragment = current.sibling,
        primaryChildProps = {
      mode: "hidden",
      children: primaryChildren
    };
    0 === (mode & 1) && workInProgress.child !== current ? (primaryChildren = workInProgress.child, primaryChildren.childLanes = 0, primaryChildren.pendingProps = primaryChildProps, workInProgress.deletions = null) : (primaryChildren = createWorkInProgress(current, primaryChildProps), primaryChildren.subtreeFlags = current.subtreeFlags & 1835008);
    null !== currentFallbackChildFragment ? fallbackChildren = createWorkInProgress(currentFallbackChildFragment, fallbackChildren) : (fallbackChildren = createFiberFromFragment(fallbackChildren, mode, renderLanes, null), fallbackChildren.flags |= 2);
    fallbackChildren.return = workInProgress;
    primaryChildren.return = workInProgress;
    primaryChildren.sibling = fallbackChildren;
    workInProgress.child = primaryChildren;
    return fallbackChildren;
  }

  function scheduleWorkOnFiber(fiber, renderLanes) {
    fiber.lanes |= renderLanes;
    var alternate = fiber.alternate;
    null !== alternate && (alternate.lanes |= renderLanes);
    scheduleWorkOnParentPath(fiber.return, renderLanes);
  }

  function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {
    var renderState = workInProgress.memoizedState;
    null === renderState ? workInProgress.memoizedState = {
      isBackwards: isBackwards,
      rendering: null,
      renderingStartTime: 0,
      last: lastContentRow,
      tail: tail,
      tailMode: tailMode
    } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
  }

  function updateSuspenseListComponent(current, workInProgress, renderLanes) {
    var nextProps = workInProgress.pendingProps,
        revealOrder = nextProps.revealOrder,
        tailMode = nextProps.tail;
    reconcileChildren(current, workInProgress, nextProps.children, renderLanes);
    nextProps = suspenseStackCursor.current;
    if (0 !== (nextProps & 2)) nextProps = nextProps & 1 | 2, workInProgress.flags |= 128;else {
      if (null !== current && 0 !== (current.flags & 128)) a: for (current = workInProgress.child; null !== current;) {
        if (13 === current.tag) null !== current.memoizedState && scheduleWorkOnFiber(current, renderLanes);else if (19 === current.tag) scheduleWorkOnFiber(current, renderLanes);else if (null !== current.child) {
          current.child.return = current;
          current = current.child;
          continue;
        }
        if (current === workInProgress) break a;

        for (; null === current.sibling;) {
          if (null === current.return || current.return === workInProgress) break a;
          current = current.return;
        }

        current.sibling.return = current.return;
        current = current.sibling;
      }
      nextProps &= 1;
    }
    push(suspenseStackCursor, nextProps);
    if (0 === (workInProgress.mode & 1)) workInProgress.memoizedState = null;else switch (revealOrder) {
      case "forwards":
        renderLanes = workInProgress.child;

        for (revealOrder = null; null !== renderLanes;) {
          current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;
        }

        renderLanes = revealOrder;
        null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);
        initSuspenseListRenderState(workInProgress, false, revealOrder, renderLanes, tailMode);
        break;

      case "backwards":
        renderLanes = null;
        revealOrder = workInProgress.child;

        for (workInProgress.child = null; null !== revealOrder;) {
          current = revealOrder.alternate;

          if (null !== current && null === findFirstSuspended(current)) {
            workInProgress.child = revealOrder;
            break;
          }

          current = revealOrder.sibling;
          revealOrder.sibling = renderLanes;
          renderLanes = revealOrder;
          revealOrder = current;
        }

        initSuspenseListRenderState(workInProgress, true, renderLanes, null, tailMode);
        break;

      case "together":
        initSuspenseListRenderState(workInProgress, false, null, null, undefined);
        break;

      default:
        workInProgress.memoizedState = null;
    }
    return workInProgress.child;
  }

  function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
    null !== current && (workInProgress.dependencies = current.dependencies);
    workInProgressRootSkippedLanes |= workInProgress.lanes;
    if (0 === (renderLanes & workInProgress.childLanes)) return null;
    if (null !== current && workInProgress.child !== current.child) throw Error("Resuming work not yet implemented.");

    if (null !== workInProgress.child) {
      current = workInProgress.child;
      renderLanes = createWorkInProgress(current, current.pendingProps);
      workInProgress.child = renderLanes;

      for (renderLanes.return = workInProgress; null !== current.sibling;) {
        current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;
      }

      renderLanes.sibling = null;
    }

    return workInProgress.child;
  }

  var appendAllChildren, updateHostContainer, updateHostComponent$1, updateHostText$1;

  appendAllChildren = function appendAllChildren(parent, workInProgress) {
    for (var node = workInProgress.child; null !== node;) {
      if (5 === node.tag || 6 === node.tag) parent._children.push(node.stateNode);else if (4 !== node.tag && null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === workInProgress) break;

      for (; null === node.sibling;) {
        if (null === node.return || node.return === workInProgress) return;
        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  };

  updateHostContainer = function updateHostContainer() {};

  updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps) {
    current.memoizedProps !== newProps && (requiredContext(contextStackCursor$1.current), workInProgress.updateQueue = UPDATE_SIGNAL) && (workInProgress.flags |= 4);
  };

  updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
    oldText !== newText && (workInProgress.flags |= 4);
  };

  function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
    switch (renderState.tailMode) {
      case "hidden":
        hasRenderedATailFallback = renderState.tail;

        for (var lastTailNode = null; null !== hasRenderedATailFallback;) {
          null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
        }

        null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
        break;

      case "collapsed":
        lastTailNode = renderState.tail;

        for (var lastTailNode$69 = null; null !== lastTailNode;) {
          null !== lastTailNode.alternate && (lastTailNode$69 = lastTailNode), lastTailNode = lastTailNode.sibling;
        }

        null === lastTailNode$69 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$69.sibling = null;
    }
  }

  function bubbleProperties(completedWork) {
    var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child,
        newChildLanes = 0,
        subtreeFlags = 0;
    if (didBailout) for (var child$70 = completedWork.child; null !== child$70;) {
      newChildLanes |= child$70.lanes | child$70.childLanes, subtreeFlags |= child$70.subtreeFlags & 1835008, subtreeFlags |= child$70.flags & 1835008, child$70.return = completedWork, child$70 = child$70.sibling;
    } else for (child$70 = completedWork.child; null !== child$70;) {
      newChildLanes |= child$70.lanes | child$70.childLanes, subtreeFlags |= child$70.subtreeFlags, subtreeFlags |= child$70.flags, child$70.return = completedWork, child$70 = child$70.sibling;
    }
    completedWork.subtreeFlags |= subtreeFlags;
    completedWork.childLanes = newChildLanes;
    return didBailout;
  }

  function completeWork(current, workInProgress, renderLanes) {
    var newProps = workInProgress.pendingProps;

    switch (workInProgress.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return bubbleProperties(workInProgress), null;

      case 1:
        return isContextProvider(workInProgress.type) && popContext(), bubbleProperties(workInProgress), null;

      case 3:
        return newProps = workInProgress.stateNode, popHostContainer(), pop(didPerformWorkStackCursor), pop(contextStackCursor), resetWorkInProgressVersions(), newProps.pendingContext && (newProps.context = newProps.pendingContext, newProps.pendingContext = null), null !== current && null !== current.child || newProps.hydrate || (workInProgress.flags |= 512), updateHostContainer(current, workInProgress), bubbleProperties(workInProgress), null;

      case 5:
        popHostContext(workInProgress);
        renderLanes = requiredContext(rootInstanceStackCursor.current);
        var type = workInProgress.type;
        if (null !== current && null != workInProgress.stateNode) updateHostComponent$1(current, workInProgress, type, newProps, renderLanes), current.ref !== workInProgress.ref && (workInProgress.flags |= 256);else {
          if (!newProps) {
            if (null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            bubbleProperties(workInProgress);
            return null;
          }

          requiredContext(contextStackCursor$1.current);
          current = allocateTag();
          type = getViewConfigForType(type);
          var updatePayload = diffProperties(null, emptyObject, newProps, type.validAttributes);

          _$$_REQUIRE(_dependencyMap[3]).UIManager.createView(current, type.uiViewClassName, renderLanes, updatePayload);

          renderLanes = new ReactNativeFiberHostComponent(current, type, workInProgress);
          instanceCache.set(current, workInProgress);
          instanceProps.set(current, newProps);
          appendAllChildren(renderLanes, workInProgress, false, false);
          workInProgress.stateNode = renderLanes;
          finalizeInitialChildren(renderLanes) && (workInProgress.flags |= 4);
          null !== workInProgress.ref && (workInProgress.flags |= 256);
        }
        bubbleProperties(workInProgress);
        return null;

      case 6:
        if (current && null != workInProgress.stateNode) updateHostText$1(current, workInProgress, current.memoizedProps, newProps);else {
          if ("string" !== typeof newProps && null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
          current = requiredContext(rootInstanceStackCursor.current);
          if (!requiredContext(contextStackCursor$1.current).isInAParentText) throw Error("Text strings must be rendered within a <Text> component.");
          renderLanes = allocateTag();

          _$$_REQUIRE(_dependencyMap[3]).UIManager.createView(renderLanes, "RCTRawText", current, {
            text: newProps
          });

          instanceCache.set(renderLanes, workInProgress);
          workInProgress.stateNode = renderLanes;
        }
        bubbleProperties(workInProgress);
        return null;

      case 13:
        pop(suspenseStackCursor);
        newProps = workInProgress.memoizedState;
        if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, workInProgress;
        newProps = null !== newProps;
        renderLanes = false;
        null !== current && (renderLanes = null !== current.memoizedState);
        if (newProps && !renderLanes && 0 !== (workInProgress.mode & 1)) if (null === current && true !== workInProgress.memoizedProps.unstable_avoidThisFallback || 0 !== (suspenseStackCursor.current & 1)) 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3);else {
          if (0 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus) workInProgressRootExitStatus = 4;
          null === workInProgressRoot || 0 === (workInProgressRootSkippedLanes & 268435455) && 0 === (workInProgressRootUpdatedLanes & 268435455) || markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
        }
        if (newProps || renderLanes) workInProgress.flags |= 4;
        bubbleProperties(workInProgress);
        return null;

      case 4:
        return popHostContainer(), updateHostContainer(current, workInProgress), bubbleProperties(workInProgress), null;

      case 10:
        return popProvider(workInProgress.type._context), bubbleProperties(workInProgress), null;

      case 17:
        return isContextProvider(workInProgress.type) && popContext(), bubbleProperties(workInProgress), null;

      case 19:
        pop(suspenseStackCursor);
        type = workInProgress.memoizedState;
        if (null === type) return bubbleProperties(workInProgress), null;
        newProps = 0 !== (workInProgress.flags & 128);
        updatePayload = type.rendering;
        if (null === updatePayload) {
          if (newProps) cutOffTailIfNeeded(type, false);else {
            if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128)) for (current = workInProgress.child; null !== current;) {
              updatePayload = findFirstSuspended(current);

              if (null !== updatePayload) {
                workInProgress.flags |= 128;
                cutOffTailIfNeeded(type, false);
                current = updatePayload.updateQueue;
                null !== current && (workInProgress.updateQueue = current, workInProgress.flags |= 4);
                workInProgress.subtreeFlags = 0;
                current = renderLanes;

                for (newProps = workInProgress.child; null !== newProps;) {
                  renderLanes = newProps, type = current, renderLanes.flags &= 1835010, updatePayload = renderLanes.alternate, null === updatePayload ? (renderLanes.childLanes = 0, renderLanes.lanes = type, renderLanes.child = null, renderLanes.subtreeFlags = 0, renderLanes.memoizedProps = null, renderLanes.memoizedState = null, renderLanes.updateQueue = null, renderLanes.dependencies = null, renderLanes.stateNode = null) : (renderLanes.childLanes = updatePayload.childLanes, renderLanes.lanes = updatePayload.lanes, renderLanes.child = updatePayload.child, renderLanes.subtreeFlags = 0, renderLanes.deletions = null, renderLanes.memoizedProps = updatePayload.memoizedProps, renderLanes.memoizedState = updatePayload.memoizedState, renderLanes.updateQueue = updatePayload.updateQueue, renderLanes.type = updatePayload.type, type = updatePayload.dependencies, renderLanes.dependencies = null === type ? null : {
                    lanes: type.lanes,
                    firstContext: type.firstContext
                  }), newProps = newProps.sibling;
                }

                push(suspenseStackCursor, suspenseStackCursor.current & 1 | 2);
                return workInProgress.child;
              }

              current = current.sibling;
            }
            null !== type.tail && _$$_REQUIRE(_dependencyMap[4]).unstable_now() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress.lanes = 4194304);
          }
        } else {
          if (!newProps) if (current = findFirstSuspended(updatePayload), null !== current) {
            if (workInProgress.flags |= 128, newProps = true, current = current.updateQueue, null !== current && (workInProgress.updateQueue = current, workInProgress.flags |= 4), cutOffTailIfNeeded(type, true), null === type.tail && "hidden" === type.tailMode && !updatePayload.alternate) return bubbleProperties(workInProgress), null;
          } else 2 * _$$_REQUIRE(_dependencyMap[4]).unstable_now() - type.renderingStartTime > workInProgressRootRenderTargetTime && 1073741824 !== renderLanes && (workInProgress.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress.lanes = 4194304);
          type.isBackwards ? (updatePayload.sibling = workInProgress.child, workInProgress.child = updatePayload) : (current = type.last, null !== current ? current.sibling = updatePayload : workInProgress.child = updatePayload, type.last = updatePayload);
        }
        if (null !== type.tail) return workInProgress = type.tail, type.rendering = workInProgress, type.tail = workInProgress.sibling, type.renderingStartTime = _$$_REQUIRE(_dependencyMap[4]).unstable_now(), workInProgress.sibling = null, current = suspenseStackCursor.current, push(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress;
        bubbleProperties(workInProgress);
        return null;

      case 22:
      case 23:
        return popRenderLanes(), renderLanes = null !== workInProgress.memoizedState, null !== current && null !== current.memoizedState !== renderLanes && "unstable-defer-without-hiding" !== newProps.mode && (workInProgress.flags |= 4), renderLanes && 0 === (subtreeRenderLanes & 1073741824) && 0 !== (workInProgress.mode & 1) || bubbleProperties(workInProgress), null;
    }

    throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
  }

  function unwindWork(workInProgress) {
    switch (workInProgress.tag) {
      case 1:
        isContextProvider(workInProgress.type) && popContext();
        var flags = workInProgress.flags;
        return flags & 16384 ? (workInProgress.flags = flags & -16385 | 128, workInProgress) : null;

      case 3:
        popHostContainer();
        pop(didPerformWorkStackCursor);
        pop(contextStackCursor);
        resetWorkInProgressVersions();
        flags = workInProgress.flags;
        if (0 !== (flags & 128)) throw Error("The root failed to unmount after an error. This is likely a bug in React. Please file an issue.");
        workInProgress.flags = flags & -16385 | 128;
        return workInProgress;

      case 5:
        return popHostContext(workInProgress), null;

      case 13:
        return pop(suspenseStackCursor), flags = workInProgress.flags, flags & 16384 ? (workInProgress.flags = flags & -16385 | 128, workInProgress) : null;

      case 19:
        return pop(suspenseStackCursor), null;

      case 4:
        return popHostContainer(), null;

      case 10:
        return popProvider(workInProgress.type._context), null;

      case 22:
      case 23:
        return popRenderLanes(), null;

      case 24:
        return null;

      default:
        return null;
    }
  }

  var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
      nextEffect = null;

  function safelyDetachRef(current, nearestMountedAncestor) {
    var ref = current.ref;
    if (null !== ref) if ("function" === typeof ref) try {
      ref(null);
    } catch (error) {
      captureCommitPhaseError(current, nearestMountedAncestor, error);
    } else ref.current = null;
  }

  var shouldFireAfterActiveInstanceBlur = false;

  function commitBeforeMutationEffects(root, firstChild) {
    for (nextEffect = firstChild; null !== nextEffect;) {
      if (root = nextEffect, firstChild = root.child, 0 !== (root.subtreeFlags & 516) && null !== firstChild) firstChild.return = root, nextEffect = firstChild;else for (; null !== nextEffect;) {
        root = nextEffect;

        try {
          var current = root.alternate;
          if (0 !== (root.flags & 512)) switch (root.tag) {
            case 0:
            case 11:
            case 15:
              break;

            case 1:
              if (null !== current) {
                var prevProps = current.memoizedProps,
                    prevState = current.memoizedState,
                    instance = root.stateNode,
                    snapshot = instance.getSnapshotBeforeUpdate(root.elementType === root.type ? prevProps : resolveDefaultProps(root.type, prevProps), prevState);
                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
              }

              break;

            case 3:
              break;

            case 5:
            case 6:
            case 4:
            case 17:
              break;

            default:
              throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
          }
        } catch (error) {
          captureCommitPhaseError(root, root.return, error);
        }

        firstChild = root.sibling;

        if (null !== firstChild) {
          firstChild.return = root.return;
          nextEffect = firstChild;
          break;
        }

        nextEffect = root.return;
      }
    }

    current = shouldFireAfterActiveInstanceBlur;
    shouldFireAfterActiveInstanceBlur = false;
    return current;
  }

  function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
    var updateQueue = finishedWork.updateQueue;
    updateQueue = null !== updateQueue ? updateQueue.lastEffect : null;

    if (null !== updateQueue) {
      var effect = updateQueue = updateQueue.next;

      do {
        if ((effect.tag & flags) === flags) {
          var destroy = effect.destroy;
          effect.destroy = undefined;

          if (undefined !== destroy) {
            var current = finishedWork,
                nearestMountedAncestor = nearestMountedAncestor$jscomp$0;

            try {
              destroy();
            } catch (error) {
              captureCommitPhaseError(current, nearestMountedAncestor, error);
            }
          }
        }

        effect = effect.next;
      } while (effect !== updateQueue);
    }
  }

  function commitHookEffectListMount(tag, finishedWork) {
    finishedWork = finishedWork.updateQueue;
    finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;

    if (null !== finishedWork) {
      var effect = finishedWork = finishedWork.next;

      do {
        if ((effect.tag & tag) === tag) {
          var create$82 = effect.create;
          effect.destroy = create$82();
        }

        effect = effect.next;
      } while (effect !== finishedWork);
    }
  }

  function hideOrUnhideAllChildren(finishedWork, isHidden) {
    for (var hostSubtreeRoot = null, node = finishedWork;;) {
      if (5 === node.tag) {
        if (null === hostSubtreeRoot) {
          hostSubtreeRoot = node;
          var instance = node.stateNode;

          if (isHidden) {
            var viewConfig = instance.viewConfig;
            var updatePayload = diffProperties(null, emptyObject, {
              style: {
                display: "none"
              }
            }, viewConfig.validAttributes);

            _$$_REQUIRE(_dependencyMap[3]).UIManager.updateView(instance._nativeTag, viewConfig.uiViewClassName, updatePayload);
          } else {
            instance = node.stateNode;
            updatePayload = node.memoizedProps;
            viewConfig = instance.viewConfig;

            var prevProps = _$$_REQUIRE(_dependencyMap[2])({}, updatePayload, {
              style: [updatePayload.style, {
                display: "none"
              }]
            });

            updatePayload = diffProperties(null, prevProps, updatePayload, viewConfig.validAttributes);

            _$$_REQUIRE(_dependencyMap[3]).UIManager.updateView(instance._nativeTag, viewConfig.uiViewClassName, updatePayload);
          }
        }
      } else if (6 === node.tag) {
        if (null === hostSubtreeRoot) throw Error("Not yet implemented.");
      } else if ((22 !== node.tag && 23 !== node.tag || null === node.memoizedState || node === finishedWork) && null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === finishedWork) break;

      for (; null === node.sibling;) {
        if (null === node.return || node.return === finishedWork) return;
        hostSubtreeRoot === node && (hostSubtreeRoot = null);
        node = node.return;
      }

      hostSubtreeRoot === node && (hostSubtreeRoot = null);
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }

  function commitUnmount(finishedRoot, current, nearestMountedAncestor$jscomp$0) {
    if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount) try {
      injectedHook.onCommitFiberUnmount(rendererID, current);
    } catch (err) {}

    switch (current.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        finishedRoot = current.updateQueue;

        if (null !== finishedRoot && (finishedRoot = finishedRoot.lastEffect, null !== finishedRoot)) {
          var effect = finishedRoot = finishedRoot.next;

          do {
            var _effect = effect,
                destroy = _effect.destroy;
            _effect = _effect.tag;

            if (undefined !== destroy && 0 !== (_effect & 2)) {
              _effect = current;
              var nearestMountedAncestor = nearestMountedAncestor$jscomp$0;

              try {
                destroy();
              } catch (error) {
                captureCommitPhaseError(_effect, nearestMountedAncestor, error);
              }
            }

            effect = effect.next;
          } while (effect !== finishedRoot);
        }

        break;

      case 1:
        safelyDetachRef(current, nearestMountedAncestor$jscomp$0);
        finishedRoot = current.stateNode;
        if ("function" === typeof finishedRoot.componentWillUnmount) try {
          finishedRoot.props = current.memoizedProps, finishedRoot.state = current.memoizedState, finishedRoot.componentWillUnmount();
        } catch (unmountError) {
          captureCommitPhaseError(current, nearestMountedAncestor$jscomp$0, unmountError);
        }
        break;

      case 5:
        safelyDetachRef(current, nearestMountedAncestor$jscomp$0);
        break;

      case 4:
        unmountHostComponents(finishedRoot, current, nearestMountedAncestor$jscomp$0);
    }
  }

  function detachFiberAfterEffects(fiber) {
    var alternate = fiber.alternate;
    null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
    fiber.child = null;
    fiber.deletions = null;
    fiber.sibling = null;
    fiber.stateNode = null;
    fiber.return = null;
    fiber.dependencies = null;
    fiber.memoizedProps = null;
    fiber.memoizedState = null;
    fiber.pendingProps = null;
    fiber.stateNode = null;
    fiber.updateQueue = null;
  }

  function isHostParent(fiber) {
    return 5 === fiber.tag || 3 === fiber.tag || 4 === fiber.tag;
  }

  function commitPlacement(finishedWork) {
    a: {
      for (var parent = finishedWork.return; null !== parent;) {
        if (isHostParent(parent)) break a;
        parent = parent.return;
      }

      throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }

    var parentFiber = parent;
    parent = parentFiber.stateNode;

    switch (parentFiber.tag) {
      case 5:
        var isContainer = false;
        break;

      case 3:
        parent = parent.containerInfo;
        isContainer = true;
        break;

      case 4:
        parent = parent.containerInfo;
        isContainer = true;
        break;

      default:
        throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
    }

    parentFiber.flags & 32 && (parentFiber.flags &= -33);

    a: b: for (parentFiber = finishedWork;;) {
      for (; null === parentFiber.sibling;) {
        if (null === parentFiber.return || isHostParent(parentFiber.return)) {
          parentFiber = null;
          break a;
        }

        parentFiber = parentFiber.return;
      }

      parentFiber.sibling.return = parentFiber.return;

      for (parentFiber = parentFiber.sibling; 5 !== parentFiber.tag && 6 !== parentFiber.tag && 18 !== parentFiber.tag;) {
        if (parentFiber.flags & 2) continue b;
        if (null === parentFiber.child || 4 === parentFiber.tag) continue b;else parentFiber.child.return = parentFiber, parentFiber = parentFiber.child;
      }

      if (!(parentFiber.flags & 2)) {
        parentFiber = parentFiber.stateNode;
        break a;
      }
    }

    isContainer ? insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, parent) : insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
  }

  function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
    var tag = node.tag;
    if (5 === tag || 6 === tag) {
      if (node = node.stateNode, before) {
        if ("number" === typeof parent) throw Error("Container does not support insertBefore operation");
      } else _$$_REQUIRE(_dependencyMap[3]).UIManager.setChildren(parent, ["number" === typeof node ? node : node._nativeTag]);
    } else if (4 !== tag && (node = node.child, null !== node)) for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;) {
      insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
    }
  }

  function insertOrAppendPlacementNode(node, before, parent) {
    var tag = node.tag;
    if (5 === tag || 6 === tag) {
      if (node = node.stateNode, before) {
        tag = parent._children;
        var index = tag.indexOf(node);
        0 <= index ? (tag.splice(index, 1), before = tag.indexOf(before), tag.splice(before, 0, node), _$$_REQUIRE(_dependencyMap[3]).UIManager.manageChildren(parent._nativeTag, [index], [before], [], [], [])) : (before = tag.indexOf(before), tag.splice(before, 0, node), _$$_REQUIRE(_dependencyMap[3]).UIManager.manageChildren(parent._nativeTag, [], [], ["number" === typeof node ? node : node._nativeTag], [before], []));
      } else before = "number" === typeof node ? node : node._nativeTag, tag = parent._children, index = tag.indexOf(node), 0 <= index ? (tag.splice(index, 1), tag.push(node), _$$_REQUIRE(_dependencyMap[3]).UIManager.manageChildren(parent._nativeTag, [index], [tag.length - 1], [], [], [])) : (tag.push(node), _$$_REQUIRE(_dependencyMap[3]).UIManager.manageChildren(parent._nativeTag, [], [], [before], [tag.length - 1], []));
    } else if (4 !== tag && (node = node.child, null !== node)) for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;) {
      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
    }
  }

  function unmountHostComponents(finishedRoot$jscomp$0, current, nearestMountedAncestor$jscomp$0) {
    for (var node = current, currentParentIsValid = false, currentParent, currentParentIsContainer;;) {
      if (!currentParentIsValid) {
        currentParentIsValid = node.return;

        a: for (;;) {
          if (null === currentParentIsValid) throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          currentParent = currentParentIsValid.stateNode;

          switch (currentParentIsValid.tag) {
            case 5:
              currentParentIsContainer = false;
              break a;

            case 3:
              currentParent = currentParent.containerInfo;
              currentParentIsContainer = true;
              break a;

            case 4:
              currentParent = currentParent.containerInfo;
              currentParentIsContainer = true;
              break a;
          }

          currentParentIsValid = currentParentIsValid.return;
        }

        currentParentIsValid = true;
      }

      if (5 === node.tag || 6 === node.tag) {
        a: for (var finishedRoot = finishedRoot$jscomp$0, root = node, nearestMountedAncestor = nearestMountedAncestor$jscomp$0, node$jscomp$0 = root;;) {
          if (commitUnmount(finishedRoot, node$jscomp$0, nearestMountedAncestor), null !== node$jscomp$0.child && 4 !== node$jscomp$0.tag) node$jscomp$0.child.return = node$jscomp$0, node$jscomp$0 = node$jscomp$0.child;else {
            if (node$jscomp$0 === root) break a;

            for (; null === node$jscomp$0.sibling;) {
              if (null === node$jscomp$0.return || node$jscomp$0.return === root) break a;
              node$jscomp$0 = node$jscomp$0.return;
            }

            node$jscomp$0.sibling.return = node$jscomp$0.return;
            node$jscomp$0 = node$jscomp$0.sibling;
          }
        }

        currentParentIsContainer ? (finishedRoot = currentParent, recursivelyUncacheFiberNode(node.stateNode), _$$_REQUIRE(_dependencyMap[3]).UIManager.manageChildren(finishedRoot, [], [], [], [], [0])) : (finishedRoot = currentParent, nearestMountedAncestor = node.stateNode, recursivelyUncacheFiberNode(nearestMountedAncestor), root = finishedRoot._children, nearestMountedAncestor = root.indexOf(nearestMountedAncestor), root.splice(nearestMountedAncestor, 1), _$$_REQUIRE(_dependencyMap[3]).UIManager.manageChildren(finishedRoot._nativeTag, [], [], [], [], [nearestMountedAncestor]));
      } else if (4 === node.tag) {
        if (null !== node.child) {
          currentParent = node.stateNode.containerInfo;
          currentParentIsContainer = true;
          node.child.return = node;
          node = node.child;
          continue;
        }
      } else if (commitUnmount(finishedRoot$jscomp$0, node, nearestMountedAncestor$jscomp$0), null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === current) break;

      for (; null === node.sibling;) {
        if (null === node.return || node.return === current) return;
        node = node.return;
        4 === node.tag && (currentParentIsValid = false);
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  }

  function commitWork(current, finishedWork) {
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        commitHookEffectListUnmount(3, finishedWork, finishedWork.return);
        return;

      case 1:
        return;

      case 5:
        var instance = finishedWork.stateNode;

        if (null != instance) {
          var newProps = finishedWork.memoizedProps;
          current = null !== current ? current.memoizedProps : newProps;
          var updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          null !== updatePayload && (finishedWork = instance.viewConfig, instanceProps.set(instance._nativeTag, newProps), newProps = diffProperties(null, current, newProps, finishedWork.validAttributes), null != newProps && _$$_REQUIRE(_dependencyMap[3]).UIManager.updateView(instance._nativeTag, finishedWork.uiViewClassName, newProps));
        }

        return;

      case 6:
        if (null === finishedWork.stateNode) throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");

        _$$_REQUIRE(_dependencyMap[3]).UIManager.updateView(finishedWork.stateNode, "RCTRawText", {
          text: finishedWork.memoizedProps
        });

        return;

      case 3:
        return;

      case 12:
        return;

      case 13:
        null !== finishedWork.memoizedState && (globalMostRecentFallbackTime = _$$_REQUIRE(_dependencyMap[4]).unstable_now(), hideOrUnhideAllChildren(finishedWork.child, true));
        attachSuspenseRetryListeners(finishedWork);
        return;

      case 19:
        attachSuspenseRetryListeners(finishedWork);
        return;

      case 17:
        return;

      case 22:
      case 23:
        hideOrUnhideAllChildren(finishedWork, null !== finishedWork.memoizedState);
        return;
    }

    throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
  }

  function attachSuspenseRetryListeners(finishedWork) {
    var wakeables = finishedWork.updateQueue;

    if (null !== wakeables) {
      finishedWork.updateQueue = null;
      var retryCache = finishedWork.stateNode;
      null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
      wakeables.forEach(function (wakeable) {
        var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
        retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
      });
    }
  }

  function commitMutationEffects(root, firstChild) {
    for (nextEffect = firstChild; null !== nextEffect;) {
      firstChild = nextEffect;
      var deletions = firstChild.deletions;
      if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];

        try {
          unmountHostComponents(root, childToDelete, firstChild);
          var alternate = childToDelete.alternate;
          null !== alternate && (alternate.return = null);
          childToDelete.return = null;
        } catch (error) {
          captureCommitPhaseError(childToDelete, firstChild, error);
        }
      }
      deletions = firstChild.child;
      if (0 !== (firstChild.subtreeFlags & 6454) && null !== deletions) deletions.return = firstChild, nextEffect = deletions;else for (; null !== nextEffect;) {
        firstChild = nextEffect;

        try {
          var flags = firstChild.flags;

          if (flags & 256) {
            var current = firstChild.alternate;

            if (null !== current) {
              var currentRef = current.ref;
              null !== currentRef && ("function" === typeof currentRef ? currentRef(null) : currentRef.current = null);
            }
          }

          switch (flags & 2054) {
            case 2:
              commitPlacement(firstChild);
              firstChild.flags &= -3;
              break;

            case 6:
              commitPlacement(firstChild);
              firstChild.flags &= -3;
              commitWork(firstChild.alternate, firstChild);
              break;

            case 2048:
              firstChild.flags &= -2049;
              break;

            case 2052:
              firstChild.flags &= -2049;
              commitWork(firstChild.alternate, firstChild);
              break;

            case 4:
              commitWork(firstChild.alternate, firstChild);
          }
        } catch (error) {
          captureCommitPhaseError(firstChild, firstChild.return, error);
        }

        deletions = firstChild.sibling;

        if (null !== deletions) {
          deletions.return = firstChild.return;
          nextEffect = deletions;
          break;
        }

        nextEffect = firstChild.return;
      }
    }
  }

  function commitLayoutEffects(finishedWork) {
    for (nextEffect = finishedWork; null !== nextEffect;) {
      var fiber = nextEffect,
          firstChild = fiber.child;
      if (0 !== (fiber.subtreeFlags & 324) && null !== firstChild) firstChild.return = fiber, nextEffect = firstChild;else for (fiber = finishedWork; null !== nextEffect;) {
        firstChild = nextEffect;

        if (0 !== (firstChild.flags & 324)) {
          var current = firstChild.alternate;

          try {
            if (0 !== (firstChild.flags & 68)) switch (firstChild.tag) {
              case 0:
              case 11:
              case 15:
                commitHookEffectListMount(3, firstChild);
                break;

              case 1:
                var instance = firstChild.stateNode;
                if (firstChild.flags & 4) if (null === current) instance.componentDidMount();else {
                  var prevProps = firstChild.elementType === firstChild.type ? current.memoizedProps : resolveDefaultProps(firstChild.type, current.memoizedProps);
                  instance.componentDidUpdate(prevProps, current.memoizedState, instance.__reactInternalSnapshotBeforeUpdate);
                }
                var updateQueue = firstChild.updateQueue;
                null !== updateQueue && commitUpdateQueue(firstChild, updateQueue, instance);
                break;

              case 3:
                var updateQueue$83 = firstChild.updateQueue;

                if (null !== updateQueue$83) {
                  current = null;
                  if (null !== firstChild.child) switch (firstChild.child.tag) {
                    case 5:
                      current = firstChild.child.stateNode;
                      break;

                    case 1:
                      current = firstChild.child.stateNode;
                  }
                  commitUpdateQueue(firstChild, updateQueue$83, current);
                }

                break;

              case 5:
                break;

              case 6:
                break;

              case 4:
                break;

              case 12:
                break;

              case 13:
                break;

              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;

              default:
                throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }

            if (firstChild.flags & 256) {
              current = undefined;
              var ref = firstChild.ref;

              if (null !== ref) {
                var instance$jscomp$0 = firstChild.stateNode;

                switch (firstChild.tag) {
                  case 5:
                    current = instance$jscomp$0;
                    break;

                  default:
                    current = instance$jscomp$0;
                }

                "function" === typeof ref ? ref(current) : ref.current = current;
              }
            }
          } catch (error) {
            captureCommitPhaseError(firstChild, firstChild.return, error);
          }
        }

        if (firstChild === fiber) {
          nextEffect = null;
          break;
        }

        current = firstChild.sibling;

        if (null !== current) {
          current.return = firstChild.return;
          nextEffect = current;
          break;
        }

        nextEffect = firstChild.return;
      }
    }
  }

  var ceil = Math.ceil,
      ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,
      ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
      ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig,
      executionContext = 0,
      workInProgressRoot = null,
      workInProgress = null,
      workInProgressRootRenderLanes = 0,
      subtreeRenderLanes = 0,
      subtreeRenderLanesCursor = createCursor(0),
      workInProgressRootExitStatus = 0,
      workInProgressRootFatalError = null,
      workInProgressRootSkippedLanes = 0,
      workInProgressRootUpdatedLanes = 0,
      workInProgressRootPingedLanes = 0,
      globalMostRecentFallbackTime = 0,
      workInProgressRootRenderTargetTime = Infinity,
      hasUncaughtError = false,
      firstUncaughtError = null,
      legacyErrorBoundariesThatAlreadyFailed = null,
      rootDoesHavePassiveEffects = false,
      rootWithPendingPassiveEffects = null,
      pendingPassiveEffectsLanes = 0,
      nestedUpdateCount = 0,
      rootWithNestedUpdates = null,
      currentEventTime = -1,
      currentEventTransitionLane = 0;

  function requestEventTime() {
    return 0 !== (executionContext & 24) ? _$$_REQUIRE(_dependencyMap[4]).unstable_now() : -1 !== currentEventTime ? currentEventTime : currentEventTime = _$$_REQUIRE(_dependencyMap[4]).unstable_now();
  }

  function requestUpdateLane(fiber) {
    if (0 === (fiber.mode & 1)) return 1;
    if (0 !== (executionContext & 8) && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
    if (0 !== ReactCurrentBatchConfig.transition) return 0 === currentEventTransitionLane && (fiber = nextTransitionLane, nextTransitionLane <<= 1, 0 === (nextTransitionLane & 4194240) && (nextTransitionLane = 64), currentEventTransitionLane = fiber), currentEventTransitionLane;
    fiber = currentUpdatePriority;
    return 0 !== fiber ? fiber : 16;
  }

  function scheduleUpdateOnFiber(fiber, lane, eventTime) {
    if (50 < nestedUpdateCount) throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
    var root = markUpdateLaneFromFiberToRoot(fiber, lane);
    if (null === root) return null;
    markRootUpdated(root, lane, eventTime);
    root === workInProgressRoot && (0 === (executionContext & 8) && (workInProgressRootUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended$1(root, workInProgressRootRenderLanes));
    1 === lane ? 0 !== (executionContext & 4) && 0 === (executionContext & 24) ? performSyncWorkOnRoot(root) : (ensureRootIsScheduled(root, eventTime), 0 === executionContext && 0 === (fiber.mode & 1) && (workInProgressRootRenderTargetTime = _$$_REQUIRE(_dependencyMap[4]).unstable_now() + 500, includesLegacySyncCallbacks && flushSyncCallbacks())) : ensureRootIsScheduled(root, eventTime);
    return root;
  }

  function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
    sourceFiber.lanes |= lane;
    var alternate = sourceFiber.alternate;
    null !== alternate && (alternate.lanes |= lane);
    alternate = sourceFiber;

    for (sourceFiber = sourceFiber.return; null !== sourceFiber;) {
      sourceFiber.childLanes |= lane, alternate = sourceFiber.alternate, null !== alternate && (alternate.childLanes |= lane), alternate = sourceFiber, sourceFiber = sourceFiber.return;
    }

    return 3 === alternate.tag ? alternate.stateNode : null;
  }

  function ensureRootIsScheduled(root, currentTime) {
    for (var existingCallbackNode = root.callbackNode, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes; 0 < lanes;) {
      var index$6 = 31 - clz32(lanes),
          lane = 1 << index$6,
          expirationTime = expirationTimes[index$6];

      if (-1 === expirationTime) {
        if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index$6] = computeExpirationTime(lane, currentTime);
      } else expirationTime <= currentTime && (root.expiredLanes |= lane);

      lanes &= ~lane;
    }

    suspendedLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : 0);
    if (0 === suspendedLanes) null !== existingCallbackNode && _$$_REQUIRE(_dependencyMap[4]).unstable_cancelCallback(existingCallbackNode), root.callbackNode = null, root.callbackPriority = 0;else if (currentTime = suspendedLanes & -suspendedLanes, root.callbackPriority !== currentTime) {
      null != existingCallbackNode && _$$_REQUIRE(_dependencyMap[4]).unstable_cancelCallback(existingCallbackNode);
      if (1 === currentTime) 0 === root.tag ? (existingCallbackNode = performSyncWorkOnRoot.bind(null, root), includesLegacySyncCallbacks = true, null === syncQueue ? syncQueue = [existingCallbackNode] : syncQueue.push(existingCallbackNode)) : (existingCallbackNode = performSyncWorkOnRoot.bind(null, root), null === syncQueue ? syncQueue = [existingCallbackNode] : syncQueue.push(existingCallbackNode)), _$$_REQUIRE(_dependencyMap[4]).unstable_scheduleCallback(_$$_REQUIRE(_dependencyMap[4]).unstable_ImmediatePriority, flushSyncCallbacks), existingCallbackNode = null;else {
        switch (lanesToEventPriority(suspendedLanes)) {
          case 1:
            existingCallbackNode = _$$_REQUIRE(_dependencyMap[4]).unstable_ImmediatePriority;
            break;

          case 4:
            existingCallbackNode = _$$_REQUIRE(_dependencyMap[4]).unstable_UserBlockingPriority;
            break;

          case 16:
            existingCallbackNode = _$$_REQUIRE(_dependencyMap[4]).unstable_NormalPriority;
            break;

          case 536870912:
            existingCallbackNode = _$$_REQUIRE(_dependencyMap[4]).unstable_IdlePriority;
            break;

          default:
            existingCallbackNode = _$$_REQUIRE(_dependencyMap[4]).unstable_NormalPriority;
        }

        existingCallbackNode = _$$_REQUIRE(_dependencyMap[4]).unstable_scheduleCallback(existingCallbackNode, performConcurrentWorkOnRoot.bind(null, root));
      }
      root.callbackPriority = currentTime;
      root.callbackNode = existingCallbackNode;
    }
  }

  function performConcurrentWorkOnRoot(root, didTimeout) {
    currentEventTime = -1;
    currentEventTransitionLane = 0;
    if (0 !== (executionContext & 24)) throw Error("Should not already be working.");
    var originalCallbackNode = root.callbackNode;
    if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode) return null;
    var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : 0);
    if (0 === lanes) return null;
    var JSCompiler_inline_result = 0 !== (lanes & root.expiredLanes) ? false : 0 === (lanes & 30);

    if (JSCompiler_inline_result && !didTimeout) {
      didTimeout = lanes;
      JSCompiler_inline_result = executionContext;
      executionContext |= 8;
      var prevDispatcher = pushDispatcher();
      if (workInProgressRoot !== root || workInProgressRootRenderLanes !== didTimeout) workInProgressRootRenderTargetTime = _$$_REQUIRE(_dependencyMap[4]).unstable_now() + 500, prepareFreshStack(root, didTimeout);

      do {
        try {
          workLoopConcurrent();
          break;
        } catch (thrownValue) {
          handleError(root, thrownValue);
        }
      } while (1);

      resetContextDependencies();
      ReactCurrentDispatcher$2.current = prevDispatcher;
      executionContext = JSCompiler_inline_result;
      null !== workInProgress ? didTimeout = 0 : (workInProgressRoot = null, workInProgressRootRenderLanes = 0, didTimeout = workInProgressRootExitStatus);
    } else didTimeout = renderRootSync(root, lanes);

    if (0 !== didTimeout) {
      2 === didTimeout && (executionContext |= 32, root.hydrate && (root.hydrate = false), JSCompiler_inline_result = getLanesToRetrySynchronouslyOnError(root), 0 !== JSCompiler_inline_result && (lanes = JSCompiler_inline_result, didTimeout = renderRootSync(root, JSCompiler_inline_result)));
      if (1 === didTimeout) throw originalCallbackNode = workInProgressRootFatalError, prepareFreshStack(root, 0), markRootSuspended$1(root, lanes), ensureRootIsScheduled(root, _$$_REQUIRE(_dependencyMap[4]).unstable_now()), originalCallbackNode;
      root.finishedWork = root.current.alternate;
      root.finishedLanes = lanes;

      switch (didTimeout) {
        case 0:
        case 1:
          throw Error("Root did not complete. This is a bug in React.");

        case 2:
          commitRoot(root);
          break;

        case 3:
          markRootSuspended$1(root, lanes);

          if ((lanes & 130023424) === lanes && (didTimeout = globalMostRecentFallbackTime + 500 - _$$_REQUIRE(_dependencyMap[4]).unstable_now(), 10 < didTimeout)) {
            if (0 !== getNextLanes(root, 0)) break;
            JSCompiler_inline_result = root.suspendedLanes;

            if ((JSCompiler_inline_result & lanes) !== lanes) {
              requestEventTime();
              root.pingedLanes |= root.suspendedLanes & JSCompiler_inline_result;
              break;
            }

            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), didTimeout);
            break;
          }

          commitRoot(root);
          break;

        case 4:
          markRootSuspended$1(root, lanes);
          if ((lanes & 4194240) === lanes) break;
          didTimeout = root.eventTimes;

          for (JSCompiler_inline_result = -1; 0 < lanes;) {
            var index$5 = 31 - clz32(lanes);
            prevDispatcher = 1 << index$5;
            index$5 = didTimeout[index$5];
            index$5 > JSCompiler_inline_result && (JSCompiler_inline_result = index$5);
            lanes &= ~prevDispatcher;
          }

          lanes = JSCompiler_inline_result;
          lanes = _$$_REQUIRE(_dependencyMap[4]).unstable_now() - lanes;
          lanes = (120 > lanes ? 120 : 480 > lanes ? 480 : 1080 > lanes ? 1080 : 1920 > lanes ? 1920 : 3e3 > lanes ? 3e3 : 4320 > lanes ? 4320 : 1960 * ceil(lanes / 1960)) - lanes;

          if (10 < lanes) {
            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), lanes);
            break;
          }

          commitRoot(root);
          break;

        case 5:
          commitRoot(root);
          break;

        default:
          throw Error("Unknown root exit status.");
      }
    }

    ensureRootIsScheduled(root, _$$_REQUIRE(_dependencyMap[4]).unstable_now());
    return root.callbackNode === originalCallbackNode ? performConcurrentWorkOnRoot.bind(null, root) : null;
  }

  function markRootSuspended$1(root, suspendedLanes) {
    suspendedLanes &= ~workInProgressRootPingedLanes;
    suspendedLanes &= ~workInProgressRootUpdatedLanes;
    root.suspendedLanes |= suspendedLanes;
    root.pingedLanes &= ~suspendedLanes;

    for (root = root.expirationTimes; 0 < suspendedLanes;) {
      var index$7 = 31 - clz32(suspendedLanes),
          lane = 1 << index$7;
      root[index$7] = -1;
      suspendedLanes &= ~lane;
    }
  }

  function performSyncWorkOnRoot(root) {
    if (0 !== (executionContext & 24)) throw Error("Should not already be working.");
    flushPassiveEffects();
    var lanes = getNextLanes(root, 0);
    if (0 === (lanes & 1)) return ensureRootIsScheduled(root, _$$_REQUIRE(_dependencyMap[4]).unstable_now()), null;
    var exitStatus = renderRootSync(root, lanes);

    if (0 !== root.tag && 2 === exitStatus) {
      executionContext |= 32;
      root.hydrate && (root.hydrate = false);
      var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
      0 !== errorRetryLanes && (lanes = errorRetryLanes, exitStatus = renderRootSync(root, lanes));
    }

    if (1 === exitStatus) throw exitStatus = workInProgressRootFatalError, prepareFreshStack(root, 0), markRootSuspended$1(root, lanes), ensureRootIsScheduled(root, _$$_REQUIRE(_dependencyMap[4]).unstable_now()), exitStatus;
    root.finishedWork = root.current.alternate;
    root.finishedLanes = lanes;
    commitRoot(root);
    ensureRootIsScheduled(root, _$$_REQUIRE(_dependencyMap[4]).unstable_now());
    return null;
  }

  function popRenderLanes() {
    subtreeRenderLanes = subtreeRenderLanesCursor.current;
    pop(subtreeRenderLanesCursor);
  }

  function prepareFreshStack(root, lanes) {
    root.finishedWork = null;
    root.finishedLanes = 0;
    var timeoutHandle = root.timeoutHandle;
    -1 !== timeoutHandle && (root.timeoutHandle = -1, cancelTimeout(timeoutHandle));
    if (null !== workInProgress) for (timeoutHandle = workInProgress.return; null !== timeoutHandle;) {
      var interruptedWork = timeoutHandle;

      switch (interruptedWork.tag) {
        case 1:
          interruptedWork = interruptedWork.type.childContextTypes;
          null !== interruptedWork && undefined !== interruptedWork && popContext();
          break;

        case 3:
          popHostContainer();
          pop(didPerformWorkStackCursor);
          pop(contextStackCursor);
          resetWorkInProgressVersions();
          break;

        case 5:
          popHostContext(interruptedWork);
          break;

        case 4:
          popHostContainer();
          break;

        case 13:
          pop(suspenseStackCursor);
          break;

        case 19:
          pop(suspenseStackCursor);
          break;

        case 10:
          popProvider(interruptedWork.type._context);
          break;

        case 22:
        case 23:
          popRenderLanes();
      }

      timeoutHandle = timeoutHandle.return;
    }
    workInProgressRoot = root;
    workInProgress = createWorkInProgress(root.current, null);
    workInProgressRootRenderLanes = subtreeRenderLanes = lanes;
    workInProgressRootExitStatus = 0;
    workInProgressRootFatalError = null;
    workInProgressRootPingedLanes = workInProgressRootUpdatedLanes = workInProgressRootSkippedLanes = 0;

    if (null !== interleavedQueues) {
      for (root = 0; root < interleavedQueues.length; root++) {
        if (lanes = interleavedQueues[root], timeoutHandle = lanes.interleaved, null !== timeoutHandle) {
          lanes.interleaved = null;
          interruptedWork = timeoutHandle.next;
          var lastPendingUpdate = lanes.pending;

          if (null !== lastPendingUpdate) {
            var firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = interruptedWork;
            timeoutHandle.next = firstPendingUpdate;
          }

          lanes.pending = timeoutHandle;
        }
      }

      interleavedQueues = null;
    }
  }

  function handleError(root$jscomp$0, thrownValue) {
    do {
      var erroredWork = workInProgress;

      try {
        resetContextDependencies();
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;

        if (didScheduleRenderPhaseUpdate) {
          for (var hook = currentlyRenderingFiber$1.memoizedState; null !== hook;) {
            var queue = hook.queue;
            null !== queue && (queue.pending = null);
            hook = hook.next;
          }

          didScheduleRenderPhaseUpdate = false;
        }

        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        ReactCurrentOwner$2.current = null;

        if (null === erroredWork || null === erroredWork.return) {
          workInProgressRootExitStatus = 1;
          workInProgressRootFatalError = thrownValue;
          workInProgress = null;
          break;
        }

        a: {
          var root = root$jscomp$0,
              returnFiber = erroredWork.return,
              sourceFiber = erroredWork,
              value = thrownValue;
          thrownValue = workInProgressRootRenderLanes;
          sourceFiber.flags |= 8192;

          if (null !== value && "object" === typeof value && "function" === typeof value.then) {
            var wakeable = value,
                tag = sourceFiber.tag;

            if (0 === (sourceFiber.mode & 1) && (0 === tag || 11 === tag || 15 === tag)) {
              var currentSource = sourceFiber.alternate;
              currentSource ? (sourceFiber.updateQueue = currentSource.updateQueue, sourceFiber.memoizedState = currentSource.memoizedState, sourceFiber.lanes = currentSource.lanes) : (sourceFiber.updateQueue = null, sourceFiber.memoizedState = null);
            }

            var hasInvisibleParentBoundary = 0 !== (suspenseStackCursor.current & 1),
                workInProgress$32 = returnFiber;

            do {
              var JSCompiler_temp;

              if (JSCompiler_temp = 13 === workInProgress$32.tag) {
                var nextState = workInProgress$32.memoizedState;
                if (null !== nextState) JSCompiler_temp = null !== nextState.dehydrated ? true : false;else {
                  var props = workInProgress$32.memoizedProps;
                  JSCompiler_temp = undefined === props.fallback ? false : true !== props.unstable_avoidThisFallback ? true : hasInvisibleParentBoundary ? false : true;
                }
              }

              if (JSCompiler_temp) {
                var wakeables = workInProgress$32.updateQueue;

                if (null === wakeables) {
                  var updateQueue = new Set();
                  updateQueue.add(wakeable);
                  workInProgress$32.updateQueue = updateQueue;
                } else wakeables.add(wakeable);

                if (0 === (workInProgress$32.mode & 1) && workInProgress$32 !== returnFiber) {
                  workInProgress$32.flags |= 128;
                  sourceFiber.flags |= 32768;
                  sourceFiber.flags &= -10053;
                  if (1 === sourceFiber.tag) if (null === sourceFiber.alternate) sourceFiber.tag = 17;else {
                    var update = createUpdate(-1, 1);
                    update.tag = 2;
                    enqueueUpdate(sourceFiber, update);
                  }
                  sourceFiber.lanes |= 1;
                  break a;
                }

                value = undefined;
                sourceFiber = thrownValue;
                var pingCache = root.pingCache;
                null === pingCache ? (pingCache = root.pingCache = new PossiblyWeakMap(), value = new Set(), pingCache.set(wakeable, value)) : (value = pingCache.get(wakeable), undefined === value && (value = new Set(), pingCache.set(wakeable, value)));

                if (!value.has(sourceFiber)) {
                  value.add(sourceFiber);
                  var ping = pingSuspendedRoot.bind(null, root, wakeable, sourceFiber);
                  wakeable.then(ping, ping);
                }

                workInProgress$32.flags |= 16384;
                workInProgress$32.lanes = thrownValue;
                break a;
              }

              workInProgress$32 = workInProgress$32.return;
            } while (null !== workInProgress$32);

            value = Error((getComponentNameFromFiber(sourceFiber) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
          }

          5 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
          value = createCapturedValue(value, sourceFiber);
          workInProgress$32 = returnFiber;

          do {
            switch (workInProgress$32.tag) {
              case 3:
                root = value;
                workInProgress$32.flags |= 16384;
                thrownValue &= -thrownValue;
                workInProgress$32.lanes |= thrownValue;
                var update$33 = createRootErrorUpdate(workInProgress$32, root, thrownValue);
                enqueueCapturedUpdate(workInProgress$32, update$33);
                break a;

              case 1:
                root = value;
                var ctor = workInProgress$32.type,
                    instance = workInProgress$32.stateNode;

                if (0 === (workInProgress$32.flags & 128) && ("function" === typeof ctor.getDerivedStateFromError || null !== instance && "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance)))) {
                  workInProgress$32.flags |= 16384;
                  thrownValue &= -thrownValue;
                  workInProgress$32.lanes |= thrownValue;
                  var update$36 = createClassErrorUpdate(workInProgress$32, root, thrownValue);
                  enqueueCapturedUpdate(workInProgress$32, update$36);
                  break a;
                }

            }

            workInProgress$32 = workInProgress$32.return;
          } while (null !== workInProgress$32);
        }

        completeUnitOfWork(erroredWork);
      } catch (yetAnotherThrownValue) {
        thrownValue = yetAnotherThrownValue;
        workInProgress === erroredWork && null !== erroredWork && (workInProgress = erroredWork = erroredWork.return);
        continue;
      }

      break;
    } while (1);
  }

  function pushDispatcher() {
    var prevDispatcher = ReactCurrentDispatcher$2.current;
    ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
    return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
  }

  function renderRootSync(root, lanes) {
    var prevExecutionContext = executionContext;
    executionContext |= 8;
    var prevDispatcher = pushDispatcher();
    workInProgressRoot === root && workInProgressRootRenderLanes === lanes || prepareFreshStack(root, lanes);

    do {
      try {
        workLoopSync();
        break;
      } catch (thrownValue) {
        handleError(root, thrownValue);
      }
    } while (1);

    resetContextDependencies();
    executionContext = prevExecutionContext;
    ReactCurrentDispatcher$2.current = prevDispatcher;
    if (null !== workInProgress) throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
    workInProgressRoot = null;
    workInProgressRootRenderLanes = 0;
    return workInProgressRootExitStatus;
  }

  function workLoopSync() {
    for (; null !== workInProgress;) {
      performUnitOfWork(workInProgress);
    }
  }

  function workLoopConcurrent() {
    for (; null !== workInProgress && !_$$_REQUIRE(_dependencyMap[4]).unstable_shouldYield();) {
      performUnitOfWork(workInProgress);
    }
  }

  function performUnitOfWork(unitOfWork) {
    var next = beginWork$1(unitOfWork.alternate, unitOfWork, subtreeRenderLanes);
    unitOfWork.memoizedProps = unitOfWork.pendingProps;
    null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    ReactCurrentOwner$2.current = null;
  }

  function completeUnitOfWork(unitOfWork) {
    var completedWork = unitOfWork;

    do {
      var current = completedWork.alternate;
      unitOfWork = completedWork.return;

      if (0 === (completedWork.flags & 8192)) {
        if (current = completeWork(current, completedWork, subtreeRenderLanes), null !== current) {
          workInProgress = current;
          return;
        }
      } else {
        current = unwindWork(completedWork);

        if (null !== current) {
          current.flags &= 8191;
          workInProgress = current;
          return;
        }

        null !== unitOfWork && (unitOfWork.flags |= 8192, unitOfWork.subtreeFlags = 0, unitOfWork.deletions = null);
      }

      completedWork = completedWork.sibling;

      if (null !== completedWork) {
        workInProgress = completedWork;
        return;
      }

      workInProgress = completedWork = unitOfWork;
    } while (null !== completedWork);

    0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
  }

  function commitRoot(root) {
    var previousUpdateLanePriority = currentUpdatePriority,
        prevTransition = ReactCurrentBatchConfig$2.transition;

    try {
      ReactCurrentBatchConfig$2.transition = 0, currentUpdatePriority = 1, commitRootImpl(root, previousUpdateLanePriority);
    } finally {
      ReactCurrentBatchConfig$2.transition = prevTransition, currentUpdatePriority = previousUpdateLanePriority;
    }

    return null;
  }

  function commitRootImpl(root, renderPriorityLevel) {
    do {
      flushPassiveEffects();
    } while (null !== rootWithPendingPassiveEffects);

    if (0 !== (executionContext & 24)) throw Error("Should not already be working.");
    var finishedWork = root.finishedWork,
        lanes = root.finishedLanes;
    if (null === finishedWork) return null;
    root.finishedWork = null;
    root.finishedLanes = 0;
    if (finishedWork === root.current) throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
    root.callbackNode = null;
    root.callbackPriority = 0;
    var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
    markRootFinished(root, remainingLanes);
    root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
    0 === (finishedWork.subtreeFlags & 1040) && 0 === (finishedWork.flags & 1040) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = true, _$$_REQUIRE(_dependencyMap[4]).unstable_scheduleCallback(_$$_REQUIRE(_dependencyMap[4]).unstable_NormalPriority, function () {
      flushPassiveEffects();
      return null;
    }));
    remainingLanes = 0 !== (finishedWork.flags & 8054);

    if (0 !== (finishedWork.subtreeFlags & 8054) || remainingLanes) {
      remainingLanes = ReactCurrentBatchConfig$2.transition;
      ReactCurrentBatchConfig$2.transition = 0;
      var previousPriority = currentUpdatePriority;
      currentUpdatePriority = 1;
      var prevExecutionContext = executionContext;
      executionContext |= 16;
      ReactCurrentOwner$2.current = null;
      commitBeforeMutationEffects(root, finishedWork);
      commitMutationEffects(root, finishedWork);
      root.current = finishedWork;
      commitLayoutEffects(finishedWork, root, lanes);

      _$$_REQUIRE(_dependencyMap[4]).unstable_requestPaint();

      executionContext = prevExecutionContext;
      currentUpdatePriority = previousPriority;
      ReactCurrentBatchConfig$2.transition = remainingLanes;
    } else root.current = finishedWork;

    rootDoesHavePassiveEffects && (rootDoesHavePassiveEffects = false, rootWithPendingPassiveEffects = root, pendingPassiveEffectsLanes = lanes);
    remainingLanes = root.pendingLanes;
    0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
    0 !== (remainingLanes & 1) ? root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root) : nestedUpdateCount = 0;
    onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
    ensureRootIsScheduled(root, _$$_REQUIRE(_dependencyMap[4]).unstable_now());
    if (hasUncaughtError) throw hasUncaughtError = false, root = firstUncaughtError, firstUncaughtError = null, root;
    if (0 !== (executionContext & 4)) return null;
    0 !== (pendingPassiveEffectsLanes & 1) && 0 !== root.tag && flushPassiveEffects();
    flushSyncCallbacks();
    return null;
  }

  function flushPassiveEffects() {
    if (null !== rootWithPendingPassiveEffects) {
      var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
          prevTransition = ReactCurrentBatchConfig$2.transition,
          previousPriority = currentUpdatePriority;

      try {
        ReactCurrentBatchConfig$2.transition = 0;
        currentUpdatePriority = 16 > renderPriority ? 16 : renderPriority;
        if (null === rootWithPendingPassiveEffects) var JSCompiler_inline_result = false;else {
          renderPriority = rootWithPendingPassiveEffects;
          rootWithPendingPassiveEffects = null;
          pendingPassiveEffectsLanes = 0;
          if (0 !== (executionContext & 24)) throw Error("Cannot flush passive effects while already rendering.");
          var prevExecutionContext = executionContext;
          executionContext |= 16;

          for (nextEffect = renderPriority.current; null !== nextEffect;) {
            var fiber = nextEffect,
                child = fiber.child;

            if (0 !== (nextEffect.flags & 16)) {
              var deletions = fiber.deletions;

              if (null !== deletions) {
                for (var i = 0; i < deletions.length; i++) {
                  var fiberToDelete = deletions[i];

                  for (nextEffect = fiberToDelete; null !== nextEffect;) {
                    var fiber$jscomp$0 = nextEffect;

                    switch (fiber$jscomp$0.tag) {
                      case 0:
                      case 11:
                      case 15:
                        commitHookEffectListUnmount(4, fiber$jscomp$0, fiber);
                    }

                    var child$jscomp$0 = fiber$jscomp$0.child;
                    if (null !== child$jscomp$0) child$jscomp$0.return = fiber$jscomp$0, nextEffect = child$jscomp$0;else for (; null !== nextEffect;) {
                      fiber$jscomp$0 = nextEffect;
                      var sibling = fiber$jscomp$0.sibling,
                          returnFiber = fiber$jscomp$0.return;
                      detachFiberAfterEffects(fiber$jscomp$0);

                      if (fiber$jscomp$0 === fiberToDelete) {
                        nextEffect = null;
                        break;
                      }

                      if (null !== sibling) {
                        sibling.return = returnFiber;
                        nextEffect = sibling;
                        break;
                      }

                      nextEffect = returnFiber;
                    }
                  }
                }

                var previousFiber = fiber.alternate;

                if (null !== previousFiber) {
                  var detachedChild = previousFiber.child;

                  if (null !== detachedChild) {
                    previousFiber.child = null;

                    do {
                      var detachedSibling = detachedChild.sibling;
                      detachedChild.sibling = null;
                      detachedChild = detachedSibling;
                    } while (null !== detachedChild);
                  }
                }

                nextEffect = fiber;
              }
            }

            if (0 !== (fiber.subtreeFlags & 1040) && null !== child) child.return = fiber, nextEffect = child;else b: for (; null !== nextEffect;) {
              fiber = nextEffect;
              if (0 !== (fiber.flags & 1024)) switch (fiber.tag) {
                case 0:
                case 11:
                case 15:
                  commitHookEffectListUnmount(5, fiber, fiber.return);
              }
              var sibling$jscomp$0 = fiber.sibling;

              if (null !== sibling$jscomp$0) {
                sibling$jscomp$0.return = fiber.return;
                nextEffect = sibling$jscomp$0;
                break b;
              }

              nextEffect = fiber.return;
            }
          }

          var finishedWork = renderPriority.current;

          for (nextEffect = finishedWork; null !== nextEffect;) {
            child = nextEffect;
            var firstChild = child.child;
            if (0 !== (child.subtreeFlags & 1040) && null !== firstChild) firstChild.return = child, nextEffect = firstChild;else b: for (child = finishedWork; null !== nextEffect;) {
              deletions = nextEffect;
              if (0 !== (deletions.flags & 1024)) try {
                switch (deletions.tag) {
                  case 0:
                  case 11:
                  case 15:
                    commitHookEffectListMount(5, deletions);
                }
              } catch (error) {
                captureCommitPhaseError(deletions, deletions.return, error);
              }

              if (deletions === child) {
                nextEffect = null;
                break b;
              }

              var sibling$jscomp$1 = deletions.sibling;

              if (null !== sibling$jscomp$1) {
                sibling$jscomp$1.return = deletions.return;
                nextEffect = sibling$jscomp$1;
                break b;
              }

              nextEffect = deletions.return;
            }
          }

          executionContext = prevExecutionContext;
          flushSyncCallbacks();
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot) try {
            injectedHook.onPostCommitFiberRoot(rendererID, renderPriority);
          } catch (err) {}
          JSCompiler_inline_result = true;
        }
        return JSCompiler_inline_result;
      } finally {
        currentUpdatePriority = previousPriority, ReactCurrentBatchConfig$2.transition = prevTransition;
      }
    }

    return false;
  }

  function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
    sourceFiber = createCapturedValue(error, sourceFiber);
    sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, 1);
    enqueueUpdate(rootFiber, sourceFiber);
    sourceFiber = requestEventTime();
    rootFiber = markUpdateLaneFromFiberToRoot(rootFiber, 1);
    null !== rootFiber && (markRootUpdated(rootFiber, 1, sourceFiber), ensureRootIsScheduled(rootFiber, sourceFiber));
  }

  function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
    if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);else for (nearestMountedAncestor = sourceFiber.return; null !== nearestMountedAncestor;) {
      if (3 === nearestMountedAncestor.tag) {
        captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
        break;
      } else if (1 === nearestMountedAncestor.tag) {
        var instance = nearestMountedAncestor.stateNode;

        if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
          sourceFiber = createCapturedValue(error, sourceFiber);
          sourceFiber = createClassErrorUpdate(nearestMountedAncestor, sourceFiber, 1);
          enqueueUpdate(nearestMountedAncestor, sourceFiber);
          sourceFiber = requestEventTime();
          nearestMountedAncestor = markUpdateLaneFromFiberToRoot(nearestMountedAncestor, 1);
          null !== nearestMountedAncestor && (markRootUpdated(nearestMountedAncestor, 1, sourceFiber), ensureRootIsScheduled(nearestMountedAncestor, sourceFiber));
          break;
        }
      }

      nearestMountedAncestor = nearestMountedAncestor.return;
    }
  }

  function pingSuspendedRoot(root, wakeable, pingedLanes) {
    var pingCache = root.pingCache;
    null !== pingCache && pingCache.delete(wakeable);
    wakeable = requestEventTime();
    root.pingedLanes |= root.suspendedLanes & pingedLanes;
    workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 130023424) === workInProgressRootRenderLanes && 500 > _$$_REQUIRE(_dependencyMap[4]).unstable_now() - globalMostRecentFallbackTime ? prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes);
    ensureRootIsScheduled(root, wakeable);
  }

  function resolveRetryWakeable(boundaryFiber, wakeable) {
    var retryCache = boundaryFiber.stateNode;
    null !== retryCache && retryCache.delete(wakeable);
    wakeable = 0;
    0 === wakeable && (0 === (boundaryFiber.mode & 1) ? wakeable = 1 : (wakeable = nextRetryLane, nextRetryLane <<= 1, 0 === (nextRetryLane & 130023424) && (nextRetryLane = 4194304)));
    retryCache = requestEventTime();
    boundaryFiber = markUpdateLaneFromFiberToRoot(boundaryFiber, wakeable);
    null !== boundaryFiber && (markRootUpdated(boundaryFiber, wakeable, retryCache), ensureRootIsScheduled(boundaryFiber, retryCache));
  }

  var beginWork$1;

  beginWork$1 = function beginWork$1(current, workInProgress, renderLanes) {
    var updateLanes = workInProgress.lanes;
    if (null !== current) {
      if (current.memoizedProps !== workInProgress.pendingProps || didPerformWorkStackCursor.current) didReceiveUpdate = true;else {
        if (0 === (renderLanes & updateLanes)) {
          didReceiveUpdate = false;

          switch (workInProgress.tag) {
            case 3:
              pushHostRootContext(workInProgress);
              break;

            case 5:
              pushHostContext(workInProgress);
              break;

            case 1:
              isContextProvider(workInProgress.type) && pushContextProvider(workInProgress);
              break;

            case 4:
              pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
              break;

            case 10:
              updateLanes = workInProgress.type._context;
              var nextValue = workInProgress.memoizedProps.value;
              push(valueCursor, updateLanes._currentValue);
              updateLanes._currentValue = nextValue;
              break;

            case 13:
              if (null !== workInProgress.memoizedState) {
                if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);
                push(suspenseStackCursor, suspenseStackCursor.current & 1);
                workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                return null !== workInProgress ? workInProgress.sibling : null;
              }

              push(suspenseStackCursor, suspenseStackCursor.current & 1);
              break;

            case 19:
              updateLanes = 0 !== (renderLanes & workInProgress.childLanes);

              if (0 !== (current.flags & 128)) {
                if (updateLanes) return updateSuspenseListComponent(current, workInProgress, renderLanes);
                workInProgress.flags |= 128;
              }

              nextValue = workInProgress.memoizedState;
              null !== nextValue && (nextValue.rendering = null, nextValue.tail = null, nextValue.lastEffect = null);
              push(suspenseStackCursor, suspenseStackCursor.current);
              if (updateLanes) break;else return null;

            case 22:
            case 23:
              return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes);
          }

          return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
        }

        didReceiveUpdate = 0 !== (current.flags & 32768) ? true : false;
      }
    } else didReceiveUpdate = false;
    workInProgress.lanes = 0;

    switch (workInProgress.tag) {
      case 2:
        updateLanes = workInProgress.type;
        null !== current && (current.alternate = null, workInProgress.alternate = null, workInProgress.flags |= 2);
        current = workInProgress.pendingProps;
        nextValue = getMaskedContext(workInProgress, contextStackCursor.current);
        prepareToReadContext(workInProgress, renderLanes);
        nextValue = renderWithHooks(null, workInProgress, updateLanes, current, nextValue, renderLanes);
        workInProgress.flags |= 1;

        if ("object" === typeof nextValue && null !== nextValue && "function" === typeof nextValue.render && undefined === nextValue.$$typeof) {
          workInProgress.tag = 1;
          workInProgress.memoizedState = null;
          workInProgress.updateQueue = null;

          if (isContextProvider(updateLanes)) {
            var hasContext = true;
            pushContextProvider(workInProgress);
          } else hasContext = false;

          workInProgress.memoizedState = null !== nextValue.state && undefined !== nextValue.state ? nextValue.state : null;
          initializeUpdateQueue(workInProgress);
          nextValue.updater = classComponentUpdater;
          workInProgress.stateNode = nextValue;
          nextValue._reactInternals = workInProgress;
          mountClassInstance(workInProgress, updateLanes, current, renderLanes);
          workInProgress = finishClassComponent(null, workInProgress, updateLanes, true, hasContext, renderLanes);
        } else workInProgress.tag = 0, reconcileChildren(null, workInProgress, nextValue, renderLanes), workInProgress = workInProgress.child;

        return workInProgress;

      case 16:
        nextValue = workInProgress.elementType;

        a: {
          null !== current && (current.alternate = null, workInProgress.alternate = null, workInProgress.flags |= 2);
          current = workInProgress.pendingProps;
          hasContext = nextValue._init;
          nextValue = hasContext(nextValue._payload);
          workInProgress.type = nextValue;
          hasContext = workInProgress.tag = resolveLazyComponentTag(nextValue);
          current = resolveDefaultProps(nextValue, current);

          switch (hasContext) {
            case 0:
              workInProgress = updateFunctionComponent(null, workInProgress, nextValue, current, renderLanes);
              break a;

            case 1:
              workInProgress = updateClassComponent(null, workInProgress, nextValue, current, renderLanes);
              break a;

            case 11:
              workInProgress = updateForwardRef(null, workInProgress, nextValue, current, renderLanes);
              break a;

            case 14:
              workInProgress = updateMemoComponent(null, workInProgress, nextValue, resolveDefaultProps(nextValue.type, current), updateLanes, renderLanes);
              break a;
          }

          throw Error("Element type is invalid. Received a promise that resolves to: " + nextValue + ". Lazy element type must resolve to a class or function.");
        }

        return workInProgress;

      case 0:
        return updateLanes = workInProgress.type, nextValue = workInProgress.pendingProps, nextValue = workInProgress.elementType === updateLanes ? nextValue : resolveDefaultProps(updateLanes, nextValue), updateFunctionComponent(current, workInProgress, updateLanes, nextValue, renderLanes);

      case 1:
        return updateLanes = workInProgress.type, nextValue = workInProgress.pendingProps, nextValue = workInProgress.elementType === updateLanes ? nextValue : resolveDefaultProps(updateLanes, nextValue), updateClassComponent(current, workInProgress, updateLanes, nextValue, renderLanes);

      case 3:
        pushHostRootContext(workInProgress);
        updateLanes = workInProgress.updateQueue;
        if (null === current || null === updateLanes) throw Error("If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.");
        nextValue = workInProgress.pendingProps;
        updateLanes = workInProgress.memoizedState.element;
        cloneUpdateQueue(current, workInProgress);
        processUpdateQueue(workInProgress, nextValue, null, renderLanes);
        nextValue = workInProgress.memoizedState.element;
        nextValue === updateLanes ? workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) : (reconcileChildren(current, workInProgress, nextValue, renderLanes), workInProgress = workInProgress.child);
        return workInProgress;

      case 5:
        return pushHostContext(workInProgress), updateLanes = workInProgress.pendingProps.children, markRef(current, workInProgress), reconcileChildren(current, workInProgress, updateLanes, renderLanes), workInProgress.child;

      case 6:
        return null;

      case 13:
        return updateSuspenseComponent(current, workInProgress, renderLanes);

      case 4:
        return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), updateLanes = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, updateLanes, renderLanes) : reconcileChildren(current, workInProgress, updateLanes, renderLanes), workInProgress.child;

      case 11:
        return updateLanes = workInProgress.type, nextValue = workInProgress.pendingProps, nextValue = workInProgress.elementType === updateLanes ? nextValue : resolveDefaultProps(updateLanes, nextValue), updateForwardRef(current, workInProgress, updateLanes, nextValue, renderLanes);

      case 7:
        return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;

      case 8:
        return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;

      case 12:
        return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;

      case 10:
        a: {
          updateLanes = workInProgress.type._context;
          nextValue = workInProgress.pendingProps;
          hasContext = workInProgress.memoizedProps;
          var newValue = nextValue.value;
          push(valueCursor, updateLanes._currentValue);
          updateLanes._currentValue = newValue;
          if (null !== hasContext) if (objectIs(hasContext.value, newValue)) {
            if (hasContext.children === nextValue.children && !didPerformWorkStackCursor.current) {
              workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
              break a;
            }
          } else for (newValue = workInProgress.child, null !== newValue && (newValue.return = workInProgress); null !== newValue;) {
            var list = newValue.dependencies;

            if (null !== list) {
              hasContext = newValue.child;

              for (var dependency = list.firstContext; null !== dependency;) {
                if (dependency.context === updateLanes) {
                  if (1 === newValue.tag) {
                    dependency = createUpdate(-1, renderLanes & -renderLanes);
                    dependency.tag = 2;
                    var updateQueue = newValue.updateQueue;

                    if (null !== updateQueue) {
                      updateQueue = updateQueue.shared;
                      var pending = updateQueue.pending;
                      null === pending ? dependency.next = dependency : (dependency.next = pending.next, pending.next = dependency);
                      updateQueue.pending = dependency;
                    }
                  }

                  newValue.lanes |= renderLanes;
                  dependency = newValue.alternate;
                  null !== dependency && (dependency.lanes |= renderLanes);
                  scheduleWorkOnParentPath(newValue.return, renderLanes);
                  list.lanes |= renderLanes;
                  break;
                }

                dependency = dependency.next;
              }
            } else hasContext = 10 === newValue.tag ? newValue.type === workInProgress.type ? null : newValue.child : newValue.child;

            if (null !== hasContext) hasContext.return = newValue;else for (hasContext = newValue; null !== hasContext;) {
              if (hasContext === workInProgress) {
                hasContext = null;
                break;
              }

              newValue = hasContext.sibling;

              if (null !== newValue) {
                newValue.return = hasContext.return;
                hasContext = newValue;
                break;
              }

              hasContext = hasContext.return;
            }
            newValue = hasContext;
          }
          reconcileChildren(current, workInProgress, nextValue.children, renderLanes);
          workInProgress = workInProgress.child;
        }

        return workInProgress;

      case 9:
        return nextValue = workInProgress.type, updateLanes = workInProgress.pendingProps.children, prepareToReadContext(workInProgress, renderLanes), nextValue = readContext(nextValue), updateLanes = updateLanes(nextValue), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, updateLanes, renderLanes), workInProgress.child;

      case 14:
        return nextValue = workInProgress.type, hasContext = resolveDefaultProps(nextValue, workInProgress.pendingProps), hasContext = resolveDefaultProps(nextValue.type, hasContext), updateMemoComponent(current, workInProgress, nextValue, hasContext, updateLanes, renderLanes);

      case 15:
        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, updateLanes, renderLanes);

      case 17:
        return updateLanes = workInProgress.type, nextValue = workInProgress.pendingProps, nextValue = workInProgress.elementType === updateLanes ? nextValue : resolveDefaultProps(updateLanes, nextValue), null !== current && (current.alternate = null, workInProgress.alternate = null, workInProgress.flags |= 2), workInProgress.tag = 1, isContextProvider(updateLanes) ? (current = true, pushContextProvider(workInProgress)) : current = false, prepareToReadContext(workInProgress, renderLanes), constructClassInstance(workInProgress, updateLanes, nextValue), mountClassInstance(workInProgress, updateLanes, nextValue, renderLanes), finishClassComponent(null, workInProgress, updateLanes, true, current, renderLanes);

      case 19:
        return updateSuspenseListComponent(current, workInProgress, renderLanes);

      case 22:
        return updateOffscreenComponent(current, workInProgress, renderLanes);

      case 23:
        return updateOffscreenComponent(current, workInProgress, renderLanes);
    }

    throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
  };

  function FiberNode(tag, pendingProps, key, mode) {
    this.tag = tag;
    this.key = key;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = pendingProps;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = mode;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }

  function createFiber(tag, pendingProps, key, mode) {
    return new FiberNode(tag, pendingProps, key, mode);
  }

  function shouldConstruct(Component) {
    Component = Component.prototype;
    return !(!Component || !Component.isReactComponent);
  }

  function resolveLazyComponentTag(Component) {
    if ("function" === typeof Component) return shouldConstruct(Component) ? 1 : 0;

    if (undefined !== Component && null !== Component) {
      Component = Component.$$typeof;
      if (Component === REACT_FORWARD_REF_TYPE) return 11;
      if (Component === REACT_MEMO_TYPE) return 14;
    }

    return 2;
  }

  function createWorkInProgress(current, pendingProps) {
    var workInProgress = current.alternate;
    null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null);
    workInProgress.flags = current.flags & 1835008;
    workInProgress.childLanes = current.childLanes;
    workInProgress.lanes = current.lanes;
    workInProgress.child = current.child;
    workInProgress.memoizedProps = current.memoizedProps;
    workInProgress.memoizedState = current.memoizedState;
    workInProgress.updateQueue = current.updateQueue;
    pendingProps = current.dependencies;
    workInProgress.dependencies = null === pendingProps ? null : {
      lanes: pendingProps.lanes,
      firstContext: pendingProps.firstContext
    };
    workInProgress.sibling = current.sibling;
    workInProgress.index = current.index;
    workInProgress.ref = current.ref;
    return workInProgress;
  }

  function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
    var fiberTag = 2;
    owner = type;
    if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);else if ("string" === typeof type) fiberTag = 5;else a: switch (type) {
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);

      case REACT_DEBUG_TRACING_MODE_TYPE:
        fiberTag = 8;
        mode |= 4;
        break;

      case REACT_STRICT_MODE_TYPE:
        fiberTag = 8;
        mode |= 8;
        break;

      case REACT_PROFILER_TYPE:
        return type = createFiber(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;

      case REACT_SUSPENSE_TYPE:
        return type = createFiber(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;

      case REACT_SUSPENSE_LIST_TYPE:
        return type = createFiber(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;

      case REACT_OFFSCREEN_TYPE:
        return createFiberFromOffscreen(pendingProps, mode, lanes, key);

      case REACT_LEGACY_HIDDEN_TYPE:
        return type = createFiber(23, pendingProps, key, mode), type.elementType = REACT_LEGACY_HIDDEN_TYPE, type.lanes = lanes, type;

      default:
        if ("object" === typeof type && null !== type) switch (type.$$typeof) {
          case REACT_PROVIDER_TYPE:
            fiberTag = 10;
            break a;

          case REACT_CONTEXT_TYPE:
            fiberTag = 9;
            break a;

          case REACT_FORWARD_REF_TYPE:
            fiberTag = 11;
            break a;

          case REACT_MEMO_TYPE:
            fiberTag = 14;
            break a;

          case REACT_LAZY_TYPE:
            fiberTag = 16;
            owner = null;
            break a;
        }
        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (null == type ? type : typeof type) + ".");
    }
    key = createFiber(fiberTag, pendingProps, key, mode);
    key.elementType = type;
    key.type = owner;
    key.lanes = lanes;
    return key;
  }

  function createFiberFromFragment(elements, mode, lanes, key) {
    elements = createFiber(7, elements, key, mode);
    elements.lanes = lanes;
    return elements;
  }

  function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
    pendingProps = createFiber(22, pendingProps, key, mode);
    pendingProps.elementType = REACT_OFFSCREEN_TYPE;
    pendingProps.lanes = lanes;
    return pendingProps;
  }

  function createFiberFromText(content, mode, lanes) {
    content = createFiber(6, content, null, mode);
    content.lanes = lanes;
    return content;
  }

  function createFiberFromPortal(portal, mode, lanes) {
    mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);
    mode.lanes = lanes;
    mode.stateNode = {
      containerInfo: portal.containerInfo,
      pendingChildren: null,
      implementation: portal.implementation
    };
    return mode;
  }

  function FiberRootNode(containerInfo, tag, hydrate) {
    this.tag = tag;
    this.containerInfo = containerInfo;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.pendingContext = this.context = null;
    this.hydrate = hydrate;
    this.callbackNode = null;
    this.callbackPriority = 0;
    this.eventTimes = createLaneMap(0);
    this.expirationTimes = createLaneMap(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = createLaneMap(0);
  }

  function createPortal(children, containerInfo, implementation) {
    var key = 3 < arguments.length && undefined !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: REACT_PORTAL_TYPE,
      key: null == key ? null : "" + key,
      children: children,
      containerInfo: containerInfo,
      implementation: implementation
    };
  }

  function findHostInstance(component) {
    var fiber = component._reactInternals;

    if (undefined === fiber) {
      if ("function" === typeof component.render) throw Error("Unable to find node on an unmounted component.");
      throw Error("Argument appears to not be a ReactComponent. Keys: " + Object.keys(component));
    }

    component = findCurrentHostFiber(fiber);
    return null === component ? null : component.stateNode;
  }

  function updateContainer(element, container, parentComponent, callback) {
    var current = container.current,
        eventTime = requestEventTime(),
        lane = requestUpdateLane(current);

    a: if (parentComponent) {
      parentComponent = parentComponent._reactInternals;

      b: {
        if (getNearestMountedFiber(parentComponent) !== parentComponent || 1 !== parentComponent.tag) throw Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var JSCompiler_inline_result = parentComponent;

        do {
          switch (JSCompiler_inline_result.tag) {
            case 3:
              JSCompiler_inline_result = JSCompiler_inline_result.stateNode.context;
              break b;

            case 1:
              if (isContextProvider(JSCompiler_inline_result.type)) {
                JSCompiler_inline_result = JSCompiler_inline_result.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }

          }

          JSCompiler_inline_result = JSCompiler_inline_result.return;
        } while (null !== JSCompiler_inline_result);

        throw Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }

      if (1 === parentComponent.tag) {
        var Component = parentComponent.type;

        if (isContextProvider(Component)) {
          parentComponent = processChildContext(parentComponent, Component, JSCompiler_inline_result);
          break a;
        }
      }

      parentComponent = JSCompiler_inline_result;
    } else parentComponent = emptyContextObject;

    null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
    container = createUpdate(eventTime, lane);
    container.payload = {
      element: element
    };
    callback = undefined === callback ? null : callback;
    null !== callback && (container.callback = callback);
    enqueueUpdate(current, container);
    element = scheduleUpdateOnFiber(current, lane, eventTime);
    null !== element && entangleTransitions(element, current, lane);
    return lane;
  }

  function emptyFindFiberByHostInstance() {
    return null;
  }

  function findNodeHandle(componentOrHandle) {
    if (null == componentOrHandle) return null;
    if ("number" === typeof componentOrHandle) return componentOrHandle;
    if (componentOrHandle._nativeTag) return componentOrHandle._nativeTag;
    if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) return componentOrHandle.canonical._nativeTag;
    componentOrHandle = findHostInstance(componentOrHandle);
    return null == componentOrHandle ? componentOrHandle : componentOrHandle.canonical ? componentOrHandle.canonical._nativeTag : componentOrHandle._nativeTag;
  }

  function unmountComponentAtNode(containerTag) {
    var root = roots.get(containerTag);
    root && updateContainer(null, root, null, function () {
      roots.delete(containerTag);
    });
  }

  batchedUpdatesImpl = function batchedUpdatesImpl(fn, a) {
    var prevExecutionContext = executionContext;
    executionContext |= 1;

    try {
      return fn(a);
    } finally {
      executionContext = prevExecutionContext, 0 === executionContext && (workInProgressRootRenderTargetTime = _$$_REQUIRE(_dependencyMap[4]).unstable_now() + 500, includesLegacySyncCallbacks && flushSyncCallbacks());
    }
  };

  var roots = new Map(),
      devToolsConfig$jscomp$inline_983 = {
    findFiberByHostInstance: getInstanceFromTag,
    bundleType: 0,
    version: "18.0.0-experimental-568dc3532",
    rendererPackageName: "react-native-renderer",
    rendererConfig: {
      getInspectorDataForViewTag: function getInspectorDataForViewTag() {
        throw Error("getInspectorDataForViewTag() is not available in production");
      },
      getInspectorDataForViewAtPoint: function () {
        throw Error("getInspectorDataForViewAtPoint() is not available in production.");
      }.bind(null, findNodeHandle)
    }
  };
  var internals$jscomp$inline_1237 = {
    bundleType: devToolsConfig$jscomp$inline_983.bundleType,
    version: devToolsConfig$jscomp$inline_983.version,
    rendererPackageName: devToolsConfig$jscomp$inline_983.rendererPackageName,
    rendererConfig: devToolsConfig$jscomp$inline_983.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ReactSharedInternals.ReactCurrentDispatcher,
    findHostInstanceByFiber: function findHostInstanceByFiber(fiber) {
      fiber = findCurrentHostFiber(fiber);
      return null === fiber ? null : fiber.stateNode;
    },
    findFiberByHostInstance: devToolsConfig$jscomp$inline_983.findFiberByHostInstance || emptyFindFiberByHostInstance,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.0.0-experimental-568dc3532"
  };

  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var hook$jscomp$inline_1238 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!hook$jscomp$inline_1238.isDisabled && hook$jscomp$inline_1238.supportsFiber) try {
      rendererID = hook$jscomp$inline_1238.inject(internals$jscomp$inline_1237), injectedHook = hook$jscomp$inline_1238;
    } catch (err) {}
  }

  exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {
    computeComponentStackForErrorReporting: function computeComponentStackForErrorReporting(reactTag) {
      return (reactTag = getInstanceFromTag(reactTag)) ? getStackByFiberInDevAndProd(reactTag) : "";
    }
  };

  exports.createPortal = function (children, containerTag) {
    return createPortal(children, containerTag, null, 2 < arguments.length && undefined !== arguments[2] ? arguments[2] : null);
  };

  exports.dispatchCommand = function (handle, command, args) {
    null != handle._nativeTag && (handle._internalInstanceHandle ? nativeFabricUIManager.dispatchCommand(handle._internalInstanceHandle.stateNode.node, command, args) : _$$_REQUIRE(_dependencyMap[3]).UIManager.dispatchViewManagerCommand(handle._nativeTag, command, args));
  };

  exports.findHostInstance_DEPRECATED = function (componentOrHandle) {
    if (null == componentOrHandle) return null;
    if (componentOrHandle._nativeTag) return componentOrHandle;
    if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) return componentOrHandle.canonical;
    componentOrHandle = findHostInstance(componentOrHandle);
    return null == componentOrHandle ? componentOrHandle : componentOrHandle.canonical ? componentOrHandle.canonical : componentOrHandle;
  };

  exports.findNodeHandle = findNodeHandle;

  exports.render = function (element, containerTag, callback) {
    var root = roots.get(containerTag);

    if (!root) {
      root = new FiberRootNode(containerTag, 0, false);
      var JSCompiler_inline_result = createFiber(3, null, null, 0);
      root.current = JSCompiler_inline_result;
      JSCompiler_inline_result.stateNode = root;
      JSCompiler_inline_result.memoizedState = {
        element: null
      };
      initializeUpdateQueue(JSCompiler_inline_result);
      roots.set(containerTag, root);
    }

    updateContainer(element, root, null, callback);

    a: if (element = root.current, element.child) switch (element.child.tag) {
      case 5:
        element = element.child.stateNode;
        break a;

      default:
        element = element.child.stateNode;
    } else element = null;

    return element;
  };

  exports.sendAccessibilityEvent = function (handle, eventType) {
    null != handle._nativeTag && (handle._internalInstanceHandle ? nativeFabricUIManager.sendAccessibilityEvent(handle._internalInstanceHandle.stateNode.node, eventType) : _$$_REQUIRE(_dependencyMap[3]).legacySendAccessibilityEvent(handle._nativeTag, eventType));
  };

  exports.unmountComponentAtNode = unmountComponentAtNode;

  exports.unmountComponentAtNodeAndRemoveContainer = function (containerTag) {
    unmountComponentAtNode(containerTag);

    _$$_REQUIRE(_dependencyMap[3]).UIManager.removeRootView(containerTag);
  };

  exports.unstable_batchedUpdates = batchedUpdates;
},"node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-prod.js",["node_modules/react-native/Libraries/ReactPrivate/ReactNativePrivateInitializeCore.js","node_modules/react/index.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/ReactPrivate/ReactNativePrivateInterface.js","node_modules/scheduler/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  _$$_REQUIRE(_dependencyMap[0]);
},"node_modules/react-native/Libraries/ReactPrivate/ReactNativePrivateInitializeCore.js",["node_modules/react-native/Libraries/Core/InitializeCore.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var start = Date.now();

  _$$_REQUIRE(_dependencyMap[0]);

  _$$_REQUIRE(_dependencyMap[1]);

  _$$_REQUIRE(_dependencyMap[2]);

  _$$_REQUIRE(_dependencyMap[3]);

  _$$_REQUIRE(_dependencyMap[4]);

  _$$_REQUIRE(_dependencyMap[5]);

  _$$_REQUIRE(_dependencyMap[6]);

  _$$_REQUIRE(_dependencyMap[7]);

  _$$_REQUIRE(_dependencyMap[8]);

  _$$_REQUIRE(_dependencyMap[9]);

  _$$_REQUIRE(_dependencyMap[10]);

  _$$_REQUIRE(_dependencyMap[11]);

  _$$_REQUIRE(_dependencyMap[12]).markPoint('initializeCore_start', _$$_REQUIRE(_dependencyMap[12]).currentTimestamp() - (Date.now() - start));

  _$$_REQUIRE(_dependencyMap[12]).markPoint('initializeCore_end');
},"node_modules/react-native/Libraries/Core/InitializeCore.js",["node_modules/react-native/Libraries/Core/setUpGlobals.js","node_modules/react-native/Libraries/Core/setUpPerformance.js","node_modules/react-native/Libraries/Core/setUpSystrace.js","node_modules/react-native/Libraries/Core/setUpErrorHandling.js","node_modules/react-native/Libraries/Core/polyfillPromise.js","node_modules/react-native/Libraries/Core/setUpRegeneratorRuntime.js","node_modules/react-native/Libraries/Core/setUpTimers.js","node_modules/react-native/Libraries/Core/setUpXHR.js","node_modules/react-native/Libraries/Core/setUpAlert.js","node_modules/react-native/Libraries/Core/setUpNavigator.js","node_modules/react-native/Libraries/Core/setUpBatchedBridge.js","node_modules/react-native/Libraries/Core/setUpSegmentFetcher.js","node_modules/react-native/Libraries/Utilities/GlobalPerformanceLogger.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (global.window === undefined) {
    global.window = global;
  }

  if (global.self === undefined) {
    global.self = global;
  }

  global.process = global.process || {};
  global.process.env = global.process.env || {};

  if (!global.process.env.NODE_ENV) {
    global.process.env.NODE_ENV = 'production';
  }
},"node_modules/react-native/Libraries/Core/setUpGlobals.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (!global.performance) {
    global.performance = {};
  }

  if (typeof global.performance.now !== 'function') {
    global.performance.now = function () {
      var performanceNow = global.nativePerformanceNow || Date.now;
      return performanceNow();
    };
  }
},"node_modules/react-native/Libraries/Core/setUpPerformance.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (global.__RCTProfileIsProfiling) {
    var Systrace = _$$_REQUIRE(_dependencyMap[0]);

    Systrace.installReactHook();
    Systrace.setEnabled(true);
  }
},"node_modules/react-native/Libraries/Core/setUpSystrace.js",["node_modules/react-native/Libraries/Performance/Systrace.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  _$$_REQUIRE(_dependencyMap[0]).installConsoleErrorReporter();

  if (!global.__fbDisableExceptionsManager) {
    var handleError = function handleError(e, isFatal) {
      try {
        _$$_REQUIRE(_dependencyMap[0]).handleException(e, isFatal);
      } catch (ee) {
        console.log('Failed to print error: ', ee.message);
        throw e;
      }
    };

    var ErrorUtils = _$$_REQUIRE(_dependencyMap[1]);

    ErrorUtils.setGlobalHandler(handleError);
  }
},"node_modules/react-native/Libraries/Core/setUpErrorHandling.js",["node_modules/react-native/Libraries/Core/ExceptionsManager.js","node_modules/react-native/Libraries/vendor/core/ErrorUtils.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var SyntheticError = function (_Error) {
    _$$_REQUIRE(_dependencyMap[2])(SyntheticError, _Error);

    var _super = _createSuper(SyntheticError);

    function SyntheticError() {
      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, SyntheticError);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.name = '';
      return _this;
    }

    return _$$_REQUIRE(_dependencyMap[4])(SyntheticError);
  }(_$$_REQUIRE(_dependencyMap[5])(Error));

  var userExceptionDecorator;
  var inUserExceptionDecorator = false;

  function unstable_setExceptionDecorator(exceptionDecorator) {
    userExceptionDecorator = exceptionDecorator;
  }

  function preprocessException(data) {
    if (userExceptionDecorator && !inUserExceptionDecorator) {
      inUserExceptionDecorator = true;

      try {
        return userExceptionDecorator(data);
      } catch (_unused) {} finally {
        inUserExceptionDecorator = false;
      }
    }

    return data;
  }

  var exceptionID = 0;

  function reportException(e, isFatal, reportToConsole) {
    var parseErrorStack = _$$_REQUIRE(_dependencyMap[6]);

    var stack = parseErrorStack(e == null ? undefined : e.stack);
    var currentExceptionID = ++exceptionID;
    var originalMessage = e.message || '';
    var message = originalMessage;

    if (e.componentStack != null) {
      message += "\n\nThis error is located at:" + e.componentStack;
    }

    var namePrefix = e.name == null || e.name === '' ? '' : e.name + ": ";

    if (!message.startsWith(namePrefix)) {
      message = namePrefix + message;
    }

    message = e.jsEngine == null ? message : message + ", js engine: " + e.jsEngine;
    var data = preprocessException({
      message: message,
      originalMessage: message === originalMessage ? null : originalMessage,
      name: e.name == null || e.name === '' ? null : e.name,
      componentStack: typeof e.componentStack === 'string' ? e.componentStack : null,
      stack: stack,
      id: currentExceptionID,
      isFatal: isFatal,
      extraData: {
        jsEngine: e.jsEngine,
        rawStack: e.stack
      }
    });

    if (reportToConsole) {
      console.error(data.message);
    }

    if (isFatal || e.type !== 'warn') {
      var NativeExceptionsManager = _$$_REQUIRE(_dependencyMap[7]).default;

      if (NativeExceptionsManager) {
        NativeExceptionsManager.reportException(data);
      }
    }
  }

  var inExceptionHandler = false;

  function handleException(e, isFatal) {
    var error;

    if (e instanceof Error) {
      error = e;
    } else {
      error = new SyntheticError(e);
    }

    try {
      inExceptionHandler = true;
      reportException(error, isFatal, true);
    } finally {
      inExceptionHandler = false;
    }
  }

  function reactConsoleErrorHandler() {
    var _console;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    (_console = console)._errorOriginal.apply(_console, args);

    if (!console.reportErrorsAsExceptions) {
      return;
    }

    if (inExceptionHandler) {
      return;
    }

    var error;
    var firstArg = args[0];

    if (firstArg != null && firstArg.stack) {
      error = firstArg;
    } else {
      var stringifySafe = _$$_REQUIRE(_dependencyMap[8]).default;

      if (typeof firstArg === 'string' && firstArg.startsWith('Warning: ')) {
        return;
      }

      var message = args.map(function (arg) {
        return typeof arg === 'string' ? arg : stringifySafe(arg);
      }).join(' ');
      error = new SyntheticError(message);
      error.name = 'console.error';
    }

    reportException(error, false, false);
  }

  function installConsoleErrorReporter() {
    if (console._errorOriginal) {
      return;
    }

    console._errorOriginal = console.error.bind(console);
    console.error = reactConsoleErrorHandler;

    if (console.reportErrorsAsExceptions === undefined) {
      console.reportErrorsAsExceptions = true;
    }
  }

  module.exports = {
    handleException: handleException,
    installConsoleErrorReporter: installConsoleErrorReporter,
    SyntheticError: SyntheticError,
    unstable_setExceptionDecorator: unstable_setExceptionDecorator
  };
},"node_modules/react-native/Libraries/Core/ExceptionsManager.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/wrapNativeSuper.js","node_modules/react-native/Libraries/Core/Devtools/parseErrorStack.js","node_modules/react-native/Libraries/Core/NativeExceptionsManager.js","node_modules/react-native/Libraries/Utilities/stringifySafe.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_$$_REQUIRE(_dependencyMap[0])(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _$$_REQUIRE(_dependencyMap[1])(Class, arguments, _$$_REQUIRE(_dependencyMap[2])(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _$$_REQUIRE(_dependencyMap[3])(Wrapper, Class);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _wrapNativeSuper(Class);
  }

  module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/wrapNativeSuper.js",["node_modules/@babel/runtime/helpers/isNativeFunction.js","node_modules/@babel/runtime/helpers/construct.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/setPrototypeOf.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/isNativeFunction.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _construct(Parent, args, Class) {
    if (_$$_REQUIRE(_dependencyMap[0])()) {
      module.exports = _construct = Reflect.construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
    } else {
      module.exports = _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _$$_REQUIRE(_dependencyMap[1])(instance, Class.prototype);
        return instance;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }

    return _construct.apply(null, arguments);
  }

  module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/construct.js",["node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js","node_modules/@babel/runtime/helpers/setPrototypeOf.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function convertHermesStack(stack) {
    var frames = [];

    for (var _iterator = _createForOfIteratorHelperLoose(stack.entries), _step; !(_step = _iterator()).done;) {
      var entry = _step.value;

      if (entry.type !== 'FRAME') {
        continue;
      }

      var location = entry.location,
          functionName = entry.functionName;

      if (location.type === 'NATIVE') {
        continue;
      }

      frames.push({
        methodName: functionName,
        file: location.sourceUrl,
        lineNumber: location.line1Based,
        column: location.type === 'SOURCE' ? location.column1Based - 1 : location.virtualOffset0Based
      });
    }

    return frames;
  }

  function parseErrorStack(errorStack) {
    if (errorStack == null) {
      return [];
    }

    var stacktraceParser = _$$_REQUIRE(_dependencyMap[0]);

    var parsedStack = Array.isArray(errorStack) ? errorStack : global.HermesInternal ? convertHermesStack(_$$_REQUIRE(_dependencyMap[1])(errorStack)) : stacktraceParser.parse(errorStack).map(function (frame) {
      return _$$_REQUIRE(_dependencyMap[2])({}, frame, {
        column: frame.column != null ? frame.column - 1 : null
      });
    });
    return parsedStack;
  }

  module.exports = parseErrorStack;
},"node_modules/react-native/Libraries/Core/Devtools/parseErrorStack.js",["node_modules/stacktrace-parser/dist/stack-trace-parser.cjs.js","node_modules/react-native/Libraries/Core/Devtools/parseHermesStack.js","node_modules/@babel/runtime/helpers/extends.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  var UNKNOWN_FUNCTION = '<unknown>';

  function parse(stackString) {
    var lines = stackString.split('\n');
    return lines.reduce(function (stack, line) {
      var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);

      if (parseResult) {
        stack.push(parseResult);
      }

      return stack;
    }, []);
  }

  var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;

  function parseChrome(line) {
    var parts = chromeRe.exec(line);

    if (!parts) {
      return null;
    }

    var isNative = parts[2] && parts[2].indexOf('native') === 0;
    var isEval = parts[2] && parts[2].indexOf('eval') === 0;
    var submatch = chromeEvalRe.exec(parts[2]);

    if (isEval && submatch != null) {
      parts[2] = submatch[1];
      parts[3] = submatch[2];
      parts[4] = submatch[3];
    }

    return {
      file: !isNative ? parts[2] : null,
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: isNative ? [parts[2]] : [],
      lineNumber: parts[3] ? +parts[3] : null,
      column: parts[4] ? +parts[4] : null
    };
  }

  var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;

  function parseWinjs(line) {
    var parts = winjsRe.exec(line);

    if (!parts) {
      return null;
    }

    return {
      file: parts[2],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[3],
      column: parts[4] ? +parts[4] : null
    };
  }

  var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

  function parseGecko(line) {
    var parts = geckoRe.exec(line);

    if (!parts) {
      return null;
    }

    var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
    var submatch = geckoEvalRe.exec(parts[3]);

    if (isEval && submatch != null) {
      parts[3] = submatch[1];
      parts[4] = submatch[2];
      parts[5] = null;
    }

    return {
      file: parts[3],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: parts[2] ? parts[2].split(',') : [],
      lineNumber: parts[4] ? +parts[4] : null,
      column: parts[5] ? +parts[5] : null
    };
  }

  var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;

  function parseJSC(line) {
    var parts = javaScriptCoreRe.exec(line);

    if (!parts) {
      return null;
    }

    return {
      file: parts[3],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[4],
      column: parts[5] ? +parts[5] : null
    };
  }

  var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;

  function parseNode(line) {
    var parts = nodeRe.exec(line);

    if (!parts) {
      return null;
    }

    return {
      file: parts[2],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[3],
      column: parts[4] ? +parts[4] : null
    };
  }

  exports.parse = parse;
},"node_modules/stacktrace-parser/dist/stack-trace-parser.cjs.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var RE_FRAME = /^ {4}at (.+?)(?: \((native)\)?| \((address at )?(.*?):(\d+):(\d+)\))$/;
  var RE_SKIPPED = /^ {4}... skipping (\d+) frames$/;

  function parseLine(line) {
    var asFrame = line.match(RE_FRAME);

    if (asFrame) {
      return {
        type: 'FRAME',
        functionName: asFrame[1],
        location: asFrame[2] === 'native' ? {
          type: 'NATIVE'
        } : asFrame[3] === 'address at ' ? {
          type: 'BYTECODE',
          sourceUrl: asFrame[4],
          line1Based: Number.parseInt(asFrame[5], 10),
          virtualOffset0Based: Number.parseInt(asFrame[6], 10)
        } : {
          type: 'SOURCE',
          sourceUrl: asFrame[4],
          line1Based: Number.parseInt(asFrame[5], 10),
          column1Based: Number.parseInt(asFrame[6], 10)
        }
      };
    }

    var asSkipped = line.match(RE_SKIPPED);

    if (asSkipped) {
      return {
        type: 'SKIPPED',
        count: Number.parseInt(asSkipped[1], 10)
      };
    }
  }

  module.exports = function parseHermesStack(stack) {
    var lines = stack.split(/\n/);
    var entries = [];
    var lastMessageLine = -1;

    for (var i = 0; i < lines.length; ++i) {
      var line = lines[i];

      if (!line) {
        continue;
      }

      var entry = parseLine(line);

      if (entry) {
        entries.push(entry);
        continue;
      }

      lastMessageLine = i;
      entries = [];
    }

    var message = lines.slice(0, lastMessageLine + 1).join('\n');
    return {
      message: message,
      entries: entries
    };
  };
},"node_modules/react-native/Libraries/Core/Devtools/parseHermesStack.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var NativeModule = TurboModuleRegistry.getEnforcing('ExceptionsManager');
  var ExceptionsManager = {
    reportFatalException: function reportFatalException(message, stack, exceptionId) {
      NativeModule.reportFatalException(message, stack, exceptionId);
    },
    reportSoftException: function reportSoftException(message, stack, exceptionId) {
      NativeModule.reportSoftException(message, stack, exceptionId);
    },
    updateExceptionMessage: function updateExceptionMessage(message, stack, exceptionId) {
      NativeModule.updateExceptionMessage(message, stack, exceptionId);
    },
    dismissRedbox: function dismissRedbox() {},
    reportException: function reportException(data) {
      if (NativeModule.reportException) {
        NativeModule.reportException(data);
        return;
      }

      if (data.isFatal) {
        ExceptionsManager.reportFatalException(data.message, data.stack, data.id);
      } else {
        ExceptionsManager.reportSoftException(data.message, data.stack, data.id);
      }
    }
  };
  var _default = ExceptionsManager;
  exports.default = _default;
},"node_modules/react-native/Libraries/Core/NativeExceptionsManager.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _global, _global$HermesInterna;

  if ((_global = global) != null && (_global$HermesInterna = _global.HermesInternal) != null && _global$HermesInterna.hasPromise != null && _global$HermesInterna.hasPromise()) {
    var HermesPromise = global.Promise;
  } else {
    _$$_REQUIRE(_dependencyMap[0]).polyfillGlobal('Promise', function () {
      return _$$_REQUIRE(_dependencyMap[1]);
    });
  }
},"node_modules/react-native/Libraries/Core/polyfillPromise.js",["node_modules/react-native/Libraries/Utilities/PolyfillFunctions.js","node_modules/react-native/Libraries/Promise.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function polyfillObjectProperty(object, name, getValue) {
    var descriptor = Object.getOwnPropertyDescriptor(object, name);

    var _ref = descriptor || {},
        enumerable = _ref.enumerable,
        writable = _ref.writable,
        _ref$configurable = _ref.configurable,
        configurable = _ref$configurable === undefined ? false : _ref$configurable;

    if (descriptor && !configurable) {
      console.error('Failed to set polyfill. ' + name + ' is not configurable.');
      return;
    }

    _$$_REQUIRE(_dependencyMap[0])(object, name, {
      get: getValue,
      enumerable: enumerable !== false,
      writable: writable !== false
    });
  }

  function polyfillGlobal(name, getValue) {
    polyfillObjectProperty(global, name, getValue);
  }

  module.exports = {
    polyfillObjectProperty: polyfillObjectProperty,
    polyfillGlobal: polyfillGlobal
  };
},"node_modules/react-native/Libraries/Utilities/PolyfillFunctions.js",["node_modules/react-native/Libraries/Utilities/defineLazyObjectProperty.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  _$$_REQUIRE(_dependencyMap[0]);

  _$$_REQUIRE(_dependencyMap[1]);

  module.exports = _$$_REQUIRE(_dependencyMap[2]);
},"node_modules/react-native/Libraries/Promise.js",["node_modules/promise/setimmediate/done.js","node_modules/promise/setimmediate/finally.js","node_modules/promise/setimmediate/es6-extensions.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = _$$_REQUIRE(_dependencyMap[0]);

  _$$_REQUIRE(_dependencyMap[0]).prototype.done = function (onFulfilled, onRejected) {
    var self = arguments.length ? this.then.apply(this, arguments) : this;
    self.then(null, function (err) {
      setTimeout(function () {
        throw err;
      }, 0);
    });
  };
},"node_modules/promise/setimmediate/done.js",["node_modules/promise/setimmediate/core.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function noop() {}

  var LAST_ERROR = null;
  var IS_ERROR = {};

  function getThen(obj) {
    try {
      return obj.then;
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  }

  function tryCallOne(fn, a) {
    try {
      return fn(a);
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  }

  function tryCallTwo(fn, a, b) {
    try {
      fn(a, b);
    } catch (ex) {
      LAST_ERROR = ex;
      return IS_ERROR;
    }
  }

  module.exports = Promise;

  function Promise(fn) {
    if (typeof this !== 'object') {
      throw new TypeError('Promises must be constructed via new');
    }

    if (typeof fn !== 'function') {
      throw new TypeError('Promise constructor\'s argument is not a function');
    }

    this._U = 0;
    this._V = 0;
    this._W = null;
    this._X = null;
    if (fn === noop) return;
    doResolve(fn, this);
  }

  Promise._Y = null;
  Promise._Z = null;
  Promise._0 = noop;

  Promise.prototype.then = function (onFulfilled, onRejected) {
    if (this.constructor !== Promise) {
      return safeThen(this, onFulfilled, onRejected);
    }

    var res = new Promise(noop);
    handle(this, new Handler(onFulfilled, onRejected, res));
    return res;
  };

  function safeThen(self, onFulfilled, onRejected) {
    return new self.constructor(function (resolve, reject) {
      var res = new Promise(noop);
      res.then(resolve, reject);
      handle(self, new Handler(onFulfilled, onRejected, res));
    });
  }

  function handle(self, deferred) {
    while (self._V === 3) {
      self = self._W;
    }

    if (Promise._Y) {
      Promise._Y(self);
    }

    if (self._V === 0) {
      if (self._U === 0) {
        self._U = 1;
        self._X = deferred;
        return;
      }

      if (self._U === 1) {
        self._U = 2;
        self._X = [self._X, deferred];
        return;
      }

      self._X.push(deferred);

      return;
    }

    handleResolved(self, deferred);
  }

  function handleResolved(self, deferred) {
    setImmediate(function () {
      var cb = self._V === 1 ? deferred.onFulfilled : deferred.onRejected;

      if (cb === null) {
        if (self._V === 1) {
          resolve(deferred.promise, self._W);
        } else {
          reject(deferred.promise, self._W);
        }

        return;
      }

      var ret = tryCallOne(cb, self._W);

      if (ret === IS_ERROR) {
        reject(deferred.promise, LAST_ERROR);
      } else {
        resolve(deferred.promise, ret);
      }
    });
  }

  function resolve(self, newValue) {
    if (newValue === self) {
      return reject(self, new TypeError('A promise cannot be resolved with itself.'));
    }

    if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
      var then = getThen(newValue);

      if (then === IS_ERROR) {
        return reject(self, LAST_ERROR);
      }

      if (then === self.then && newValue instanceof Promise) {
        self._V = 3;
        self._W = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(then.bind(newValue), self);
        return;
      }
    }

    self._V = 1;
    self._W = newValue;
    finale(self);
  }

  function reject(self, newValue) {
    self._V = 2;
    self._W = newValue;

    if (Promise._Z) {
      Promise._Z(self, newValue);
    }

    finale(self);
  }

  function finale(self) {
    if (self._U === 1) {
      handle(self, self._X);
      self._X = null;
    }

    if (self._U === 2) {
      for (var i = 0; i < self._X.length; i++) {
        handle(self, self._X[i]);
      }

      self._X = null;
    }
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  function doResolve(fn, promise) {
    var done = false;
    var res = tryCallTwo(fn, function (value) {
      if (done) return;
      done = true;
      resolve(promise, value);
    }, function (reason) {
      if (done) return;
      done = true;
      reject(promise, reason);
    });

    if (!done && res === IS_ERROR) {
      done = true;
      reject(promise, LAST_ERROR);
    }
  }
},"node_modules/promise/setimmediate/core.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = _$$_REQUIRE(_dependencyMap[0]);

  _$$_REQUIRE(_dependencyMap[0]).prototype.finally = function (f) {
    return this.then(function (value) {
      return _$$_REQUIRE(_dependencyMap[0]).resolve(f()).then(function () {
        return value;
      });
    }, function (err) {
      return _$$_REQUIRE(_dependencyMap[0]).resolve(f()).then(function () {
        throw err;
      });
    });
  };
},"node_modules/promise/setimmediate/finally.js",["node_modules/promise/setimmediate/core.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = _$$_REQUIRE(_dependencyMap[0]);
  var TRUE = valuePromise(true);
  var FALSE = valuePromise(false);
  var NULL = valuePromise(null);
  var UNDEFINED = valuePromise(undefined);
  var ZERO = valuePromise(0);
  var EMPTYSTRING = valuePromise('');

  function valuePromise(value) {
    var p = new (_$$_REQUIRE(_dependencyMap[0]))(_$$_REQUIRE(_dependencyMap[0])._0);
    p._V = 1;
    p._W = value;
    return p;
  }

  _$$_REQUIRE(_dependencyMap[0]).resolve = function (value) {
    if (value instanceof _$$_REQUIRE(_dependencyMap[0])) return value;
    if (value === null) return NULL;
    if (value === undefined) return UNDEFINED;
    if (value === true) return TRUE;
    if (value === false) return FALSE;
    if (value === 0) return ZERO;
    if (value === '') return EMPTYSTRING;

    if (typeof value === 'object' || typeof value === 'function') {
      try {
        var then = value.then;

        if (typeof then === 'function') {
          return new (_$$_REQUIRE(_dependencyMap[0]))(then.bind(value));
        }
      } catch (ex) {
        return new (_$$_REQUIRE(_dependencyMap[0]))(function (resolve, reject) {
          reject(ex);
        });
      }
    }

    return valuePromise(value);
  };

  var _iterableToArray = function iterableToArray(iterable) {
    if (typeof Array.from === 'function') {
      _iterableToArray = Array.from;
      return Array.from(iterable);
    }

    _iterableToArray = function iterableToArray(x) {
      return Array.prototype.slice.call(x);
    };

    return Array.prototype.slice.call(iterable);
  };

  _$$_REQUIRE(_dependencyMap[0]).all = function (arr) {
    var args = _iterableToArray(arr);

    return new (_$$_REQUIRE(_dependencyMap[0]))(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          if (val instanceof _$$_REQUIRE(_dependencyMap[0]) && val.then === _$$_REQUIRE(_dependencyMap[0]).prototype.then) {
            while (val._V === 3) {
              val = val._W;
            }

            if (val._V === 1) return res(i, val._W);
            if (val._V === 2) reject(val._W);
            val.then(function (val) {
              res(i, val);
            }, reject);
            return;
          } else {
            var then = val.then;

            if (typeof then === 'function') {
              var p = new (_$$_REQUIRE(_dependencyMap[0]))(then.bind(val));
              p.then(function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
        }

        args[i] = val;

        if (--remaining === 0) {
          resolve(args);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  _$$_REQUIRE(_dependencyMap[0]).reject = function (value) {
    return new (_$$_REQUIRE(_dependencyMap[0]))(function (resolve, reject) {
      reject(value);
    });
  };

  _$$_REQUIRE(_dependencyMap[0]).race = function (values) {
    return new (_$$_REQUIRE(_dependencyMap[0]))(function (resolve, reject) {
      _iterableToArray(values).forEach(function (value) {
        _$$_REQUIRE(_dependencyMap[0]).resolve(value).then(resolve, reject);
      });
    });
  };

  _$$_REQUIRE(_dependencyMap[0]).prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };
},"node_modules/promise/setimmediate/es6-extensions.js",["node_modules/promise/setimmediate/core.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var hasNativeGenerator;

  try {
    hasNativeGenerator = _$$_REQUIRE(_dependencyMap[0]).hasNativeConstructor(_$$_REQUIRE(_dependencyMap[1]).mark(function _callee() {
      return _$$_REQUIRE(_dependencyMap[1]).wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }), 'GeneratorFunction');
  } catch (_unused) {
    hasNativeGenerator = false;
  }

  if (!hasNativeGenerator) {
    _$$_REQUIRE(_dependencyMap[2]).polyfillGlobal('regeneratorRuntime', function () {
      delete global.regeneratorRuntime;
      return _$$_REQUIRE(_dependencyMap[3]);
    });
  }
},"node_modules/react-native/Libraries/Core/setUpRegeneratorRuntime.js",["node_modules/react-native/Libraries/Utilities/FeatureDetection.js","node_modules/@babel/runtime/regenerator/index.js","node_modules/react-native/Libraries/Utilities/PolyfillFunctions.js","node_modules/regenerator-runtime/runtime.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function isNativeFunction(f) {
    return typeof f === 'function' && f.toString().indexOf('[native code]') > -1;
  }

  function hasNativeConstructor(o, expectedName) {
    var con = Object.getPrototypeOf(o).constructor;
    return con.name === expectedName && isNativeFunction(con);
  }

  module.exports = {
    isNativeFunction: isNativeFunction,
    hasNativeConstructor: hasNativeConstructor
  };
},"node_modules/react-native/Libraries/Utilities/FeatureDetection.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]);
},"node_modules/@babel/runtime/regenerator/index.js",["node_modules/regenerator-runtime/runtime.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var runtime = function (exports) {
    "use strict";

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }

    try {
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap;

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}

    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    define(Gp, "constructor", GeneratorFunctionPrototype);
    define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }

      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    });
    exports.AsyncIterator = AsyncIterator;

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === undefined) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined) {
        context.delegate = null;

        if (context.method === "throw") {
          if (delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined;
        }
      } else {
        return info;
      }

      context.delegate = null;
      return ContinueSentinel;
    }

    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator");
    define(Gp, iteratorSymbol, function () {
      return this;
    });
    define(Gp, "toString", function () {
      return "[object Generator]";
    });

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse();
      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      }

      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            context.method = "next";
            context.arg = undefined;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        }

        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          this.arg = undefined;
        }

        return ContinueSentinel;
      }
    };
    return exports;
  }(typeof module === "object" ? module.exports : {});

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
},"node_modules/regenerator-runtime/runtime.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _global$HermesInterna, _global$HermesInterna2;

  var hasHermesPromiseQueuedToJSVM = ((_global$HermesInterna = global.HermesInternal) == null ? undefined : _global$HermesInterna.hasPromise == null ? undefined : _global$HermesInterna.hasPromise()) === true && ((_global$HermesInterna2 = global.HermesInternal) == null ? undefined : _global$HermesInterna2.useEngineQueue == null ? undefined : _global$HermesInterna2.useEngineQueue()) === true;

  var hasNativePromise = _$$_REQUIRE(_dependencyMap[0]).isNativeFunction(Promise);

  var hasPromiseQueuedToJSVM = hasNativePromise || hasHermesPromiseQueuedToJSVM;

  if (global.RN$Bridgeless !== true) {
    var defineLazyTimer = function defineLazyTimer(name) {
      _$$_REQUIRE(_dependencyMap[1]).polyfillGlobal(name, function () {
        return _$$_REQUIRE(_dependencyMap[2])[name];
      });
    };

    defineLazyTimer('setTimeout');
    defineLazyTimer('clearTimeout');
    defineLazyTimer('setInterval');
    defineLazyTimer('clearInterval');
    defineLazyTimer('requestAnimationFrame');
    defineLazyTimer('cancelAnimationFrame');
    defineLazyTimer('requestIdleCallback');
    defineLazyTimer('cancelIdleCallback');
  }

  if (hasPromiseQueuedToJSVM) {
    _$$_REQUIRE(_dependencyMap[1]).polyfillGlobal('setImmediate', function () {
      return _$$_REQUIRE(_dependencyMap[3]).setImmediate;
    });

    _$$_REQUIRE(_dependencyMap[1]).polyfillGlobal('clearImmediate', function () {
      return _$$_REQUIRE(_dependencyMap[3]).clearImmediate;
    });
  } else {
    if (global.RN$Bridgeless !== true) {
      _$$_REQUIRE(_dependencyMap[1]).polyfillGlobal('setImmediate', function () {
        return _$$_REQUIRE(_dependencyMap[2]).queueReactNativeMicrotask;
      });

      _$$_REQUIRE(_dependencyMap[1]).polyfillGlobal('clearImmediate', function () {
        return _$$_REQUIRE(_dependencyMap[2]).clearReactNativeMicrotask;
      });
    }
  }

  if (hasHermesPromiseQueuedToJSVM) {
    _$$_REQUIRE(_dependencyMap[1]).polyfillGlobal('queueMicrotask', function () {
      var _global$HermesInterna3;

      return (_global$HermesInterna3 = global.HermesInternal) == null ? undefined : _global$HermesInterna3.enqueueJob;
    });
  } else {
    _$$_REQUIRE(_dependencyMap[1]).polyfillGlobal('queueMicrotask', function () {
      return _$$_REQUIRE(_dependencyMap[4]).default;
    });
  }
},"node_modules/react-native/Libraries/Core/setUpTimers.js",["node_modules/react-native/Libraries/Utilities/FeatureDetection.js","node_modules/react-native/Libraries/Utilities/PolyfillFunctions.js","node_modules/react-native/Libraries/Core/Timers/JSTimers.js","node_modules/react-native/Libraries/Core/Timers/immediateShim.js","node_modules/react-native/Libraries/Core/Timers/queueMicrotask.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _NativeTiming = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var FRAME_DURATION = 16.666666666666668;
  var IDLE_CALLBACK_FRAME_DEADLINE = 1;
  var callbacks = [];
  var types = [];
  var timerIDs = [];
  var reactNativeMicrotasks = [];
  var requestIdleCallbacks = [];
  var requestIdleCallbackTimeouts = {};
  var GUID = 1;
  var errors = [];
  var hasEmittedTimeDriftWarning = false;

  function _getFreeIndex() {
    var freeIndex = timerIDs.indexOf(null);

    if (freeIndex === -1) {
      freeIndex = timerIDs.length;
    }

    return freeIndex;
  }

  function _allocateCallback(func, type) {
    var id = GUID++;

    var freeIndex = _getFreeIndex();

    timerIDs[freeIndex] = id;
    callbacks[freeIndex] = func;
    types[freeIndex] = type;
    return id;
  }

  function _callTimer(timerID, frameTime, didTimeout) {
    if (timerID > GUID) {
      console.warn('Tried to call timer with ID %s but no such timer exists.', timerID);
    }

    var timerIndex = timerIDs.indexOf(timerID);

    if (timerIndex === -1) {
      return;
    }

    var type = types[timerIndex];
    var callback = callbacks[timerIndex];

    if (!callback || !type) {
      console.error('No callback found for timerID ' + timerID);
      return;
    }

    if (type !== 'setInterval') {
      _clearIndex(timerIndex);
    }

    try {
      if (type === 'setTimeout' || type === 'setInterval' || type === 'queueReactNativeMicrotask') {
        callback();
      } else if (type === 'requestAnimationFrame') {
        callback(global.performance.now());
      } else if (type === 'requestIdleCallback') {
        callback({
          timeRemaining: function timeRemaining() {
            return Math.max(0, FRAME_DURATION - (global.performance.now() - frameTime));
          },
          didTimeout: !!didTimeout
        });
      } else {
        console.error('Tried to call a callback with invalid type: ' + type);
      }
    } catch (e) {
      errors.push(e);
    }
  }

  function _callReactNativeMicrotasksPass() {
    if (reactNativeMicrotasks.length === 0) {
      return false;
    }

    var passReactNativeMicrotasks = reactNativeMicrotasks;
    reactNativeMicrotasks = [];

    for (var i = 0; i < passReactNativeMicrotasks.length; ++i) {
      _callTimer(passReactNativeMicrotasks[i], 0);
    }

    return reactNativeMicrotasks.length > 0;
  }

  function _clearIndex(i) {
    timerIDs[i] = null;
    callbacks[i] = null;
    types[i] = null;
  }

  function _freeCallback(timerID) {
    if (timerID == null) {
      return;
    }

    var index = timerIDs.indexOf(timerID);

    if (index !== -1) {
      var type = types[index];

      _clearIndex(index);

      if (type !== 'queueReactNativeMicrotask' && type !== 'requestIdleCallback') {
        deleteTimer(timerID);
      }
    }
  }

  var JSTimers = {
    setTimeout: function setTimeout(func, duration) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      var id = _allocateCallback(function () {
        return func.apply(undefined, args);
      }, 'setTimeout');

      createTimer(id, duration || 0, Date.now(), false);
      return id;
    },
    setInterval: function setInterval(func, duration) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      var id = _allocateCallback(function () {
        return func.apply(undefined, args);
      }, 'setInterval');

      createTimer(id, duration || 0, Date.now(), true);
      return id;
    },
    queueReactNativeMicrotask: function queueReactNativeMicrotask(func) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      var id = _allocateCallback(function () {
        return func.apply(undefined, args);
      }, 'queueReactNativeMicrotask');

      reactNativeMicrotasks.push(id);
      return id;
    },
    requestAnimationFrame: function requestAnimationFrame(func) {
      var id = _allocateCallback(func, 'requestAnimationFrame');

      createTimer(id, 1, Date.now(), false);
      return id;
    },
    requestIdleCallback: function requestIdleCallback(func, options) {
      if (requestIdleCallbacks.length === 0) {
        setSendIdleEvents(true);
      }

      var timeout = options && options.timeout;

      var id = _allocateCallback(timeout != null ? function (deadline) {
        var timeoutId = requestIdleCallbackTimeouts[id];

        if (timeoutId) {
          JSTimers.clearTimeout(timeoutId);
          delete requestIdleCallbackTimeouts[id];
        }

        return func(deadline);
      } : func, 'requestIdleCallback');

      requestIdleCallbacks.push(id);

      if (timeout != null) {
        var timeoutId = JSTimers.setTimeout(function () {
          var index = requestIdleCallbacks.indexOf(id);

          if (index > -1) {
            requestIdleCallbacks.splice(index, 1);

            _callTimer(id, global.performance.now(), true);
          }

          delete requestIdleCallbackTimeouts[id];

          if (requestIdleCallbacks.length === 0) {
            setSendIdleEvents(false);
          }
        }, timeout);
        requestIdleCallbackTimeouts[id] = timeoutId;
      }

      return id;
    },
    cancelIdleCallback: function cancelIdleCallback(timerID) {
      _freeCallback(timerID);

      var index = requestIdleCallbacks.indexOf(timerID);

      if (index !== -1) {
        requestIdleCallbacks.splice(index, 1);
      }

      var timeoutId = requestIdleCallbackTimeouts[timerID];

      if (timeoutId) {
        JSTimers.clearTimeout(timeoutId);
        delete requestIdleCallbackTimeouts[timerID];
      }

      if (requestIdleCallbacks.length === 0) {
        setSendIdleEvents(false);
      }
    },
    clearTimeout: function clearTimeout(timerID) {
      _freeCallback(timerID);
    },
    clearInterval: function clearInterval(timerID) {
      _freeCallback(timerID);
    },
    clearReactNativeMicrotask: function clearReactNativeMicrotask(timerID) {
      _freeCallback(timerID);

      var index = reactNativeMicrotasks.indexOf(timerID);

      if (index !== -1) {
        reactNativeMicrotasks.splice(index, 1);
      }
    },
    cancelAnimationFrame: function cancelAnimationFrame(timerID) {
      _freeCallback(timerID);
    },
    callTimers: function callTimers(timersToCall) {
      _$$_REQUIRE(_dependencyMap[2])(timersToCall.length !== 0, 'Cannot call `callTimers` with an empty list of IDs.');

      errors.length = 0;

      for (var i = 0; i < timersToCall.length; i++) {
        _callTimer(timersToCall[i], 0);
      }

      var errorCount = errors.length;

      if (errorCount > 0) {
        if (errorCount > 1) {
          for (var ii = 1; ii < errorCount; ii++) {
            JSTimers.setTimeout(function (error) {
              throw error;
            }.bind(null, errors[ii]), 0);
          }
        }

        throw errors[0];
      }
    },
    callIdleCallbacks: function callIdleCallbacks(frameTime) {
      if (FRAME_DURATION - (global.performance.now() - frameTime) < IDLE_CALLBACK_FRAME_DEADLINE) {
        return;
      }

      errors.length = 0;

      if (requestIdleCallbacks.length > 0) {
        var passIdleCallbacks = requestIdleCallbacks;
        requestIdleCallbacks = [];

        for (var i = 0; i < passIdleCallbacks.length; ++i) {
          _callTimer(passIdleCallbacks[i], frameTime);
        }
      }

      if (requestIdleCallbacks.length === 0) {
        setSendIdleEvents(false);
      }

      errors.forEach(function (error) {
        return JSTimers.setTimeout(function () {
          throw error;
        }, 0);
      });
    },
    callReactNativeMicrotasks: function callReactNativeMicrotasks() {
      errors.length = 0;

      while (_callReactNativeMicrotasksPass()) {}

      errors.forEach(function (error) {
        return JSTimers.setTimeout(function () {
          throw error;
        }, 0);
      });
    },
    emitTimeDriftWarning: function emitTimeDriftWarning(warningMessage) {
      if (hasEmittedTimeDriftWarning) {
        return;
      }

      hasEmittedTimeDriftWarning = true;
      console.warn(warningMessage);
    }
  };

  function createTimer(callbackID, duration, jsSchedulingTime, repeats) {
    _$$_REQUIRE(_dependencyMap[2])(_NativeTiming.default, 'NativeTiming is available');

    _NativeTiming.default.createTimer(callbackID, duration, jsSchedulingTime, repeats);
  }

  function deleteTimer(timerID) {
    _$$_REQUIRE(_dependencyMap[2])(_NativeTiming.default, 'NativeTiming is available');

    _NativeTiming.default.deleteTimer(timerID);
  }

  function setSendIdleEvents(sendIdleEvents) {
    _$$_REQUIRE(_dependencyMap[2])(_NativeTiming.default, 'NativeTiming is available');

    _NativeTiming.default.setSendIdleEvents(sendIdleEvents);
  }

  var ExportedJSTimers;

  if (!_NativeTiming.default) {
    console.warn("Timing native module is not available, can't set timers.");
    ExportedJSTimers = {
      callReactNativeMicrotasks: JSTimers.callReactNativeMicrotasks,
      queueReactNativeMicrotask: JSTimers.queueReactNativeMicrotask
    };
  } else {
    ExportedJSTimers = JSTimers;
  }

  _$$_REQUIRE(_dependencyMap[3]).setReactNativeMicrotasksCallback(JSTimers.callReactNativeMicrotasks);

  module.exports = ExportedJSTimers;
},"node_modules/react-native/Libraries/Core/Timers/JSTimers.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Core/Timers/NativeTiming.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/BatchedBridge/BatchedBridge.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('Timing');

  exports.default = _default;
},"node_modules/react-native/Libraries/Core/Timers/NativeTiming.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var GUIID = 1;
  var clearedImmediates = new Set();

  function setImmediate(callback) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (arguments.length < 1) {
      throw new TypeError('setImmediate must be called with at least one argument (a function to call)');
    }

    if (typeof callback !== 'function') {
      throw new TypeError('The first argument to setImmediate must be a function.');
    }

    var id = GUIID++;

    if (clearedImmediates.has(id)) {
      clearedImmediates.delete(id);
    }

    global.queueMicrotask(function () {
      if (!clearedImmediates.has(id)) {
        callback.apply(undefined, args);
      } else {
        clearedImmediates.delete(id);
      }
    });
    return id;
  }

  function clearImmediate(immediateID) {
    clearedImmediates.add(immediateID);
  }

  var immediateShim = {
    setImmediate: setImmediate,
    clearImmediate: clearImmediate
  };
  module.exports = immediateShim;
},"node_modules/react-native/Libraries/Core/Timers/immediateShim.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = queueMicrotask;
  var resolvedPromise;

  function queueMicrotask(callback) {
    if (arguments.length < 1) {
      throw new TypeError('queueMicrotask must be called with at least one argument (a function to call)');
    }

    if (typeof callback !== 'function') {
      throw new TypeError('The argument to queueMicrotask must be a function.');
    }

    (resolvedPromise || (resolvedPromise = Promise.resolve())).then(callback).catch(function (error) {
      return setTimeout(function () {
        throw error;
      }, 0);
    });
  }
},"node_modules/react-native/Libraries/Core/Timers/queueMicrotask.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  _$$_REQUIRE(_dependencyMap[0]).polyfillGlobal('XMLHttpRequest', function () {
    return _$$_REQUIRE(_dependencyMap[1]);
  });

  _$$_REQUIRE(_dependencyMap[0]).polyfillGlobal('FormData', function () {
    return _$$_REQUIRE(_dependencyMap[2]);
  });

  _$$_REQUIRE(_dependencyMap[0]).polyfillGlobal('fetch', function () {
    return _$$_REQUIRE(_dependencyMap[3]).fetch;
  });

  _$$_REQUIRE(_dependencyMap[0]).polyfillGlobal('Headers', function () {
    return _$$_REQUIRE(_dependencyMap[3]).Headers;
  });

  _$$_REQUIRE(_dependencyMap[0]).polyfillGlobal('Request', function () {
    return _$$_REQUIRE(_dependencyMap[3]).Request;
  });

  _$$_REQUIRE(_dependencyMap[0]).polyfillGlobal('Response', function () {
    return _$$_REQUIRE(_dependencyMap[3]).Response;
  });

  _$$_REQUIRE(_dependencyMap[0]).polyfillGlobal('WebSocket', function () {
    return _$$_REQUIRE(_dependencyMap[4]);
  });

  _$$_REQUIRE(_dependencyMap[0]).polyfillGlobal('Blob', function () {
    return _$$_REQUIRE(_dependencyMap[5]);
  });

  _$$_REQUIRE(_dependencyMap[0]).polyfillGlobal('File', function () {
    return _$$_REQUIRE(_dependencyMap[6]);
  });

  _$$_REQUIRE(_dependencyMap[0]).polyfillGlobal('FileReader', function () {
    return _$$_REQUIRE(_dependencyMap[7]);
  });

  _$$_REQUIRE(_dependencyMap[0]).polyfillGlobal('URL', function () {
    return _$$_REQUIRE(_dependencyMap[8]).URL;
  });

  _$$_REQUIRE(_dependencyMap[0]).polyfillGlobal('URLSearchParams', function () {
    return _$$_REQUIRE(_dependencyMap[8]).URLSearchParams;
  });

  _$$_REQUIRE(_dependencyMap[0]).polyfillGlobal('AbortController', function () {
    return _$$_REQUIRE(_dependencyMap[9]).AbortController;
  });

  _$$_REQUIRE(_dependencyMap[0]).polyfillGlobal('AbortSignal', function () {
    return _$$_REQUIRE(_dependencyMap[9]).AbortSignal;
  });
},"node_modules/react-native/Libraries/Core/setUpXHR.js",["node_modules/react-native/Libraries/Utilities/PolyfillFunctions.js","node_modules/react-native/Libraries/Network/XMLHttpRequest.js","node_modules/react-native/Libraries/Network/FormData.js","node_modules/react-native/Libraries/Network/fetch.js","node_modules/react-native/Libraries/WebSocket/WebSocket.js","node_modules/react-native/Libraries/Blob/Blob.js","node_modules/react-native/Libraries/Blob/File.js","node_modules/react-native/Libraries/Blob/FileReader.js","node_modules/react-native/Libraries/Blob/URL.js","node_modules/abort-controller/dist/abort-controller.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _get2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var DEBUG_NETWORK_SEND_DELAY = false;

  if (_$$_REQUIRE(_dependencyMap[8]).isAvailable) {
    _$$_REQUIRE(_dependencyMap[8]).addNetworkingHandler();
  }

  var UNSENT = 0;
  var OPENED = 1;
  var HEADERS_RECEIVED = 2;
  var LOADING = 3;
  var DONE = 4;
  var SUPPORTED_RESPONSE_TYPES = {
    arraybuffer: typeof global.ArrayBuffer === 'function',
    blob: typeof global.Blob === 'function',
    document: false,
    json: true,
    text: true,
    '': true
  };
  var REQUEST_EVENTS = ['abort', 'error', 'load', 'loadstart', 'progress', 'timeout', 'loadend'];
  var XHR_EVENTS = REQUEST_EVENTS.concat('readystatechange');

  var XMLHttpRequestEventTarget = function (_ref) {
    (0, _inherits2.default)(XMLHttpRequestEventTarget, _ref);

    var _super = _createSuper(XMLHttpRequestEventTarget);

    function XMLHttpRequestEventTarget() {
      (0, _classCallCheck2.default)(this, XMLHttpRequestEventTarget);
      return _super.apply(this, arguments);
    }

    return (0, _createClass2.default)(XMLHttpRequestEventTarget);
  }(_$$_REQUIRE(_dependencyMap[9]).apply(undefined, REQUEST_EVENTS));

  var XMLHttpRequest = function (_ref2) {
    (0, _inherits2.default)(XMLHttpRequest, _ref2);

    var _super2 = _createSuper(XMLHttpRequest);

    function XMLHttpRequest() {
      var _this;

      (0, _classCallCheck2.default)(this, XMLHttpRequest);
      _this = _super2.call(this);
      _this.UNSENT = UNSENT;
      _this.OPENED = OPENED;
      _this.HEADERS_RECEIVED = HEADERS_RECEIVED;
      _this.LOADING = LOADING;
      _this.DONE = DONE;
      _this.readyState = UNSENT;
      _this.status = 0;
      _this.timeout = 0;
      _this.withCredentials = true;
      _this.upload = new XMLHttpRequestEventTarget();
      _this._aborted = false;
      _this._hasError = false;
      _this._method = null;
      _this._perfKey = null;
      _this._response = '';
      _this._url = null;
      _this._timedOut = false;
      _this._trackingName = 'unknown';
      _this._incrementalEvents = false;
      _this._performanceLogger = _$$_REQUIRE(_dependencyMap[10]);

      _this._reset();

      return _this;
    }

    (0, _createClass2.default)(XMLHttpRequest, [{
      key: "_reset",
      value: function _reset() {
        this.readyState = this.UNSENT;
        this.responseHeaders = undefined;
        this.status = 0;
        delete this.responseURL;
        this._requestId = null;
        this._cachedResponse = undefined;
        this._hasError = false;
        this._headers = {};
        this._response = '';
        this._responseType = '';
        this._sent = false;
        this._lowerCaseResponseHeaders = {};

        this._clearSubscriptions();

        this._timedOut = false;
      }
    }, {
      key: "responseType",
      get: function get() {
        return this._responseType;
      },
      set: function set(responseType) {
        if (this._sent) {
          throw new Error("Failed to set the 'responseType' property on 'XMLHttpRequest': The response type cannot be set after the request has been sent.");
        }

        if (!SUPPORTED_RESPONSE_TYPES.hasOwnProperty(responseType)) {
          console.warn("The provided value '" + responseType + "' is not a valid 'responseType'.");
          return;
        }

        _$$_REQUIRE(_dependencyMap[11])(SUPPORTED_RESPONSE_TYPES[responseType] || responseType === 'document', "The provided value '" + responseType + "' is unsupported in this environment.");

        if (responseType === 'blob') {
          _$$_REQUIRE(_dependencyMap[11])(_$$_REQUIRE(_dependencyMap[8]).isAvailable, 'Native module BlobModule is required for blob support');
        }

        this._responseType = responseType;
      }
    }, {
      key: "responseText",
      get: function get() {
        if (this._responseType !== '' && this._responseType !== 'text') {
          throw new Error("The 'responseText' property is only available if 'responseType' " + ("is set to '' or 'text', but it is '" + this._responseType + "'."));
        }

        if (this.readyState < LOADING) {
          return '';
        }

        return this._response;
      }
    }, {
      key: "response",
      get: function get() {
        var responseType = this.responseType;

        if (responseType === '' || responseType === 'text') {
          return this.readyState < LOADING || this._hasError ? '' : this._response;
        }

        if (this.readyState !== DONE) {
          return null;
        }

        if (this._cachedResponse !== undefined) {
          return this._cachedResponse;
        }

        switch (responseType) {
          case 'document':
            this._cachedResponse = null;
            break;

          case 'arraybuffer':
            this._cachedResponse = _$$_REQUIRE(_dependencyMap[12]).toByteArray(this._response).buffer;
            break;

          case 'blob':
            if (typeof this._response === 'object' && this._response) {
              this._cachedResponse = _$$_REQUIRE(_dependencyMap[8]).createFromOptions(this._response);
            } else if (this._response === '') {
              this._cachedResponse = _$$_REQUIRE(_dependencyMap[8]).createFromParts([]);
            } else {
              throw new Error("Invalid response for blob: " + this._response);
            }

            break;

          case 'json':
            try {
              this._cachedResponse = JSON.parse(this._response);
            } catch (_) {
              this._cachedResponse = null;
            }

            break;

          default:
            this._cachedResponse = null;
        }

        return this._cachedResponse;
      }
    }, {
      key: "__didCreateRequest",
      value: function __didCreateRequest(requestId) {
        this._requestId = requestId;
        XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.requestSent(requestId, this._url || '', this._method || 'GET', this._headers);
      }
    }, {
      key: "__didUploadProgress",
      value: function __didUploadProgress(requestId, progress, total) {
        if (requestId === this._requestId) {
          this.upload.dispatchEvent({
            type: 'progress',
            lengthComputable: true,
            loaded: progress,
            total: total
          });
        }
      }
    }, {
      key: "__didReceiveResponse",
      value: function __didReceiveResponse(requestId, status, responseHeaders, responseURL) {
        if (requestId === this._requestId) {
          this._perfKey != null && this._performanceLogger.stopTimespan(this._perfKey);
          this.status = status;
          this.setResponseHeaders(responseHeaders);
          this.setReadyState(this.HEADERS_RECEIVED);

          if (responseURL || responseURL === '') {
            this.responseURL = responseURL;
          } else {
            delete this.responseURL;
          }

          XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.responseReceived(requestId, responseURL || this._url || '', status, responseHeaders || {});
        }
      }
    }, {
      key: "__didReceiveData",
      value: function __didReceiveData(requestId, response) {
        if (requestId !== this._requestId) {
          return;
        }

        this._response = response;
        this._cachedResponse = undefined;
        this.setReadyState(this.LOADING);
        XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.dataReceived(requestId, response);
      }
    }, {
      key: "__didReceiveIncrementalData",
      value: function __didReceiveIncrementalData(requestId, responseText, progress, total) {
        if (requestId !== this._requestId) {
          return;
        }

        if (!this._response) {
          this._response = responseText;
        } else {
          this._response += responseText;
        }

        XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.dataReceived(requestId, responseText);
        this.setReadyState(this.LOADING);

        this.__didReceiveDataProgress(requestId, progress, total);
      }
    }, {
      key: "__didReceiveDataProgress",
      value: function __didReceiveDataProgress(requestId, loaded, total) {
        if (requestId !== this._requestId) {
          return;
        }

        this.dispatchEvent({
          type: 'progress',
          lengthComputable: total >= 0,
          loaded: loaded,
          total: total
        });
      }
    }, {
      key: "__didCompleteResponse",
      value: function __didCompleteResponse(requestId, error, timeOutError) {
        if (requestId === this._requestId) {
          if (error) {
            if (this._responseType === '' || this._responseType === 'text') {
              this._response = error;
            }

            this._hasError = true;

            if (timeOutError) {
              this._timedOut = true;
            }
          }

          this._clearSubscriptions();

          this._requestId = null;
          this.setReadyState(this.DONE);

          if (error) {
            XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.loadingFailed(requestId, error);
          } else {
            XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.loadingFinished(requestId, this._response.length);
          }
        }
      }
    }, {
      key: "_clearSubscriptions",
      value: function _clearSubscriptions() {
        (this._subscriptions || []).forEach(function (sub) {
          if (sub) {
            sub.remove();
          }
        });
        this._subscriptions = [];
      }
    }, {
      key: "getAllResponseHeaders",
      value: function getAllResponseHeaders() {
        if (!this.responseHeaders) {
          return null;
        }

        var responseHeaders = this.responseHeaders;
        var unsortedHeaders = new Map();

        for (var _i = 0, _Object$keys = Object.keys(responseHeaders); _i < _Object$keys.length; _i++) {
          var rawHeaderName = _Object$keys[_i];
          var headerValue = responseHeaders[rawHeaderName];
          var lowerHeaderName = rawHeaderName.toLowerCase();
          var header = unsortedHeaders.get(lowerHeaderName);

          if (header) {
            header.headerValue += ', ' + headerValue;
            unsortedHeaders.set(lowerHeaderName, header);
          } else {
            unsortedHeaders.set(lowerHeaderName, {
              lowerHeaderName: lowerHeaderName,
              upperHeaderName: rawHeaderName.toUpperCase(),
              headerValue: headerValue
            });
          }
        }

        var sortedHeaders = (0, _toConsumableArray2.default)(unsortedHeaders.values()).sort(function (a, b) {
          if (a.upperHeaderName < b.upperHeaderName) {
            return -1;
          }

          if (a.upperHeaderName > b.upperHeaderName) {
            return 1;
          }

          return 0;
        });
        return sortedHeaders.map(function (header) {
          return header.lowerHeaderName + ': ' + header.headerValue;
        }).join('\r\n') + '\r\n';
      }
    }, {
      key: "getResponseHeader",
      value: function getResponseHeader(header) {
        var value = this._lowerCaseResponseHeaders[header.toLowerCase()];

        return value !== undefined ? value : null;
      }
    }, {
      key: "setRequestHeader",
      value: function setRequestHeader(header, value) {
        if (this.readyState !== this.OPENED) {
          throw new Error('Request has not been opened');
        }

        this._headers[header.toLowerCase()] = String(value);
      }
    }, {
      key: "setTrackingName",
      value: function setTrackingName(trackingName) {
        this._trackingName = trackingName;
        return this;
      }
    }, {
      key: "setPerformanceLogger",
      value: function setPerformanceLogger(performanceLogger) {
        this._performanceLogger = performanceLogger;
        return this;
      }
    }, {
      key: "open",
      value: function open(method, url, async) {
        if (this.readyState !== this.UNSENT) {
          throw new Error('Cannot open, already sending');
        }

        if (async !== undefined && !async) {
          throw new Error('Synchronous http requests are not supported');
        }

        if (!url) {
          throw new Error('Cannot load an empty url');
        }

        this._method = method.toUpperCase();
        this._url = url;
        this._aborted = false;
        this.setReadyState(this.OPENED);
      }
    }, {
      key: "send",
      value: function send(data) {
        var _this2 = this;

        if (this.readyState !== this.OPENED) {
          throw new Error('Request has not been opened');
        }

        if (this._sent) {
          throw new Error('Request has already been sent');
        }

        this._sent = true;
        var incrementalEvents = this._incrementalEvents || !!this.onreadystatechange || !!this.onprogress;

        this._subscriptions.push(_$$_REQUIRE(_dependencyMap[13]).addListener('didSendNetworkData', function (args) {
          return _this2.__didUploadProgress.apply(_this2, (0, _toConsumableArray2.default)(args));
        }));

        this._subscriptions.push(_$$_REQUIRE(_dependencyMap[13]).addListener('didReceiveNetworkResponse', function (args) {
          return _this2.__didReceiveResponse.apply(_this2, (0, _toConsumableArray2.default)(args));
        }));

        this._subscriptions.push(_$$_REQUIRE(_dependencyMap[13]).addListener('didReceiveNetworkData', function (args) {
          return _this2.__didReceiveData.apply(_this2, (0, _toConsumableArray2.default)(args));
        }));

        this._subscriptions.push(_$$_REQUIRE(_dependencyMap[13]).addListener('didReceiveNetworkIncrementalData', function (args) {
          return _this2.__didReceiveIncrementalData.apply(_this2, (0, _toConsumableArray2.default)(args));
        }));

        this._subscriptions.push(_$$_REQUIRE(_dependencyMap[13]).addListener('didReceiveNetworkDataProgress', function (args) {
          return _this2.__didReceiveDataProgress.apply(_this2, (0, _toConsumableArray2.default)(args));
        }));

        this._subscriptions.push(_$$_REQUIRE(_dependencyMap[13]).addListener('didCompleteNetworkResponse', function (args) {
          return _this2.__didCompleteResponse.apply(_this2, (0, _toConsumableArray2.default)(args));
        }));

        var nativeResponseType = 'text';

        if (this._responseType === 'arraybuffer') {
          nativeResponseType = 'base64';
        }

        if (this._responseType === 'blob') {
          nativeResponseType = 'blob';
        }

        var doSend = function doSend() {
          var friendlyName = _this2._trackingName !== 'unknown' ? _this2._trackingName : _this2._url;
          _this2._perfKey = 'network_XMLHttpRequest_' + String(friendlyName);

          _this2._performanceLogger.startTimespan(_this2._perfKey);

          _$$_REQUIRE(_dependencyMap[11])(_this2._method, 'XMLHttpRequest method needs to be defined (%s).', friendlyName);

          _$$_REQUIRE(_dependencyMap[11])(_this2._url, 'XMLHttpRequest URL needs to be defined (%s).', friendlyName);

          _$$_REQUIRE(_dependencyMap[13]).sendRequest(_this2._method, _this2._trackingName, _this2._url, _this2._headers, data, nativeResponseType, incrementalEvents, _this2.timeout, _this2.__didCreateRequest.bind(_this2), _this2.withCredentials);
        };

        {
          doSend();
        }
      }
    }, {
      key: "abort",
      value: function abort() {
        this._aborted = true;

        if (this._requestId) {
          _$$_REQUIRE(_dependencyMap[13]).abortRequest(this._requestId);
        }

        if (!(this.readyState === this.UNSENT || this.readyState === this.OPENED && !this._sent || this.readyState === this.DONE)) {
          this._reset();

          this.setReadyState(this.DONE);
        }

        this._reset();
      }
    }, {
      key: "setResponseHeaders",
      value: function setResponseHeaders(responseHeaders) {
        this.responseHeaders = responseHeaders || null;
        var headers = responseHeaders || {};
        this._lowerCaseResponseHeaders = Object.keys(headers).reduce(function (lcaseHeaders, headerName) {
          lcaseHeaders[headerName.toLowerCase()] = headers[headerName];
          return lcaseHeaders;
        }, {});
      }
    }, {
      key: "setReadyState",
      value: function setReadyState(newState) {
        this.readyState = newState;
        this.dispatchEvent({
          type: 'readystatechange'
        });

        if (newState === this.DONE) {
          if (this._aborted) {
            this.dispatchEvent({
              type: 'abort'
            });
          } else if (this._hasError) {
            if (this._timedOut) {
              this.dispatchEvent({
                type: 'timeout'
              });
            } else {
              this.dispatchEvent({
                type: 'error'
              });
            }
          } else {
            this.dispatchEvent({
              type: 'load'
            });
          }

          this.dispatchEvent({
            type: 'loadend'
          });
        }
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener) {
        if (type === 'readystatechange' || type === 'progress') {
          this._incrementalEvents = true;
        }

        (0, _get2.default)((0, _getPrototypeOf2.default)(XMLHttpRequest.prototype), "addEventListener", this).call(this, type, listener);
      }
    }], [{
      key: "setInterceptor",
      value: function setInterceptor(interceptor) {
        XMLHttpRequest._interceptor = interceptor;
      }
    }]);
    return XMLHttpRequest;
  }(_$$_REQUIRE(_dependencyMap[9]).apply(undefined, (0, _toConsumableArray2.default)(XHR_EVENTS)));

  XMLHttpRequest.UNSENT = UNSENT;
  XMLHttpRequest.OPENED = OPENED;
  XMLHttpRequest.HEADERS_RECEIVED = HEADERS_RECEIVED;
  XMLHttpRequest.LOADING = LOADING;
  XMLHttpRequest.DONE = DONE;
  XMLHttpRequest._interceptor = null;
  module.exports = XMLHttpRequest;
},"node_modules/react-native/Libraries/Network/XMLHttpRequest.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/@babel/runtime/helpers/get.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Blob/BlobManager.js","node_modules/event-target-shim/dist/event-target-shim.js","node_modules/react-native/Libraries/Utilities/GlobalPerformanceLogger.js","node_modules/invariant/browser.js","node_modules/base64-js/index.js","node_modules/react-native/Libraries/Network/RCTNetworking.ios.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      module.exports = _get = Reflect.get, module.exports.__esModule = true, module.exports["default"] = module.exports;
    } else {
      module.exports = _get = function _get(target, property, receiver) {
        var base = _$$_REQUIRE(_dependencyMap[0])(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }

    return _get.apply(this, arguments);
  }

  module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/get.js",["node_modules/@babel/runtime/helpers/superPropBase.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _$$_REQUIRE(_dependencyMap[0])(object);
      if (object === null) break;
    }

    return object;
  }

  module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/superPropBase.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _NativeBlobModule = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
          v = c == 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  }

  function createBlobCollector(blobId) {
    if (global.__blobCollectorProvider == null) {
      return null;
    } else {
      return global.__blobCollectorProvider(blobId);
    }
  }

  var BlobManager = function () {
    function BlobManager() {
      (0, _classCallCheck2.default)(this, BlobManager);
    }

    (0, _createClass2.default)(BlobManager, null, [{
      key: "createFromParts",
      value: function createFromParts(parts, options) {
        (0, _invariant.default)(_NativeBlobModule.default, 'NativeBlobModule is available.');
        var blobId = uuidv4();
        var items = parts.map(function (part) {
          if (part instanceof ArrayBuffer || global.ArrayBufferView && part instanceof global.ArrayBufferView) {
            throw new Error("Creating blobs from 'ArrayBuffer' and 'ArrayBufferView' are not supported");
          }

          if (part instanceof _$$_REQUIRE(_dependencyMap[6])) {
            return {
              data: part.data,
              type: 'blob'
            };
          } else {
            return {
              data: String(part),
              type: 'string'
            };
          }
        });
        var size = items.reduce(function (acc, curr) {
          if (curr.type === 'string') {
            return acc + global.unescape(encodeURI(curr.data)).length;
          } else {
            return acc + curr.data.size;
          }
        }, 0);

        _NativeBlobModule.default.createFromParts(items, blobId);

        return BlobManager.createFromOptions({
          blobId: blobId,
          offset: 0,
          size: size,
          type: options ? options.type : '',
          lastModified: options ? options.lastModified : Date.now()
        });
      }
    }, {
      key: "createFromOptions",
      value: function createFromOptions(options) {
        _$$_REQUIRE(_dependencyMap[7]).register(options.blobId);

        return (0, _extends2.default)(Object.create(_$$_REQUIRE(_dependencyMap[6]).prototype), {
          data: options.__collector == null ? (0, _extends2.default)({}, options, {
            __collector: createBlobCollector(options.blobId)
          }) : options
        });
      }
    }, {
      key: "release",
      value: function release(blobId) {
        (0, _invariant.default)(_NativeBlobModule.default, 'NativeBlobModule is available.');

        _$$_REQUIRE(_dependencyMap[7]).unregister(blobId);

        if (_$$_REQUIRE(_dependencyMap[7]).has(blobId)) {
          return;
        }

        _NativeBlobModule.default.release(blobId);
      }
    }, {
      key: "addNetworkingHandler",
      value: function addNetworkingHandler() {
        (0, _invariant.default)(_NativeBlobModule.default, 'NativeBlobModule is available.');

        _NativeBlobModule.default.addNetworkingHandler();
      }
    }, {
      key: "addWebSocketHandler",
      value: function addWebSocketHandler(socketId) {
        (0, _invariant.default)(_NativeBlobModule.default, 'NativeBlobModule is available.');

        _NativeBlobModule.default.addWebSocketHandler(socketId);
      }
    }, {
      key: "removeWebSocketHandler",
      value: function removeWebSocketHandler(socketId) {
        (0, _invariant.default)(_NativeBlobModule.default, 'NativeBlobModule is available.');

        _NativeBlobModule.default.removeWebSocketHandler(socketId);
      }
    }, {
      key: "sendOverSocket",
      value: function sendOverSocket(blob, socketId) {
        (0, _invariant.default)(_NativeBlobModule.default, 'NativeBlobModule is available.');

        _NativeBlobModule.default.sendOverSocket(blob.data, socketId);
      }
    }]);
    return BlobManager;
  }();

  BlobManager.isAvailable = !!_NativeBlobModule.default;
  module.exports = BlobManager;
},"node_modules/react-native/Libraries/Blob/BlobManager.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Blob/NativeBlobModule.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/Blob/Blob.js","node_modules/react-native/Libraries/Blob/BlobRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var NativeModule = TurboModuleRegistry.get('BlobModule');
  var constants = null;
  var NativeBlobModule = null;

  if (NativeModule != null) {
    NativeBlobModule = {
      getConstants: function getConstants() {
        if (constants == null) {
          constants = NativeModule.getConstants();
        }

        return constants;
      },
      addNetworkingHandler: function addNetworkingHandler() {
        NativeModule.addNetworkingHandler();
      },
      addWebSocketHandler: function addWebSocketHandler(id) {
        NativeModule.addWebSocketHandler(id);
      },
      removeWebSocketHandler: function removeWebSocketHandler(id) {
        NativeModule.removeWebSocketHandler(id);
      },
      sendOverSocket: function sendOverSocket(blob, socketID) {
        NativeModule.sendOverSocket(blob, socketID);
      },
      createFromParts: function createFromParts(parts, withId) {
        NativeModule.createFromParts(parts, withId);
      },
      release: function release(blobId) {
        NativeModule.release(blobId);
      }
    };
  }

  var _default = NativeBlobModule;
  exports.default = _default;
},"node_modules/react-native/Libraries/Blob/NativeBlobModule.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Blob = function () {
    function Blob() {
      var parts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 ? arguments[1] : undefined;

      _$$_REQUIRE(_dependencyMap[0])(this, Blob);

      var BlobManager = _$$_REQUIRE(_dependencyMap[1]);

      this.data = BlobManager.createFromParts(parts, options).data;
    }

    _$$_REQUIRE(_dependencyMap[2])(Blob, [{
      key: "data",
      get: function get() {
        if (!this._data) {
          throw new Error('Blob has been closed and is no longer available');
        }

        return this._data;
      },
      set: function set(data) {
        this._data = data;
      }
    }, {
      key: "slice",
      value: function slice(start, end) {
        var BlobManager = _$$_REQUIRE(_dependencyMap[1]);

        var _this$data = this.data,
            offset = _this$data.offset,
            size = _this$data.size;

        if (typeof start === 'number') {
          if (start > size) {
            start = size;
          }

          offset += start;
          size -= start;

          if (typeof end === 'number') {
            if (end < 0) {
              end = this.size + end;
            }

            size = end - start;
          }
        }

        return BlobManager.createFromOptions({
          blobId: this.data.blobId,
          offset: offset,
          size: size
        });
      }
    }, {
      key: "close",
      value: function close() {
        var BlobManager = _$$_REQUIRE(_dependencyMap[1]);

        BlobManager.release(this.data.blobId);
        this.data = null;
      }
    }, {
      key: "size",
      get: function get() {
        return this.data.size;
      }
    }, {
      key: "type",
      get: function get() {
        return this.data.type || '';
      }
    }]);

    return Blob;
  }();

  module.exports = Blob;
},"node_modules/react-native/Libraries/Blob/Blob.js",["node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/react-native/Libraries/Blob/BlobManager.js","node_modules/@babel/runtime/helpers/createClass.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var registry = {};

  var register = function register(id) {
    if (registry[id]) {
      registry[id]++;
    } else {
      registry[id] = 1;
    }
  };

  var unregister = function unregister(id) {
    if (registry[id]) {
      registry[id]--;

      if (registry[id] <= 0) {
        delete registry[id];
      }
    }
  };

  var has = function has(id) {
    return registry[id] && registry[id] > 0;
  };

  module.exports = {
    register: register,
    unregister: unregister,
    has: has
  };
},"node_modules/react-native/Libraries/Blob/BlobRegistry.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  var privateData = new WeakMap();
  var wrappers = new WeakMap();

  function pd(event) {
    var retv = privateData.get(event);
    console.assert(retv != null, "'this' is expected an Event object, but got", event);
    return retv;
  }

  function setCancelFlag(data) {
    if (data.passiveListener != null) {
      if (typeof console !== "undefined" && typeof console.error === "function") {
        console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
      }

      return;
    }

    if (!data.event.cancelable) {
      return;
    }

    data.canceled = true;

    if (typeof data.event.preventDefault === "function") {
      data.event.preventDefault();
    }
  }

  function Event(eventTarget, event) {
    privateData.set(this, {
      eventTarget: eventTarget,
      event: event,
      eventPhase: 2,
      currentTarget: eventTarget,
      canceled: false,
      stopped: false,
      immediateStopped: false,
      passiveListener: null,
      timeStamp: event.timeStamp || Date.now()
    });
    Object.defineProperty(this, "isTrusted", {
      value: false,
      enumerable: true
    });
    var keys = Object.keys(event);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!(key in this)) {
        Object.defineProperty(this, key, defineRedirectDescriptor(key));
      }
    }
  }

  Event.prototype = {
    get type() {
      return pd(this).event.type;
    },

    get target() {
      return pd(this).eventTarget;
    },

    get currentTarget() {
      return pd(this).currentTarget;
    },

    composedPath: function composedPath() {
      var currentTarget = pd(this).currentTarget;

      if (currentTarget == null) {
        return [];
      }

      return [currentTarget];
    },

    get NONE() {
      return 0;
    },

    get CAPTURING_PHASE() {
      return 1;
    },

    get AT_TARGET() {
      return 2;
    },

    get BUBBLING_PHASE() {
      return 3;
    },

    get eventPhase() {
      return pd(this).eventPhase;
    },

    stopPropagation: function stopPropagation() {
      var data = pd(this);
      data.stopped = true;

      if (typeof data.event.stopPropagation === "function") {
        data.event.stopPropagation();
      }
    },
    stopImmediatePropagation: function stopImmediatePropagation() {
      var data = pd(this);
      data.stopped = true;
      data.immediateStopped = true;

      if (typeof data.event.stopImmediatePropagation === "function") {
        data.event.stopImmediatePropagation();
      }
    },

    get bubbles() {
      return Boolean(pd(this).event.bubbles);
    },

    get cancelable() {
      return Boolean(pd(this).event.cancelable);
    },

    preventDefault: function preventDefault() {
      setCancelFlag(pd(this));
    },

    get defaultPrevented() {
      return pd(this).canceled;
    },

    get composed() {
      return Boolean(pd(this).event.composed);
    },

    get timeStamp() {
      return pd(this).timeStamp;
    },

    get srcElement() {
      return pd(this).eventTarget;
    },

    get cancelBubble() {
      return pd(this).stopped;
    },

    set cancelBubble(value) {
      if (!value) {
        return;
      }

      var data = pd(this);
      data.stopped = true;

      if (typeof data.event.cancelBubble === "boolean") {
        data.event.cancelBubble = true;
      }
    },

    get returnValue() {
      return !pd(this).canceled;
    },

    set returnValue(value) {
      if (!value) {
        setCancelFlag(pd(this));
      }
    },

    initEvent: function initEvent() {}
  };
  Object.defineProperty(Event.prototype, "constructor", {
    value: Event,
    configurable: true,
    writable: true
  });

  if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event.prototype, window.Event.prototype);
    wrappers.set(window.Event.prototype, Event);
  }

  function defineRedirectDescriptor(key) {
    return {
      get: function get() {
        return pd(this).event[key];
      },
      set: function set(value) {
        pd(this).event[key] = value;
      },
      configurable: true,
      enumerable: true
    };
  }

  function defineCallDescriptor(key) {
    return {
      value: function value() {
        var event = pd(this).event;
        return event[key].apply(event, arguments);
      },
      configurable: true,
      enumerable: true
    };
  }

  function defineWrapper(BaseEvent, proto) {
    var keys = Object.keys(proto);

    if (keys.length === 0) {
      return BaseEvent;
    }

    function CustomEvent(eventTarget, event) {
      BaseEvent.call(this, eventTarget, event);
    }

    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
      constructor: {
        value: CustomEvent,
        configurable: true,
        writable: true
      }
    });

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!(key in BaseEvent.prototype)) {
        var descriptor = Object.getOwnPropertyDescriptor(proto, key);
        var isFunc = typeof descriptor.value === "function";
        Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
      }
    }

    return CustomEvent;
  }

  function getWrapper(proto) {
    if (proto == null || proto === Object.prototype) {
      return Event;
    }

    var wrapper = wrappers.get(proto);

    if (wrapper == null) {
      wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
      wrappers.set(proto, wrapper);
    }

    return wrapper;
  }

  function wrapEvent(eventTarget, event) {
    var Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event);
  }

  function isStopped(event) {
    return pd(event).immediateStopped;
  }

  function setEventPhase(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
  }

  function setCurrentTarget(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
  }

  function setPassiveListener(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
  }

  var listenersMap = new WeakMap();
  var CAPTURE = 1;
  var BUBBLE = 2;
  var ATTRIBUTE = 3;

  function isObject(x) {
    return x !== null && typeof x === "object";
  }

  function getListeners(eventTarget) {
    var listeners = listenersMap.get(eventTarget);

    if (listeners == null) {
      throw new TypeError("'this' is expected an EventTarget object, but got another value.");
    }

    return listeners;
  }

  function defineEventAttributeDescriptor(eventName) {
    return {
      get: function get() {
        var listeners = getListeners(this);
        var node = listeners.get(eventName);

        while (node != null) {
          if (node.listenerType === ATTRIBUTE) {
            return node.listener;
          }

          node = node.next;
        }

        return null;
      },
      set: function set(listener) {
        if (typeof listener !== "function" && !isObject(listener)) {
          listener = null;
        }

        var listeners = getListeners(this);
        var prev = null;
        var node = listeners.get(eventName);

        while (node != null) {
          if (node.listenerType === ATTRIBUTE) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }

          node = node.next;
        }

        if (listener !== null) {
          var newNode = {
            listener: listener,
            listenerType: ATTRIBUTE,
            passive: false,
            once: false,
            next: null
          };

          if (prev === null) {
            listeners.set(eventName, newNode);
          } else {
            prev.next = newNode;
          }
        }
      },
      configurable: true,
      enumerable: true
    };
  }

  function defineEventAttribute(eventTargetPrototype, eventName) {
    Object.defineProperty(eventTargetPrototype, "on" + eventName, defineEventAttributeDescriptor(eventName));
  }

  function defineCustomEventTarget(eventNames) {
    function CustomEventTarget() {
      EventTarget.call(this);
    }

    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
      constructor: {
        value: CustomEventTarget,
        configurable: true,
        writable: true
      }
    });

    for (var i = 0; i < eventNames.length; ++i) {
      defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
    }

    return CustomEventTarget;
  }

  function EventTarget() {
    if (this instanceof EventTarget) {
      listenersMap.set(this, new Map());
      return;
    }

    if (arguments.length === 1 && Array.isArray(arguments[0])) {
      return defineCustomEventTarget(arguments[0]);
    }

    if (arguments.length > 0) {
      var types = new Array(arguments.length);

      for (var i = 0; i < arguments.length; ++i) {
        types[i] = arguments[i];
      }

      return defineCustomEventTarget(types);
    }

    throw new TypeError("Cannot call a class as a function");
  }

  EventTarget.prototype = {
    addEventListener: function addEventListener(eventName, listener, options) {
      if (listener == null) {
        return;
      }

      if (typeof listener !== "function" && !isObject(listener)) {
        throw new TypeError("'listener' should be a function or an object.");
      }

      var listeners = getListeners(this);
      var optionsIsObj = isObject(options);
      var capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
      var listenerType = capture ? CAPTURE : BUBBLE;
      var newNode = {
        listener: listener,
        listenerType: listenerType,
        passive: optionsIsObj && Boolean(options.passive),
        once: optionsIsObj && Boolean(options.once),
        next: null
      };
      var node = listeners.get(eventName);

      if (node === undefined) {
        listeners.set(eventName, newNode);
        return;
      }

      var prev = null;

      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          return;
        }

        prev = node;
        node = node.next;
      }

      prev.next = newNode;
    },
    removeEventListener: function removeEventListener(eventName, listener, options) {
      if (listener == null) {
        return;
      }

      var listeners = getListeners(this);
      var capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
      var listenerType = capture ? CAPTURE : BUBBLE;
      var prev = null;
      var node = listeners.get(eventName);

      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }

          return;
        }

        prev = node;
        node = node.next;
      }
    },
    dispatchEvent: function dispatchEvent(event) {
      if (event == null || typeof event.type !== "string") {
        throw new TypeError('"event.type" should be a string.');
      }

      var listeners = getListeners(this);
      var eventName = event.type;
      var node = listeners.get(eventName);

      if (node == null) {
        return true;
      }

      var wrappedEvent = wrapEvent(this, event);
      var prev = null;

      while (node != null) {
        if (node.once) {
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
        } else {
          prev = node;
        }

        setPassiveListener(wrappedEvent, node.passive ? node.listener : null);

        if (typeof node.listener === "function") {
          try {
            node.listener.call(this, wrappedEvent);
          } catch (err) {
            if (typeof console !== "undefined" && typeof console.error === "function") {
              console.error(err);
            }
          }
        } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
          node.listener.handleEvent(wrappedEvent);
        }

        if (isStopped(wrappedEvent)) {
          break;
        }

        node = node.next;
      }

      setPassiveListener(wrappedEvent, null);
      setEventPhase(wrappedEvent, 0);
      setCurrentTarget(wrappedEvent, null);
      return !wrappedEvent.defaultPrevented;
    }
  };
  Object.defineProperty(EventTarget.prototype, "constructor", {
    value: EventTarget,
    configurable: true,
    writable: true
  });

  if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
  }

  exports.defineEventAttribute = defineEventAttribute;
  exports.EventTarget = EventTarget;
  exports.default = EventTarget;
  module.exports = EventTarget;
  module.exports.EventTarget = module.exports["default"] = EventTarget;
  module.exports.defineEventAttribute = defineEventAttribute;
},"node_modules/event-target-shim/dist/event-target-shim.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _createPerformanceLogger = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var GlobalPerformanceLogger = (0, _createPerformanceLogger.default)();
  module.exports = GlobalPerformanceLogger;
},"node_modules/react-native/Libraries/Utilities/GlobalPerformanceLogger.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/createPerformanceLogger.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createPerformanceLogger;
  exports.getCurrentTimestamp = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _global$nativeQPLTime;

  var _cookies = {};
  var PRINT_TO_CONSOLE = false;
  var getCurrentTimestamp = (_global$nativeQPLTime = global.nativeQPLTimestamp) != null ? _global$nativeQPLTime : global.performance.now.bind(global.performance);
  exports.getCurrentTimestamp = getCurrentTimestamp;

  var PerformanceLogger = function () {
    function PerformanceLogger() {
      (0, _classCallCheck2.default)(this, PerformanceLogger);
      this._timespans = {};
      this._extras = {};
      this._points = {};
      this._pointExtras = {};
      this._closed = false;
    }

    (0, _createClass2.default)(PerformanceLogger, [{
      key: "addTimespan",
      value: function addTimespan(key, startTime, endTime, startExtras, endExtras) {
        if (this._closed) {
          return;
        }

        if (this._timespans[key]) {
          return;
        }

        this._timespans[key] = {
          startTime: startTime,
          endTime: endTime,
          totalTime: endTime - (startTime || 0),
          startExtras: startExtras,
          endExtras: endExtras
        };
      }
    }, {
      key: "append",
      value: function append(performanceLogger) {
        this._timespans = (0, _extends2.default)({}, performanceLogger.getTimespans(), this._timespans);
        this._extras = (0, _extends2.default)({}, performanceLogger.getExtras(), this._extras);
        this._points = (0, _extends2.default)({}, performanceLogger.getPoints(), this._points);
        this._pointExtras = (0, _extends2.default)({}, performanceLogger.getPointExtras(), this._pointExtras);
      }
    }, {
      key: "clear",
      value: function clear() {
        this._timespans = {};
        this._extras = {};
        this._points = {};
      }
    }, {
      key: "clearCompleted",
      value: function clearCompleted() {
        for (var _key in this._timespans) {
          var _this$_timespans$_key;

          if (((_this$_timespans$_key = this._timespans[_key]) == null ? undefined : _this$_timespans$_key.totalTime) != null) {
            delete this._timespans[_key];
          }
        }

        this._extras = {};
        this._points = {};
      }
    }, {
      key: "close",
      value: function close() {
        this._closed = true;
      }
    }, {
      key: "currentTimestamp",
      value: function currentTimestamp() {
        return getCurrentTimestamp();
      }
    }, {
      key: "getExtras",
      value: function getExtras() {
        return this._extras;
      }
    }, {
      key: "getPoints",
      value: function getPoints() {
        return this._points;
      }
    }, {
      key: "getPointExtras",
      value: function getPointExtras() {
        return this._pointExtras;
      }
    }, {
      key: "getTimespans",
      value: function getTimespans() {
        return this._timespans;
      }
    }, {
      key: "hasTimespan",
      value: function hasTimespan(key) {
        return !!this._timespans[key];
      }
    }, {
      key: "isClosed",
      value: function isClosed() {
        return this._closed;
      }
    }, {
      key: "logEverything",
      value: function logEverything() {}
    }, {
      key: "markPoint",
      value: function markPoint(key) {
        var timestamp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getCurrentTimestamp();
        var extras = arguments.length > 2 ? arguments[2] : undefined;

        if (this._closed) {
          return;
        }

        if (this._points[key] != null) {
          return;
        }

        this._points[key] = timestamp;

        if (extras) {
          this._pointExtras[key] = extras;
        }
      }
    }, {
      key: "removeExtra",
      value: function removeExtra(key) {
        var value = this._extras[key];
        delete this._extras[key];
        return value;
      }
    }, {
      key: "setExtra",
      value: function setExtra(key, value) {
        if (this._closed) {
          return;
        }

        if (this._extras.hasOwnProperty(key)) {
          return;
        }

        this._extras[key] = value;
      }
    }, {
      key: "startTimespan",
      value: function startTimespan(key) {
        var timestamp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getCurrentTimestamp();
        var extras = arguments.length > 2 ? arguments[2] : undefined;

        if (this._closed) {
          return;
        }

        if (this._timespans[key]) {
          return;
        }

        this._timespans[key] = {
          startTime: timestamp,
          startExtras: extras
        };
        _cookies[key] = _$$_REQUIRE(_dependencyMap[4]).beginAsyncEvent(key);
      }
    }, {
      key: "stopTimespan",
      value: function stopTimespan(key) {
        var timestamp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getCurrentTimestamp();
        var extras = arguments.length > 2 ? arguments[2] : undefined;

        if (this._closed) {
          return;
        }

        var timespan = this._timespans[key];

        if (!timespan || timespan.startTime == null) {
          return;
        }

        if (timespan.endTime != null) {
          return;
        }

        timespan.endExtras = extras;
        timespan.endTime = timestamp;
        timespan.totalTime = timespan.endTime - (timespan.startTime || 0);

        if (_cookies[key] != null) {
          _$$_REQUIRE(_dependencyMap[4]).endAsyncEvent(key, _cookies[key]);

          delete _cookies[key];
        }
      }
    }]);
    return PerformanceLogger;
  }();

  function createPerformanceLogger() {
    return new PerformanceLogger();
  }
},"node_modules/react-native/Libraries/Utilities/createPerformanceLogger.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Performance/Systrace.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  exports.byteLength = byteLength;
  exports.toByteArray = toByteArray;
  exports.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;

  function getLens(b64) {
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    }

    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }

  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;

    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 0xFF;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];

    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
      output.push(tripletToBase64(tmp));
    }

    return output.join('');
  }

  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var parts = [];
    var maxChunkLength = 16383;

    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }

    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }

    return parts.join('');
  }
},"node_modules/base64-js/index.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _RCTDeviceEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _NativeNetworkingIOS = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _convertRequestBody = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var RCTNetworking = {
    addListener: function addListener(eventType, listener, context) {
      return _RCTDeviceEventEmitter.default.addListener(eventType, listener, context);
    },
    sendRequest: function sendRequest(method, trackingName, url, headers, data, responseType, incrementalUpdates, timeout, callback, withCredentials) {
      var body = (0, _convertRequestBody.default)(data);

      _NativeNetworkingIOS.default.sendRequest({
        method: method,
        url: url,
        data: (0, _extends2.default)({}, body, {
          trackingName: trackingName
        }),
        headers: headers,
        responseType: responseType,
        incrementalUpdates: incrementalUpdates,
        timeout: timeout,
        withCredentials: withCredentials
      }, callback);
    },
    abortRequest: function abortRequest(requestId) {
      _NativeNetworkingIOS.default.abortRequest(requestId);
    },
    clearCookies: function clearCookies(callback) {
      _NativeNetworkingIOS.default.clearCookies(callback);
    }
  };
  module.exports = RCTNetworking;
},"node_modules/react-native/Libraries/Network/RCTNetworking.ios.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/EventEmitter/RCTDeviceEventEmitter.js","node_modules/react-native/Libraries/Network/NativeNetworkingIOS.js","node_modules/react-native/Libraries/Network/convertRequestBody.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.getEnforcing('Networking');

  exports.default = _default;
},"node_modules/react-native/Libraries/Network/NativeNetworkingIOS.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function convertRequestBody(body) {
    if (typeof body === 'string') {
      return {
        string: body
      };
    }

    if (body instanceof _$$_REQUIRE(_dependencyMap[0])) {
      return {
        blob: body.data
      };
    }

    if (body instanceof _$$_REQUIRE(_dependencyMap[1])) {
      return {
        formData: body.getParts()
      };
    }

    if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {
      return {
        base64: _$$_REQUIRE(_dependencyMap[2])(body)
      };
    }

    return body;
  }

  module.exports = convertRequestBody;
},"node_modules/react-native/Libraries/Network/convertRequestBody.js",["node_modules/react-native/Libraries/Blob/Blob.js","node_modules/react-native/Libraries/Network/FormData.js","node_modules/react-native/Libraries/Utilities/binaryToBase64.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var FormData = function () {
    function FormData() {
      _$$_REQUIRE(_dependencyMap[0])(this, FormData);

      this._parts = [];
    }

    _$$_REQUIRE(_dependencyMap[1])(FormData, [{
      key: "append",
      value: function append(key, value) {
        this._parts.push([key, value]);
      }
    }, {
      key: "getParts",
      value: function getParts() {
        return this._parts.map(function (_ref) {
          var _ref2 = _$$_REQUIRE(_dependencyMap[2])(_ref, 2),
              name = _ref2[0],
              value = _ref2[1];

          var contentDisposition = 'form-data; name="' + name + '"';
          var headers = {
            'content-disposition': contentDisposition
          };

          if (typeof value === 'object' && value) {
            if (typeof value.name === 'string') {
              headers['content-disposition'] += '; filename="' + value.name + '"';
            }

            if (typeof value.type === 'string') {
              headers['content-type'] = value.type;
            }

            return _$$_REQUIRE(_dependencyMap[3])({}, value, {
              headers: headers,
              fieldName: name
            });
          }

          return {
            string: String(value),
            headers: headers,
            fieldName: name
          };
        });
      }
    }]);

    return FormData;
  }();

  module.exports = FormData;
},"node_modules/react-native/Libraries/Network/FormData.js",["node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/extends.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function binaryToBase64(data) {
    if (data instanceof ArrayBuffer) {
      data = new Uint8Array(data);
    }

    if (data instanceof Uint8Array) {
      return _$$_REQUIRE(_dependencyMap[0]).fromByteArray(data);
    }

    if (!ArrayBuffer.isView(data)) {
      throw new Error('data must be ArrayBuffer or typed array');
    }

    var _ref = data,
        buffer = _ref.buffer,
        byteOffset = _ref.byteOffset,
        byteLength = _ref.byteLength;
    return _$$_REQUIRE(_dependencyMap[0]).fromByteArray(new Uint8Array(buffer, byteOffset, byteLength));
  }

  module.exports = binaryToBase64;
},"node_modules/react-native/Libraries/Utilities/binaryToBase64.js",["node_modules/base64-js/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  _$$_REQUIRE(_dependencyMap[0]);

  module.exports = {
    fetch: fetch,
    Headers: Headers,
    Request: Request,
    Response: Response
  };
},"node_modules/react-native/Libraries/Network/fetch.js",["node_modules/whatwg-fetch/dist/fetch.umd.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.WHATWGFetch = {});
  })(this, function (exports) {
    'use strict';

    var global = typeof globalThis !== 'undefined' && globalThis || typeof self !== 'undefined' && self || typeof global !== 'undefined' && global;
    var support = {
      searchParams: 'URLSearchParams' in global,
      iterable: 'Symbol' in global && 'iterator' in Symbol,
      blob: 'FileReader' in global && 'Blob' in global && function () {
        try {
          new Blob();
          return true;
        } catch (e) {
          return false;
        }
      }(),
      formData: 'FormData' in global,
      arrayBuffer: 'ArrayBuffer' in global
    };

    function isDataView(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj);
    }

    if (support.arrayBuffer) {
      var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

      var isArrayBufferView = ArrayBuffer.isView || function (obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
      };
    }

    function normalizeName(name) {
      if (typeof name !== 'string') {
        name = String(name);
      }

      if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
        throw new TypeError('Invalid character in header field name: "' + name + '"');
      }

      return name.toLowerCase();
    }

    function normalizeValue(value) {
      if (typeof value !== 'string') {
        value = String(value);
      }

      return value;
    }

    function iteratorFor(items) {
      var iterator = {
        next: function next() {
          var value = items.shift();
          return {
            done: value === undefined,
            value: value
          };
        }
      };

      if (support.iterable) {
        iterator[Symbol.iterator] = function () {
          return iterator;
        };
      }

      return iterator;
    }

    function Headers(headers) {
      this.map = {};

      if (headers instanceof Headers) {
        headers.forEach(function (value, name) {
          this.append(name, value);
        }, this);
      } else if (Array.isArray(headers)) {
        headers.forEach(function (header) {
          this.append(header[0], header[1]);
        }, this);
      } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function (name) {
          this.append(name, headers[name]);
        }, this);
      }
    }

    Headers.prototype.append = function (name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var oldValue = this.map[name];
      this.map[name] = oldValue ? oldValue + ', ' + value : value;
    };

    Headers.prototype['delete'] = function (name) {
      delete this.map[normalizeName(name)];
    };

    Headers.prototype.get = function (name) {
      name = normalizeName(name);
      return this.has(name) ? this.map[name] : null;
    };

    Headers.prototype.has = function (name) {
      return this.map.hasOwnProperty(normalizeName(name));
    };

    Headers.prototype.set = function (name, value) {
      this.map[normalizeName(name)] = normalizeValue(value);
    };

    Headers.prototype.forEach = function (callback, thisArg) {
      for (var name in this.map) {
        if (this.map.hasOwnProperty(name)) {
          callback.call(thisArg, this.map[name], name, this);
        }
      }
    };

    Headers.prototype.keys = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push(name);
      });
      return iteratorFor(items);
    };

    Headers.prototype.values = function () {
      var items = [];
      this.forEach(function (value) {
        items.push(value);
      });
      return iteratorFor(items);
    };

    Headers.prototype.entries = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push([name, value]);
      });
      return iteratorFor(items);
    };

    if (support.iterable) {
      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }

    function consumed(body) {
      if (body.bodyUsed) {
        return Promise.reject(new TypeError('Already read'));
      }

      body.bodyUsed = true;
    }

    function fileReaderReady(reader) {
      return new Promise(function (resolve, reject) {
        reader.onload = function () {
          resolve(reader.result);
        };

        reader.onerror = function () {
          reject(reader.error);
        };
      });
    }

    function readBlobAsArrayBuffer(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsArrayBuffer(blob);
      return promise;
    }

    function readBlobAsText(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsText(blob);
      return promise;
    }

    function readArrayBufferAsText(buf) {
      var view = new Uint8Array(buf);
      var chars = new Array(view.length);

      for (var i = 0; i < view.length; i++) {
        chars[i] = String.fromCharCode(view[i]);
      }

      return chars.join('');
    }

    function bufferClone(buf) {
      if (buf.slice) {
        return buf.slice(0);
      } else {
        var view = new Uint8Array(buf.byteLength);
        view.set(new Uint8Array(buf));
        return view.buffer;
      }
    }

    function Body() {
      this.bodyUsed = false;

      this._initBody = function (body) {
        this.bodyUsed = this.bodyUsed;
        this._bodyInit = body;

        if (!body) {
          this._bodyText = '';
        } else if (typeof body === 'string') {
          this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
          this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
          this._bodyFormData = body;
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this._bodyText = body.toString();
        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
          this._bodyArrayBuffer = bufferClone(body.buffer);
          this._bodyInit = new Blob([this._bodyArrayBuffer]);
        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
          this._bodyArrayBuffer = bufferClone(body);
        } else {
          this._bodyText = body = Object.prototype.toString.call(body);
        }

        if (!this.headers.get('content-type')) {
          if (typeof body === 'string') {
            this.headers.set('content-type', 'text/plain;charset=UTF-8');
          } else if (this._bodyBlob && this._bodyBlob.type) {
            this.headers.set('content-type', this._bodyBlob.type);
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
          }
        }
      };

      if (support.blob) {
        this.blob = function () {
          var rejected = consumed(this);

          if (rejected) {
            return rejected;
          }

          if (this._bodyBlob) {
            return Promise.resolve(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as blob');
          } else {
            return Promise.resolve(new Blob([this._bodyText]));
          }
        };

        this.arrayBuffer = function () {
          if (this._bodyArrayBuffer) {
            var isConsumed = consumed(this);

            if (isConsumed) {
              return isConsumed;
            }

            if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
              return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
            } else {
              return Promise.resolve(this._bodyArrayBuffer);
            }
          } else {
            return this.blob().then(readBlobAsArrayBuffer);
          }
        };
      }

      this.text = function () {
        var rejected = consumed(this);

        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text');
        } else {
          return Promise.resolve(this._bodyText);
        }
      };

      if (support.formData) {
        this.formData = function () {
          return this.text().then(decode);
        };
      }

      this.json = function () {
        return this.text().then(JSON.parse);
      };

      return this;
    }

    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

    function normalizeMethod(method) {
      var upcased = method.toUpperCase();
      return methods.indexOf(upcased) > -1 ? upcased : method;
    }

    function Request(input, options) {
      if (!(this instanceof Request)) {
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
      }

      options = options || {};
      var body = options.body;

      if (input instanceof Request) {
        if (input.bodyUsed) {
          throw new TypeError('Already read');
        }

        this.url = input.url;
        this.credentials = input.credentials;

        if (!options.headers) {
          this.headers = new Headers(input.headers);
        }

        this.method = input.method;
        this.mode = input.mode;
        this.signal = input.signal;

        if (!body && input._bodyInit != null) {
          body = input._bodyInit;
          input.bodyUsed = true;
        }
      } else {
        this.url = String(input);
      }

      this.credentials = options.credentials || this.credentials || 'same-origin';

      if (options.headers || !this.headers) {
        this.headers = new Headers(options.headers);
      }

      this.method = normalizeMethod(options.method || this.method || 'GET');
      this.mode = options.mode || this.mode || null;
      this.signal = options.signal || this.signal;
      this.referrer = null;

      if ((this.method === 'GET' || this.method === 'HEAD') && body) {
        throw new TypeError('Body not allowed for GET or HEAD requests');
      }

      this._initBody(body);

      if (this.method === 'GET' || this.method === 'HEAD') {
        if (options.cache === 'no-store' || options.cache === 'no-cache') {
          var reParamSearch = /([?&])_=[^&]*/;

          if (reParamSearch.test(this.url)) {
            this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
          } else {
            var reQueryString = /\?/;
            this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
          }
        }
      }
    }

    Request.prototype.clone = function () {
      return new Request(this, {
        body: this._bodyInit
      });
    };

    function decode(body) {
      var form = new FormData();
      body.trim().split('&').forEach(function (bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
      return form;
    }

    function parseHeaders(rawHeaders) {
      var headers = new Headers();
      var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
      preProcessedHeaders.split('\r').map(function (header) {
        return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header;
      }).forEach(function (line) {
        var parts = line.split(':');
        var key = parts.shift().trim();

        if (key) {
          var value = parts.join(':').trim();
          headers.append(key, value);
        }
      });
      return headers;
    }

    Body.call(Request.prototype);

    function Response(bodyInit, options) {
      if (!(this instanceof Response)) {
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
      }

      if (!options) {
        options = {};
      }

      this.type = 'default';
      this.status = options.status === undefined ? 200 : options.status;
      this.ok = this.status >= 200 && this.status < 300;
      this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
      this.headers = new Headers(options.headers);
      this.url = options.url || '';

      this._initBody(bodyInit);
    }

    Body.call(Response.prototype);

    Response.prototype.clone = function () {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      });
    };

    Response.error = function () {
      var response = new Response(null, {
        status: 0,
        statusText: ''
      });
      response.type = 'error';
      return response;
    };

    var redirectStatuses = [301, 302, 303, 307, 308];

    Response.redirect = function (url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError('Invalid status code');
      }

      return new Response(null, {
        status: status,
        headers: {
          location: url
        }
      });
    };

    exports.DOMException = global.DOMException;

    try {
      new exports.DOMException();
    } catch (err) {
      exports.DOMException = function (message, name) {
        this.message = message;
        this.name = name;
        var error = Error(message);
        this.stack = error.stack;
      };

      exports.DOMException.prototype = Object.create(Error.prototype);
      exports.DOMException.prototype.constructor = exports.DOMException;
    }

    function fetch(input, init) {
      return new Promise(function (resolve, reject) {
        var request = new Request(input, init);

        if (request.signal && request.signal.aborted) {
          return reject(new exports.DOMException('Aborted', 'AbortError'));
        }

        var xhr = new XMLHttpRequest();

        function abortXhr() {
          xhr.abort();
        }

        xhr.onload = function () {
          var options = {
            status: xhr.status,
            statusText: xhr.statusText,
            headers: parseHeaders(xhr.getAllResponseHeaders() || '')
          };
          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
          var body = 'response' in xhr ? xhr.response : xhr.responseText;
          setTimeout(function () {
            resolve(new Response(body, options));
          }, 0);
        };

        xhr.onerror = function () {
          setTimeout(function () {
            reject(new TypeError('Network request failed'));
          }, 0);
        };

        xhr.ontimeout = function () {
          setTimeout(function () {
            reject(new TypeError('Network request failed'));
          }, 0);
        };

        xhr.onabort = function () {
          setTimeout(function () {
            reject(new exports.DOMException('Aborted', 'AbortError'));
          }, 0);
        };

        function fixUrl(url) {
          try {
            return url === '' && global.location.href ? global.location.href : url;
          } catch (e) {
            return url;
          }
        }

        xhr.open(request.method, fixUrl(request.url), true);

        if (request.credentials === 'include') {
          xhr.withCredentials = true;
        } else if (request.credentials === 'omit') {
          xhr.withCredentials = false;
        }

        if ('responseType' in xhr) {
          if (support.blob) {
            xhr.responseType = 'blob';
          } else if (support.arrayBuffer && request.headers.get('Content-Type') && request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1) {
            xhr.responseType = 'arraybuffer';
          }
        }

        if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {
          Object.getOwnPropertyNames(init.headers).forEach(function (name) {
            xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
          });
        } else {
          request.headers.forEach(function (value, name) {
            xhr.setRequestHeader(name, value);
          });
        }

        if (request.signal) {
          request.signal.addEventListener('abort', abortXhr);

          xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
              request.signal.removeEventListener('abort', abortXhr);
            }
          };
        }

        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
      });
    }

    fetch.polyfill = true;

    if (!global.fetch) {
      global.fetch = fetch;
      global.Headers = Headers;
      global.Request = Request;
      global.Response = Response;
    }

    exports.Headers = Headers;
    exports.Request = Request;
    exports.Response = Response;
    exports.fetch = fetch;
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
  });
},"node_modules/whatwg-fetch/dist/fetch.umd.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _Blob = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _BlobManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _NativeEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _binaryToBase = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _NativeWebSocketModule = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var _WebSocketEvent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[13]));

  var _base64Js = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[14]));

  var _eventTargetShim = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[15]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[16]));

  var _excluded = ["headers"];

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var CONNECTING = 0;
  var OPEN = 1;
  var CLOSING = 2;
  var CLOSED = 3;
  var CLOSE_NORMAL = 1000;
  var WEBSOCKET_EVENTS = ['close', 'error', 'message', 'open'];
  var nextWebSocketId = 0;

  var WebSocket = function (_ref) {
    (0, _inherits2.default)(WebSocket, _ref);

    var _super = _createSuper(WebSocket);

    function WebSocket(url, protocols, options) {
      var _this;

      (0, _classCallCheck2.default)(this, WebSocket);
      _this = _super.call(this);
      _this.CONNECTING = CONNECTING;
      _this.OPEN = OPEN;
      _this.CLOSING = CLOSING;
      _this.CLOSED = CLOSED;
      _this.readyState = CONNECTING;
      _this.url = url;

      if (typeof protocols === 'string') {
        protocols = [protocols];
      }

      var _ref2 = options || {},
          _ref2$headers = _ref2.headers,
          headers = _ref2$headers === undefined ? {} : _ref2$headers,
          unrecognized = (0, _objectWithoutProperties2.default)(_ref2, _excluded);

      if (unrecognized && typeof unrecognized.origin === 'string') {
        console.warn('Specifying `origin` as a WebSocket connection option is deprecated. Include it under `headers` instead.');
        headers.origin = unrecognized.origin;
        delete unrecognized.origin;
      }

      if (Object.keys(unrecognized).length > 0) {
        console.warn('Unrecognized WebSocket connection option(s) `' + Object.keys(unrecognized).join('`, `') + '`. ' + 'Did you mean to put these under `headers`?');
      }

      if (!Array.isArray(protocols)) {
        protocols = null;
      }

      _this._eventEmitter = new _NativeEventEmitter.default(_Platform.default.OS !== 'ios' ? null : _NativeWebSocketModule.default);
      _this._socketId = nextWebSocketId++;

      _this._registerEvents();

      _NativeWebSocketModule.default.connect(url, protocols, {
        headers: headers
      }, _this._socketId);

      return _this;
    }

    (0, _createClass2.default)(WebSocket, [{
      key: "binaryType",
      get: function get() {
        return this._binaryType;
      },
      set: function set(binaryType) {
        if (binaryType !== 'blob' && binaryType !== 'arraybuffer') {
          throw new Error("binaryType must be either 'blob' or 'arraybuffer'");
        }

        if (this._binaryType === 'blob' || binaryType === 'blob') {
          (0, _invariant.default)(_BlobManager.default.isAvailable, 'Native module BlobModule is required for blob support');

          if (binaryType === 'blob') {
            _BlobManager.default.addWebSocketHandler(this._socketId);
          } else {
            _BlobManager.default.removeWebSocketHandler(this._socketId);
          }
        }

        this._binaryType = binaryType;
      }
    }, {
      key: "close",
      value: function close(code, reason) {
        if (this.readyState === this.CLOSING || this.readyState === this.CLOSED) {
          return;
        }

        this.readyState = this.CLOSING;

        this._close(code, reason);
      }
    }, {
      key: "send",
      value: function send(data) {
        if (this.readyState === this.CONNECTING) {
          throw new Error('INVALID_STATE_ERR');
        }

        if (data instanceof _Blob.default) {
          (0, _invariant.default)(_BlobManager.default.isAvailable, 'Native module BlobModule is required for blob support');

          _BlobManager.default.sendOverSocket(data, this._socketId);

          return;
        }

        if (typeof data === 'string') {
          _NativeWebSocketModule.default.send(data, this._socketId);

          return;
        }

        if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
          _NativeWebSocketModule.default.sendBinary((0, _binaryToBase.default)(data), this._socketId);

          return;
        }

        throw new Error('Unsupported data type');
      }
    }, {
      key: "ping",
      value: function ping() {
        if (this.readyState === this.CONNECTING) {
          throw new Error('INVALID_STATE_ERR');
        }

        _NativeWebSocketModule.default.ping(this._socketId);
      }
    }, {
      key: "_close",
      value: function _close(code, reason) {
        var statusCode = typeof code === 'number' ? code : CLOSE_NORMAL;
        var closeReason = typeof reason === 'string' ? reason : '';

        _NativeWebSocketModule.default.close(statusCode, closeReason, this._socketId);

        if (_BlobManager.default.isAvailable && this._binaryType === 'blob') {
          _BlobManager.default.removeWebSocketHandler(this._socketId);
        }
      }
    }, {
      key: "_unregisterEvents",
      value: function _unregisterEvents() {
        this._subscriptions.forEach(function (e) {
          return e.remove();
        });

        this._subscriptions = [];
      }
    }, {
      key: "_registerEvents",
      value: function _registerEvents() {
        var _this2 = this;

        this._subscriptions = [this._eventEmitter.addListener('websocketMessage', function (ev) {
          if (ev.id !== _this2._socketId) {
            return;
          }

          var data = ev.data;

          switch (ev.type) {
            case 'binary':
              data = _base64Js.default.toByteArray(ev.data).buffer;
              break;

            case 'blob':
              data = _BlobManager.default.createFromOptions(ev.data);
              break;
          }

          _this2.dispatchEvent(new _WebSocketEvent.default('message', {
            data: data
          }));
        }), this._eventEmitter.addListener('websocketOpen', function (ev) {
          if (ev.id !== _this2._socketId) {
            return;
          }

          _this2.readyState = _this2.OPEN;
          _this2.protocol = ev.protocol;

          _this2.dispatchEvent(new _WebSocketEvent.default('open'));
        }), this._eventEmitter.addListener('websocketClosed', function (ev) {
          if (ev.id !== _this2._socketId) {
            return;
          }

          _this2.readyState = _this2.CLOSED;

          _this2.dispatchEvent(new _WebSocketEvent.default('close', {
            code: ev.code,
            reason: ev.reason
          }));

          _this2._unregisterEvents();

          _this2.close();
        }), this._eventEmitter.addListener('websocketFailed', function (ev) {
          if (ev.id !== _this2._socketId) {
            return;
          }

          _this2.readyState = _this2.CLOSED;

          _this2.dispatchEvent(new _WebSocketEvent.default('error', {
            message: ev.message
          }));

          _this2.dispatchEvent(new _WebSocketEvent.default('close', {
            message: ev.message
          }));

          _this2._unregisterEvents();

          _this2.close();
        })];
      }
    }]);
    return WebSocket;
  }(_eventTargetShim.default.apply(undefined, WEBSOCKET_EVENTS));

  WebSocket.CONNECTING = CONNECTING;
  WebSocket.OPEN = OPEN;
  WebSocket.CLOSING = CLOSING;
  WebSocket.CLOSED = CLOSED;
  module.exports = WebSocket;
},"node_modules/react-native/Libraries/WebSocket/WebSocket.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Blob/Blob.js","node_modules/react-native/Libraries/Blob/BlobManager.js","node_modules/react-native/Libraries/EventEmitter/NativeEventEmitter.js","node_modules/react-native/Libraries/Utilities/binaryToBase64.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/WebSocket/NativeWebSocketModule.js","node_modules/react-native/Libraries/WebSocket/WebSocketEvent.js","node_modules/base64-js/index.js","node_modules/event-target-shim/dist/event-target-shim.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _$$_REQUIRE(_dependencyMap[0])(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/objectWithoutProperties.js",["node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _RCTDeviceEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var NativeEventEmitter = function () {
    function NativeEventEmitter(nativeModule) {
      (0, _classCallCheck2.default)(this, NativeEventEmitter);

      if (_Platform.default.OS === 'ios') {
        (0, _invariant.default)(nativeModule != null, '`new NativeEventEmitter()` requires a non-null argument.');
      }

      var hasAddListener = !!nativeModule && typeof nativeModule.addListener === 'function';
      var hasRemoveListeners = !!nativeModule && typeof nativeModule.removeListeners === 'function';

      if (nativeModule && hasAddListener && hasRemoveListeners) {
        this._nativeModule = nativeModule;
      } else if (nativeModule != null) {
        if (!hasAddListener) {
          console.warn('`new NativeEventEmitter()` was called with a non-null argument without the required `addListener` method.');
        }

        if (!hasRemoveListeners) {
          console.warn('`new NativeEventEmitter()` was called with a non-null argument without the required `removeListeners` method.');
        }
      }
    }

    (0, _createClass2.default)(NativeEventEmitter, [{
      key: "addListener",
      value: function addListener(eventType, listener, context) {
        var _this$_nativeModule,
            _this = this;

        (_this$_nativeModule = this._nativeModule) == null ? undefined : _this$_nativeModule.addListener(eventType);

        var subscription = _RCTDeviceEventEmitter.default.addListener(eventType, listener, context);

        return {
          remove: function remove() {
            if (subscription != null) {
              var _this$_nativeModule2;

              (_this$_nativeModule2 = _this._nativeModule) == null ? undefined : _this$_nativeModule2.removeListeners(1);
              subscription.remove();
              subscription = null;
            }
          }
        };
      }
    }, {
      key: "removeListener",
      value: function removeListener(eventType, listener) {
        var _this$_nativeModule3;

        (_this$_nativeModule3 = this._nativeModule) == null ? undefined : _this$_nativeModule3.removeListeners(1);

        _RCTDeviceEventEmitter.default.removeListener(eventType, listener);
      }
    }, {
      key: "emit",
      value: function emit(eventType) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        _RCTDeviceEventEmitter.default.emit.apply(_RCTDeviceEventEmitter.default, [eventType].concat(args));
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners(eventType) {
        var _this$_nativeModule4;

        (0, _invariant.default)(eventType != null, '`NativeEventEmitter.removeAllListener()` requires a non-null argument.');
        (_this$_nativeModule4 = this._nativeModule) == null ? undefined : _this$_nativeModule4.removeListeners(this.listenerCount(eventType));

        _RCTDeviceEventEmitter.default.removeAllListeners(eventType);
      }
    }, {
      key: "listenerCount",
      value: function listenerCount(eventType) {
        return _RCTDeviceEventEmitter.default.listenerCount(eventType);
      }
    }]);
    return NativeEventEmitter;
  }();

  exports.default = NativeEventEmitter;
},"node_modules/react-native/Libraries/EventEmitter/NativeEventEmitter.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/EventEmitter/RCTDeviceEventEmitter.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.getEnforcing('WebSocketModule');

  exports.default = _default;
},"node_modules/react-native/Libraries/WebSocket/NativeWebSocketModule.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var WebSocketEvent = _$$_REQUIRE(_dependencyMap[0])(function WebSocketEvent(type, eventInitDict) {
    _$$_REQUIRE(_dependencyMap[1])(this, WebSocketEvent);

    this.type = type.toString();

    _$$_REQUIRE(_dependencyMap[2])(this, eventInitDict);
  });

  module.exports = WebSocketEvent;
},"node_modules/react-native/Libraries/WebSocket/WebSocketEvent.js",["node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/extends.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var File = function (_Blob) {
    _$$_REQUIRE(_dependencyMap[2])(File, _Blob);

    var _super = _createSuper(File);

    function File(parts, name, options) {
      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, File);

      _$$_REQUIRE(_dependencyMap[4])(parts != null && name != null, 'Failed to construct `File`: Must pass both `parts` and `name` arguments.');

      _this = _super.call(this, parts, options);
      _this.data.name = name;
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[5])(File, [{
      key: "name",
      get: function get() {
        _$$_REQUIRE(_dependencyMap[4])(this.data.name != null, 'Files must have a name set.');

        return this.data.name;
      }
    }, {
      key: "lastModified",
      get: function get() {
        return this.data.lastModified || 0;
      }
    }]);

    return File;
  }(_$$_REQUIRE(_dependencyMap[6]));

  module.exports = File;
},"node_modules/react-native/Libraries/Blob/File.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/invariant/browser.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Blob/Blob.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _NativeFileReaderModule = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var READER_EVENTS = ['abort', 'error', 'load', 'loadstart', 'loadend', 'progress'];
  var EMPTY = 0;
  var LOADING = 1;
  var DONE = 2;

  var FileReader = function (_ref) {
    (0, _inherits2.default)(FileReader, _ref);

    var _super = _createSuper(FileReader);

    function FileReader() {
      var _this;

      (0, _classCallCheck2.default)(this, FileReader);
      _this = _super.call(this);
      _this.EMPTY = EMPTY;
      _this.LOADING = LOADING;
      _this.DONE = DONE;
      _this._aborted = false;
      _this._subscriptions = [];

      _this._reset();

      return _this;
    }

    (0, _createClass2.default)(FileReader, [{
      key: "_reset",
      value: function _reset() {
        this._readyState = EMPTY;
        this._error = null;
        this._result = null;
      }
    }, {
      key: "_clearSubscriptions",
      value: function _clearSubscriptions() {
        this._subscriptions.forEach(function (sub) {
          return sub.remove();
        });

        this._subscriptions = [];
      }
    }, {
      key: "_setReadyState",
      value: function _setReadyState(newState) {
        this._readyState = newState;
        this.dispatchEvent({
          type: 'readystatechange'
        });

        if (newState === DONE) {
          if (this._aborted) {
            this.dispatchEvent({
              type: 'abort'
            });
          } else if (this._error) {
            this.dispatchEvent({
              type: 'error'
            });
          } else {
            this.dispatchEvent({
              type: 'load'
            });
          }

          this.dispatchEvent({
            type: 'loadend'
          });
        }
      }
    }, {
      key: "readAsArrayBuffer",
      value: function readAsArrayBuffer() {
        throw new Error('FileReader.readAsArrayBuffer is not implemented');
      }
    }, {
      key: "readAsDataURL",
      value: function readAsDataURL(blob) {
        var _this2 = this;

        this._aborted = false;

        if (blob == null) {
          throw new TypeError("Failed to execute 'readAsDataURL' on 'FileReader': parameter 1 is not of type 'Blob'");
        }

        _NativeFileReaderModule.default.readAsDataURL(blob.data).then(function (text) {
          if (_this2._aborted) {
            return;
          }

          _this2._result = text;

          _this2._setReadyState(DONE);
        }, function (error) {
          if (_this2._aborted) {
            return;
          }

          _this2._error = error;

          _this2._setReadyState(DONE);
        });
      }
    }, {
      key: "readAsText",
      value: function readAsText(blob) {
        var _this3 = this;

        var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';
        this._aborted = false;

        if (blob == null) {
          throw new TypeError("Failed to execute 'readAsText' on 'FileReader': parameter 1 is not of type 'Blob'");
        }

        _NativeFileReaderModule.default.readAsText(blob.data, encoding).then(function (text) {
          if (_this3._aborted) {
            return;
          }

          _this3._result = text;

          _this3._setReadyState(DONE);
        }, function (error) {
          if (_this3._aborted) {
            return;
          }

          _this3._error = error;

          _this3._setReadyState(DONE);
        });
      }
    }, {
      key: "abort",
      value: function abort() {
        this._aborted = true;

        if (this._readyState !== EMPTY && this._readyState !== DONE) {
          this._reset();

          this._setReadyState(DONE);
        }

        this._reset();
      }
    }, {
      key: "readyState",
      get: function get() {
        return this._readyState;
      }
    }, {
      key: "error",
      get: function get() {
        return this._error;
      }
    }, {
      key: "result",
      get: function get() {
        return this._result;
      }
    }]);
    return FileReader;
  }(_$$_REQUIRE(_dependencyMap[7]).apply(undefined, READER_EVENTS));

  FileReader.EMPTY = EMPTY;
  FileReader.LOADING = LOADING;
  FileReader.DONE = DONE;
  module.exports = FileReader;
},"node_modules/react-native/Libraries/Blob/FileReader.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Blob/NativeFileReaderModule.js","node_modules/event-target-shim/dist/event-target-shim.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.getEnforcing('FileReaderModule');

  exports.default = _default;
},"node_modules/react-native/Libraries/Blob/NativeFileReaderModule.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URLSearchParams = exports.URL = undefined;

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _NativeBlobModule = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _Symbol$iterator;

  var BLOB_URL_PREFIX = null;

  if (_NativeBlobModule.default && typeof _NativeBlobModule.default.getConstants().BLOB_URI_SCHEME === 'string') {
    var constants = _NativeBlobModule.default.getConstants();

    BLOB_URL_PREFIX = constants.BLOB_URI_SCHEME + ':';

    if (typeof constants.BLOB_URI_HOST === 'string') {
      BLOB_URL_PREFIX += "//" + constants.BLOB_URI_HOST + "/";
    }
  }

  _Symbol$iterator = Symbol.iterator;

  var URLSearchParams = function () {
    function URLSearchParams(params) {
      var _this = this;

      (0, _classCallCheck2.default)(this, URLSearchParams);
      this._searchParams = [];

      if (typeof params === 'object') {
        Object.keys(params).forEach(function (key) {
          return _this.append(key, params[key]);
        });
      }
    }

    (0, _createClass2.default)(URLSearchParams, [{
      key: "append",
      value: function append(key, value) {
        this._searchParams.push([key, value]);
      }
    }, {
      key: "delete",
      value: function _delete(name) {
        throw new Error('URLSearchParams.delete is not implemented');
      }
    }, {
      key: "get",
      value: function get(name) {
        throw new Error('URLSearchParams.get is not implemented');
      }
    }, {
      key: "getAll",
      value: function getAll(name) {
        throw new Error('URLSearchParams.getAll is not implemented');
      }
    }, {
      key: "has",
      value: function has(name) {
        throw new Error('URLSearchParams.has is not implemented');
      }
    }, {
      key: "set",
      value: function set(name, value) {
        throw new Error('URLSearchParams.set is not implemented');
      }
    }, {
      key: "sort",
      value: function sort() {
        throw new Error('URLSearchParams.sort is not implemented');
      }
    }, {
      key: _Symbol$iterator,
      value: function value() {
        return this._searchParams[Symbol.iterator]();
      }
    }, {
      key: "toString",
      value: function toString() {
        if (this._searchParams.length === 0) {
          return '';
        }

        var last = this._searchParams.length - 1;
        return this._searchParams.reduce(function (acc, curr, index) {
          return acc + curr.join('=') + (index === last ? '' : '&');
        }, '');
      }
    }]);
    return URLSearchParams;
  }();

  exports.URLSearchParams = URLSearchParams;

  function validateBaseUrl(url) {
    return /^(?:(?:(?:https?|ftp):)?\/\/)(?:(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)*(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/.test(url);
  }

  var URL = function () {
    function URL(url, base) {
      (0, _classCallCheck2.default)(this, URL);
      this._searchParamsInstance = null;
      var baseUrl = null;

      if (!base || validateBaseUrl(url)) {
        this._url = url;

        if (!this._url.endsWith('/')) {
          this._url += '/';
        }
      } else {
        if (typeof base === 'string') {
          baseUrl = base;

          if (!validateBaseUrl(baseUrl)) {
            throw new TypeError("Invalid base URL: " + baseUrl);
          }
        } else {
          baseUrl = base.toString();
        }

        if (baseUrl.endsWith('/')) {
          baseUrl = baseUrl.slice(0, baseUrl.length - 1);
        }

        if (!url.startsWith('/')) {
          url = "/" + url;
        }

        if (baseUrl.endsWith(url)) {
          url = '';
        }

        this._url = "" + baseUrl + url;
      }
    }

    (0, _createClass2.default)(URL, [{
      key: "hash",
      get: function get() {
        throw new Error('URL.hash is not implemented');
      }
    }, {
      key: "host",
      get: function get() {
        throw new Error('URL.host is not implemented');
      }
    }, {
      key: "hostname",
      get: function get() {
        throw new Error('URL.hostname is not implemented');
      }
    }, {
      key: "href",
      get: function get() {
        return this.toString();
      }
    }, {
      key: "origin",
      get: function get() {
        throw new Error('URL.origin is not implemented');
      }
    }, {
      key: "password",
      get: function get() {
        throw new Error('URL.password is not implemented');
      }
    }, {
      key: "pathname",
      get: function get() {
        throw new Error('URL.pathname not implemented');
      }
    }, {
      key: "port",
      get: function get() {
        throw new Error('URL.port is not implemented');
      }
    }, {
      key: "protocol",
      get: function get() {
        throw new Error('URL.protocol is not implemented');
      }
    }, {
      key: "search",
      get: function get() {
        throw new Error('URL.search is not implemented');
      }
    }, {
      key: "searchParams",
      get: function get() {
        if (this._searchParamsInstance == null) {
          this._searchParamsInstance = new URLSearchParams();
        }

        return this._searchParamsInstance;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.toString();
      }
    }, {
      key: "toString",
      value: function toString() {
        if (this._searchParamsInstance === null) {
          return this._url;
        }

        var instanceString = this._searchParamsInstance.toString();

        var separator = this._url.indexOf('?') > -1 ? '&' : '?';
        return this._url + separator + instanceString;
      }
    }, {
      key: "username",
      get: function get() {
        throw new Error('URL.username is not implemented');
      }
    }], [{
      key: "createObjectURL",
      value: function createObjectURL(blob) {
        if (BLOB_URL_PREFIX === null) {
          throw new Error('Cannot create URL for blob!');
        }

        return "" + BLOB_URL_PREFIX + blob.data.blobId + "?offset=" + blob.data.offset + "&size=" + blob.size;
      }
    }, {
      key: "revokeObjectURL",
      value: function revokeObjectURL(url) {}
    }]);
    return URL;
  }();

  exports.URL = URL;
},"node_modules/react-native/Libraries/Blob/URL.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Blob/NativeBlobModule.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  Object.defineProperty(exports, '__esModule', {
    value: true
  });

  var AbortSignal = function (_eventTargetShim$Even) {
    _$$_REQUIRE(_dependencyMap[2])(AbortSignal, _eventTargetShim$Even);

    var _super = _createSuper(AbortSignal);

    function AbortSignal() {
      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, AbortSignal);

      _this = _super.call(this);
      throw new TypeError("AbortSignal cannot be constructed directly");
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[4])(AbortSignal, [{
      key: "aborted",
      get: function get() {
        var aborted = abortedFlags.get(this);

        if (typeof aborted !== "boolean") {
          throw new TypeError("Expected 'this' to be an 'AbortSignal' object, but got " + (this === null ? "null" : typeof this));
        }

        return aborted;
      }
    }]);

    return AbortSignal;
  }(_$$_REQUIRE(_dependencyMap[5]).EventTarget);

  _$$_REQUIRE(_dependencyMap[5]).defineEventAttribute(AbortSignal.prototype, "abort");

  function createAbortSignal() {
    var signal = Object.create(AbortSignal.prototype);

    _$$_REQUIRE(_dependencyMap[5]).EventTarget.call(signal);

    abortedFlags.set(signal, false);
    return signal;
  }

  function abortSignal(signal) {
    if (abortedFlags.get(signal) !== false) {
      return;
    }

    abortedFlags.set(signal, true);
    signal.dispatchEvent({
      type: "abort"
    });
  }

  var abortedFlags = new WeakMap();
  Object.defineProperties(AbortSignal.prototype, {
    aborted: {
      enumerable: true
    }
  });

  if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
      configurable: true,
      value: "AbortSignal"
    });
  }

  var AbortController = function () {
    function AbortController() {
      _$$_REQUIRE(_dependencyMap[3])(this, AbortController);

      signals.set(this, createAbortSignal());
    }

    _$$_REQUIRE(_dependencyMap[4])(AbortController, [{
      key: "signal",
      get: function get() {
        return getSignal(this);
      }
    }, {
      key: "abort",
      value: function abort() {
        abortSignal(getSignal(this));
      }
    }]);

    return AbortController;
  }();

  var signals = new WeakMap();

  function getSignal(controller) {
    var signal = signals.get(controller);

    if (signal == null) {
      throw new TypeError("Expected 'this' to be an 'AbortController' object, but got " + (controller === null ? "null" : typeof controller));
    }

    return signal;
  }

  Object.defineProperties(AbortController.prototype, {
    signal: {
      enumerable: true
    },
    abort: {
      enumerable: true
    }
  });

  if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {
      configurable: true,
      value: "AbortController"
    });
  }

  exports.AbortController = AbortController;
  exports.AbortSignal = AbortSignal;
  exports.default = AbortController;
  module.exports = AbortController;
  module.exports.AbortController = module.exports["default"] = AbortController;
  module.exports.AbortSignal = AbortSignal;
},"node_modules/abort-controller/dist/abort-controller.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/event-target-shim/dist/event-target-shim.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  if (!global.alert) {
    global.alert = function (text) {
      _$$_REQUIRE(_dependencyMap[0]).alert('Alert', '' + text);
    };
  }
},"node_modules/react-native/Libraries/Core/setUpAlert.js",["node_modules/react-native/Libraries/Alert/Alert.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _RCTAlertManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var Alert = function () {
    function Alert() {
      (0, _classCallCheck2.default)(this, Alert);
    }

    (0, _createClass2.default)(Alert, null, [{
      key: "alert",
      value: function alert(title, message, buttons, options) {
        if (_Platform.default.OS === 'ios') {
          Alert.prompt(title, message, buttons, 'default');
        } else if (_Platform.default.OS === 'android') {
          var NativeDialogManagerAndroid = _$$_REQUIRE(_dependencyMap[5]).default;

          if (!NativeDialogManagerAndroid) {
            return;
          }

          var constants = NativeDialogManagerAndroid.getConstants();
          var config = {
            title: title || '',
            message: message || '',
            cancelable: false
          };

          if (options && options.cancelable) {
            config.cancelable = options.cancelable;
          }

          var defaultPositiveText = 'OK';
          var validButtons = buttons ? buttons.slice(0, 3) : [{
            text: defaultPositiveText
          }];
          var buttonPositive = validButtons.pop();
          var buttonNegative = validButtons.pop();
          var buttonNeutral = validButtons.pop();

          if (buttonNeutral) {
            config.buttonNeutral = buttonNeutral.text || '';
          }

          if (buttonNegative) {
            config.buttonNegative = buttonNegative.text || '';
          }

          if (buttonPositive) {
            config.buttonPositive = buttonPositive.text || defaultPositiveText;
          }

          var onAction = function onAction(action, buttonKey) {
            if (action === constants.buttonClicked) {
              if (buttonKey === constants.buttonNeutral) {
                buttonNeutral.onPress && buttonNeutral.onPress();
              } else if (buttonKey === constants.buttonNegative) {
                buttonNegative.onPress && buttonNegative.onPress();
              } else if (buttonKey === constants.buttonPositive) {
                buttonPositive.onPress && buttonPositive.onPress();
              }
            } else if (action === constants.dismissed) {
              options && options.onDismiss && options.onDismiss();
            }
          };

          var onError = function onError(errorMessage) {
            return console.warn(errorMessage);
          };

          NativeDialogManagerAndroid.showAlert(config, onError, onAction);
        }
      }
    }, {
      key: "prompt",
      value: function prompt(title, message, callbackOrButtons) {
        var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'plain-text';
        var defaultValue = arguments.length > 4 ? arguments[4] : undefined;
        var keyboardType = arguments.length > 5 ? arguments[5] : undefined;

        if (_Platform.default.OS === 'ios') {
          var callbacks = [];
          var buttons = [];
          var cancelButtonKey;
          var destructiveButtonKey;

          if (typeof callbackOrButtons === 'function') {
            callbacks = [callbackOrButtons];
          } else if (Array.isArray(callbackOrButtons)) {
            callbackOrButtons.forEach(function (btn, index) {
              callbacks[index] = btn.onPress;

              if (btn.style === 'cancel') {
                cancelButtonKey = String(index);
              } else if (btn.style === 'destructive') {
                destructiveButtonKey = String(index);
              }

              if (btn.text || index < (callbackOrButtons || []).length - 1) {
                var btnDef = {};
                btnDef[index] = btn.text || '';
                buttons.push(btnDef);
              }
            });
          }

          _RCTAlertManager.default.alertWithArgs({
            title: title || '',
            message: message || undefined,
            buttons: buttons,
            type: type || undefined,
            defaultValue: defaultValue,
            cancelButtonKey: cancelButtonKey,
            destructiveButtonKey: destructiveButtonKey,
            keyboardType: keyboardType
          }, function (id, value) {
            var cb = callbacks[id];
            cb && cb(value);
          });
        }
      }
    }]);
    return Alert;
  }();

  module.exports = Alert;
},"node_modules/react-native/Libraries/Alert/Alert.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/Alert/RCTAlertManager.ios.js","node_modules/react-native/Libraries/NativeModules/specs/NativeDialogManagerAndroid.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _NativeAlertManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  module.exports = {
    alertWithArgs: function alertWithArgs(args, callback) {
      if (_NativeAlertManager.default == null) {
        return;
      }

      _NativeAlertManager.default.alertWithArgs(args, callback);
    }
  };
},"node_modules/react-native/Libraries/Alert/RCTAlertManager.ios.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Alert/NativeAlertManager.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('AlertManager');

  exports.default = _default;
},"node_modules/react-native/Libraries/Alert/NativeAlertManager.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('DialogManagerAndroid');

  exports.default = _default;
},"node_modules/react-native/Libraries/NativeModules/specs/NativeDialogManagerAndroid.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var navigator = global.navigator;

  if (navigator === undefined) {
    global.navigator = navigator = {};
  }

  _$$_REQUIRE(_dependencyMap[0]).polyfillObjectProperty(navigator, 'product', function () {
    return 'ReactNative';
  });
},"node_modules/react-native/Libraries/Core/setUpNavigator.js",["node_modules/react-native/Libraries/Utilities/PolyfillFunctions.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var registerModule;

  if (global.RN$Bridgeless === true && global.RN$registerCallableModule) {
    registerModule = global.RN$registerCallableModule;
  } else {
    var BatchedBridge = _$$_REQUIRE(_dependencyMap[0]);

    registerModule = function registerModule(moduleName, factory) {
      return BatchedBridge.registerLazyCallableModule(moduleName, factory);
    };
  }

  registerModule('Systrace', function () {
    return _$$_REQUIRE(_dependencyMap[1]);
  });
  registerModule('JSTimers', function () {
    return _$$_REQUIRE(_dependencyMap[2]);
  });
  registerModule('HeapCapture', function () {
    return _$$_REQUIRE(_dependencyMap[3]);
  });
  registerModule('SamplingProfiler', function () {
    return _$$_REQUIRE(_dependencyMap[4]);
  });
  registerModule('RCTLog', function () {
    return _$$_REQUIRE(_dependencyMap[5]);
  });
  registerModule('RCTDeviceEventEmitter', function () {
    return _$$_REQUIRE(_dependencyMap[6]).default;
  });
  registerModule('RCTNativeAppEventEmitter', function () {
    return _$$_REQUIRE(_dependencyMap[7]);
  });
  registerModule('GlobalPerformanceLogger', function () {
    return _$$_REQUIRE(_dependencyMap[8]);
  });
  registerModule('JSDevSupportModule', function () {
    return _$$_REQUIRE(_dependencyMap[9]);
  });
  {
    registerModule('HMRClient', function () {
      return _$$_REQUIRE(_dependencyMap[10]);
    });
  }
},"node_modules/react-native/Libraries/Core/setUpBatchedBridge.js",["node_modules/react-native/Libraries/BatchedBridge/BatchedBridge.js","node_modules/react-native/Libraries/Performance/Systrace.js","node_modules/react-native/Libraries/Core/Timers/JSTimers.js","node_modules/react-native/Libraries/HeapCapture/HeapCapture.js","node_modules/react-native/Libraries/Performance/SamplingProfiler.js","node_modules/react-native/Libraries/Utilities/RCTLog.js","node_modules/react-native/Libraries/EventEmitter/RCTDeviceEventEmitter.js","node_modules/react-native/Libraries/EventEmitter/RCTNativeAppEventEmitter.js","node_modules/react-native/Libraries/Utilities/GlobalPerformanceLogger.js","node_modules/react-native/Libraries/Utilities/JSDevSupportModule.js","node_modules/react-native/Libraries/Utilities/HMRClientProdShim.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _NativeJSCHeapCapture = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var HeapCapture = {
    captureHeap: function captureHeap(path) {
      var error = null;

      try {
        global.nativeCaptureHeap(path);
        console.log('HeapCapture.captureHeap succeeded: ' + path);
      } catch (e) {
        console.log('HeapCapture.captureHeap error: ' + e.toString());
        error = e.toString();
      }

      if (_NativeJSCHeapCapture.default) {
        _NativeJSCHeapCapture.default.captureComplete(path, error);
      }
    }
  };
  module.exports = HeapCapture;
},"node_modules/react-native/Libraries/HeapCapture/HeapCapture.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/HeapCapture/NativeJSCHeapCapture.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('JSCHeapCapture');

  exports.default = _default;
},"node_modules/react-native/Libraries/HeapCapture/NativeJSCHeapCapture.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var SamplingProfiler = {
    poke: function poke(token) {
      var error = null;
      var result = null;

      try {
        result = global.pokeSamplingProfiler();

        if (result === null) {
          console.log('The JSC Sampling Profiler has started');
        } else {
          console.log('The JSC Sampling Profiler has stopped');
        }
      } catch (e) {
        console.log('Error occurred when restarting Sampling Profiler: ' + e.toString());
        error = e.toString();
      }

      var NativeJSCSamplingProfiler = _$$_REQUIRE(_dependencyMap[0]).default;

      if (NativeJSCSamplingProfiler) {
        NativeJSCSamplingProfiler.operationComplete(token, result, error);
      }
    }
  };
  module.exports = SamplingProfiler;
},"node_modules/react-native/Libraries/Performance/SamplingProfiler.js",["node_modules/react-native/Libraries/Performance/NativeJSCSamplingProfiler.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('JSCSamplingProfiler');

  exports.default = _default;
},"node_modules/react-native/Libraries/Performance/NativeJSCSamplingProfiler.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var levelsMap = {
    log: 'log',
    info: 'info',
    warn: 'warn',
    error: 'error',
    fatal: 'error'
  };
  var warningHandler = null;
  var RCTLog = {
    logIfNoNativeHook: function logIfNoNativeHook(level) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (typeof global.nativeLoggingHook === 'undefined') {
        RCTLog.logToConsole.apply(RCTLog, [level].concat(args));
      } else {
        if (warningHandler && level === 'warn') {
          warningHandler.apply(undefined, args);
        }
      }
    },
    logToConsole: function logToConsole(level) {
      var _console;

      var logFn = levelsMap[level];

      _$$_REQUIRE(_dependencyMap[0])(logFn, 'Level "' + level + '" not one of ' + Object.keys(levelsMap).toString());

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      (_console = console)[logFn].apply(_console, args);
    },
    setWarningHandler: function setWarningHandler(handler) {
      warningHandler = handler;
    }
  };
  module.exports = RCTLog;
},"node_modules/react-native/Libraries/Utilities/RCTLog.js",["node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _RCTDeviceEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var RCTNativeAppEventEmitter = _RCTDeviceEventEmitter.default;
  module.exports = RCTNativeAppEventEmitter;
},"node_modules/react-native/Libraries/EventEmitter/RCTNativeAppEventEmitter.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/EventEmitter/RCTDeviceEventEmitter.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _NativeJSDevSupport = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var JSDevSupportModule = {
    getJSHierarchy: function getJSHierarchy(tag) {
      if (_NativeJSDevSupport.default) {
        var constants = _NativeJSDevSupport.default.getConstants();

        try {
          var computeComponentStackForErrorReporting = _$$_REQUIRE(_dependencyMap[2]).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.computeComponentStackForErrorReporting;

          var componentStack = computeComponentStackForErrorReporting(tag);

          if (!componentStack) {
            _NativeJSDevSupport.default.onFailure(constants.ERROR_CODE_VIEW_NOT_FOUND, "Component stack doesn't exist for tag " + tag);
          } else {
            _NativeJSDevSupport.default.onSuccess(componentStack);
          }
        } catch (e) {
          _NativeJSDevSupport.default.onFailure(constants.ERROR_CODE_EXCEPTION, e.message);
        }
      }
    }
  };
  module.exports = JSDevSupportModule;
},"node_modules/react-native/Libraries/Utilities/JSDevSupportModule.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/NativeJSDevSupport.js","node_modules/react-native/Libraries/Renderer/shims/ReactNative.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('JSDevSupport');

  exports.default = _default;
},"node_modules/react-native/Libraries/Utilities/NativeJSDevSupport.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var HMRClientProdShim = {
    setup: function setup() {},
    enable: function enable() {
      console.error("Fast Refresh is disabled in JavaScript bundles built in production mode. Did you forget to run Metro?");
    },
    disable: function disable() {},
    registerBundle: function registerBundle() {},
    log: function log() {}
  };
  module.exports = HMRClientProdShim;
},"node_modules/react-native/Libraries/Utilities/HMRClientProdShim.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function __fetchSegment(segmentId, options, callback) {
    var SegmentFetcher = _$$_REQUIRE(_dependencyMap[0]).default;

    SegmentFetcher.fetchSegment(segmentId, options, function (errorObject) {
      if (errorObject) {
        var error = new Error(errorObject.message);
        error.code = errorObject.code;
        callback(error);
      }

      callback(null);
    });
  }

  global.__fetchSegment = __fetchSegment;

  function __getSegment(segmentId, options, callback) {
    var SegmentFetcher = _$$_REQUIRE(_dependencyMap[0]).default;

    if (!SegmentFetcher.getSegment) {
      throw new Error('SegmentFetcher.getSegment must be defined');
    }

    SegmentFetcher.getSegment(segmentId, options, function (errorObject, path) {
      if (errorObject) {
        var error = new Error(errorObject.message);
        error.code = errorObject.code;
        callback(error);
      }

      callback(null, path);
    });
  }

  global.__getSegment = __getSegment;
},"node_modules/react-native/Libraries/Core/setUpSegmentFetcher.js",["node_modules/react-native/Libraries/Core/SegmentFetcher/NativeSegmentFetcher.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.getEnforcing('SegmentFetcher');

  exports.default = _default;
},"node_modules/react-native/Libraries/Core/SegmentFetcher/NativeSegmentFetcher.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  {
    module.exports = _$$_REQUIRE(_dependencyMap[0]);
  }
},"node_modules/react/index.js",["node_modules/react/cjs/react.production.min.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /** @license React v17.0.2
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  var n = 60103,
      p = 60106;
  exports.Fragment = 60107;
  exports.StrictMode = 60108;
  exports.Profiler = 60114;
  var q = 60109,
      r = 60110,
      t = 60112;
  exports.Suspense = 60113;
  var u = 60115,
      v = 60116;

  if ("function" === typeof Symbol && Symbol.for) {
    var w = Symbol.for;
    n = w("react.element");
    p = w("react.portal");
    exports.Fragment = w("react.fragment");
    exports.StrictMode = w("react.strict_mode");
    exports.Profiler = w("react.profiler");
    q = w("react.provider");
    r = w("react.context");
    t = w("react.forward_ref");
    exports.Suspense = w("react.suspense");
    u = w("react.memo");
    v = w("react.lazy");
  }

  var x = "function" === typeof Symbol && Symbol.iterator;

  function y(a) {
    if (null === a || "object" !== typeof a) return null;
    a = x && a[x] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }

  function z(a) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) {
      b += "&args[]=" + encodeURIComponent(arguments[c]);
    }

    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }

  var A = {
    isMounted: function isMounted() {
      return false;
    },
    enqueueForceUpdate: function enqueueForceUpdate() {},
    enqueueReplaceState: function enqueueReplaceState() {},
    enqueueSetState: function enqueueSetState() {}
  },
      B = {};

  function C(a, b, c) {
    this.props = a;
    this.context = b;
    this.refs = B;
    this.updater = c || A;
  }

  C.prototype.isReactComponent = {};

  C.prototype.setState = function (a, b) {
    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error(z(85));
    this.updater.enqueueSetState(this, a, b, "setState");
  };

  C.prototype.forceUpdate = function (a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };

  function D() {}

  D.prototype = C.prototype;

  function E(a, b, c) {
    this.props = a;
    this.context = b;
    this.refs = B;
    this.updater = c || A;
  }

  var F = E.prototype = new D();
  F.constructor = E;

  _$$_REQUIRE(_dependencyMap[0])(F, C.prototype);

  F.isPureReactComponent = true;
  var G = {
    current: null
  },
      H = Object.prototype.hasOwnProperty,
      I = {
    key: true,
    ref: true,
    __self: true,
    __source: true
  };

  function J(a, b, c) {
    var e,
        d = {},
        k = null,
        h = null;
    if (null != b) for (e in undefined !== b.ref && (h = b.ref), undefined !== b.key && (k = "" + b.key), b) {
      H.call(b, e) && !I.hasOwnProperty(e) && (d[e] = b[e]);
    }
    var g = arguments.length - 2;
    if (1 === g) d.children = c;else if (1 < g) {
      for (var f = Array(g), m = 0; m < g; m++) {
        f[m] = arguments[m + 2];
      }

      d.children = f;
    }
    if (a && a.defaultProps) for (e in g = a.defaultProps, g) {
      undefined === d[e] && (d[e] = g[e]);
    }
    return {
      $$typeof: n,
      type: a,
      key: k,
      ref: h,
      props: d,
      _owner: G.current
    };
  }

  function K(a, b) {
    return {
      $$typeof: n,
      type: a.type,
      key: b,
      ref: a.ref,
      props: a.props,
      _owner: a._owner
    };
  }

  function L(a) {
    return "object" === typeof a && null !== a && a.$$typeof === n;
  }

  function escape(a) {
    var b = {
      "=": "=0",
      ":": "=2"
    };
    return "$" + a.replace(/[=:]/g, function (a) {
      return b[a];
    });
  }

  var M = /\/+/g;

  function N(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
  }

  function O(a, b, c, e, d) {
    var k = typeof a;
    if ("undefined" === k || "boolean" === k) a = null;
    var h = false;
    if (null === a) h = true;else switch (k) {
      case "string":
      case "number":
        h = true;
        break;

      case "object":
        switch (a.$$typeof) {
          case n:
          case p:
            h = true;
        }

    }
    if (h) return h = a, d = d(h), a = "" === e ? "." + N(h, 0) : e, Array.isArray(d) ? (c = "", null != a && (c = a.replace(M, "$&/") + "/"), O(d, b, c, "", function (a) {
      return a;
    })) : null != d && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M, "$&/") + "/") + a)), b.push(d)), 1;
    h = 0;
    e = "" === e ? "." : e + ":";
    if (Array.isArray(a)) for (var g = 0; g < a.length; g++) {
      k = a[g];
      var f = e + N(k, g);
      h += O(k, b, c, f, d);
    } else if (f = y(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) {
      k = k.value, f = e + N(k, g++), h += O(k, b, c, f, d);
    } else if ("object" === k) throw b = "" + a, Error(z(31, "[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
    return h;
  }

  function P(a, b, c) {
    if (null == a) return a;
    var e = [],
        d = 0;
    O(a, e, "", "", function (a) {
      return b.call(c, a, d++);
    });
    return e;
  }

  function Q(a) {
    if (-1 === a._status) {
      var b = a._result;
      b = b();
      a._status = 0;
      a._result = b;
      b.then(function (b) {
        0 === a._status && (b = b.default, a._status = 1, a._result = b);
      }, function (b) {
        0 === a._status && (a._status = 2, a._result = b);
      });
    }

    if (1 === a._status) return a._result;
    throw a._result;
  }

  var R = {
    current: null
  };

  function S() {
    var a = R.current;
    if (null === a) throw Error(z(321));
    return a;
  }

  var T = {
    ReactCurrentDispatcher: R,
    ReactCurrentBatchConfig: {
      transition: 0
    },
    ReactCurrentOwner: G,
    IsSomeRendererActing: {
      current: false
    },
    assign: _$$_REQUIRE(_dependencyMap[0])
  };
  exports.Children = {
    map: P,
    forEach: function forEach(a, b, c) {
      P(a, function () {
        b.apply(this, arguments);
      }, c);
    },
    count: function count(a) {
      var b = 0;
      P(a, function () {
        b++;
      });
      return b;
    },
    toArray: function toArray(a) {
      return P(a, function (a) {
        return a;
      }) || [];
    },
    only: function only(a) {
      if (!L(a)) throw Error(z(143));
      return a;
    }
  };
  exports.Component = C;
  exports.PureComponent = E;
  exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T;

  exports.cloneElement = function (a, b, c) {
    if (null === a || undefined === a) throw Error(z(267, a));

    var e = _$$_REQUIRE(_dependencyMap[0])({}, a.props),
        d = a.key,
        k = a.ref,
        h = a._owner;

    if (null != b) {
      undefined !== b.ref && (k = b.ref, h = G.current);
      undefined !== b.key && (d = "" + b.key);
      if (a.type && a.type.defaultProps) var g = a.type.defaultProps;

      for (f in b) {
        H.call(b, f) && !I.hasOwnProperty(f) && (e[f] = undefined === b[f] && undefined !== g ? g[f] : b[f]);
      }
    }

    var f = arguments.length - 2;
    if (1 === f) e.children = c;else if (1 < f) {
      g = Array(f);

      for (var m = 0; m < f; m++) {
        g[m] = arguments[m + 2];
      }

      e.children = g;
    }
    return {
      $$typeof: n,
      type: a.type,
      key: d,
      ref: k,
      props: e,
      _owner: h
    };
  };

  exports.createContext = function (a, b) {
    undefined === b && (b = null);
    a = {
      $$typeof: r,
      _calculateChangedBits: b,
      _currentValue: a,
      _currentValue2: a,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    };
    a.Provider = {
      $$typeof: q,
      _context: a
    };
    return a.Consumer = a;
  };

  exports.createElement = J;

  exports.createFactory = function (a) {
    var b = J.bind(null, a);
    b.type = a;
    return b;
  };

  exports.createRef = function () {
    return {
      current: null
    };
  };

  exports.forwardRef = function (a) {
    return {
      $$typeof: t,
      render: a
    };
  };

  exports.isValidElement = L;

  exports.lazy = function (a) {
    return {
      $$typeof: v,
      _payload: {
        _status: -1,
        _result: a
      },
      _init: Q
    };
  };

  exports.memo = function (a, b) {
    return {
      $$typeof: u,
      type: a,
      compare: undefined === b ? null : b
    };
  };

  exports.useCallback = function (a, b) {
    return S().useCallback(a, b);
  };

  exports.useContext = function (a, b) {
    return S().useContext(a, b);
  };

  exports.useDebugValue = function () {};

  exports.useEffect = function (a, b) {
    return S().useEffect(a, b);
  };

  exports.useImperativeHandle = function (a, b, c) {
    return S().useImperativeHandle(a, b, c);
  };

  exports.useLayoutEffect = function (a, b) {
    return S().useLayoutEffect(a, b);
  };

  exports.useMemo = function (a, b) {
    return S().useMemo(a, b);
  };

  exports.useReducer = function (a, b, c) {
    return S().useReducer(a, b, c);
  };

  exports.useRef = function (a) {
    return S().useRef(a);
  };

  exports.useState = function (a) {
    return S().useState(a);
  };

  exports.version = "17.0.2";
},"node_modules/react/cjs/react.production.min.js",["node_modules/object-assign/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  'use strict';

  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError('Object.assign cannot be called with null or undefined');
    }

    return Object(val);
  }

  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }

      var test1 = new String('abc');
      test1[5] = 'de';

      if (Object.getOwnPropertyNames(test1)[0] === '5') {
        return false;
      }

      var test2 = {};

      for (var i = 0; i < 10; i++) {
        test2['_' + String.fromCharCode(i)] = i;
      }

      var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
        return test2[n];
      });

      if (order2.join('') !== '0123456789') {
        return false;
      }

      var test3 = {};
      'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
        test3[letter] = letter;
      });

      if (Object.keys(_$$_REQUIRE(_dependencyMap[0])({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
        return false;
      }

      return true;
    } catch (err) {
      return false;
    }
  }

  module.exports = shouldUseNative() ? Object.assign : function (target, source) {
    var from;
    var to = toObject(target);
    var symbols;

    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);

      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }

      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);

        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }

    return to;
  };
},"node_modules/object-assign/index.js",["node_modules/@babel/runtime/helpers/extends.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    get BatchedBridge() {
      return _$$_REQUIRE(_dependencyMap[0]);
    },

    get ExceptionsManager() {
      return _$$_REQUIRE(_dependencyMap[1]);
    },

    get Platform() {
      return _$$_REQUIRE(_dependencyMap[2]);
    },

    get RCTEventEmitter() {
      return _$$_REQUIRE(_dependencyMap[3]);
    },

    get ReactNativeViewConfigRegistry() {
      return _$$_REQUIRE(_dependencyMap[4]);
    },

    get TextInputState() {
      return _$$_REQUIRE(_dependencyMap[5]);
    },

    get UIManager() {
      return _$$_REQUIRE(_dependencyMap[6]);
    },

    get deepDiffer() {
      return _$$_REQUIRE(_dependencyMap[7]);
    },

    get deepFreezeAndThrowOnMutationInDev() {
      return _$$_REQUIRE(_dependencyMap[8]);
    },

    get flattenStyle() {
      return _$$_REQUIRE(_dependencyMap[9]);
    },

    get ReactFiberErrorDialog() {
      return _$$_REQUIRE(_dependencyMap[10]).default;
    },

    get legacySendAccessibilityEvent() {
      return _$$_REQUIRE(_dependencyMap[11]);
    }

  };
},"node_modules/react-native/Libraries/ReactPrivate/ReactNativePrivateInterface.js",["node_modules/react-native/Libraries/BatchedBridge/BatchedBridge.js","node_modules/react-native/Libraries/Core/ExceptionsManager.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/EventEmitter/RCTEventEmitter.js","node_modules/react-native/Libraries/Renderer/shims/ReactNativeViewConfigRegistry.js","node_modules/react-native/Libraries/Components/TextInput/TextInputState.js","node_modules/react-native/Libraries/ReactNative/UIManager.js","node_modules/react-native/Libraries/Utilities/differ/deepDiffer.js","node_modules/react-native/Libraries/Utilities/deepFreezeAndThrowOnMutationInDev.js","node_modules/react-native/Libraries/StyleSheet/flattenStyle.js","node_modules/react-native/Libraries/Core/ReactFiberErrorDialog.js","node_modules/react-native/Libraries/Components/AccessibilityInfo/legacySendAccessibilityEvent.ios.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var RCTEventEmitter = {
    register: function register(eventEmitter) {
      if (global.RN$Bridgeless) {
        global.RN$registerCallableModule('RCTEventEmitter', function () {
          return eventEmitter;
        });
      } else {
        _$$_REQUIRE(_dependencyMap[0]).registerCallableModule('RCTEventEmitter', eventEmitter);
      }
    }
  };
  module.exports = RCTEventEmitter;
},"node_modules/react-native/Libraries/EventEmitter/RCTEventEmitter.js",["node_modules/react-native/Libraries/BatchedBridge/BatchedBridge.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var customBubblingEventTypes = {};
  var customDirectEventTypes = {};
  exports.customBubblingEventTypes = customBubblingEventTypes;
  exports.customDirectEventTypes = customDirectEventTypes;
  var viewConfigCallbacks = new Map();
  var viewConfigs = new Map();

  function processEventTypes(viewConfig) {
    var bubblingEventTypes = viewConfig.bubblingEventTypes,
        directEventTypes = viewConfig.directEventTypes;

    if (bubblingEventTypes != null) {
      for (var _topLevelType in bubblingEventTypes) {
        if (customBubblingEventTypes[_topLevelType] == null) {
          customBubblingEventTypes[_topLevelType] = bubblingEventTypes[_topLevelType];
        }
      }
    }

    if (directEventTypes != null) {
      for (var _topLevelType2 in directEventTypes) {
        if (customDirectEventTypes[_topLevelType2] == null) {
          customDirectEventTypes[_topLevelType2] = directEventTypes[_topLevelType2];
        }
      }
    }
  }

  exports.register = function (name, callback) {
    (0, _invariant.default)(!viewConfigCallbacks.has(name), 'Tried to register two views with the same name %s', name);
    (0, _invariant.default)(typeof callback === 'function', 'View config getter callback for component `%s` must be a function (received `%s`)', name, callback === null ? 'null' : typeof callback);
    viewConfigCallbacks.set(name, callback);
    return name;
  };

  exports.get = function (name) {
    var viewConfig;

    if (!viewConfigs.has(name)) {
      var callback = viewConfigCallbacks.get(name);

      if (typeof callback !== 'function') {
        (0, _invariant.default)(false, 'View config getter callback for component `%s` must be a function (received `%s`).%s', name, callback === null ? 'null' : typeof callback, typeof name[0] === 'string' && /[a-z]/.test(name[0]) ? ' Make sure to start component names with a capital letter.' : '');
      }

      viewConfig = callback();
      processEventTypes(viewConfig);
      viewConfigs.set(name, viewConfig);
      viewConfigCallbacks.set(name, null);
    } else {
      viewConfig = viewConfigs.get(name);
    }

    (0, _invariant.default)(viewConfig, 'View config not found for name %s', name);
    return viewConfig;
  };
},"node_modules/react-native/Libraries/Renderer/shims/ReactNativeViewConfigRegistry.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var React = _$$_REQUIRE(_dependencyMap[0]);

  var currentlyFocusedInputRef = null;
  var inputs = new Set();

  function currentlyFocusedInput() {
    return currentlyFocusedInputRef;
  }

  function currentlyFocusedField() {
    return _$$_REQUIRE(_dependencyMap[1]).findNodeHandle(currentlyFocusedInputRef);
  }

  function focusInput(textField) {
    if (currentlyFocusedInputRef !== textField && textField != null) {
      currentlyFocusedInputRef = textField;
    }
  }

  function blurInput(textField) {
    if (currentlyFocusedInputRef === textField && textField != null) {
      currentlyFocusedInputRef = null;
    }
  }

  function focusField(textFieldID) {
    return;
  }

  function blurField(textFieldID) {
    return;
  }

  function focusTextInput(textField) {
    if (typeof textField === 'number') {
      return;
    }

    if (currentlyFocusedInputRef !== textField && textField != null) {
      focusInput(textField);
      {
        _$$_REQUIRE(_dependencyMap[2]).Commands.focus(textField);
      }
    }
  }

  function blurTextInput(textField) {
    if (typeof textField === 'number') {
      return;
    }

    if (currentlyFocusedInputRef === textField && textField != null) {
      blurInput(textField);
      {
        _$$_REQUIRE(_dependencyMap[2]).Commands.blur(textField);
      }
    }
  }

  function registerInput(textField) {
    if (typeof textField === 'number') {
      return;
    }

    inputs.add(textField);
  }

  function unregisterInput(textField) {
    if (typeof textField === 'number') {
      return;
    }

    inputs.delete(textField);
  }

  function isTextInput(textField) {
    if (typeof textField === 'number') {
      return false;
    }

    return inputs.has(textField);
  }

  module.exports = {
    currentlyFocusedInput: currentlyFocusedInput,
    focusInput: focusInput,
    blurInput: blurInput,
    currentlyFocusedField: currentlyFocusedField,
    focusField: focusField,
    blurField: blurField,
    focusTextInput: focusTextInput,
    blurTextInput: blurTextInput,
    registerInput: registerInput,
    unregisterInput: unregisterInput,
    isTextInput: isTextInput
  };
},"node_modules/react-native/Libraries/Components/TextInput/TextInputState.js",["node_modules/react/index.js","node_modules/react-native/Libraries/Renderer/shims/ReactNative.js","node_modules/react-native/Libraries/Components/TextInput/RCTSingelineTextInputNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.Commands = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _codegenNativeCommands = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _RCTTextInputViewConfig = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var NativeComponentRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var Commands = (0, _codegenNativeCommands.default)({
    supportedCommands: ['focus', 'blur', 'setTextAndSelection']
  });
  exports.Commands = Commands;
  var SinglelineTextInputNativeComponent = NativeComponentRegistry.get('RCTSinglelineTextInputView', function () {
    return (0, _extends2.default)({
      uiViewClassName: 'RCTSinglelineTextInputView'
    }, _RCTTextInputViewConfig.default);
  });
  var _default = SinglelineTextInputNativeComponent;
  exports.default = _default;
},"node_modules/react-native/Libraries/Components/TextInput/RCTSingelineTextInputNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Utilities/codegenNativeCommands.js","node_modules/react-native/Libraries/Components/TextInput/RCTTextInputViewConfig.js","node_modules/react-native/Libraries/NativeComponent/NativeComponentRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  function codegenNativeCommands(options) {
    var commandObj = {};
    options.supportedCommands.forEach(function (command) {
      commandObj[command] = function (ref) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        (0, _$$_REQUIRE(_dependencyMap[0]).dispatchCommand)(ref, command, args);
      };
    });
    return commandObj;
  }

  var _default = codegenNativeCommands;
  exports.default = _default;
},"node_modules/react-native/Libraries/Utilities/codegenNativeCommands.js",["node_modules/react-native/Libraries/Renderer/shims/ReactNative.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var RCTTextInputViewConfig = {
    bubblingEventTypes: {
      topBlur: {
        phasedRegistrationNames: {
          bubbled: 'onBlur',
          captured: 'onBlurCapture'
        }
      },
      topChange: {
        phasedRegistrationNames: {
          bubbled: 'onChange',
          captured: 'onChangeCapture'
        }
      },
      topContentSizeChange: {
        phasedRegistrationNames: {
          captured: 'onContentSizeChangeCapture',
          bubbled: 'onContentSizeChange'
        }
      },
      topEndEditing: {
        phasedRegistrationNames: {
          bubbled: 'onEndEditing',
          captured: 'onEndEditingCapture'
        }
      },
      topFocus: {
        phasedRegistrationNames: {
          bubbled: 'onFocus',
          captured: 'onFocusCapture'
        }
      },
      topKeyPress: {
        phasedRegistrationNames: {
          bubbled: 'onKeyPress',
          captured: 'onKeyPressCapture'
        }
      },
      topSubmitEditing: {
        phasedRegistrationNames: {
          bubbled: 'onSubmitEditing',
          captured: 'onSubmitEditingCapture'
        }
      },
      topTouchCancel: {
        phasedRegistrationNames: {
          bubbled: 'onTouchCancel',
          captured: 'onTouchCancelCapture'
        }
      },
      topTouchEnd: {
        phasedRegistrationNames: {
          bubbled: 'onTouchEnd',
          captured: 'onTouchEndCapture'
        }
      },
      topTouchMove: {
        phasedRegistrationNames: {
          bubbled: 'onTouchMove',
          captured: 'onTouchMoveCapture'
        }
      }
    },
    directEventTypes: {
      topTextInput: {
        registrationName: 'onTextInput'
      },
      topKeyPressSync: {
        registrationName: 'onKeyPressSync'
      },
      topScroll: {
        registrationName: 'onScroll'
      },
      topSelectionChange: {
        registrationName: 'onSelectionChange'
      },
      topChangeSync: {
        registrationName: 'onChangeSync'
      }
    },
    validAttributes: {
      fontSize: true,
      fontWeight: true,
      fontVariant: true,
      textShadowOffset: {
        diff: _$$_REQUIRE(_dependencyMap[0])
      },
      allowFontScaling: true,
      fontStyle: true,
      textTransform: true,
      textAlign: true,
      fontFamily: true,
      lineHeight: true,
      isHighlighted: true,
      writingDirection: true,
      textDecorationLine: true,
      textShadowRadius: true,
      letterSpacing: true,
      textDecorationStyle: true,
      textDecorationColor: {
        process: _$$_REQUIRE(_dependencyMap[1])
      },
      color: {
        process: _$$_REQUIRE(_dependencyMap[1])
      },
      maxFontSizeMultiplier: true,
      textShadowColor: {
        process: _$$_REQUIRE(_dependencyMap[1])
      },
      editable: true,
      inputAccessoryViewID: true,
      caretHidden: true,
      enablesReturnKeyAutomatically: true,
      placeholderTextColor: {
        process: _$$_REQUIRE(_dependencyMap[1])
      },
      clearButtonMode: true,
      keyboardType: true,
      selection: true,
      returnKeyType: true,
      blurOnSubmit: true,
      mostRecentEventCount: true,
      scrollEnabled: true,
      selectionColor: {
        process: _$$_REQUIRE(_dependencyMap[1])
      },
      contextMenuHidden: true,
      secureTextEntry: true,
      placeholder: true,
      autoCorrect: true,
      multiline: true,
      textContentType: true,
      maxLength: true,
      autoCapitalize: true,
      keyboardAppearance: true,
      passwordRules: true,
      spellCheck: true,
      selectTextOnFocus: true,
      text: true,
      clearTextOnFocus: true,
      showSoftInputOnFocus: true,
      autoFocus: true
    }
  };
  module.exports = RCTTextInputViewConfig;
},"node_modules/react-native/Libraries/Components/TextInput/RCTTextInputViewConfig.js",["node_modules/react-native/Libraries/Utilities/differ/sizesDiffer.js","node_modules/react-native/Libraries/StyleSheet/processColor.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var dummySize = {
    width: undefined,
    height: undefined
  };

  var sizesDiffer = function sizesDiffer(one, two) {
    var defaultedOne = one || dummySize;
    var defaultedTwo = two || dummySize;
    return defaultedOne !== defaultedTwo && (defaultedOne.width !== defaultedTwo.width || defaultedOne.height !== defaultedTwo.height);
  };

  module.exports = sizesDiffer;
},"node_modules/react-native/Libraries/Utilities/differ/sizesDiffer.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function processColor(color) {
    if (color === undefined || color === null) {
      return color;
    }

    var normalizedColor = _$$_REQUIRE(_dependencyMap[0])(color);

    if (normalizedColor === null || normalizedColor === undefined) {
      return undefined;
    }

    if (typeof normalizedColor === 'object') {
      var processColorObject = _$$_REQUIRE(_dependencyMap[1]).processColorObject;

      var processedColorObj = processColorObject(normalizedColor);

      if (processedColorObj != null) {
        return processedColorObj;
      }
    }

    if (typeof normalizedColor !== 'number') {
      return null;
    }

    normalizedColor = (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;
    return normalizedColor;
  }

  module.exports = processColor;
},"node_modules/react-native/Libraries/StyleSheet/processColor.js",["node_modules/react-native/Libraries/StyleSheet/normalizeColor.js","node_modules/react-native/Libraries/StyleSheet/PlatformColorValueTypes.ios.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _normalizeColor2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  function normalizeColor(color) {
    if (typeof color === 'object' && color != null) {
      var _require = _$$_REQUIRE(_dependencyMap[2]),
          normalizeColorObject = _require.normalizeColorObject;

      var normalizedColor = normalizeColorObject(color);

      if (normalizedColor != null) {
        return color;
      }
    }

    if (typeof color === 'string' || typeof color === 'number') {
      return (0, _normalizeColor2.default)(color);
    }
  }

  module.exports = normalizeColor;
},"node_modules/react-native/Libraries/StyleSheet/normalizeColor.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-native/normalize-color/index.js","node_modules/react-native/Libraries/StyleSheet/PlatformColorValueTypes.ios.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function normalizeColor(color) {
    if (typeof color === 'number') {
      if (color >>> 0 === color && color >= 0 && color <= 0xffffffff) {
        return color;
      }

      return null;
    }

    if (typeof color !== 'string') {
      return null;
    }

    var matchers = getMatchers();
    var match;

    if (match = matchers.hex6.exec(color)) {
      return parseInt(match[1] + 'ff', 16) >>> 0;
    }

    var colorFromKeyword = normalizeKeyword(color);

    if (colorFromKeyword != null) {
      return colorFromKeyword;
    }

    if (match = matchers.rgb.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 0x000000ff) >>> 0;
    }

    if (match = matchers.rgba.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
    }

    if (match = matchers.hex3.exec(color)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + 'ff', 16) >>> 0;
    }

    if (match = matchers.hex8.exec(color)) {
      return parseInt(match[1], 16) >>> 0;
    }

    if (match = matchers.hex4.exec(color)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
    }

    if (match = matchers.hsl.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 0x000000ff) >>> 0;
    }

    if (match = matchers.hsla.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
    }

    return null;
  }

  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }

    if (t > 1) {
      t -= 1;
    }

    if (t < 0.16666666666666666) {
      return p + (q - p) * 6 * t;
    }

    if (t < 0.5) {
      return q;
    }

    if (t < 0.6666666666666666) {
      return p + (q - p) * (0.6666666666666666 - t) * 6;
    }

    return p;
  }

  function hslToRgb(h, s, l) {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    var r = hue2rgb(p, q, h + 0.3333333333333333);
    var g = hue2rgb(p, q, h);
    var b = hue2rgb(p, q, h - 0.3333333333333333);
    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
  }

  var NUMBER = '[-+]?\\d*\\.?\\d+';
  var PERCENTAGE = "[-+]?\\d*\\.?\\d+%";

  function call() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return '\\(\\s*(' + args.join(')\\s*,\\s*(') + ')\\s*\\)';
  }

  var cachedMatchers;

  function getMatchers() {
    if (cachedMatchers === undefined) {
      cachedMatchers = {
        rgb: new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER)),
        rgba: new RegExp('rgba' + call(NUMBER, NUMBER, NUMBER, NUMBER)),
        hsl: new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hsla: new RegExp('hsla' + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)),
        hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#([0-9a-fA-F]{6})$/,
        hex8: /^#([0-9a-fA-F]{8})$/
      };
    }

    return cachedMatchers;
  }

  function parse255(str) {
    var int = parseInt(str, 10);

    if (int < 0) {
      return 0;
    }

    if (int > 255) {
      return 255;
    }

    return int;
  }

  function parse360(str) {
    var int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }

  function parse1(str) {
    var num = parseFloat(str);

    if (num < 0) {
      return 0;
    }

    if (num > 1) {
      return 255;
    }

    return Math.round(num * 255);
  }

  function parsePercentage(str) {
    var int = parseFloat(str);

    if (int < 0) {
      return 0;
    }

    if (int > 100) {
      return 1;
    }

    return int / 100;
  }

  function normalizeKeyword(name) {
    switch (name) {
      case 'transparent':
        return 0x00000000;

      case 'aliceblue':
        return 0xf0f8ffff;

      case 'antiquewhite':
        return 0xfaebd7ff;

      case 'aqua':
        return 0x00ffffff;

      case 'aquamarine':
        return 0x7fffd4ff;

      case 'azure':
        return 0xf0ffffff;

      case 'beige':
        return 0xf5f5dcff;

      case 'bisque':
        return 0xffe4c4ff;

      case 'black':
        return 0x000000ff;

      case 'blanchedalmond':
        return 0xffebcdff;

      case 'blue':
        return 0x0000ffff;

      case 'blueviolet':
        return 0x8a2be2ff;

      case 'brown':
        return 0xa52a2aff;

      case 'burlywood':
        return 0xdeb887ff;

      case 'burntsienna':
        return 0xea7e5dff;

      case 'cadetblue':
        return 0x5f9ea0ff;

      case 'chartreuse':
        return 0x7fff00ff;

      case 'chocolate':
        return 0xd2691eff;

      case 'coral':
        return 0xff7f50ff;

      case 'cornflowerblue':
        return 0x6495edff;

      case 'cornsilk':
        return 0xfff8dcff;

      case 'crimson':
        return 0xdc143cff;

      case 'cyan':
        return 0x00ffffff;

      case 'darkblue':
        return 0x00008bff;

      case 'darkcyan':
        return 0x008b8bff;

      case 'darkgoldenrod':
        return 0xb8860bff;

      case 'darkgray':
        return 0xa9a9a9ff;

      case 'darkgreen':
        return 0x006400ff;

      case 'darkgrey':
        return 0xa9a9a9ff;

      case 'darkkhaki':
        return 0xbdb76bff;

      case 'darkmagenta':
        return 0x8b008bff;

      case 'darkolivegreen':
        return 0x556b2fff;

      case 'darkorange':
        return 0xff8c00ff;

      case 'darkorchid':
        return 0x9932ccff;

      case 'darkred':
        return 0x8b0000ff;

      case 'darksalmon':
        return 0xe9967aff;

      case 'darkseagreen':
        return 0x8fbc8fff;

      case 'darkslateblue':
        return 0x483d8bff;

      case 'darkslategray':
        return 0x2f4f4fff;

      case 'darkslategrey':
        return 0x2f4f4fff;

      case 'darkturquoise':
        return 0x00ced1ff;

      case 'darkviolet':
        return 0x9400d3ff;

      case 'deeppink':
        return 0xff1493ff;

      case 'deepskyblue':
        return 0x00bfffff;

      case 'dimgray':
        return 0x696969ff;

      case 'dimgrey':
        return 0x696969ff;

      case 'dodgerblue':
        return 0x1e90ffff;

      case 'firebrick':
        return 0xb22222ff;

      case 'floralwhite':
        return 0xfffaf0ff;

      case 'forestgreen':
        return 0x228b22ff;

      case 'fuchsia':
        return 0xff00ffff;

      case 'gainsboro':
        return 0xdcdcdcff;

      case 'ghostwhite':
        return 0xf8f8ffff;

      case 'gold':
        return 0xffd700ff;

      case 'goldenrod':
        return 0xdaa520ff;

      case 'gray':
        return 0x808080ff;

      case 'green':
        return 0x008000ff;

      case 'greenyellow':
        return 0xadff2fff;

      case 'grey':
        return 0x808080ff;

      case 'honeydew':
        return 0xf0fff0ff;

      case 'hotpink':
        return 0xff69b4ff;

      case 'indianred':
        return 0xcd5c5cff;

      case 'indigo':
        return 0x4b0082ff;

      case 'ivory':
        return 0xfffff0ff;

      case 'khaki':
        return 0xf0e68cff;

      case 'lavender':
        return 0xe6e6faff;

      case 'lavenderblush':
        return 0xfff0f5ff;

      case 'lawngreen':
        return 0x7cfc00ff;

      case 'lemonchiffon':
        return 0xfffacdff;

      case 'lightblue':
        return 0xadd8e6ff;

      case 'lightcoral':
        return 0xf08080ff;

      case 'lightcyan':
        return 0xe0ffffff;

      case 'lightgoldenrodyellow':
        return 0xfafad2ff;

      case 'lightgray':
        return 0xd3d3d3ff;

      case 'lightgreen':
        return 0x90ee90ff;

      case 'lightgrey':
        return 0xd3d3d3ff;

      case 'lightpink':
        return 0xffb6c1ff;

      case 'lightsalmon':
        return 0xffa07aff;

      case 'lightseagreen':
        return 0x20b2aaff;

      case 'lightskyblue':
        return 0x87cefaff;

      case 'lightslategray':
        return 0x778899ff;

      case 'lightslategrey':
        return 0x778899ff;

      case 'lightsteelblue':
        return 0xb0c4deff;

      case 'lightyellow':
        return 0xffffe0ff;

      case 'lime':
        return 0x00ff00ff;

      case 'limegreen':
        return 0x32cd32ff;

      case 'linen':
        return 0xfaf0e6ff;

      case 'magenta':
        return 0xff00ffff;

      case 'maroon':
        return 0x800000ff;

      case 'mediumaquamarine':
        return 0x66cdaaff;

      case 'mediumblue':
        return 0x0000cdff;

      case 'mediumorchid':
        return 0xba55d3ff;

      case 'mediumpurple':
        return 0x9370dbff;

      case 'mediumseagreen':
        return 0x3cb371ff;

      case 'mediumslateblue':
        return 0x7b68eeff;

      case 'mediumspringgreen':
        return 0x00fa9aff;

      case 'mediumturquoise':
        return 0x48d1ccff;

      case 'mediumvioletred':
        return 0xc71585ff;

      case 'midnightblue':
        return 0x191970ff;

      case 'mintcream':
        return 0xf5fffaff;

      case 'mistyrose':
        return 0xffe4e1ff;

      case 'moccasin':
        return 0xffe4b5ff;

      case 'navajowhite':
        return 0xffdeadff;

      case 'navy':
        return 0x000080ff;

      case 'oldlace':
        return 0xfdf5e6ff;

      case 'olive':
        return 0x808000ff;

      case 'olivedrab':
        return 0x6b8e23ff;

      case 'orange':
        return 0xffa500ff;

      case 'orangered':
        return 0xff4500ff;

      case 'orchid':
        return 0xda70d6ff;

      case 'palegoldenrod':
        return 0xeee8aaff;

      case 'palegreen':
        return 0x98fb98ff;

      case 'paleturquoise':
        return 0xafeeeeff;

      case 'palevioletred':
        return 0xdb7093ff;

      case 'papayawhip':
        return 0xffefd5ff;

      case 'peachpuff':
        return 0xffdab9ff;

      case 'peru':
        return 0xcd853fff;

      case 'pink':
        return 0xffc0cbff;

      case 'plum':
        return 0xdda0ddff;

      case 'powderblue':
        return 0xb0e0e6ff;

      case 'purple':
        return 0x800080ff;

      case 'rebeccapurple':
        return 0x663399ff;

      case 'red':
        return 0xff0000ff;

      case 'rosybrown':
        return 0xbc8f8fff;

      case 'royalblue':
        return 0x4169e1ff;

      case 'saddlebrown':
        return 0x8b4513ff;

      case 'salmon':
        return 0xfa8072ff;

      case 'sandybrown':
        return 0xf4a460ff;

      case 'seagreen':
        return 0x2e8b57ff;

      case 'seashell':
        return 0xfff5eeff;

      case 'sienna':
        return 0xa0522dff;

      case 'silver':
        return 0xc0c0c0ff;

      case 'skyblue':
        return 0x87ceebff;

      case 'slateblue':
        return 0x6a5acdff;

      case 'slategray':
        return 0x708090ff;

      case 'slategrey':
        return 0x708090ff;

      case 'snow':
        return 0xfffafaff;

      case 'springgreen':
        return 0x00ff7fff;

      case 'steelblue':
        return 0x4682b4ff;

      case 'tan':
        return 0xd2b48cff;

      case 'teal':
        return 0x008080ff;

      case 'thistle':
        return 0xd8bfd8ff;

      case 'tomato':
        return 0xff6347ff;

      case 'turquoise':
        return 0x40e0d0ff;

      case 'violet':
        return 0xee82eeff;

      case 'wheat':
        return 0xf5deb3ff;

      case 'white':
        return 0xffffffff;

      case 'whitesmoke':
        return 0xf5f5f5ff;

      case 'yellow':
        return 0xffff00ff;

      case 'yellowgreen':
        return 0x9acd32ff;
    }

    return null;
  }

  module.exports = normalizeColor;
},"node_modules/@react-native/normalize-color/index.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.processColorObject = exports.normalizeColorObject = exports.PlatformColor = exports.DynamicColorIOSPrivate = undefined;

  var PlatformColor = function PlatformColor() {
    for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {
      names[_key] = arguments[_key];
    }

    return {
      semantic: names
    };
  };

  exports.PlatformColor = PlatformColor;

  var DynamicColorIOSPrivate = function DynamicColorIOSPrivate(tuple) {
    return {
      dynamic: {
        light: tuple.light,
        dark: tuple.dark,
        highContrastLight: tuple.highContrastLight,
        highContrastDark: tuple.highContrastDark
      }
    };
  };

  exports.DynamicColorIOSPrivate = DynamicColorIOSPrivate;

  var normalizeColorObject = function normalizeColorObject(color) {
    if ('semantic' in color) {
      return color;
    } else if ('dynamic' in color && color.dynamic !== undefined) {
      var normalizeColor = _$$_REQUIRE(_dependencyMap[0]);

      var dynamic = color.dynamic;
      var dynamicColor = {
        dynamic: {
          light: normalizeColor(dynamic.light),
          dark: normalizeColor(dynamic.dark),
          highContrastLight: normalizeColor(dynamic.highContrastLight),
          highContrastDark: normalizeColor(dynamic.highContrastDark)
        }
      };
      return dynamicColor;
    }

    return null;
  };

  exports.normalizeColorObject = normalizeColorObject;

  var processColorObject = function processColorObject(color) {
    if ('dynamic' in color && color.dynamic != null) {
      var processColor = _$$_REQUIRE(_dependencyMap[1]);

      var dynamic = color.dynamic;
      var dynamicColor = {
        dynamic: {
          light: processColor(dynamic.light),
          dark: processColor(dynamic.dark),
          highContrastLight: processColor(dynamic.highContrastLight),
          highContrastDark: processColor(dynamic.highContrastDark)
        }
      };
      return dynamicColor;
    }

    return color;
  };

  exports.processColorObject = processColorObject;
},"node_modules/react-native/Libraries/StyleSheet/PlatformColorValueTypes.ios.js",["node_modules/react-native/Libraries/StyleSheet/normalizeColor.js","node_modules/react-native/Libraries/StyleSheet/processColor.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.get = get;
  exports.getWithFallback_DEPRECATED = getWithFallback_DEPRECATED;
  exports.setRuntimeConfigProvider = setRuntimeConfigProvider;
  exports.unstable_hasStaticViewConfig = unstable_hasStaticViewConfig;

  var StaticViewConfigValidator = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _UIManager = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  var _ReactNativeViewConfigRegistry = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[3]));

  var _getNativeComponentAttributes = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[4]));

  var _verifyComponentAttributeEquivalence = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[5]));

  var _invariant = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[6]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[7]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var getRuntimeConfig;
  var componentNameToExists = new Map();

  function setRuntimeConfigProvider(runtimeConfigProvider) {
    (0, _invariant.default)(getRuntimeConfig == null, 'NativeComponentRegistry.setRuntimeConfigProvider() called more than once.');
    getRuntimeConfig = runtimeConfigProvider;
  }

  function get(name, viewConfigProvider) {
    _ReactNativeViewConfigRegistry.default.register(name, function () {
      var _getRuntimeConfig;

      var _ref = (_getRuntimeConfig = getRuntimeConfig == null ? undefined : getRuntimeConfig(name)) != null ? _getRuntimeConfig : {
        native: true,
        strict: false,
        verify: false
      },
          native = _ref.native,
          strict = _ref.strict,
          verify = _ref.verify;

      var viewConfig = native ? (0, _getNativeComponentAttributes.default)(name) : (0, _$$_REQUIRE(_dependencyMap[8]).createViewConfig)(viewConfigProvider());

      if (verify) {
        var nativeViewConfig = native ? viewConfig : (0, _getNativeComponentAttributes.default)(name);
        var staticViewConfig = native ? (0, _$$_REQUIRE(_dependencyMap[8]).createViewConfig)(viewConfigProvider()) : viewConfig;

        if (strict) {
          var validationOutput = StaticViewConfigValidator.validate(name, nativeViewConfig, staticViewConfig);

          if (validationOutput.type === 'invalid') {
            console.error(StaticViewConfigValidator.stringifyValidationResult(name, validationOutput));
          }
        } else {
          (0, _verifyComponentAttributeEquivalence.default)(nativeViewConfig, staticViewConfig);
        }
      }

      return viewConfig;
    });

    return name;
  }

  function getWithFallback_DEPRECATED(name, viewConfigProvider) {
    if (getRuntimeConfig == null) {
      if (hasNativeViewConfig(name)) {
        return get(name, viewConfigProvider);
      }
    } else {
      if (getRuntimeConfig(name) != null) {
        return get(name, viewConfigProvider);
      }
    }

    var FallbackNativeComponent = function FallbackNativeComponent(props) {
      return null;
    };

    FallbackNativeComponent.displayName = "Fallback(" + name + ")";
    return FallbackNativeComponent;
  }

  function hasNativeViewConfig(name) {
    (0, _invariant.default)(getRuntimeConfig == null, 'Unexpected invocation!');
    return _UIManager.default.getViewManagerConfig(name) != null;
  }

  function unstable_hasStaticViewConfig(name) {
    var _getRuntimeConfig2;

    var _ref2 = (_getRuntimeConfig2 = getRuntimeConfig == null ? undefined : getRuntimeConfig(name)) != null ? _getRuntimeConfig2 : {
      native: true
    },
        native = _ref2.native;

    return !native;
  }
},"node_modules/react-native/Libraries/NativeComponent/NativeComponentRegistry.js",["node_modules/react-native/Libraries/NativeComponent/StaticViewConfigValidator.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/ReactNative/UIManager.js","node_modules/react-native/Libraries/Renderer/shims/ReactNativeViewConfigRegistry.js","node_modules/react-native/Libraries/ReactNative/getNativeComponentAttributes.js","node_modules/react-native/Libraries/Utilities/verifyComponentAttributeEquivalence.js","node_modules/invariant/browser.js","node_modules/react/index.js","node_modules/react-native/Libraries/NativeComponent/ViewConfig.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.stringifyValidationResult = stringifyValidationResult;
  exports.validate = validate;
  exports.validateStaticViewConfigs = validateStaticViewConfigs;

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _getNativeComponentAttributes = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  function validateStaticViewConfigs(nativeComponent) {
    var nativeViewConfig = (0, _getNativeComponentAttributes.default)(nativeComponent.default || nativeComponent);
    var generatedPartialViewConfig = nativeComponent.__INTERNAL_VIEW_CONFIG;
    var staticViewConfig = generatedPartialViewConfig && (0, _$$_REQUIRE(_dependencyMap[3]).createViewConfig)(generatedPartialViewConfig);
    var componentName = nativeComponent.default || nativeComponent;
    var validationResult = nativeViewConfig && staticViewConfig && validate(componentName, nativeViewConfig, staticViewConfig);
    return {
      componentName: componentName,
      nativeViewConfig: nativeViewConfig,
      staticViewConfig: staticViewConfig,
      validationResult: validationResult
    };
  }

  function validate(name, nativeViewConfig, staticViewConfig) {
    var differences = [];
    accumulateDifferences(differences, [], {
      bubblingEventTypes: nativeViewConfig.bubblingEventTypes,
      directEventTypes: nativeViewConfig.directEventTypes,
      uiViewClassName: nativeViewConfig.uiViewClassName,
      validAttributes: nativeViewConfig.validAttributes
    }, {
      bubblingEventTypes: staticViewConfig.bubblingEventTypes,
      directEventTypes: staticViewConfig.directEventTypes,
      uiViewClassName: staticViewConfig.uiViewClassName,
      validAttributes: staticViewConfig.validAttributes
    });

    if (differences.length === 0) {
      return {
        type: 'valid'
      };
    }

    return {
      type: 'invalid',
      differences: differences
    };
  }

  function stringifyValidationResult(name, validationResult) {
    var differences = validationResult.differences;
    return ["StaticViewConfigValidator: Invalid static view config for '" + name + "'.", ''].concat((0, _toConsumableArray2.default)(differences.map(function (difference) {
      var type = difference.type,
          path = difference.path;

      switch (type) {
        case 'missing':
          return "- '" + path.join('.') + "' is missing.";

        case 'unequal':
          return "- '" + path.join('.') + "' is the wrong value.";

        case 'unexpected':
          return "- '" + path.join('.') + "' is present but not expected to be.";
      }
    })), ['']).join('\n');
  }

  function accumulateDifferences(differences, path, nativeObject, staticObject) {
    for (var nativeKey in nativeObject) {
      var nativeValue = nativeObject[nativeKey];

      if (!staticObject.hasOwnProperty(nativeKey)) {
        differences.push({
          path: [].concat((0, _toConsumableArray2.default)(path), [nativeKey]),
          type: 'missing',
          nativeValue: nativeValue
        });
        continue;
      }

      var staticValue = staticObject[nativeKey];
      var nativeValueIfObject = ifObject(nativeValue);

      if (nativeValueIfObject != null) {
        var staticValueIfObject = ifObject(staticValue);

        if (staticValueIfObject != null) {
          path.push(nativeKey);
          accumulateDifferences(differences, path, nativeValueIfObject, staticValueIfObject);
          path.pop();
          continue;
        }
      }

      if (nativeValue !== staticValue) {
        differences.push({
          path: [].concat((0, _toConsumableArray2.default)(path), [nativeKey]),
          type: 'unequal',
          nativeValue: nativeValue,
          staticValue: staticValue
        });
      }
    }

    for (var staticKey in staticObject) {
      if (!nativeObject.hasOwnProperty(staticKey)) {
        differences.push({
          path: [].concat((0, _toConsumableArray2.default)(path), [staticKey]),
          type: 'unexpected',
          staticValue: staticObject[staticKey]
        });
      }
    }
  }

  function ifObject(value) {
    return typeof value === 'object' && !Array.isArray(value) ? value : null;
  }
},"node_modules/react-native/Libraries/NativeComponent/StaticViewConfigValidator.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/react-native/Libraries/ReactNative/getNativeComponentAttributes.js","node_modules/react-native/Libraries/NativeComponent/ViewConfig.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function getNativeComponentAttributes(uiViewClassName) {
    var _bubblingEventTypes, _directEventTypes;

    var viewConfig = _$$_REQUIRE(_dependencyMap[0]).getViewManagerConfig(uiViewClassName);

    _$$_REQUIRE(_dependencyMap[1])(viewConfig != null && viewConfig.NativeProps != null, 'requireNativeComponent: "%s" was not found in the UIManager.', uiViewClassName);

    var baseModuleName = viewConfig.baseModuleName,
        bubblingEventTypes = viewConfig.bubblingEventTypes,
        directEventTypes = viewConfig.directEventTypes;
    var nativeProps = viewConfig.NativeProps;
    bubblingEventTypes = (_bubblingEventTypes = bubblingEventTypes) != null ? _bubblingEventTypes : {};
    directEventTypes = (_directEventTypes = directEventTypes) != null ? _directEventTypes : {};

    while (baseModuleName) {
      var baseModule = _$$_REQUIRE(_dependencyMap[0]).getViewManagerConfig(baseModuleName);

      if (!baseModule) {
        baseModuleName = null;
      } else {
        bubblingEventTypes = _$$_REQUIRE(_dependencyMap[2])({}, baseModule.bubblingEventTypes, bubblingEventTypes);
        directEventTypes = _$$_REQUIRE(_dependencyMap[2])({}, baseModule.directEventTypes, directEventTypes);
        nativeProps = _$$_REQUIRE(_dependencyMap[2])({}, baseModule.NativeProps, nativeProps);
        baseModuleName = baseModule.baseModuleName;
      }
    }

    var validAttributes = {};

    for (var key in nativeProps) {
      var typeName = nativeProps[key];
      var diff = getDifferForType(typeName);
      var process = getProcessorForType(typeName);
      validAttributes[key] = diff == null ? process == null ? true : {
        process: process
      } : process == null ? {
        diff: diff
      } : {
        diff: diff,
        process: process
      };
    }

    validAttributes.style = _$$_REQUIRE(_dependencyMap[3]);

    _$$_REQUIRE(_dependencyMap[2])(viewConfig, {
      uiViewClassName: uiViewClassName,
      validAttributes: validAttributes,
      bubblingEventTypes: bubblingEventTypes,
      directEventTypes: directEventTypes
    });

    attachDefaultEventTypes(viewConfig);
    return viewConfig;
  }

  function attachDefaultEventTypes(viewConfig) {
    var constants = _$$_REQUIRE(_dependencyMap[0]).getConstants();

    if (constants.ViewManagerNames || constants.LazyViewManagersEnabled) {
      viewConfig = merge(viewConfig, _$$_REQUIRE(_dependencyMap[0]).getDefaultEventTypes());
    } else {
      viewConfig.bubblingEventTypes = merge(viewConfig.bubblingEventTypes, constants.genericBubblingEventTypes);
      viewConfig.directEventTypes = merge(viewConfig.directEventTypes, constants.genericDirectEventTypes);
    }
  }

  function merge(destination, source) {
    if (!source) {
      return destination;
    }

    if (!destination) {
      return source;
    }

    for (var key in source) {
      if (!source.hasOwnProperty(key)) {
        continue;
      }

      var sourceValue = source[key];

      if (destination.hasOwnProperty(key)) {
        var destinationValue = destination[key];

        if (typeof sourceValue === 'object' && typeof destinationValue === 'object') {
          sourceValue = merge(destinationValue, sourceValue);
        }
      }

      destination[key] = sourceValue;
    }

    return destination;
  }

  function getDifferForType(typeName) {
    switch (typeName) {
      case 'CATransform3D':
        return _$$_REQUIRE(_dependencyMap[4]);

      case 'CGPoint':
        return _$$_REQUIRE(_dependencyMap[5]);

      case 'CGSize':
        return _$$_REQUIRE(_dependencyMap[6]);

      case 'UIEdgeInsets':
        return _$$_REQUIRE(_dependencyMap[7]);

      case 'Point':
        return _$$_REQUIRE(_dependencyMap[5]);

      case 'EdgeInsets':
        return _$$_REQUIRE(_dependencyMap[7]);
    }

    return null;
  }

  function getProcessorForType(typeName) {
    switch (typeName) {
      case 'CGColor':
      case 'UIColor':
        return _$$_REQUIRE(_dependencyMap[8]);

      case 'CGColorArray':
      case 'UIColorArray':
        return _$$_REQUIRE(_dependencyMap[9]);

      case 'CGImage':
      case 'UIImage':
      case 'RCTImageSource':
        return _$$_REQUIRE(_dependencyMap[10]);

      case 'Color':
        return _$$_REQUIRE(_dependencyMap[8]);

      case 'ColorArray':
        return _$$_REQUIRE(_dependencyMap[9]);

      case 'ImageSource':
        return _$$_REQUIRE(_dependencyMap[10]);
    }

    return null;
  }

  module.exports = getNativeComponentAttributes;
},"node_modules/react-native/Libraries/ReactNative/getNativeComponentAttributes.js",["node_modules/react-native/Libraries/ReactNative/UIManager.js","node_modules/invariant/browser.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js","node_modules/react-native/Libraries/Utilities/differ/matricesDiffer.js","node_modules/react-native/Libraries/Utilities/differ/pointsDiffer.js","node_modules/react-native/Libraries/Utilities/differ/sizesDiffer.js","node_modules/react-native/Libraries/Utilities/differ/insetsDiffer.js","node_modules/react-native/Libraries/StyleSheet/processColor.js","node_modules/react-native/Libraries/StyleSheet/processColorArray.js","node_modules/react-native/Libraries/Image/resolveAssetSource.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _require$default$unst;

  var UIManager = global.RN$Bridgeless === true ? _$$_REQUIRE(_dependencyMap[0]) : (_require$default$unst = _$$_REQUIRE(_dependencyMap[1]).default.unstable_UIManager) != null ? _require$default$unst : _$$_REQUIRE(_dependencyMap[2]);
  module.exports = UIManager;
},"node_modules/react-native/Libraries/ReactNative/UIManager.js",["node_modules/react-native/Libraries/ReactNative/DummyUIManager.js","node_modules/react-native/Libraries/ReactNative/UIManagerInjection.js","node_modules/react-native/Libraries/ReactNative/PaperUIManager.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = {
    getViewManagerConfig: function getViewManagerConfig(viewManagerName) {
      console.warn('getViewManagerConfig is unavailable in Bridgeless, use hasViewManagerConfig instead. viewManagerName: ' + viewManagerName);

      if (viewManagerName === 'RCTVirtualText') {
        return {};
      }

      return null;
    },
    hasViewManagerConfig: function hasViewManagerConfig(viewManagerName) {
      var staticViewConfigsEnabled = global.__fbStaticViewConfig === true;

      if (staticViewConfigsEnabled) {
        return (0, _$$_REQUIRE(_dependencyMap[0]).unstable_hasComponent)(viewManagerName);
      } else {
        return viewManagerName === 'RCTVirtualText' || viewManagerName === 'RCTShimmeringView';
      }
    },
    getConstants: function getConstants() {
      return {};
    },
    getConstantsForViewManager: function getConstantsForViewManager(viewManagerName) {},
    getDefaultEventTypes: function getDefaultEventTypes() {
      return [];
    },
    lazilyLoadView: function lazilyLoadView(name) {},
    createView: function createView(reactTag, viewName, rootTag, props) {},
    updateView: function updateView(reactTag, viewName, props) {},
    focus: function focus(reactTag) {},
    blur: function blur(reactTag) {},
    findSubviewIn: function findSubviewIn(reactTag, point, callback) {},
    dispatchViewManagerCommand: function dispatchViewManagerCommand(reactTag, commandID, commandArgs) {},
    measure: function measure(reactTag, callback) {},
    measureInWindow: function measureInWindow(reactTag, callback) {},
    viewIsDescendantOf: function viewIsDescendantOf(reactTag, ancestorReactTag, callback) {},
    measureLayout: function measureLayout(reactTag, ancestorReactTag, errorCallback, callback) {},
    measureLayoutRelativeToParent: function measureLayoutRelativeToParent(reactTag, errorCallback, callback) {},
    setJSResponder: function setJSResponder(reactTag, blockNativeResponder) {},
    clearJSResponder: function clearJSResponder() {},
    configureNextLayoutAnimation: function configureNextLayoutAnimation(config, callback, errorCallback) {},
    removeSubviewsFromContainerWithID: function removeSubviewsFromContainerWithID(containerID) {},
    replaceExistingNonRootView: function replaceExistingNonRootView(reactTag, newReactTag) {},
    setChildren: function setChildren(containerTag, reactTags) {},
    manageChildren: function manageChildren(containerTag, moveFromIndices, moveToIndices, addChildReactTags, addAtIndices, removeAtIndices) {},
    setLayoutAnimationEnabledExperimental: function setLayoutAnimationEnabledExperimental(enabled) {},
    sendAccessibilityEvent: function sendAccessibilityEvent(reactTag, eventType) {},
    showPopupMenu: function showPopupMenu(reactTag, items, error, success) {},
    dismissPopupMenu: function dismissPopupMenu() {}
  };
},"node_modules/react-native/Libraries/ReactNative/DummyUIManager.js",["node_modules/react-native/Libraries/NativeComponent/NativeComponentRegistryUnstable.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.unstable_hasComponent = unstable_hasComponent;
  var componentNameToExists = new Map();

  function unstable_hasComponent(name) {
    var hasNativeComponent = componentNameToExists.get(name);

    if (hasNativeComponent == null) {
      if (global.__nativeComponentRegistry__hasComponent) {
        hasNativeComponent = global.__nativeComponentRegistry__hasComponent(name);
        componentNameToExists.set(name, hasNativeComponent);
      } else {
        throw "unstable_hasComponent('" + name + "'): Global function is not registered";
      }
    }

    return hasNativeComponent;
  }
},"node_modules/react-native/Libraries/NativeComponent/NativeComponentRegistryUnstable.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = {
    unstable_UIManager: null
  };
  exports.default = _default;
},"node_modules/react-native/Libraries/ReactNative/UIManagerInjection.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _NativeUIManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var viewManagerConfigs = {};
  var triedLoadingConfig = new Set();
  var NativeUIManagerConstants = {};
  var isNativeUIManagerConstantsSet = false;

  function _getConstants() {
    if (!isNativeUIManagerConstantsSet) {
      NativeUIManagerConstants = _NativeUIManager.default.getConstants();
      isNativeUIManagerConstantsSet = true;
    }

    return NativeUIManagerConstants;
  }

  function _getViewManagerConfig(viewManagerName) {
    if (viewManagerConfigs[viewManagerName] === undefined && global.nativeCallSyncHook && _NativeUIManager.default.getConstantsForViewManager) {
      try {
        viewManagerConfigs[viewManagerName] = _NativeUIManager.default.getConstantsForViewManager(viewManagerName);
      } catch (e) {
        console.error("NativeUIManager.getConstantsForViewManager('" + viewManagerName + "') threw an exception.", e);
        viewManagerConfigs[viewManagerName] = null;
      }
    }

    var config = viewManagerConfigs[viewManagerName];

    if (config) {
      return config;
    }

    if (!global.nativeCallSyncHook) {
      return config;
    }

    if (_NativeUIManager.default.lazilyLoadView && !triedLoadingConfig.has(viewManagerName)) {
      var result = _NativeUIManager.default.lazilyLoadView(viewManagerName);

      triedLoadingConfig.add(viewManagerName);

      if (result != null && result.viewConfig != null) {
        _getConstants()[viewManagerName] = result.viewConfig;
        lazifyViewManagerConfig(viewManagerName);
      }
    }

    return viewManagerConfigs[viewManagerName];
  }

  var UIManagerJS = (0, _extends2.default)({}, _NativeUIManager.default, {
    createView: function createView(reactTag, viewName, rootTag, props) {
      if (viewManagerConfigs[viewName] === undefined) {
        _getViewManagerConfig(viewName);
      }

      _NativeUIManager.default.createView(reactTag, viewName, rootTag, props);
    },
    getConstants: function getConstants() {
      return _getConstants();
    },
    getViewManagerConfig: function getViewManagerConfig(viewManagerName) {
      return _getViewManagerConfig(viewManagerName);
    },
    hasViewManagerConfig: function hasViewManagerConfig(viewManagerName) {
      return _getViewManagerConfig(viewManagerName) != null;
    }
  });
  _NativeUIManager.default.getViewManagerConfig = UIManagerJS.getViewManagerConfig;

  function lazifyViewManagerConfig(viewName) {
    var viewConfig = _getConstants()[viewName];

    viewManagerConfigs[viewName] = viewConfig;

    if (viewConfig.Manager) {
      _$$_REQUIRE(_dependencyMap[3])(viewConfig, 'Constants', {
        get: function get() {
          var viewManager = _$$_REQUIRE(_dependencyMap[4])[viewConfig.Manager];

          var constants = {};
          viewManager && Object.keys(viewManager).forEach(function (key) {
            var value = viewManager[key];

            if (typeof value !== 'function') {
              constants[key] = value;
            }
          });
          return constants;
        }
      });

      _$$_REQUIRE(_dependencyMap[3])(viewConfig, 'Commands', {
        get: function get() {
          var viewManager = _$$_REQUIRE(_dependencyMap[4])[viewConfig.Manager];

          var commands = {};
          var index = 0;
          viewManager && Object.keys(viewManager).forEach(function (key) {
            var value = viewManager[key];

            if (typeof value === 'function') {
              commands[key] = index++;
            }
          });
          return commands;
        }
      });
    }
  }

  {
    Object.keys(_getConstants()).forEach(function (viewName) {
      lazifyViewManagerConfig(viewName);
    });
  }

  if (!global.nativeCallSyncHook) {
    Object.keys(_getConstants()).forEach(function (viewManagerName) {
      if (!_$$_REQUIRE(_dependencyMap[5]).includes(viewManagerName)) {
        if (!viewManagerConfigs[viewManagerName]) {
          viewManagerConfigs[viewManagerName] = _getConstants()[viewManagerName];
        }

        _$$_REQUIRE(_dependencyMap[3])(_NativeUIManager.default, viewManagerName, {
          get: function get() {
            console.warn("Accessing view manager configs directly off UIManager via UIManager['" + viewManagerName + "'] " + ("is no longer supported. Use UIManager.getViewManagerConfig('" + viewManagerName + "') instead."));
            return UIManagerJS.getViewManagerConfig(viewManagerName);
          }
        });
      }
    });
  }

  module.exports = UIManagerJS;
},"node_modules/react-native/Libraries/ReactNative/PaperUIManager.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/ReactNative/NativeUIManager.js","node_modules/react-native/Libraries/Utilities/defineLazyObjectProperty.js","node_modules/react-native/Libraries/BatchedBridge/NativeModules.js","node_modules/react-native/Libraries/ReactNative/UIManagerProperties.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.getEnforcing('UIManager');

  exports.default = _default;
},"node_modules/react-native/Libraries/ReactNative/NativeUIManager.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = ['clearJSResponder', 'configureNextLayoutAnimation', 'createView', 'dismissPopupMenu', 'dispatchViewManagerCommand', 'findSubviewIn', 'getConstantsForViewManager', 'getDefaultEventTypes', 'manageChildren', 'measure', 'measureInWindow', 'measureLayout', 'measureLayoutRelativeToParent', 'removeRootView', 'removeSubviewsFromContainerWithID', 'replaceExistingNonRootView', 'sendAccessibilityEvent', 'setChildren', 'setJSResponder', 'setLayoutAnimationEnabledExperimental', 'showPopupMenu', 'updateView', 'viewIsDescendantOf', 'PopupMenu', 'LazyViewManagersEnabled', 'ViewManagerNames', 'StyleConstants', 'AccessibilityEventTypes', 'UIView', 'getViewManagerConfig', 'hasViewManagerConfig', 'blur', 'focus', 'genericBubblingEventTypes', 'genericDirectEventTypes', 'lazilyLoadView'];
},"node_modules/react-native/Libraries/ReactNative/UIManagerProperties.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _processColor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _processTransform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _sizesDiffer = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var colorAttributes = {
    process: _processColor.default
  };
  var ReactNativeStyleAttributes = {
    alignContent: true,
    alignItems: true,
    alignSelf: true,
    aspectRatio: true,
    borderBottomWidth: true,
    borderEndWidth: true,
    borderLeftWidth: true,
    borderRightWidth: true,
    borderStartWidth: true,
    borderTopWidth: true,
    borderWidth: true,
    bottom: true,
    direction: true,
    display: true,
    end: true,
    flex: true,
    flexBasis: true,
    flexDirection: true,
    flexGrow: true,
    flexShrink: true,
    flexWrap: true,
    height: true,
    justifyContent: true,
    left: true,
    margin: true,
    marginBottom: true,
    marginEnd: true,
    marginHorizontal: true,
    marginLeft: true,
    marginRight: true,
    marginStart: true,
    marginTop: true,
    marginVertical: true,
    maxHeight: true,
    maxWidth: true,
    minHeight: true,
    minWidth: true,
    overflow: true,
    padding: true,
    paddingBottom: true,
    paddingEnd: true,
    paddingHorizontal: true,
    paddingLeft: true,
    paddingRight: true,
    paddingStart: true,
    paddingTop: true,
    paddingVertical: true,
    position: true,
    right: true,
    start: true,
    top: true,
    width: true,
    zIndex: true,
    elevation: true,
    shadowColor: colorAttributes,
    shadowOffset: {
      diff: _sizesDiffer.default
    },
    shadowOpacity: true,
    shadowRadius: true,
    decomposedMatrix: true,
    rotation: true,
    scaleX: true,
    scaleY: true,
    transform: {
      process: _processTransform.default
    },
    transformMatrix: true,
    translateX: true,
    translateY: true,
    backfaceVisibility: true,
    backgroundColor: colorAttributes,
    borderBottomColor: colorAttributes,
    borderBottomEndRadius: true,
    borderBottomLeftRadius: true,
    borderBottomRightRadius: true,
    borderBottomStartRadius: true,
    borderColor: colorAttributes,
    borderEndColor: colorAttributes,
    borderLeftColor: colorAttributes,
    borderRadius: true,
    borderRightColor: colorAttributes,
    borderStartColor: colorAttributes,
    borderStyle: true,
    borderTopColor: colorAttributes,
    borderTopEndRadius: true,
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderTopStartRadius: true,
    opacity: true,
    color: colorAttributes,
    fontFamily: true,
    fontSize: true,
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    includeFontPadding: true,
    letterSpacing: true,
    lineHeight: true,
    textAlign: true,
    textAlignVertical: true,
    textDecorationColor: colorAttributes,
    textDecorationLine: true,
    textDecorationStyle: true,
    textShadowColor: colorAttributes,
    textShadowOffset: true,
    textShadowRadius: true,
    textTransform: true,
    writingDirection: true,
    overlayColor: colorAttributes,
    resizeMode: true,
    tintColor: colorAttributes
  };
  module.exports = ReactNativeStyleAttributes;
},"node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/StyleSheet/processColor.js","node_modules/react-native/Libraries/StyleSheet/processTransform.js","node_modules/react-native/Libraries/Utilities/differ/sizesDiffer.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function processTransform(transform) {
    {
      return transform;
    }

    var result = _$$_REQUIRE(_dependencyMap[0]).createIdentityMatrix();

    transform.forEach(function (transformation) {
      var key = Object.keys(transformation)[0];
      var value = transformation[key];

      switch (key) {
        case 'matrix':
          _$$_REQUIRE(_dependencyMap[0]).multiplyInto(result, result, value);

          break;

        case 'perspective':
          _multiplyTransform(result, _$$_REQUIRE(_dependencyMap[0]).reusePerspectiveCommand, [value]);

          break;

        case 'rotateX':
          _multiplyTransform(result, _$$_REQUIRE(_dependencyMap[0]).reuseRotateXCommand, [_convertToRadians(value)]);

          break;

        case 'rotateY':
          _multiplyTransform(result, _$$_REQUIRE(_dependencyMap[0]).reuseRotateYCommand, [_convertToRadians(value)]);

          break;

        case 'rotate':
        case 'rotateZ':
          _multiplyTransform(result, _$$_REQUIRE(_dependencyMap[0]).reuseRotateZCommand, [_convertToRadians(value)]);

          break;

        case 'scale':
          _multiplyTransform(result, _$$_REQUIRE(_dependencyMap[0]).reuseScaleCommand, [value]);

          break;

        case 'scaleX':
          _multiplyTransform(result, _$$_REQUIRE(_dependencyMap[0]).reuseScaleXCommand, [value]);

          break;

        case 'scaleY':
          _multiplyTransform(result, _$$_REQUIRE(_dependencyMap[0]).reuseScaleYCommand, [value]);

          break;

        case 'translate':
          _multiplyTransform(result, _$$_REQUIRE(_dependencyMap[0]).reuseTranslate3dCommand, [value[0], value[1], value[2] || 0]);

          break;

        case 'translateX':
          _multiplyTransform(result, _$$_REQUIRE(_dependencyMap[0]).reuseTranslate2dCommand, [value, 0]);

          break;

        case 'translateY':
          _multiplyTransform(result, _$$_REQUIRE(_dependencyMap[0]).reuseTranslate2dCommand, [0, value]);

          break;

        case 'skewX':
          _multiplyTransform(result, _$$_REQUIRE(_dependencyMap[0]).reuseSkewXCommand, [_convertToRadians(value)]);

          break;

        case 'skewY':
          _multiplyTransform(result, _$$_REQUIRE(_dependencyMap[0]).reuseSkewYCommand, [_convertToRadians(value)]);

          break;

        default:
          throw new Error('Invalid transform name: ' + key);
      }
    });
    return result;
  }

  function _multiplyTransform(result, matrixMathFunction, args) {
    var matrixToApply = _$$_REQUIRE(_dependencyMap[0]).createIdentityMatrix();

    var argsWithIdentity = [matrixToApply].concat(args);
    matrixMathFunction.apply(this, argsWithIdentity);

    _$$_REQUIRE(_dependencyMap[0]).multiplyInto(result, result, matrixToApply);
  }

  function _convertToRadians(value) {
    var floatValue = parseFloat(value);
    return value.indexOf('rad') > -1 ? floatValue : floatValue * Math.PI / 180;
  }

  module.exports = processTransform;
},"node_modules/react-native/Libraries/StyleSheet/processTransform.js",["node_modules/react-native/Libraries/Utilities/MatrixMath.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var MatrixMath = {
    createIdentityMatrix: function createIdentityMatrix() {
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    },
    createCopy: function createCopy(m) {
      return [m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]];
    },
    createOrthographic: function createOrthographic(left, right, bottom, top, near, far) {
      var a = 2 / (right - left);
      var b = 2 / (top - bottom);
      var c = -2 / (far - near);
      var tx = -(right + left) / (right - left);
      var ty = -(top + bottom) / (top - bottom);
      var tz = -(far + near) / (far - near);
      return [a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, tx, ty, tz, 1];
    },
    createFrustum: function createFrustum(left, right, bottom, top, near, far) {
      var r_width = 1 / (right - left);
      var r_height = 1 / (top - bottom);
      var r_depth = 1 / (near - far);
      var x = 2 * (near * r_width);
      var y = 2 * (near * r_height);
      var A = (right + left) * r_width;
      var B = (top + bottom) * r_height;
      var C = (far + near) * r_depth;
      var D = 2 * (far * near * r_depth);
      return [x, 0, 0, 0, 0, y, 0, 0, A, B, C, -1, 0, 0, D, 0];
    },
    createPerspective: function createPerspective(fovInRadians, aspect, near, far) {
      var h = 1 / Math.tan(fovInRadians / 2);
      var r_depth = 1 / (near - far);
      var C = (far + near) * r_depth;
      var D = 2 * (far * near * r_depth);
      return [h / aspect, 0, 0, 0, 0, h, 0, 0, 0, 0, C, -1, 0, 0, D, 0];
    },
    createTranslate2d: function createTranslate2d(x, y) {
      var mat = MatrixMath.createIdentityMatrix();
      MatrixMath.reuseTranslate2dCommand(mat, x, y);
      return mat;
    },
    reuseTranslate2dCommand: function reuseTranslate2dCommand(matrixCommand, x, y) {
      matrixCommand[12] = x;
      matrixCommand[13] = y;
    },
    reuseTranslate3dCommand: function reuseTranslate3dCommand(matrixCommand, x, y, z) {
      matrixCommand[12] = x;
      matrixCommand[13] = y;
      matrixCommand[14] = z;
    },
    createScale: function createScale(factor) {
      var mat = MatrixMath.createIdentityMatrix();
      MatrixMath.reuseScaleCommand(mat, factor);
      return mat;
    },
    reuseScaleCommand: function reuseScaleCommand(matrixCommand, factor) {
      matrixCommand[0] = factor;
      matrixCommand[5] = factor;
    },
    reuseScale3dCommand: function reuseScale3dCommand(matrixCommand, x, y, z) {
      matrixCommand[0] = x;
      matrixCommand[5] = y;
      matrixCommand[10] = z;
    },
    reusePerspectiveCommand: function reusePerspectiveCommand(matrixCommand, p) {
      matrixCommand[11] = -1 / p;
    },
    reuseScaleXCommand: function reuseScaleXCommand(matrixCommand, factor) {
      matrixCommand[0] = factor;
    },
    reuseScaleYCommand: function reuseScaleYCommand(matrixCommand, factor) {
      matrixCommand[5] = factor;
    },
    reuseScaleZCommand: function reuseScaleZCommand(matrixCommand, factor) {
      matrixCommand[10] = factor;
    },
    reuseRotateXCommand: function reuseRotateXCommand(matrixCommand, radians) {
      matrixCommand[5] = Math.cos(radians);
      matrixCommand[6] = Math.sin(radians);
      matrixCommand[9] = -Math.sin(radians);
      matrixCommand[10] = Math.cos(radians);
    },
    reuseRotateYCommand: function reuseRotateYCommand(matrixCommand, amount) {
      matrixCommand[0] = Math.cos(amount);
      matrixCommand[2] = -Math.sin(amount);
      matrixCommand[8] = Math.sin(amount);
      matrixCommand[10] = Math.cos(amount);
    },
    reuseRotateZCommand: function reuseRotateZCommand(matrixCommand, radians) {
      matrixCommand[0] = Math.cos(radians);
      matrixCommand[1] = Math.sin(radians);
      matrixCommand[4] = -Math.sin(radians);
      matrixCommand[5] = Math.cos(radians);
    },
    createRotateZ: function createRotateZ(radians) {
      var mat = MatrixMath.createIdentityMatrix();
      MatrixMath.reuseRotateZCommand(mat, radians);
      return mat;
    },
    reuseSkewXCommand: function reuseSkewXCommand(matrixCommand, radians) {
      matrixCommand[4] = Math.tan(radians);
    },
    reuseSkewYCommand: function reuseSkewYCommand(matrixCommand, radians) {
      matrixCommand[1] = Math.tan(radians);
    },
    multiplyInto: function multiplyInto(out, a, b) {
      var a00 = a[0],
          a01 = a[1],
          a02 = a[2],
          a03 = a[3],
          a10 = a[4],
          a11 = a[5],
          a12 = a[6],
          a13 = a[7],
          a20 = a[8],
          a21 = a[9],
          a22 = a[10],
          a23 = a[11],
          a30 = a[12],
          a31 = a[13],
          a32 = a[14],
          a33 = a[15];
      var b0 = b[0],
          b1 = b[1],
          b2 = b[2],
          b3 = b[3];
      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[4];
      b1 = b[5];
      b2 = b[6];
      b3 = b[7];
      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[8];
      b1 = b[9];
      b2 = b[10];
      b3 = b[11];
      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[12];
      b1 = b[13];
      b2 = b[14];
      b3 = b[15];
      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    },
    determinant: function determinant(matrix) {
      var _matrix = _$$_REQUIRE(_dependencyMap[0])(matrix, 16),
          m00 = _matrix[0],
          m01 = _matrix[1],
          m02 = _matrix[2],
          m03 = _matrix[3],
          m10 = _matrix[4],
          m11 = _matrix[5],
          m12 = _matrix[6],
          m13 = _matrix[7],
          m20 = _matrix[8],
          m21 = _matrix[9],
          m22 = _matrix[10],
          m23 = _matrix[11],
          m30 = _matrix[12],
          m31 = _matrix[13],
          m32 = _matrix[14],
          m33 = _matrix[15];

      return m03 * m12 * m21 * m30 - m02 * m13 * m21 * m30 - m03 * m11 * m22 * m30 + m01 * m13 * m22 * m30 + m02 * m11 * m23 * m30 - m01 * m12 * m23 * m30 - m03 * m12 * m20 * m31 + m02 * m13 * m20 * m31 + m03 * m10 * m22 * m31 - m00 * m13 * m22 * m31 - m02 * m10 * m23 * m31 + m00 * m12 * m23 * m31 + m03 * m11 * m20 * m32 - m01 * m13 * m20 * m32 - m03 * m10 * m21 * m32 + m00 * m13 * m21 * m32 + m01 * m10 * m23 * m32 - m00 * m11 * m23 * m32 - m02 * m11 * m20 * m33 + m01 * m12 * m20 * m33 + m02 * m10 * m21 * m33 - m00 * m12 * m21 * m33 - m01 * m10 * m22 * m33 + m00 * m11 * m22 * m33;
    },
    inverse: function inverse(matrix) {
      var det = MatrixMath.determinant(matrix);

      if (!det) {
        return matrix;
      }

      var _matrix2 = _$$_REQUIRE(_dependencyMap[0])(matrix, 16),
          m00 = _matrix2[0],
          m01 = _matrix2[1],
          m02 = _matrix2[2],
          m03 = _matrix2[3],
          m10 = _matrix2[4],
          m11 = _matrix2[5],
          m12 = _matrix2[6],
          m13 = _matrix2[7],
          m20 = _matrix2[8],
          m21 = _matrix2[9],
          m22 = _matrix2[10],
          m23 = _matrix2[11],
          m30 = _matrix2[12],
          m31 = _matrix2[13],
          m32 = _matrix2[14],
          m33 = _matrix2[15];

      return [(m12 * m23 * m31 - m13 * m22 * m31 + m13 * m21 * m32 - m11 * m23 * m32 - m12 * m21 * m33 + m11 * m22 * m33) / det, (m03 * m22 * m31 - m02 * m23 * m31 - m03 * m21 * m32 + m01 * m23 * m32 + m02 * m21 * m33 - m01 * m22 * m33) / det, (m02 * m13 * m31 - m03 * m12 * m31 + m03 * m11 * m32 - m01 * m13 * m32 - m02 * m11 * m33 + m01 * m12 * m33) / det, (m03 * m12 * m21 - m02 * m13 * m21 - m03 * m11 * m22 + m01 * m13 * m22 + m02 * m11 * m23 - m01 * m12 * m23) / det, (m13 * m22 * m30 - m12 * m23 * m30 - m13 * m20 * m32 + m10 * m23 * m32 + m12 * m20 * m33 - m10 * m22 * m33) / det, (m02 * m23 * m30 - m03 * m22 * m30 + m03 * m20 * m32 - m00 * m23 * m32 - m02 * m20 * m33 + m00 * m22 * m33) / det, (m03 * m12 * m30 - m02 * m13 * m30 - m03 * m10 * m32 + m00 * m13 * m32 + m02 * m10 * m33 - m00 * m12 * m33) / det, (m02 * m13 * m20 - m03 * m12 * m20 + m03 * m10 * m22 - m00 * m13 * m22 - m02 * m10 * m23 + m00 * m12 * m23) / det, (m11 * m23 * m30 - m13 * m21 * m30 + m13 * m20 * m31 - m10 * m23 * m31 - m11 * m20 * m33 + m10 * m21 * m33) / det, (m03 * m21 * m30 - m01 * m23 * m30 - m03 * m20 * m31 + m00 * m23 * m31 + m01 * m20 * m33 - m00 * m21 * m33) / det, (m01 * m13 * m30 - m03 * m11 * m30 + m03 * m10 * m31 - m00 * m13 * m31 - m01 * m10 * m33 + m00 * m11 * m33) / det, (m03 * m11 * m20 - m01 * m13 * m20 - m03 * m10 * m21 + m00 * m13 * m21 + m01 * m10 * m23 - m00 * m11 * m23) / det, (m12 * m21 * m30 - m11 * m22 * m30 - m12 * m20 * m31 + m10 * m22 * m31 + m11 * m20 * m32 - m10 * m21 * m32) / det, (m01 * m22 * m30 - m02 * m21 * m30 + m02 * m20 * m31 - m00 * m22 * m31 - m01 * m20 * m32 + m00 * m21 * m32) / det, (m02 * m11 * m30 - m01 * m12 * m30 - m02 * m10 * m31 + m00 * m12 * m31 + m01 * m10 * m32 - m00 * m11 * m32) / det, (m01 * m12 * m20 - m02 * m11 * m20 + m02 * m10 * m21 - m00 * m12 * m21 - m01 * m10 * m22 + m00 * m11 * m22) / det];
    },
    transpose: function transpose(m) {
      return [m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]];
    },
    multiplyVectorByMatrix: function multiplyVectorByMatrix(v, m) {
      var _v = _$$_REQUIRE(_dependencyMap[0])(v, 4),
          vx = _v[0],
          vy = _v[1],
          vz = _v[2],
          vw = _v[3];

      return [vx * m[0] + vy * m[4] + vz * m[8] + vw * m[12], vx * m[1] + vy * m[5] + vz * m[9] + vw * m[13], vx * m[2] + vy * m[6] + vz * m[10] + vw * m[14], vx * m[3] + vy * m[7] + vz * m[11] + vw * m[15]];
    },
    v3Length: function v3Length(a) {
      return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
    },
    v3Normalize: function v3Normalize(vector, v3Length) {
      var im = 1 / (v3Length || MatrixMath.v3Length(vector));
      return [vector[0] * im, vector[1] * im, vector[2] * im];
    },
    v3Dot: function v3Dot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    },
    v3Combine: function v3Combine(a, b, aScale, bScale) {
      return [aScale * a[0] + bScale * b[0], aScale * a[1] + bScale * b[1], aScale * a[2] + bScale * b[2]];
    },
    v3Cross: function v3Cross(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    },
    quaternionToDegreesXYZ: function quaternionToDegreesXYZ(q, matrix, row) {
      var _q = _$$_REQUIRE(_dependencyMap[0])(q, 4),
          qx = _q[0],
          qy = _q[1],
          qz = _q[2],
          qw = _q[3];

      var qw2 = qw * qw;
      var qx2 = qx * qx;
      var qy2 = qy * qy;
      var qz2 = qz * qz;
      var test = qx * qy + qz * qw;
      var unit = qw2 + qx2 + qy2 + qz2;
      var conv = 180 / Math.PI;

      if (test > 0.49999 * unit) {
        return [0, 2 * Math.atan2(qx, qw) * conv, 90];
      }

      if (test < -0.49999 * unit) {
        return [0, -2 * Math.atan2(qx, qw) * conv, -90];
      }

      return [MatrixMath.roundTo3Places(Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx2 - 2 * qz2) * conv), MatrixMath.roundTo3Places(Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy2 - 2 * qz2) * conv), MatrixMath.roundTo3Places(Math.asin(2 * qx * qy + 2 * qz * qw) * conv)];
    },
    roundTo3Places: function roundTo3Places(n) {
      var arr = n.toString().split('e');
      return Math.round(arr[0] + 'e' + (arr[1] ? +arr[1] - 3 : 3)) * 0.001;
    },
    decomposeMatrix: function decomposeMatrix(transformMatrix) {
      _$$_REQUIRE(_dependencyMap[1])(transformMatrix.length === 16, 'Matrix decomposition needs a list of 3d matrix values, received %s', transformMatrix);

      var perspective = [];
      var quaternion = [];
      var scale = [];
      var skew = [];
      var translation = [];

      if (!transformMatrix[15]) {
        return;
      }

      var matrix = [];
      var perspectiveMatrix = [];

      for (var i = 0; i < 4; i++) {
        matrix.push([]);

        for (var j = 0; j < 4; j++) {
          var value = transformMatrix[i * 4 + j] / transformMatrix[15];
          matrix[i].push(value);
          perspectiveMatrix.push(j === 3 ? 0 : value);
        }
      }

      perspectiveMatrix[15] = 1;

      if (!MatrixMath.determinant(perspectiveMatrix)) {
        return;
      }

      if (matrix[0][3] !== 0 || matrix[1][3] !== 0 || matrix[2][3] !== 0) {
        var rightHandSide = [matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]];
        var inversePerspectiveMatrix = MatrixMath.inverse(perspectiveMatrix);
        var transposedInversePerspectiveMatrix = MatrixMath.transpose(inversePerspectiveMatrix);
        perspective = MatrixMath.multiplyVectorByMatrix(rightHandSide, transposedInversePerspectiveMatrix);
      } else {
        perspective[0] = perspective[1] = perspective[2] = 0;
        perspective[3] = 1;
      }

      for (var _i = 0; _i < 3; _i++) {
        translation[_i] = matrix[3][_i];
      }

      var row = [];

      for (var _i2 = 0; _i2 < 3; _i2++) {
        row[_i2] = [matrix[_i2][0], matrix[_i2][1], matrix[_i2][2]];
      }

      scale[0] = MatrixMath.v3Length(row[0]);
      row[0] = MatrixMath.v3Normalize(row[0], scale[0]);
      skew[0] = MatrixMath.v3Dot(row[0], row[1]);
      row[1] = MatrixMath.v3Combine(row[1], row[0], 1.0, -skew[0]);
      scale[1] = MatrixMath.v3Length(row[1]);
      row[1] = MatrixMath.v3Normalize(row[1], scale[1]);
      skew[0] /= scale[1];
      skew[1] = MatrixMath.v3Dot(row[0], row[2]);
      row[2] = MatrixMath.v3Combine(row[2], row[0], 1.0, -skew[1]);
      skew[2] = MatrixMath.v3Dot(row[1], row[2]);
      row[2] = MatrixMath.v3Combine(row[2], row[1], 1.0, -skew[2]);
      scale[2] = MatrixMath.v3Length(row[2]);
      row[2] = MatrixMath.v3Normalize(row[2], scale[2]);
      skew[1] /= scale[2];
      skew[2] /= scale[2];
      var pdum3 = MatrixMath.v3Cross(row[1], row[2]);

      if (MatrixMath.v3Dot(row[0], pdum3) < 0) {
        for (var _i3 = 0; _i3 < 3; _i3++) {
          scale[_i3] *= -1;
          row[_i3][0] *= -1;
          row[_i3][1] *= -1;
          row[_i3][2] *= -1;
        }
      }

      quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
      quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
      quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
      quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));

      if (row[2][1] > row[1][2]) {
        quaternion[0] = -quaternion[0];
      }

      if (row[0][2] > row[2][0]) {
        quaternion[1] = -quaternion[1];
      }

      if (row[1][0] > row[0][1]) {
        quaternion[2] = -quaternion[2];
      }

      var rotationDegrees;

      if (quaternion[0] < 0.001 && quaternion[0] >= 0 && quaternion[1] < 0.001 && quaternion[1] >= 0) {
        rotationDegrees = [0, 0, MatrixMath.roundTo3Places(Math.atan2(row[0][1], row[0][0]) * 180 / Math.PI)];
      } else {
        rotationDegrees = MatrixMath.quaternionToDegreesXYZ(quaternion, matrix, row);
      }

      return {
        rotationDegrees: rotationDegrees,
        perspective: perspective,
        quaternion: quaternion,
        scale: scale,
        skew: skew,
        translation: translation,
        rotate: rotationDegrees[2],
        rotateX: rotationDegrees[0],
        rotateY: rotationDegrees[1],
        scaleX: scale[0],
        scaleY: scale[1],
        translateX: translation[0],
        translateY: translation[1]
      };
    }
  };
  module.exports = MatrixMath;
},"node_modules/react-native/Libraries/Utilities/MatrixMath.js",["node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var matricesDiffer = function matricesDiffer(one, two) {
    if (one === two) {
      return false;
    }

    return !one || !two || one[12] !== two[12] || one[13] !== two[13] || one[14] !== two[14] || one[5] !== two[5] || one[10] !== two[10] || one[0] !== two[0] || one[1] !== two[1] || one[2] !== two[2] || one[3] !== two[3] || one[4] !== two[4] || one[6] !== two[6] || one[7] !== two[7] || one[8] !== two[8] || one[9] !== two[9] || one[11] !== two[11] || one[15] !== two[15];
  };

  module.exports = matricesDiffer;
},"node_modules/react-native/Libraries/Utilities/differ/matricesDiffer.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var dummyPoint = {
    x: undefined,
    y: undefined
  };

  var pointsDiffer = function pointsDiffer(one, two) {
    one = one || dummyPoint;
    two = two || dummyPoint;
    return one !== two && (one.x !== two.x || one.y !== two.y);
  };

  module.exports = pointsDiffer;
},"node_modules/react-native/Libraries/Utilities/differ/pointsDiffer.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var dummyInsets = {
    top: undefined,
    left: undefined,
    right: undefined,
    bottom: undefined
  };

  var insetsDiffer = function insetsDiffer(one, two) {
    one = one || dummyInsets;
    two = two || dummyInsets;
    return one !== two && (one.top !== two.top || one.left !== two.left || one.right !== two.right || one.bottom !== two.bottom);
  };

  module.exports = insetsDiffer;
},"node_modules/react-native/Libraries/Utilities/differ/insetsDiffer.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _processColor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var TRANSPARENT = 0;

  function processColorArray(colors) {
    return colors == null ? null : colors.map(processColorElement);
  }

  function processColorElement(color) {
    var value = (0, _processColor.default)(color);

    if (value == null) {
      console.error('Invalid value in color array:', color);
      return TRANSPARENT;
    }

    return value;
  }

  module.exports = processColorArray;
},"node_modules/react-native/Libraries/StyleSheet/processColorArray.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/StyleSheet/processColor.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _customSourceTransformer, _serverURL, _scriptURL;

  var _sourceCodeScriptURL;

  function getSourceCodeScriptURL() {
    if (_sourceCodeScriptURL) {
      return _sourceCodeScriptURL;
    }

    var sourceCode = global.nativeExtensions && global.nativeExtensions.SourceCode;

    if (!sourceCode) {
      sourceCode = _$$_REQUIRE(_dependencyMap[0]).default;
    }

    _sourceCodeScriptURL = sourceCode.getConstants().scriptURL;
    return _sourceCodeScriptURL;
  }

  function getDevServerURL() {
    if (_serverURL === undefined) {
      var sourceCodeScriptURL = getSourceCodeScriptURL();
      var match = sourceCodeScriptURL && sourceCodeScriptURL.match(/^https?:\/\/.*?\//);

      if (match) {
        _serverURL = match[0];
      } else {
        _serverURL = null;
      }
    }

    return _serverURL;
  }

  function _coerceLocalScriptURL(scriptURL) {
    if (scriptURL) {
      if (scriptURL.startsWith('assets://')) {
        return null;
      }

      scriptURL = scriptURL.substring(0, scriptURL.lastIndexOf('/') + 1);

      if (!scriptURL.includes('://')) {
        scriptURL = 'file://' + scriptURL;
      }
    }

    return scriptURL;
  }

  function getScriptURL() {
    if (_scriptURL === undefined) {
      _scriptURL = _coerceLocalScriptURL(getSourceCodeScriptURL());
    }

    return _scriptURL;
  }

  function setCustomSourceTransformer(transformer) {
    _customSourceTransformer = transformer;
  }

  function resolveAssetSource(source) {
    if (typeof source === 'object') {
      return source;
    }

    var asset = _$$_REQUIRE(_dependencyMap[1]).getAssetByID(source);

    if (!asset) {
      return null;
    }

    var resolver = new (_$$_REQUIRE(_dependencyMap[2]))(getDevServerURL(), getScriptURL(), asset);

    if (_customSourceTransformer) {
      return _customSourceTransformer(resolver);
    }

    return resolver.defaultAsset();
  }

  module.exports = resolveAssetSource;
  module.exports.pickScale = _$$_REQUIRE(_dependencyMap[3]).pickScale;
  module.exports.setCustomSourceTransformer = setCustomSourceTransformer;
},"node_modules/react-native/Libraries/Image/resolveAssetSource.js",["node_modules/react-native/Libraries/NativeModules/specs/NativeSourceCode.js","node_modules/@react-native/assets/registry.js","node_modules/react-native/Libraries/Image/AssetSourceResolver.js","node_modules/react-native/Libraries/Image/AssetUtils.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var NativeModule = TurboModuleRegistry.getEnforcing('SourceCode');
  var constants = null;
  var NativeSourceCode = {
    getConstants: function getConstants() {
      if (constants == null) {
        constants = NativeModule.getConstants();
      }

      return constants;
    }
  };
  var _default = NativeSourceCode;
  exports.default = _default;
},"node_modules/react-native/Libraries/NativeModules/specs/NativeSourceCode.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var assets = [];

  function registerAsset(asset) {
    return assets.push(asset);
  }

  function getAssetByID(assetId) {
    return assets[assetId - 1];
  }

  module.exports = {
    registerAsset: registerAsset,
    getAssetByID: getAssetByID
  };
},"node_modules/@react-native/assets/registry.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function getScaledAssetPath(asset) {
    var scale = _$$_REQUIRE(_dependencyMap[0]).pickScale(asset.scales, _$$_REQUIRE(_dependencyMap[1]).get());

    var scaleSuffix = scale === 1 ? '' : '@' + scale + 'x';

    var assetDir = _$$_REQUIRE(_dependencyMap[2]).getBasePath(asset);

    return assetDir + '/' + asset.name + scaleSuffix + '.' + asset.type;
  }

  function getAssetPathInDrawableFolder(asset) {
    var scale = _$$_REQUIRE(_dependencyMap[0]).pickScale(asset.scales, _$$_REQUIRE(_dependencyMap[1]).get());

    var drawbleFolder = _$$_REQUIRE(_dependencyMap[2]).getAndroidResourceFolderName(asset, scale);

    var fileName = _$$_REQUIRE(_dependencyMap[2]).getAndroidResourceIdentifier(asset);

    return drawbleFolder + '/' + fileName + '.' + asset.type;
  }

  var AssetSourceResolver = function () {
    function AssetSourceResolver(serverUrl, jsbundleUrl, asset) {
      _$$_REQUIRE(_dependencyMap[3])(this, AssetSourceResolver);

      this.serverUrl = serverUrl;
      this.jsbundleUrl = jsbundleUrl;
      this.asset = asset;
    }

    _$$_REQUIRE(_dependencyMap[4])(AssetSourceResolver, [{
      key: "isLoadedFromServer",
      value: function isLoadedFromServer() {
        return !!this.serverUrl;
      }
    }, {
      key: "isLoadedFromFileSystem",
      value: function isLoadedFromFileSystem() {
        return !!(this.jsbundleUrl && this.jsbundleUrl.startsWith('file://'));
      }
    }, {
      key: "defaultAsset",
      value: function defaultAsset() {
        if (this.isLoadedFromServer()) {
          return this.assetServerURL();
        }

        {
          return this.scaledAssetURLNearBundle();
        }
      }
    }, {
      key: "assetServerURL",
      value: function assetServerURL() {
        _$$_REQUIRE(_dependencyMap[5])(!!this.serverUrl, 'need server to load from');

        return this.fromSource(this.serverUrl + getScaledAssetPath(this.asset) + '?platform=' + "ios" + '&hash=' + this.asset.hash);
      }
    }, {
      key: "scaledAssetPath",
      value: function scaledAssetPath() {
        return this.fromSource(getScaledAssetPath(this.asset));
      }
    }, {
      key: "scaledAssetURLNearBundle",
      value: function scaledAssetURLNearBundle() {
        var path = this.jsbundleUrl || 'file://';
        return this.fromSource(path + getScaledAssetPath(this.asset).replace(/\.\.\//g, '_'));
      }
    }, {
      key: "resourceIdentifierWithoutScale",
      value: function resourceIdentifierWithoutScale() {
        _$$_REQUIRE(_dependencyMap[5])(false, 'resource identifiers work on Android');

        return this.fromSource(_$$_REQUIRE(_dependencyMap[2]).getAndroidResourceIdentifier(this.asset));
      }
    }, {
      key: "drawableFolderInBundle",
      value: function drawableFolderInBundle() {
        var path = this.jsbundleUrl || 'file://';
        return this.fromSource(path + getAssetPathInDrawableFolder(this.asset));
      }
    }, {
      key: "fromSource",
      value: function fromSource(source) {
        return {
          __packager_asset: true,
          width: this.asset.width,
          height: this.asset.height,
          uri: source,
          scale: _$$_REQUIRE(_dependencyMap[0]).pickScale(this.asset.scales, _$$_REQUIRE(_dependencyMap[1]).get())
        };
      }
    }]);

    return AssetSourceResolver;
  }();

  AssetSourceResolver.pickScale = _$$_REQUIRE(_dependencyMap[0]).pickScale;
  module.exports = AssetSourceResolver;
},"node_modules/react-native/Libraries/Image/AssetSourceResolver.js",["node_modules/react-native/Libraries/Image/AssetUtils.js","node_modules/react-native/Libraries/Utilities/PixelRatio.js","node_modules/@react-native/assets/path-support.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getUrlCacheBreaker = getUrlCacheBreaker;
  exports.pickScale = pickScale;
  exports.setUrlCacheBreaker = setUrlCacheBreaker;

  var _PixelRatio = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var cacheBreaker;
  var warnIfCacheBreakerUnset = true;

  function pickScale(scales, deviceScale) {
    if (deviceScale == null) {
      deviceScale = _PixelRatio.default.get();
    }

    for (var i = 0; i < scales.length; i++) {
      if (scales[i] >= deviceScale) {
        return scales[i];
      }
    }

    return scales[scales.length - 1] || 1;
  }

  function setUrlCacheBreaker(appendage) {
    cacheBreaker = appendage;
  }

  function getUrlCacheBreaker() {
    if (cacheBreaker == null) {
      return '';
    }

    return cacheBreaker;
  }
},"node_modules/react-native/Libraries/Image/AssetUtils.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/PixelRatio.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var PixelRatio = function () {
    function PixelRatio() {
      _$$_REQUIRE(_dependencyMap[0])(this, PixelRatio);
    }

    _$$_REQUIRE(_dependencyMap[1])(PixelRatio, null, [{
      key: "get",
      value: function get() {
        return _$$_REQUIRE(_dependencyMap[2]).get('window').scale;
      }
    }, {
      key: "getFontScale",
      value: function getFontScale() {
        return _$$_REQUIRE(_dependencyMap[2]).get('window').fontScale || PixelRatio.get();
      }
    }, {
      key: "getPixelSizeForLayoutSize",
      value: function getPixelSizeForLayoutSize(layoutSize) {
        return Math.round(layoutSize * PixelRatio.get());
      }
    }, {
      key: "roundToNearestPixel",
      value: function roundToNearestPixel(layoutSize) {
        var ratio = PixelRatio.get();
        return Math.round(layoutSize * ratio) / ratio;
      }
    }, {
      key: "startDetecting",
      value: function startDetecting() {}
    }]);

    return PixelRatio;
  }();

  module.exports = PixelRatio;
},"node_modules/react-native/Libraries/Utilities/PixelRatio.js",["node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Utilities/Dimensions.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _EventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _RCTDeviceEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _NativeDeviceInfo = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var eventEmitter = new _EventEmitter.default();
  var dimensionsInitialized = false;
  var dimensions;

  var Dimensions = function () {
    function Dimensions() {
      (0, _classCallCheck2.default)(this, Dimensions);
    }

    (0, _createClass2.default)(Dimensions, null, [{
      key: "get",
      value: function get(dim) {
        (0, _invariant.default)(dimensions[dim], 'No dimension set for key ' + dim);
        return dimensions[dim];
      }
    }, {
      key: "set",
      value: function set(dims) {
        var screen = dims.screen,
            window = dims.window;
        var windowPhysicalPixels = dims.windowPhysicalPixels;

        if (windowPhysicalPixels) {
          window = {
            width: windowPhysicalPixels.width / windowPhysicalPixels.scale,
            height: windowPhysicalPixels.height / windowPhysicalPixels.scale,
            scale: windowPhysicalPixels.scale,
            fontScale: windowPhysicalPixels.fontScale
          };
        }

        var screenPhysicalPixels = dims.screenPhysicalPixels;

        if (screenPhysicalPixels) {
          screen = {
            width: screenPhysicalPixels.width / screenPhysicalPixels.scale,
            height: screenPhysicalPixels.height / screenPhysicalPixels.scale,
            scale: screenPhysicalPixels.scale,
            fontScale: screenPhysicalPixels.fontScale
          };
        } else if (screen == null) {
          screen = window;
        }

        dimensions = {
          window: window,
          screen: screen
        };

        if (dimensionsInitialized) {
          eventEmitter.emit('change', dimensions);
        } else {
          dimensionsInitialized = true;
        }
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, handler) {
        (0, _invariant.default)(type === 'change', 'Trying to subscribe to unknown event: "%s"', type);
        return eventEmitter.addListener(type, handler);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, handler) {
        (0, _invariant.default)(type === 'change', 'Trying to remove listener for unknown event: "%s"', type);
        eventEmitter.removeListener(type, handler);
      }
    }]);
    return Dimensions;
  }();

  var initialDims = global.nativeExtensions && global.nativeExtensions.DeviceInfo && global.nativeExtensions.DeviceInfo.Dimensions;

  if (!initialDims) {
    _RCTDeviceEventEmitter.default.addListener('didUpdateDimensions', function (update) {
      Dimensions.set(update);
    });

    initialDims = _NativeDeviceInfo.default.getConstants().Dimensions;
  }

  Dimensions.set(initialDims);
  module.exports = Dimensions;
},"node_modules/react-native/Libraries/Utilities/Dimensions.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/vendor/emitter/EventEmitter.js","node_modules/react-native/Libraries/EventEmitter/RCTDeviceEventEmitter.js","node_modules/react-native/Libraries/Utilities/NativeDeviceInfo.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var NativeModule = TurboModuleRegistry.getEnforcing('DeviceInfo');
  var constants = null;
  var NativeDeviceInfo = {
    getConstants: function getConstants() {
      if (constants == null) {
        constants = NativeModule.getConstants();
      }

      return constants;
    }
  };
  var _default = NativeDeviceInfo;
  exports.default = _default;
},"node_modules/react-native/Libraries/Utilities/NativeDeviceInfo.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var androidScaleSuffix = {
    '0.75': 'ldpi',
    '1': 'mdpi',
    '1.5': 'hdpi',
    '2': 'xhdpi',
    '3': 'xxhdpi',
    '4': 'xxxhdpi'
  };

  function getAndroidAssetSuffix(scale) {
    if (scale.toString() in androidScaleSuffix) {
      return androidScaleSuffix[scale.toString()];
    }

    throw new Error('no such scale ' + scale.toString());
  }

  var drawableFileTypes = new Set(['gif', 'jpeg', 'jpg', 'png', 'svg', 'webp', 'xml']);

  function getAndroidResourceFolderName(asset, scale) {
    if (!drawableFileTypes.has(asset.type)) {
      return 'raw';
    }

    var suffix = getAndroidAssetSuffix(scale);

    if (!suffix) {
      throw new Error("Don't know which android drawable suffix to use for scale: " + scale + '\nAsset: ' + JSON.stringify(asset, null, '\t') + '\nPossible scales are:' + JSON.stringify(androidScaleSuffix, null, '\t'));
    }

    return 'drawable-' + suffix;
  }

  function getAndroidResourceIdentifier(asset) {
    return (getBasePath(asset) + '/' + asset.name).toLowerCase().replace(/\//g, '_').replace(/([^a-z0-9_])/g, '').replace(/^assets_/, '');
  }

  function getBasePath(asset) {
    var basePath = asset.httpServerLocation;
    return basePath.startsWith('/') ? basePath.substr(1) : basePath;
  }

  module.exports = {
    getAndroidResourceFolderName: getAndroidResourceFolderName,
    getAndroidResourceIdentifier: getAndroidResourceIdentifier,
    getBasePath: getBasePath
  };
},"node_modules/@react-native/assets/path-support.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createViewConfig = createViewConfig;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _ReactNativeViewViewConfig = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  function createViewConfig(partialViewConfig) {
    return {
      uiViewClassName: partialViewConfig.uiViewClassName,
      Commands: {},
      bubblingEventTypes: composeIndexers(_ReactNativeViewViewConfig.default.bubblingEventTypes, partialViewConfig.bubblingEventTypes),
      directEventTypes: composeIndexers(_ReactNativeViewViewConfig.default.directEventTypes, partialViewConfig.directEventTypes),
      validAttributes: composeIndexers(_ReactNativeViewViewConfig.default.validAttributes, partialViewConfig.validAttributes)
    };
  }

  function composeIndexers(maybeA, maybeB) {
    var _ref;

    return maybeA == null || maybeB == null ? (_ref = maybeA != null ? maybeA : maybeB) != null ? _ref : {} : (0, _extends2.default)({}, maybeA, maybeB);
  }
},"node_modules/react-native/Libraries/NativeComponent/ViewConfig.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Components/View/ReactNativeViewViewConfig.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _ReactNativeViewViewConfigAndroid = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[3]);

  var ReactNativeViewConfig = {
    uiViewClassName: 'RCTView',
    baseModuleName: null,
    Manager: 'ViewManager',
    Commands: {},
    Constants: {},
    bubblingEventTypes: (0, _extends2.default)({}, _ReactNativeViewViewConfigAndroid.default.bubblingEventTypes, {
      topBlur: {
        phasedRegistrationNames: {
          bubbled: 'onBlur',
          captured: 'onBlurCapture'
        }
      },
      topChange: {
        phasedRegistrationNames: {
          bubbled: 'onChange',
          captured: 'onChangeCapture'
        }
      },
      topEndEditing: {
        phasedRegistrationNames: {
          bubbled: 'onEndEditing',
          captured: 'onEndEditingCapture'
        }
      },
      topFocus: {
        phasedRegistrationNames: {
          bubbled: 'onFocus',
          captured: 'onFocusCapture'
        }
      },
      topKeyPress: {
        phasedRegistrationNames: {
          bubbled: 'onKeyPress',
          captured: 'onKeyPressCapture'
        }
      },
      topPress: {
        phasedRegistrationNames: {
          bubbled: 'onPress',
          captured: 'onPressCapture'
        }
      },
      topSubmitEditing: {
        phasedRegistrationNames: {
          bubbled: 'onSubmitEditing',
          captured: 'onSubmitEditingCapture'
        }
      },
      topTouchCancel: {
        phasedRegistrationNames: {
          bubbled: 'onTouchCancel',
          captured: 'onTouchCancelCapture'
        }
      },
      topTouchEnd: {
        phasedRegistrationNames: {
          bubbled: 'onTouchEnd',
          captured: 'onTouchEndCapture'
        }
      },
      topTouchMove: {
        phasedRegistrationNames: {
          bubbled: 'onTouchMove',
          captured: 'onTouchMoveCapture'
        }
      },
      topTouchStart: {
        phasedRegistrationNames: {
          bubbled: 'onTouchStart',
          captured: 'onTouchStartCapture'
        }
      }
    }),
    directEventTypes: (0, _extends2.default)({}, _ReactNativeViewViewConfigAndroid.default.directEventTypes, {
      topAccessibilityAction: {
        registrationName: 'onAccessibilityAction'
      },
      topAccessibilityEscape: {
        registrationName: 'onAccessibilityEscape'
      },
      topAccessibilityTap: {
        registrationName: 'onAccessibilityTap'
      },
      topLayout: {
        registrationName: 'onLayout'
      },
      topMagicTap: {
        registrationName: 'onMagicTap'
      },
      topPointerEnter: {
        registrationName: 'pointerenter'
      },
      topPointerLeave: {
        registrationName: 'pointerleave'
      },
      topPointerMove: {
        registrationName: 'pointermove'
      },
      onGestureHandlerEvent: {
        registrationName: 'onGestureHandlerEvent'
      },
      onGestureHandlerStateChange: {
        registrationName: 'onGestureHandlerStateChange'
      }
    }),
    validAttributes: (0, _extends2.default)({}, _ReactNativeViewViewConfigAndroid.default.validAttributes, {
      accessibilityActions: true,
      accessibilityElementsHidden: true,
      accessibilityHint: true,
      accessibilityIgnoresInvertColors: true,
      accessibilityLabel: true,
      accessibilityLiveRegion: true,
      accessibilityRole: true,
      accessibilityState: true,
      accessibilityValue: true,
      accessibilityViewIsModal: true,
      accessible: true,
      alignContent: true,
      alignItems: true,
      alignSelf: true,
      aspectRatio: true,
      backfaceVisibility: true,
      backgroundColor: {
        process: _$$_REQUIRE(_dependencyMap[4])
      },
      borderBottomColor: {
        process: _$$_REQUIRE(_dependencyMap[4])
      },
      borderBottomEndRadius: true,
      borderBottomLeftRadius: true,
      borderBottomRightRadius: true,
      borderBottomStartRadius: true,
      borderBottomWidth: true,
      borderColor: {
        process: _$$_REQUIRE(_dependencyMap[4])
      },
      borderEndColor: {
        process: _$$_REQUIRE(_dependencyMap[4])
      },
      borderEndWidth: true,
      borderLeftColor: {
        process: _$$_REQUIRE(_dependencyMap[4])
      },
      borderLeftWidth: true,
      borderRadius: true,
      borderRightColor: {
        process: _$$_REQUIRE(_dependencyMap[4])
      },
      borderRightWidth: true,
      borderStartColor: {
        process: _$$_REQUIRE(_dependencyMap[4])
      },
      borderStartWidth: true,
      borderStyle: true,
      borderTopColor: {
        process: _$$_REQUIRE(_dependencyMap[4])
      },
      borderTopEndRadius: true,
      borderTopLeftRadius: true,
      borderTopRightRadius: true,
      borderTopStartRadius: true,
      borderTopWidth: true,
      borderWidth: true,
      bottom: true,
      clickable: true,
      collapsable: true,
      direction: true,
      display: true,
      elevation: true,
      end: true,
      flex: true,
      flexBasis: true,
      flexDirection: true,
      flexGrow: true,
      flexShrink: true,
      flexWrap: true,
      height: true,
      hitSlop: {
        diff: _$$_REQUIRE(_dependencyMap[5])
      },
      importantForAccessibility: true,
      justifyContent: true,
      left: true,
      margin: true,
      marginBottom: true,
      marginEnd: true,
      marginHorizontal: true,
      marginLeft: true,
      marginRight: true,
      marginStart: true,
      marginTop: true,
      marginVertical: true,
      maxHeight: true,
      maxWidth: true,
      minHeight: true,
      minWidth: true,
      nativeID: true,
      needsOffscreenAlphaCompositing: true,
      onAccessibilityAction: true,
      onAccessibilityEscape: true,
      onAccessibilityTap: true,
      pointerenter: true,
      pointerleave: true,
      pointermove: true,
      onLayout: true,
      onMagicTap: true,
      opacity: true,
      overflow: true,
      padding: true,
      paddingBottom: true,
      paddingEnd: true,
      paddingHorizontal: true,
      paddingLeft: true,
      paddingRight: true,
      paddingStart: true,
      paddingTop: true,
      paddingVertical: true,
      pointerEvents: true,
      position: true,
      removeClippedSubviews: true,
      renderToHardwareTextureAndroid: true,
      right: true,
      rotation: true,
      scaleX: true,
      scaleY: true,
      shadowColor: {
        process: _$$_REQUIRE(_dependencyMap[4])
      },
      shadowOffset: {
        diff: _$$_REQUIRE(_dependencyMap[6])
      },
      shadowOpacity: true,
      shadowRadius: true,
      shouldRasterizeIOS: true,
      start: true,
      style: {
        alignContent: true,
        alignItems: true,
        alignSelf: true,
        aspectRatio: true,
        backfaceVisibility: true,
        backgroundColor: {
          process: _$$_REQUIRE(_dependencyMap[4])
        },
        borderBottomColor: {
          process: _$$_REQUIRE(_dependencyMap[4])
        },
        borderBottomEndRadius: true,
        borderBottomLeftRadius: true,
        borderBottomRightRadius: true,
        borderBottomStartRadius: true,
        borderBottomWidth: true,
        borderColor: {
          process: _$$_REQUIRE(_dependencyMap[4])
        },
        borderEndColor: {
          process: _$$_REQUIRE(_dependencyMap[4])
        },
        borderEndWidth: true,
        borderLeftColor: {
          process: _$$_REQUIRE(_dependencyMap[4])
        },
        borderLeftWidth: true,
        borderRadius: true,
        borderRightColor: {
          process: _$$_REQUIRE(_dependencyMap[4])
        },
        borderRightWidth: true,
        borderStartColor: {
          process: _$$_REQUIRE(_dependencyMap[4])
        },
        borderStartWidth: true,
        borderStyle: true,
        borderTopColor: {
          process: _$$_REQUIRE(_dependencyMap[4])
        },
        borderTopEndRadius: true,
        borderTopLeftRadius: true,
        borderTopRightRadius: true,
        borderTopStartRadius: true,
        borderTopWidth: true,
        borderWidth: true,
        bottom: true,
        color: {
          process: _$$_REQUIRE(_dependencyMap[4])
        },
        decomposedMatrix: true,
        direction: true,
        display: true,
        elevation: true,
        end: true,
        flex: true,
        flexBasis: true,
        flexDirection: true,
        flexGrow: true,
        flexShrink: true,
        flexWrap: true,
        fontFamily: true,
        fontSize: true,
        fontStyle: true,
        fontVariant: true,
        fontWeight: true,
        height: true,
        includeFontPadding: true,
        justifyContent: true,
        left: true,
        letterSpacing: true,
        lineHeight: true,
        margin: true,
        marginBottom: true,
        marginEnd: true,
        marginHorizontal: true,
        marginLeft: true,
        marginRight: true,
        marginStart: true,
        marginTop: true,
        marginVertical: true,
        maxHeight: true,
        maxWidth: true,
        minHeight: true,
        minWidth: true,
        opacity: true,
        overflow: true,
        overlayColor: {
          process: _$$_REQUIRE(_dependencyMap[4])
        },
        padding: true,
        paddingBottom: true,
        paddingEnd: true,
        paddingHorizontal: true,
        paddingLeft: true,
        paddingRight: true,
        paddingStart: true,
        paddingTop: true,
        paddingVertical: true,
        position: true,
        resizeMode: true,
        right: true,
        rotation: true,
        scaleX: true,
        scaleY: true,
        shadowColor: {
          process: _$$_REQUIRE(_dependencyMap[4])
        },
        shadowOffset: {
          diff: _$$_REQUIRE(_dependencyMap[6])
        },
        shadowOpacity: true,
        shadowRadius: true,
        start: true,
        textAlign: true,
        textAlignVertical: true,
        textDecorationColor: {
          process: _$$_REQUIRE(_dependencyMap[4])
        },
        textDecorationLine: true,
        textDecorationStyle: true,
        textShadowColor: {
          process: _$$_REQUIRE(_dependencyMap[4])
        },
        textShadowOffset: true,
        textShadowRadius: true,
        textTransform: true,
        tintColor: {
          process: _$$_REQUIRE(_dependencyMap[4])
        },
        top: true,
        transform: _reactNative.Platform.OS === 'ios' ? {
          diff: _$$_REQUIRE(_dependencyMap[7])
        } : {
          process: _$$_REQUIRE(_dependencyMap[8])
        },
        transformMatrix: true,
        translateX: true,
        translateY: true,
        width: true,
        writingDirection: true,
        zIndex: true
      },
      testID: true,
      top: true,
      transform: _reactNative.Platform.OS === 'ios' ? {
        diff: _$$_REQUIRE(_dependencyMap[7])
      } : {
        process: _$$_REQUIRE(_dependencyMap[8])
      },
      translateX: true,
      translateY: true,
      width: true,
      zIndex: true
    })
  };
  module.exports = ReactNativeViewConfig;
},"node_modules/react-native/Libraries/Components/View/ReactNativeViewViewConfig.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Components/View/ReactNativeViewViewConfigAndroid.js","node_modules/react-native/index.js","node_modules/react-native/Libraries/StyleSheet/processColor.js","node_modules/react-native/Libraries/Utilities/differ/insetsDiffer.js","node_modules/react-native/Libraries/Utilities/differ/sizesDiffer.js","node_modules/react-native/Libraries/Utilities/differ/matricesDiffer.js","node_modules/react-native/Libraries/StyleSheet/processTransform.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ReactNativeViewViewConfigAndroid = {
    uiViewClassName: 'RCTView',
    bubblingEventTypes: {
      topSelect: {
        phasedRegistrationNames: {
          bubbled: 'onSelect',
          captured: 'onSelectCapture'
        }
      },
      topAssetDidLoad: {
        phasedRegistrationNames: {
          bubbled: 'onAssetDidLoad',
          captured: 'onAssetDidLoadCapture'
        }
      }
    },
    directEventTypes: {
      topClick: {
        registrationName: 'onClick'
      },
      topContentSizeChange: {
        registrationName: 'onContentSizeChange'
      },
      topLoadingError: {
        registrationName: 'onLoadingError'
      },
      topLoadingFinish: {
        registrationName: 'onLoadingFinish'
      },
      topLoadingStart: {
        registrationName: 'onLoadingStart'
      },
      topMessage: {
        registrationName: 'onMessage'
      },
      topMomentumScrollBegin: {
        registrationName: 'onMomentumScrollBegin'
      },
      topMomentumScrollEnd: {
        registrationName: 'onMomentumScrollEnd'
      },
      topScroll: {
        registrationName: 'onScroll'
      },
      topScrollBeginDrag: {
        registrationName: 'onScrollBeginDrag'
      },
      topScrollEndDrag: {
        registrationName: 'onScrollEndDrag'
      },
      topSelectionChange: {
        registrationName: 'onSelectionChange'
      },
      onAssetDidLoad: {
        registrationName: 'onAssetDidLoad'
      }
    },
    validAttributes: {
      hasTVPreferredFocus: true,
      focusable: true,
      nativeBackgroundAndroid: true,
      nativeForegroundAndroid: true,
      nextFocusDown: true,
      nextFocusForward: true,
      nextFocusLeft: true,
      nextFocusRight: true,
      nextFocusUp: true
    }
  };
  module.exports = ReactNativeViewViewConfigAndroid;
},"node_modules/react-native/Libraries/Components/View/ReactNativeViewViewConfigAndroid.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = verifyComponentAttributeEquivalence;
  exports.getConfigWithoutViewProps = getConfigWithoutViewProps;
  exports.lefthandObjectDiff = lefthandObjectDiff;
  exports.stringifyViewConfig = stringifyViewConfig;

  var _ReactNativeViewViewConfig = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var IGNORED_KEYS = ['transform', 'hitSlop'];

  function verifyComponentAttributeEquivalence(nativeViewConfig, staticViewConfig) {
    for (var _i = 0, _arr = ['validAttributes', 'bubblingEventTypes', 'directEventTypes']; _i < _arr.length; _i++) {
      var prop = _arr[_i];
      var diff = Object.keys(lefthandObjectDiff(nativeViewConfig[prop], staticViewConfig[prop]));

      if (diff.length > 0) {
        var _staticViewConfig$uiV;

        var name = (_staticViewConfig$uiV = staticViewConfig.uiViewClassName) != null ? _staticViewConfig$uiV : nativeViewConfig.uiViewClassName;
        console.error("'" + name + "' has a view config that does not match native. " + ("'" + prop + "' is missing: " + diff.join(', ')));
      }
    }
  }

  function lefthandObjectDiff(leftObj, rightObj) {
    var differentKeys = {};

    function compare(leftItem, rightItem, key) {
      if (typeof leftItem !== typeof rightItem && leftItem != null) {
        differentKeys[key] = rightItem;
        return;
      }

      if (typeof leftItem === 'object') {
        var objDiff = lefthandObjectDiff(leftItem, rightItem);

        if (Object.keys(objDiff).length > 1) {
          differentKeys[key] = objDiff;
        }

        return;
      }

      if (leftItem !== rightItem) {
        differentKeys[key] = rightItem;
        return;
      }
    }

    for (var key in leftObj) {
      if (IGNORED_KEYS.includes(key)) {
        continue;
      }

      if (!rightObj) {
        differentKeys[key] = {};
      } else if (leftObj.hasOwnProperty(key)) {
        compare(leftObj[key], rightObj[key], key);
      }
    }

    return differentKeys;
  }

  function getConfigWithoutViewProps(viewConfig, propName) {
    if (!viewConfig[propName]) {
      return {};
    }

    return Object.keys(viewConfig[propName]).filter(function (prop) {
      return !_ReactNativeViewViewConfig.default[propName][prop];
    }).reduce(function (obj, prop) {
      obj[prop] = viewConfig[propName][prop];
      return obj;
    }, {});
  }

  function stringifyViewConfig(viewConfig) {
    return JSON.stringify(viewConfig, function (key, val) {
      if (typeof val === 'function') {
        return "\u0192 " + val.name;
      }

      return val;
    }, 2);
  }
},"node_modules/react-native/Libraries/Utilities/verifyComponentAttributeEquivalence.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Components/View/ReactNativeViewViewConfig.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var logListeners;

  function unstable_setLogListeners(listeners) {
    logListeners = listeners;
  }

  var deepDiffer = function deepDiffer(one, two) {
    var maxDepthOrOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    var maybeOptions = arguments.length > 3 ? arguments[3] : undefined;
    var options = typeof maxDepthOrOptions === 'number' ? maybeOptions : maxDepthOrOptions;
    var maxDepth = typeof maxDepthOrOptions === 'number' ? maxDepthOrOptions : -1;

    if (maxDepth === 0) {
      return true;
    }

    if (one === two) {
      return false;
    }

    if (typeof one === 'function' && typeof two === 'function') {
      var unsafelyIgnoreFunctions = options == null ? undefined : options.unsafelyIgnoreFunctions;

      if (unsafelyIgnoreFunctions == null) {
        if (logListeners && logListeners.onDifferentFunctionsIgnored && (!options || !('unsafelyIgnoreFunctions' in options))) {
          logListeners.onDifferentFunctionsIgnored(one.name, two.name);
        }

        unsafelyIgnoreFunctions = true;
      }

      return !unsafelyIgnoreFunctions;
    }

    if (typeof one !== 'object' || one === null) {
      return one !== two;
    }

    if (typeof two !== 'object' || two === null) {
      return true;
    }

    if (one.constructor !== two.constructor) {
      return true;
    }

    if (Array.isArray(one)) {
      var len = one.length;

      if (two.length !== len) {
        return true;
      }

      for (var ii = 0; ii < len; ii++) {
        if (deepDiffer(one[ii], two[ii], maxDepth - 1, options)) {
          return true;
        }
      }
    } else {
      for (var key in one) {
        if (deepDiffer(one[key], two[key], maxDepth - 1, options)) {
          return true;
        }
      }

      for (var twoKey in two) {
        if (one[twoKey] === undefined && two[twoKey] !== undefined) {
          return true;
        }
      }
    }

    return false;
  };

  module.exports = deepDiffer;
  module.exports.unstable_setLogListeners = unstable_setLogListeners;
},"node_modules/react-native/Libraries/Utilities/differ/deepDiffer.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function deepFreezeAndThrowOnMutationInDev(object) {
    return object;
  }

  module.exports = deepFreezeAndThrowOnMutationInDev;
},"node_modules/react-native/Libraries/Utilities/deepFreezeAndThrowOnMutationInDev.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function flattenStyle(style) {
    if (style === null || typeof style !== 'object') {
      return undefined;
    }

    if (!Array.isArray(style)) {
      return style;
    }

    var result = {};

    for (var i = 0, styleLength = style.length; i < styleLength; ++i) {
      var computedStyle = flattenStyle(style[i]);

      if (computedStyle) {
        for (var key in computedStyle) {
          result[key] = computedStyle[key];
        }
      }
    }

    return result;
  }

  module.exports = flattenStyle;
},"node_modules/react-native/Libraries/StyleSheet/flattenStyle.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var ReactFiberErrorDialog = {
    showErrorDialog: function showErrorDialog(_ref) {
      var componentStack = _ref.componentStack,
          errorValue = _ref.error;
      var error;

      if (errorValue instanceof Error) {
        error = errorValue;
      } else if (typeof errorValue === 'string') {
        error = new (_$$_REQUIRE(_dependencyMap[0]).SyntheticError)(errorValue);
      } else {
        error = new (_$$_REQUIRE(_dependencyMap[0]).SyntheticError)('Unspecified error');
      }

      try {
        error.componentStack = componentStack;
        error.isComponentError = true;
      } catch (_unused) {}

      (0, _$$_REQUIRE(_dependencyMap[0]).handleException)(error, false);
      return false;
    }
  };
  var _default = ReactFiberErrorDialog;
  exports.default = _default;
},"node_modules/react-native/Libraries/Core/ReactFiberErrorDialog.js",["node_modules/react-native/Libraries/Core/ExceptionsManager.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  {
    module.exports = _$$_REQUIRE(_dependencyMap[0]);
  }
},"node_modules/scheduler/index.js",["node_modules/scheduler/cjs/scheduler.production.min.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /** @license React v0.20.2
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  var _f, g, h, k;

  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l = performance;

    exports.unstable_now = function () {
      return l.now();
    };
  } else {
    var p = Date,
        q = p.now();

    exports.unstable_now = function () {
      return p.now() - q;
    };
  }

  if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
    var t = null,
        u = null,
        w = function w() {
      if (null !== t) try {
        var a = exports.unstable_now();
        t(true, a);
        t = null;
      } catch (b) {
        throw setTimeout(w, 0), b;
      }
    };

    _f = function f(a) {
      null !== t ? setTimeout(_f, 0, a) : (t = a, setTimeout(w, 0));
    };

    g = function g(a, b) {
      u = setTimeout(a, b);
    };

    h = function h() {
      clearTimeout(u);
    };

    exports.unstable_shouldYield = function () {
      return false;
    };

    k = exports.unstable_forceFrameRate = function () {};
  } else {
    var x = window.setTimeout,
        y = window.clearTimeout;

    if ("undefined" !== typeof console) {
      var z = window.cancelAnimationFrame;
      "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      "function" !== typeof z && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }

    var A = false,
        B = null,
        C = -1,
        D = 5,
        E = 0;

    exports.unstable_shouldYield = function () {
      return exports.unstable_now() >= E;
    };

    k = function k() {};

    exports.unstable_forceFrameRate = function (a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D = 0 < a ? Math.floor(1E3 / a) : 5;
    };

    var F = new MessageChannel(),
        G = F.port2;

    F.port1.onmessage = function () {
      if (null !== B) {
        var a = exports.unstable_now();
        E = a + D;

        try {
          B(true, a) ? G.postMessage(null) : (A = false, B = null);
        } catch (b) {
          throw G.postMessage(null), b;
        }
      } else A = false;
    };

    _f = function _f(a) {
      B = a;
      A || (A = true, G.postMessage(null));
    };

    g = function g(a, b) {
      C = x(function () {
        a(exports.unstable_now());
      }, b);
    };

    h = function h() {
      y(C);
      C = -1;
    };
  }

  function H(a, b) {
    var c = a.length;
    a.push(b);

    a: for (;;) {
      var d = c - 1 >>> 1,
          e = a[d];
      if (undefined !== e && 0 < I(e, b)) a[d] = b, a[c] = e, c = d;else break a;
    }
  }

  function J(a) {
    a = a[0];
    return undefined === a ? null : a;
  }

  function K(a) {
    var b = a[0];

    if (undefined !== b) {
      var c = a.pop();

      if (c !== b) {
        a[0] = c;

        a: for (var d = 0, e = a.length; d < e;) {
          var m = 2 * (d + 1) - 1,
              n = a[m],
              v = m + 1,
              r = a[v];
          if (undefined !== n && 0 > I(n, c)) undefined !== r && 0 > I(r, n) ? (a[d] = r, a[v] = c, d = v) : (a[d] = n, a[m] = c, d = m);else if (undefined !== r && 0 > I(r, c)) a[d] = r, a[v] = c, d = v;else break a;
        }
      }

      return b;
    }

    return null;
  }

  function I(a, b) {
    var c = a.sortIndex - b.sortIndex;
    return 0 !== c ? c : a.id - b.id;
  }

  var L = [],
      M = [],
      N = 1,
      O = null,
      P = 3,
      Q = false,
      R = false,
      S = false;

  function T(a) {
    for (var b = J(M); null !== b;) {
      if (null === b.callback) K(M);else if (b.startTime <= a) K(M), b.sortIndex = b.expirationTime, H(L, b);else break;
      b = J(M);
    }
  }

  function U(a) {
    S = false;
    T(a);
    if (!R) if (null !== J(L)) R = true, _f(V);else {
      var b = J(M);
      null !== b && g(U, b.startTime - a);
    }
  }

  function V(a, b) {
    R = false;
    S && (S = false, h());
    Q = true;
    var c = P;

    try {
      T(b);

      for (O = J(L); null !== O && (!(O.expirationTime > b) || a && !exports.unstable_shouldYield());) {
        var d = O.callback;

        if ("function" === typeof d) {
          O.callback = null;
          P = O.priorityLevel;
          var e = d(O.expirationTime <= b);
          b = exports.unstable_now();
          "function" === typeof e ? O.callback = e : O === J(L) && K(L);
          T(b);
        } else K(L);

        O = J(L);
      }

      if (null !== O) var m = true;else {
        var n = J(M);
        null !== n && g(U, n.startTime - b);
        m = false;
      }
      return m;
    } finally {
      O = null, P = c, Q = false;
    }
  }

  var W = k;
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;

  exports.unstable_cancelCallback = function (a) {
    a.callback = null;
  };

  exports.unstable_continueExecution = function () {
    R || Q || (R = true, _f(V));
  };

  exports.unstable_getCurrentPriorityLevel = function () {
    return P;
  };

  exports.unstable_getFirstCallbackNode = function () {
    return J(L);
  };

  exports.unstable_next = function (a) {
    switch (P) {
      case 1:
      case 2:
      case 3:
        var b = 3;
        break;

      default:
        b = P;
    }

    var c = P;
    P = b;

    try {
      return a();
    } finally {
      P = c;
    }
  };

  exports.unstable_pauseExecution = function () {};

  exports.unstable_requestPaint = W;

  exports.unstable_runWithPriority = function (a, b) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;

      default:
        a = 3;
    }

    var c = P;
    P = a;

    try {
      return b();
    } finally {
      P = c;
    }
  };

  exports.unstable_scheduleCallback = function (a, b, c) {
    var d = exports.unstable_now();
    "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;

    switch (a) {
      case 1:
        var e = -1;
        break;

      case 2:
        e = 250;
        break;

      case 5:
        e = 1073741823;
        break;

      case 4:
        e = 1E4;
        break;

      default:
        e = 5E3;
    }

    e = c + e;
    a = {
      id: N++,
      callback: b,
      priorityLevel: a,
      startTime: c,
      expirationTime: e,
      sortIndex: -1
    };
    c > d ? (a.sortIndex = c, H(M, a), null === J(L) && a === J(M) && (S ? h() : S = true, g(U, c - d))) : (a.sortIndex = e, H(L, a), R || Q || (R = true, _f(V)));
    return a;
  };

  exports.unstable_wrapCallback = function (a) {
    var b = P;
    return function () {
      var c = P;
      P = b;

      try {
        return a.apply(this, arguments);
      } finally {
        P = c;
      }
    };
  };
},"node_modules/scheduler/cjs/scheduler.production.min.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _View = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _excluded = ["animating", "color", "hidesWhenStopped", "onLayout", "size", "style"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var PlatformActivityIndicator = _Platform.default.OS === 'android' ? _$$_REQUIRE(_dependencyMap[7]) : _$$_REQUIRE(_dependencyMap[8]).default;
  var GRAY = '#999999';

  var ActivityIndicator = function ActivityIndicator(_ref, forwardedRef) {
    var _ref$animating = _ref.animating,
        animating = _ref$animating === undefined ? true : _ref$animating,
        _ref$color = _ref.color,
        color = _ref$color === undefined ? _Platform.default.OS === 'ios' ? GRAY : null : _ref$color,
        _ref$hidesWhenStopped = _ref.hidesWhenStopped,
        hidesWhenStopped = _ref$hidesWhenStopped === undefined ? true : _ref$hidesWhenStopped,
        onLayout = _ref.onLayout,
        _ref$size = _ref.size,
        size = _ref$size === undefined ? 'small' : _ref$size,
        style = _ref.style,
        restProps = (0, _objectWithoutProperties2.default)(_ref, _excluded);
    var sizeStyle;
    var sizeProp;

    switch (size) {
      case 'small':
        sizeStyle = styles.sizeSmall;
        sizeProp = 'small';
        break;

      case 'large':
        sizeStyle = styles.sizeLarge;
        sizeProp = 'large';
        break;

      default:
        sizeStyle = {
          height: size,
          width: size
        };
        break;
    }

    var nativeProps = (0, _extends2.default)({
      animating: animating,
      color: color,
      hidesWhenStopped: hidesWhenStopped
    }, restProps, {
      ref: forwardedRef,
      style: sizeStyle,
      size: sizeProp
    });
    var androidProps = {
      styleAttr: 'Normal',
      indeterminate: true
    };
    return React.createElement(_View.default, {
      onLayout: onLayout,
      style: _StyleSheet.default.compose(styles.container, style)
    }, _Platform.default.OS === 'android' ? React.createElement(PlatformActivityIndicator, (0, _extends2.default)({}, nativeProps, androidProps)) : React.createElement(PlatformActivityIndicator, nativeProps));
  };

  var ActivityIndicatorWithRef = React.forwardRef(ActivityIndicator);
  ActivityIndicatorWithRef.displayName = 'ActivityIndicator';

  var styles = _StyleSheet.default.create({
    container: {
      alignItems: 'center',
      justifyContent: 'center'
    },
    sizeSmall: {
      width: 20,
      height: 20
    },
    sizeLarge: {
      width: 36,
      height: 36
    }
  });

  module.exports = ActivityIndicatorWithRef;
},"node_modules/react-native/Libraries/Components/ActivityIndicator/ActivityIndicator.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/react-native/Libraries/Components/ProgressBarAndroid/ProgressBarAndroid.ios.js","node_modules/react-native/Libraries/Components/ActivityIndicator/ActivityIndicatorViewNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var hairlineWidth = _$$_REQUIRE(_dependencyMap[0]).roundToNearestPixel(0.4);

  if (hairlineWidth === 0) {
    hairlineWidth = 1 / _$$_REQUIRE(_dependencyMap[0]).get();
  }

  var absoluteFill = {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };
  module.exports = {
    hairlineWidth: hairlineWidth,
    absoluteFill: absoluteFill,
    absoluteFillObject: absoluteFill,
    compose: function compose(style1, style2) {
      if (style1 != null && style2 != null) {
        return [style1, style2];
      } else {
        return style1 != null ? style1 : style2;
      }
    },
    flatten: _$$_REQUIRE(_dependencyMap[1]),
    setStyleAttributePreprocessor: function setStyleAttributePreprocessor(property, process) {
      var value;

      if (_$$_REQUIRE(_dependencyMap[2])[property] === true) {
        value = {
          process: process
        };
      } else if (typeof _$$_REQUIRE(_dependencyMap[2])[property] === 'object') {
        value = _$$_REQUIRE(_dependencyMap[3])({}, _$$_REQUIRE(_dependencyMap[2])[property], {
          process: process
        });
      } else {
        console.error(property + " is not a valid style attribute");
        return;
      }

      _$$_REQUIRE(_dependencyMap[2])[property] = value;
    },
    create: function create(obj) {
      return obj;
    }
  };
},"node_modules/react-native/Libraries/StyleSheet/StyleSheet.js",["node_modules/react-native/Libraries/Utilities/PixelRatio.js","node_modules/react-native/Libraries/StyleSheet/flattenStyle.js","node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js","node_modules/@babel/runtime/helpers/extends.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _ViewNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _TextAncestor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var View = React.forwardRef(function (props, forwardedRef) {
    return React.createElement(_TextAncestor.default.Provider, {
      value: false
    }, React.createElement(_ViewNativeComponent.default, (0, _extends2.default)({}, props, {
      ref: forwardedRef
    })));
  });
  View.displayName = 'View';
  module.exports = View;
},"node_modules/react-native/Libraries/Components/View/View.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Components/View/ViewNativeComponent.js","node_modules/react-native/Libraries/Text/TextAncestor.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.Commands = undefined;

  var NativeComponentRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _Platform = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  var _codegenNativeCommands = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[3]));

  var _ReactNativeViewViewConfigAndroid = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[4]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[5]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var ViewNativeComponent = NativeComponentRegistry.get('RCTView', function () {
    return _Platform.default.OS === 'android' ? _ReactNativeViewViewConfigAndroid.default : {
      uiViewClassName: 'RCTView'
    };
  });
  var Commands = (0, _codegenNativeCommands.default)({
    supportedCommands: ['hotspotUpdate', 'setPressed']
  });
  exports.Commands = Commands;
  var _default = ViewNativeComponent;
  exports.default = _default;
},"node_modules/react-native/Libraries/Components/View/ViewNativeComponent.js",["node_modules/react-native/Libraries/NativeComponent/NativeComponentRegistry.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/Utilities/codegenNativeCommands.js","node_modules/react-native/Libraries/Components/View/ReactNativeViewViewConfigAndroid.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var React = _$$_REQUIRE(_dependencyMap[0]);

  var TextAncestorContext = React.createContext(false);
  module.exports = TextAncestorContext;
},"node_modules/react-native/Libraries/Text/TextAncestor.js",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = _$$_REQUIRE(_dependencyMap[0]);
},"node_modules/react-native/Libraries/Components/ProgressBarAndroid/ProgressBarAndroid.ios.js",["node_modules/react-native/Libraries/Components/UnimplementedViews/UnimplementedView.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[6]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var UnimplementedView = function (_React$Component) {
    (0, _inherits2.default)(UnimplementedView, _React$Component);

    var _super = _createSuper(UnimplementedView);

    function UnimplementedView() {
      (0, _classCallCheck2.default)(this, UnimplementedView);
      return _super.apply(this, arguments);
    }

    (0, _createClass2.default)(UnimplementedView, [{
      key: "render",
      value: function render() {
        var View = _$$_REQUIRE(_dependencyMap[8]);

        return React.createElement(View, {
          style: [styles.unimplementedView, this.props.style]
        }, this.props.children);
      }
    }]);
    return UnimplementedView;
  }(React.Component);

  var styles = _StyleSheet.default.create({
    unimplementedView: {}
  });

  module.exports = UnimplementedView;
},"node_modules/react-native/Libraries/Components/UnimplementedViews/UnimplementedView.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react/index.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Components/View/View.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _default = (0, _codegenNativeComponent.default)('ActivityIndicatorView', {
    paperComponentName: 'RCTActivityIndicatorView'
  });

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/ActivityIndicator/ActivityIndicatorViewNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _requireNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _UIManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  function codegenNativeComponent(componentName, options) {
    var componentNameInUse = options && options.paperComponentName != null ? options.paperComponentName : componentName;

    if (options != null && options.paperComponentNameDeprecated != null) {
      if (_UIManager.default.getViewManagerConfig(componentName)) {
        componentNameInUse = componentName;
      } else if (options.paperComponentNameDeprecated != null && _UIManager.default.getViewManagerConfig(options.paperComponentNameDeprecated)) {
        componentNameInUse = options.paperComponentNameDeprecated;
      } else {
        var _options$paperCompone;

        throw new Error("Failed to find native component for either " + componentName + " or " + ((_options$paperCompone = options.paperComponentNameDeprecated) != null ? _options$paperCompone : '(unknown)'));
      }
    }

    return (0, _requireNativeComponent.default)(componentNameInUse);
  }

  var _default = codegenNativeComponent;
  exports.default = _default;
},"node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/ReactNative/requireNativeComponent.js","node_modules/react-native/Libraries/ReactNative/UIManager.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var requireNativeComponent = function requireNativeComponent(uiViewClassName) {
    return _$$_REQUIRE(_dependencyMap[0])(uiViewClassName, function () {
      return _$$_REQUIRE(_dependencyMap[1])(uiViewClassName);
    });
  };

  module.exports = requireNativeComponent;
},"node_modules/react-native/Libraries/ReactNative/requireNativeComponent.js",["node_modules/react-native/Libraries/Renderer/shims/createReactNativeComponentClass.js","node_modules/react-native/Libraries/ReactNative/getNativeComponentAttributes.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var register = _$$_REQUIRE(_dependencyMap[0]).ReactNativeViewConfigRegistry.register;

  var createReactNativeComponentClass = function createReactNativeComponentClass(name, callback) {
    return register(name, callback);
  };

  module.exports = createReactNativeComponentClass;
},"node_modules/react-native/Libraries/Renderer/shims/createReactNativeComponentClass.js",["node_modules/react-native/Libraries/ReactPrivate/ReactNativePrivateInterface.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[7]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _Text = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _TouchableNativeFeedback = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _TouchableOpacity = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var _View = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[13]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[14]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var Button = function (_React$Component) {
    (0, _inherits2.default)(Button, _React$Component);

    var _super = _createSuper(Button);

    function Button() {
      (0, _classCallCheck2.default)(this, Button);
      return _super.apply(this, arguments);
    }

    (0, _createClass2.default)(Button, [{
      key: "render",
      value: function render() {
        var _this$props$accessibi, _this$props$accessibi2;

        var _this$props = this.props,
            accessibilityLabel = _this$props.accessibilityLabel,
            color = _this$props.color,
            onPress = _this$props.onPress,
            touchSoundDisabled = _this$props.touchSoundDisabled,
            title = _this$props.title,
            hasTVPreferredFocus = _this$props.hasTVPreferredFocus,
            nextFocusDown = _this$props.nextFocusDown,
            nextFocusForward = _this$props.nextFocusForward,
            nextFocusLeft = _this$props.nextFocusLeft,
            nextFocusRight = _this$props.nextFocusRight,
            nextFocusUp = _this$props.nextFocusUp,
            testID = _this$props.testID,
            accessible = _this$props.accessible,
            accessibilityActions = _this$props.accessibilityActions,
            accessibilityHint = _this$props.accessibilityHint,
            onAccessibilityAction = _this$props.onAccessibilityAction;
        var buttonStyles = [styles.button];
        var textStyles = [styles.text];

        if (color) {
          if (_Platform.default.OS === 'ios') {
            textStyles.push({
              color: color
            });
          } else {
            buttonStyles.push({
              backgroundColor: color
            });
          }
        }

        var disabled = this.props.disabled != null ? this.props.disabled : (_this$props$accessibi = this.props.accessibilityState) == null ? undefined : _this$props$accessibi.disabled;
        var accessibilityState = disabled !== ((_this$props$accessibi2 = this.props.accessibilityState) == null ? undefined : _this$props$accessibi2.disabled) ? (0, _extends2.default)({}, this.props.accessibilityState, {
          disabled: disabled
        }) : this.props.accessibilityState;

        if (disabled) {
          buttonStyles.push(styles.buttonDisabled);
          textStyles.push(styles.textDisabled);
        }

        (0, _invariant.default)(typeof title === 'string', 'The title prop of a Button must be a string');
        var formattedTitle = _Platform.default.OS === 'android' ? title.toUpperCase() : title;
        var Touchable = _Platform.default.OS === 'android' ? _TouchableNativeFeedback.default : _TouchableOpacity.default;
        return React.createElement(Touchable, {
          accessible: accessible,
          accessibilityActions: accessibilityActions,
          onAccessibilityAction: onAccessibilityAction,
          accessibilityLabel: accessibilityLabel,
          accessibilityHint: accessibilityHint,
          accessibilityRole: "button",
          accessibilityState: accessibilityState,
          hasTVPreferredFocus: hasTVPreferredFocus,
          nextFocusDown: nextFocusDown,
          nextFocusForward: nextFocusForward,
          nextFocusLeft: nextFocusLeft,
          nextFocusRight: nextFocusRight,
          nextFocusUp: nextFocusUp,
          testID: testID,
          disabled: disabled,
          onPress: onPress,
          touchSoundDisabled: touchSoundDisabled
        }, React.createElement(_View.default, {
          style: buttonStyles
        }, React.createElement(_Text.default, {
          style: textStyles,
          disabled: disabled
        }, formattedTitle)));
      }
    }]);
    return Button;
  }(React.Component);

  var styles = _StyleSheet.default.create({
    button: _Platform.default.select({
      ios: {},
      android: {
        elevation: 4,
        backgroundColor: '#2196F3',
        borderRadius: 2
      }
    }),
    text: (0, _extends2.default)({
      textAlign: 'center',
      margin: 8
    }, _Platform.default.select({
      ios: {
        color: '#007AFF',
        fontSize: 18
      },
      android: {
        color: 'white',
        fontWeight: '500'
      }
    })),
    buttonDisabled: _Platform.default.select({
      ios: {},
      android: {
        elevation: 0,
        backgroundColor: '#dfdfdf'
      }
    }),
    textDisabled: _Platform.default.select({
      ios: {
        color: '#cdcdcd'
      },
      android: {
        color: '#a1a1a1'
      }
    })
  });

  module.exports = Button;
},"node_modules/react-native/Libraries/Components/Button.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react/index.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Text/Text.js","node_modules/react-native/Libraries/Components/Touchable/TouchableNativeFeedback.js","node_modules/react-native/Libraries/Components/Touchable/TouchableOpacity.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var PressabilityDebug = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  var _usePressability = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _processColor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _TextAncestor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[9]));

  var _excluded = ["accessible", "allowFontScaling", "ellipsizeMode", "onLongPress", "onPress", "onPressIn", "onPressOut", "onResponderGrant", "onResponderMove", "onResponderRelease", "onResponderTerminate", "onResponderTerminationRequest", "onStartShouldSetResponder", "pressRetentionOffset", "suppressHighlighting"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var Text = React.forwardRef(function (props, forwardedRef) {
    var accessible = props.accessible,
        allowFontScaling = props.allowFontScaling,
        ellipsizeMode = props.ellipsizeMode,
        onLongPress = props.onLongPress,
        onPress = props.onPress,
        _onPressIn = props.onPressIn,
        _onPressOut = props.onPressOut,
        _onResponderGrant = props.onResponderGrant,
        _onResponderMove = props.onResponderMove,
        _onResponderRelease = props.onResponderRelease,
        _onResponderTerminate = props.onResponderTerminate,
        onResponderTerminationRequest = props.onResponderTerminationRequest,
        onStartShouldSetResponder = props.onStartShouldSetResponder,
        pressRetentionOffset = props.pressRetentionOffset,
        suppressHighlighting = props.suppressHighlighting,
        restProps = (0, _objectWithoutProperties2.default)(props, _excluded);

    var _useState = (0, React.useState)(false),
        _useState2 = (0, _slicedToArray2.default)(_useState, 2),
        isHighlighted = _useState2[0],
        setHighlighted = _useState2[1];

    var isPressable = (onPress != null || onLongPress != null || onStartShouldSetResponder != null) && restProps.disabled !== true;
    var initialized = useLazyInitialization(isPressable);
    var config = (0, React.useMemo)(function () {
      return initialized ? {
        disabled: !isPressable,
        pressRectOffset: pressRetentionOffset,
        onLongPress: onLongPress,
        onPress: onPress,
        onPressIn: function onPressIn(event) {
          setHighlighted(!suppressHighlighting);
          _onPressIn == null ? undefined : _onPressIn(event);
        },
        onPressOut: function onPressOut(event) {
          setHighlighted(false);
          _onPressOut == null ? undefined : _onPressOut(event);
        },
        onResponderTerminationRequest_DEPRECATED: onResponderTerminationRequest,
        onStartShouldSetResponder_DEPRECATED: onStartShouldSetResponder
      } : null;
    }, [initialized, isPressable, pressRetentionOffset, onLongPress, onPress, _onPressIn, _onPressOut, onResponderTerminationRequest, onStartShouldSetResponder, suppressHighlighting]);
    var eventHandlers = (0, _usePressability.default)(config);
    var eventHandlersForText = (0, React.useMemo)(function () {
      return eventHandlers == null ? null : {
        onResponderGrant: function onResponderGrant(event) {
          eventHandlers.onResponderGrant(event);

          if (_onResponderGrant != null) {
            _onResponderGrant(event);
          }
        },
        onResponderMove: function onResponderMove(event) {
          eventHandlers.onResponderMove(event);

          if (_onResponderMove != null) {
            _onResponderMove(event);
          }
        },
        onResponderRelease: function onResponderRelease(event) {
          eventHandlers.onResponderRelease(event);

          if (_onResponderRelease != null) {
            _onResponderRelease(event);
          }
        },
        onResponderTerminate: function onResponderTerminate(event) {
          eventHandlers.onResponderTerminate(event);

          if (_onResponderTerminate != null) {
            _onResponderTerminate(event);
          }
        },
        onResponderTerminationRequest: eventHandlers.onResponderTerminationRequest,
        onStartShouldSetResponder: eventHandlers.onStartShouldSetResponder
      };
    }, [eventHandlers, _onResponderGrant, _onResponderMove, _onResponderRelease, _onResponderTerminate]);
    var selectionColor = restProps.selectionColor == null ? null : (0, _processColor.default)(restProps.selectionColor);
    var style = restProps.style;
    var numberOfLines = restProps.numberOfLines;

    if (numberOfLines != null && !(numberOfLines >= 0)) {
      console.error("'numberOfLines' in <Text> must be a non-negative number, received: " + numberOfLines + ". The value will be set to 0.");
      numberOfLines = 0;
    }

    var hasTextAncestor = (0, React.useContext)(_TextAncestor.default);
    return hasTextAncestor ? React.createElement(_$$_REQUIRE(_dependencyMap[10]).NativeVirtualText, (0, _extends2.default)({}, restProps, eventHandlersForText, {
      isHighlighted: isHighlighted,
      isPressable: isPressable,
      numberOfLines: numberOfLines,
      selectionColor: selectionColor,
      style: style,
      ref: forwardedRef
    })) : React.createElement(_TextAncestor.default.Provider, {
      value: true
    }, React.createElement(_$$_REQUIRE(_dependencyMap[10]).NativeText, (0, _extends2.default)({}, restProps, eventHandlersForText, {
      accessible: accessible !== false,
      allowFontScaling: allowFontScaling !== false,
      ellipsizeMode: ellipsizeMode != null ? ellipsizeMode : 'tail',
      isHighlighted: isHighlighted,
      numberOfLines: numberOfLines,
      selectionColor: selectionColor,
      style: style,
      ref: forwardedRef
    })));
  });
  Text.displayName = 'Text';
  Text.propTypes = _$$_REQUIRE(_dependencyMap[11]).TextPropTypes;

  function useLazyInitialization(newValue) {
    var _useState3 = (0, React.useState)(newValue),
        _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
        oldValue = _useState4[0],
        setValue = _useState4[1];

    if (!oldValue && newValue) {
      setValue(newValue);
    }

    return oldValue;
  }

  module.exports = Text;
},"node_modules/react-native/Libraries/Text/Text.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react-native/Libraries/Pressability/PressabilityDebug.js","node_modules/react-native/Libraries/Pressability/usePressability.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/StyleSheet/processColor.js","node_modules/react-native/Libraries/Text/TextAncestor.js","node_modules/react/index.js","node_modules/react-native/Libraries/Text/TextNativeComponent.js","node_modules/deprecated-react-native-prop-types/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PressabilityDebugView = PressabilityDebugView;
  exports.isEnabled = isEnabled;
  exports.setEnabled = setEnabled;

  var _normalizeColor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _View = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function PressabilityDebugView(_ref) {
    var color = _ref.color,
        hitSlop = _ref.hitSlop;
    return null;
  }

  var isDebugEnabled = false;

  function isEnabled() {
    return false;
  }

  function setEnabled(value) {}
},"node_modules/react-native/Libraries/Pressability/PressabilityDebug.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/StyleSheet/normalizeColor.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = usePressability;

  var _Pressability = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _react = _$$_REQUIRE(_dependencyMap[2]);

  function usePressability(config) {
    var pressabilityRef = (0, _react.useRef)(null);

    if (config != null && pressabilityRef.current == null) {
      pressabilityRef.current = new _Pressability.default(config);
    }

    var pressability = pressabilityRef.current;
    (0, _react.useEffect)(function () {
      if (config != null && pressability != null) {
        pressability.configure(config);
      }
    }, [config, pressability]);
    (0, _react.useEffect)(function () {
      if (pressability != null) {
        return function () {
          pressability.reset();
        };
      }
    }, [pressability]);
    return pressability == null ? null : pressability.getEventHandlers();
  }
},"node_modules/react-native/Libraries/Pressability/usePressability.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Pressability/Pressability.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _SoundManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _PressabilityPerformanceEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _UIManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[9]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var Transitions = Object.freeze({
    NOT_RESPONDER: {
      DELAY: 'ERROR',
      RESPONDER_GRANT: 'RESPONDER_INACTIVE_PRESS_IN',
      RESPONDER_RELEASE: 'ERROR',
      RESPONDER_TERMINATED: 'ERROR',
      ENTER_PRESS_RECT: 'ERROR',
      LEAVE_PRESS_RECT: 'ERROR',
      LONG_PRESS_DETECTED: 'ERROR'
    },
    RESPONDER_INACTIVE_PRESS_IN: {
      DELAY: 'RESPONDER_ACTIVE_PRESS_IN',
      RESPONDER_GRANT: 'ERROR',
      RESPONDER_RELEASE: 'NOT_RESPONDER',
      RESPONDER_TERMINATED: 'NOT_RESPONDER',
      ENTER_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_IN',
      LEAVE_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_OUT',
      LONG_PRESS_DETECTED: 'ERROR'
    },
    RESPONDER_INACTIVE_PRESS_OUT: {
      DELAY: 'RESPONDER_ACTIVE_PRESS_OUT',
      RESPONDER_GRANT: 'ERROR',
      RESPONDER_RELEASE: 'NOT_RESPONDER',
      RESPONDER_TERMINATED: 'NOT_RESPONDER',
      ENTER_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_IN',
      LEAVE_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_OUT',
      LONG_PRESS_DETECTED: 'ERROR'
    },
    RESPONDER_ACTIVE_PRESS_IN: {
      DELAY: 'ERROR',
      RESPONDER_GRANT: 'ERROR',
      RESPONDER_RELEASE: 'NOT_RESPONDER',
      RESPONDER_TERMINATED: 'NOT_RESPONDER',
      ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_IN',
      LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_OUT',
      LONG_PRESS_DETECTED: 'RESPONDER_ACTIVE_LONG_PRESS_IN'
    },
    RESPONDER_ACTIVE_PRESS_OUT: {
      DELAY: 'ERROR',
      RESPONDER_GRANT: 'ERROR',
      RESPONDER_RELEASE: 'NOT_RESPONDER',
      RESPONDER_TERMINATED: 'NOT_RESPONDER',
      ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_IN',
      LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_OUT',
      LONG_PRESS_DETECTED: 'ERROR'
    },
    RESPONDER_ACTIVE_LONG_PRESS_IN: {
      DELAY: 'ERROR',
      RESPONDER_GRANT: 'ERROR',
      RESPONDER_RELEASE: 'NOT_RESPONDER',
      RESPONDER_TERMINATED: 'NOT_RESPONDER',
      ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_IN',
      LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',
      LONG_PRESS_DETECTED: 'RESPONDER_ACTIVE_LONG_PRESS_IN'
    },
    RESPONDER_ACTIVE_LONG_PRESS_OUT: {
      DELAY: 'ERROR',
      RESPONDER_GRANT: 'ERROR',
      RESPONDER_RELEASE: 'NOT_RESPONDER',
      RESPONDER_TERMINATED: 'NOT_RESPONDER',
      ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_IN',
      LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',
      LONG_PRESS_DETECTED: 'ERROR'
    },
    ERROR: {
      DELAY: 'NOT_RESPONDER',
      RESPONDER_GRANT: 'RESPONDER_INACTIVE_PRESS_IN',
      RESPONDER_RELEASE: 'NOT_RESPONDER',
      RESPONDER_TERMINATED: 'NOT_RESPONDER',
      ENTER_PRESS_RECT: 'NOT_RESPONDER',
      LEAVE_PRESS_RECT: 'NOT_RESPONDER',
      LONG_PRESS_DETECTED: 'NOT_RESPONDER'
    }
  });

  var isActiveSignal = function isActiveSignal(signal) {
    return signal === 'RESPONDER_ACTIVE_PRESS_IN' || signal === 'RESPONDER_ACTIVE_LONG_PRESS_IN';
  };

  var isActivationSignal = function isActivationSignal(signal) {
    return signal === 'RESPONDER_ACTIVE_PRESS_OUT' || signal === 'RESPONDER_ACTIVE_PRESS_IN';
  };

  var isPressInSignal = function isPressInSignal(signal) {
    return signal === 'RESPONDER_INACTIVE_PRESS_IN' || signal === 'RESPONDER_ACTIVE_PRESS_IN' || signal === 'RESPONDER_ACTIVE_LONG_PRESS_IN';
  };

  var isTerminalSignal = function isTerminalSignal(signal) {
    return signal === 'RESPONDER_TERMINATED' || signal === 'RESPONDER_RELEASE';
  };

  var DEFAULT_LONG_PRESS_DELAY_MS = 500;
  var DEFAULT_PRESS_RECT_OFFSETS = {
    bottom: 30,
    left: 20,
    right: 20,
    top: 20
  };
  var DEFAULT_MIN_PRESS_DURATION = 130;

  var Pressability = function () {
    function Pressability(config) {
      var _this = this;

      (0, _classCallCheck2.default)(this, Pressability);
      this._eventHandlers = null;
      this._hoverInDelayTimeout = null;
      this._hoverOutDelayTimeout = null;
      this._isHovered = false;
      this._longPressDelayTimeout = null;
      this._pressDelayTimeout = null;
      this._pressOutDelayTimeout = null;
      this._responderID = null;
      this._responderRegion = null;
      this._touchState = 'NOT_RESPONDER';

      this._measureCallback = function (left, top, width, height, pageX, pageY) {
        if (!left && !top && !width && !height && !pageX && !pageY) {
          return;
        }

        _this._responderRegion = {
          bottom: pageY + height,
          left: pageX,
          right: pageX + width,
          top: pageY
        };
      };

      this.configure(config);
    }

    (0, _createClass2.default)(Pressability, [{
      key: "configure",
      value: function configure(config) {
        this._config = config;
      }
    }, {
      key: "reset",
      value: function reset() {
        this._cancelHoverInDelayTimeout();

        this._cancelHoverOutDelayTimeout();

        this._cancelLongPressDelayTimeout();

        this._cancelPressDelayTimeout();

        this._cancelPressOutDelayTimeout();

        this._config = Object.freeze({});
      }
    }, {
      key: "getEventHandlers",
      value: function getEventHandlers() {
        if (this._eventHandlers == null) {
          this._eventHandlers = this._createEventHandlers();
        }

        return this._eventHandlers;
      }
    }, {
      key: "_createEventHandlers",
      value: function _createEventHandlers() {
        var _this2 = this;

        var focusEventHandlers = {
          onBlur: function onBlur(event) {
            var onBlur = _this2._config.onBlur;

            if (onBlur != null) {
              onBlur(event);
            }
          },
          onFocus: function onFocus(event) {
            var onFocus = _this2._config.onFocus;

            if (onFocus != null) {
              onFocus(event);
            }
          }
        };
        var responderEventHandlers = {
          onStartShouldSetResponder: function onStartShouldSetResponder() {
            var disabled = _this2._config.disabled;

            if (disabled == null) {
              var onStartShouldSetResponder_DEPRECATED = _this2._config.onStartShouldSetResponder_DEPRECATED;
              return onStartShouldSetResponder_DEPRECATED == null ? true : onStartShouldSetResponder_DEPRECATED();
            }

            return !disabled;
          },
          onResponderGrant: function onResponderGrant(event) {
            event.persist();

            _this2._cancelPressOutDelayTimeout();

            _this2._responderID = event.currentTarget;
            _this2._touchState = 'NOT_RESPONDER';

            _this2._receiveSignal('RESPONDER_GRANT', event);

            var delayPressIn = normalizeDelay(_this2._config.delayPressIn);

            if (delayPressIn > 0) {
              _this2._pressDelayTimeout = setTimeout(function () {
                _this2._receiveSignal('DELAY', event);
              }, delayPressIn);
            } else {
              _this2._receiveSignal('DELAY', event);
            }

            var delayLongPress = normalizeDelay(_this2._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS - delayPressIn);
            _this2._longPressDelayTimeout = setTimeout(function () {
              _this2._handleLongPress(event);
            }, delayLongPress + delayPressIn);
          },
          onResponderMove: function onResponderMove(event) {
            var onPressMove = _this2._config.onPressMove;

            if (onPressMove != null) {
              onPressMove(event);
            }

            var responderRegion = _this2._responderRegion;

            if (responderRegion == null) {
              return;
            }

            var touch = getTouchFromPressEvent(event);

            if (touch == null) {
              _this2._cancelLongPressDelayTimeout();

              _this2._receiveSignal('LEAVE_PRESS_RECT', event);

              return;
            }

            if (_this2._touchActivatePosition != null) {
              var deltaX = _this2._touchActivatePosition.pageX - touch.pageX;
              var deltaY = _this2._touchActivatePosition.pageY - touch.pageY;

              if (Math.hypot(deltaX, deltaY) > 10) {
                _this2._cancelLongPressDelayTimeout();
              }
            }

            if (_this2._isTouchWithinResponderRegion(touch, responderRegion)) {
              _this2._receiveSignal('ENTER_PRESS_RECT', event);
            } else {
              _this2._cancelLongPressDelayTimeout();

              _this2._receiveSignal('LEAVE_PRESS_RECT', event);
            }
          },
          onResponderRelease: function onResponderRelease(event) {
            _this2._receiveSignal('RESPONDER_RELEASE', event);
          },
          onResponderTerminate: function onResponderTerminate(event) {
            _this2._receiveSignal('RESPONDER_TERMINATED', event);
          },
          onResponderTerminationRequest: function onResponderTerminationRequest() {
            var cancelable = _this2._config.cancelable;

            if (cancelable == null) {
              var onResponderTerminationRequest_DEPRECATED = _this2._config.onResponderTerminationRequest_DEPRECATED;
              return onResponderTerminationRequest_DEPRECATED == null ? true : onResponderTerminationRequest_DEPRECATED();
            }

            return cancelable;
          },
          onClick: function onClick(event) {
            var _this2$_config = _this2._config,
                onPress = _this2$_config.onPress,
                disabled = _this2$_config.disabled;

            if (onPress != null && disabled !== true) {
              onPress(event);
            }
          }
        };
        var mouseEventHandlers = _Platform.default.OS === 'ios' || _Platform.default.OS === 'android' ? null : {
          onMouseEnter: function onMouseEnter(event) {
            if ((0, _$$_REQUIRE(_dependencyMap[10]).isHoverEnabled)()) {
              _this2._isHovered = true;

              _this2._cancelHoverOutDelayTimeout();

              var onHoverIn = _this2._config.onHoverIn;

              if (onHoverIn != null) {
                var delayHoverIn = normalizeDelay(_this2._config.delayHoverIn);

                if (delayHoverIn > 0) {
                  event.persist();
                  _this2._hoverInDelayTimeout = setTimeout(function () {
                    onHoverIn(event);
                  }, delayHoverIn);
                } else {
                  onHoverIn(event);
                }
              }
            }
          },
          onMouseLeave: function onMouseLeave(event) {
            if (_this2._isHovered) {
              _this2._isHovered = false;

              _this2._cancelHoverInDelayTimeout();

              var onHoverOut = _this2._config.onHoverOut;

              if (onHoverOut != null) {
                var delayHoverOut = normalizeDelay(_this2._config.delayHoverOut);

                if (delayHoverOut > 0) {
                  event.persist();
                  _this2._hoverInDelayTimeout = setTimeout(function () {
                    onHoverOut(event);
                  }, delayHoverOut);
                } else {
                  onHoverOut(event);
                }
              }
            }
          }
        };
        return (0, _extends2.default)({}, focusEventHandlers, responderEventHandlers, mouseEventHandlers);
      }
    }, {
      key: "_receiveSignal",
      value: function _receiveSignal(signal, event) {
        var _Transitions$prevStat;

        if (event.nativeEvent.timestamp != null) {
          _PressabilityPerformanceEventEmitter.default.emitEvent(function () {
            return {
              signal: signal,
              nativeTimestamp: event.nativeEvent.timestamp
            };
          });
        }

        var prevState = this._touchState;
        var nextState = (_Transitions$prevStat = Transitions[prevState]) == null ? undefined : _Transitions$prevStat[signal];

        if (this._responderID == null && signal === 'RESPONDER_RELEASE') {
          return;
        }

        (0, _invariant.default)(nextState != null && nextState !== 'ERROR', 'Pressability: Invalid signal `%s` for state `%s` on responder: %s', signal, prevState, typeof this._responderID === 'number' ? this._responderID : '<<host component>>');

        if (prevState !== nextState) {
          this._performTransitionSideEffects(prevState, nextState, signal, event);

          this._touchState = nextState;
        }
      }
    }, {
      key: "_performTransitionSideEffects",
      value: function _performTransitionSideEffects(prevState, nextState, signal, event) {
        if (isTerminalSignal(signal)) {
          this._touchActivatePosition = null;

          this._cancelLongPressDelayTimeout();
        }

        var isInitialTransition = prevState === 'NOT_RESPONDER' && nextState === 'RESPONDER_INACTIVE_PRESS_IN';
        var isActivationTransition = !isActivationSignal(prevState) && isActivationSignal(nextState);

        if (isInitialTransition || isActivationTransition) {
          this._measureResponderRegion();
        }

        if (isPressInSignal(prevState) && signal === 'LONG_PRESS_DETECTED') {
          var onLongPress = this._config.onLongPress;

          if (onLongPress != null) {
            onLongPress(event);
          }
        }

        var isPrevActive = isActiveSignal(prevState);
        var isNextActive = isActiveSignal(nextState);

        if (!isPrevActive && isNextActive) {
          this._activate(event);
        } else if (isPrevActive && !isNextActive) {
          this._deactivate(event);
        }

        if (isPressInSignal(prevState) && signal === 'RESPONDER_RELEASE') {
          if (!isNextActive && !isPrevActive) {
            this._activate(event);

            this._deactivate(event);
          }

          var _this$_config = this._config,
              _onLongPress = _this$_config.onLongPress,
              onPress = _this$_config.onPress,
              android_disableSound = _this$_config.android_disableSound;

          if (onPress != null) {
            var isPressCanceledByLongPress = _onLongPress != null && prevState === 'RESPONDER_ACTIVE_LONG_PRESS_IN' && this._shouldLongPressCancelPress();

            if (!isPressCanceledByLongPress) {
              if (_Platform.default.OS === 'android' && android_disableSound !== true) {
                _SoundManager.default.playTouchSound();
              }

              onPress(event);
            }
          }
        }

        this._cancelPressDelayTimeout();
      }
    }, {
      key: "_activate",
      value: function _activate(event) {
        var onPressIn = this._config.onPressIn;

        var _getTouchFromPressEve = getTouchFromPressEvent(event),
            pageX = _getTouchFromPressEve.pageX,
            pageY = _getTouchFromPressEve.pageY;

        this._touchActivatePosition = {
          pageX: pageX,
          pageY: pageY
        };
        this._touchActivateTime = Date.now();

        if (onPressIn != null) {
          onPressIn(event);
        }
      }
    }, {
      key: "_deactivate",
      value: function _deactivate(event) {
        var onPressOut = this._config.onPressOut;

        if (onPressOut != null) {
          var _this$_touchActivateT;

          var minPressDuration = normalizeDelay(this._config.minPressDuration, 0, DEFAULT_MIN_PRESS_DURATION);
          var pressDuration = Date.now() - ((_this$_touchActivateT = this._touchActivateTime) != null ? _this$_touchActivateT : 0);
          var delayPressOut = Math.max(minPressDuration - pressDuration, normalizeDelay(this._config.delayPressOut));

          if (delayPressOut > 0) {
            event.persist();
            this._pressOutDelayTimeout = setTimeout(function () {
              onPressOut(event);
            }, delayPressOut);
          } else {
            onPressOut(event);
          }
        }

        this._touchActivateTime = null;
      }
    }, {
      key: "_measureResponderRegion",
      value: function _measureResponderRegion() {
        if (this._responderID == null) {
          return;
        }

        if (typeof this._responderID === 'number') {
          _UIManager.default.measure(this._responderID, this._measureCallback);
        } else {
          this._responderID.measure(this._measureCallback);
        }
      }
    }, {
      key: "_isTouchWithinResponderRegion",
      value: function _isTouchWithinResponderRegion(touch, responderRegion) {
        var _pressRectOffset$bott, _pressRectOffset$left, _pressRectOffset$righ, _pressRectOffset$top;

        var hitSlop = (0, _$$_REQUIRE(_dependencyMap[11]).normalizeRect)(this._config.hitSlop);
        var pressRectOffset = (0, _$$_REQUIRE(_dependencyMap[11]).normalizeRect)(this._config.pressRectOffset);
        var regionBottom = responderRegion.bottom;
        var regionLeft = responderRegion.left;
        var regionRight = responderRegion.right;
        var regionTop = responderRegion.top;

        if (hitSlop != null) {
          if (hitSlop.bottom != null) {
            regionBottom += hitSlop.bottom;
          }

          if (hitSlop.left != null) {
            regionLeft -= hitSlop.left;
          }

          if (hitSlop.right != null) {
            regionRight += hitSlop.right;
          }

          if (hitSlop.top != null) {
            regionTop -= hitSlop.top;
          }
        }

        regionBottom += (_pressRectOffset$bott = pressRectOffset == null ? undefined : pressRectOffset.bottom) != null ? _pressRectOffset$bott : DEFAULT_PRESS_RECT_OFFSETS.bottom;
        regionLeft -= (_pressRectOffset$left = pressRectOffset == null ? undefined : pressRectOffset.left) != null ? _pressRectOffset$left : DEFAULT_PRESS_RECT_OFFSETS.left;
        regionRight += (_pressRectOffset$righ = pressRectOffset == null ? undefined : pressRectOffset.right) != null ? _pressRectOffset$righ : DEFAULT_PRESS_RECT_OFFSETS.right;
        regionTop -= (_pressRectOffset$top = pressRectOffset == null ? undefined : pressRectOffset.top) != null ? _pressRectOffset$top : DEFAULT_PRESS_RECT_OFFSETS.top;
        return touch.pageX > regionLeft && touch.pageX < regionRight && touch.pageY > regionTop && touch.pageY < regionBottom;
      }
    }, {
      key: "_handleLongPress",
      value: function _handleLongPress(event) {
        if (this._touchState === 'RESPONDER_ACTIVE_PRESS_IN' || this._touchState === 'RESPONDER_ACTIVE_LONG_PRESS_IN') {
          this._receiveSignal('LONG_PRESS_DETECTED', event);
        }
      }
    }, {
      key: "_shouldLongPressCancelPress",
      value: function _shouldLongPressCancelPress() {
        return this._config.onLongPressShouldCancelPress_DEPRECATED == null || this._config.onLongPressShouldCancelPress_DEPRECATED();
      }
    }, {
      key: "_cancelHoverInDelayTimeout",
      value: function _cancelHoverInDelayTimeout() {
        if (this._hoverInDelayTimeout != null) {
          clearTimeout(this._hoverInDelayTimeout);
          this._hoverInDelayTimeout = null;
        }
      }
    }, {
      key: "_cancelHoverOutDelayTimeout",
      value: function _cancelHoverOutDelayTimeout() {
        if (this._hoverOutDelayTimeout != null) {
          clearTimeout(this._hoverOutDelayTimeout);
          this._hoverOutDelayTimeout = null;
        }
      }
    }, {
      key: "_cancelLongPressDelayTimeout",
      value: function _cancelLongPressDelayTimeout() {
        if (this._longPressDelayTimeout != null) {
          clearTimeout(this._longPressDelayTimeout);
          this._longPressDelayTimeout = null;
        }
      }
    }, {
      key: "_cancelPressDelayTimeout",
      value: function _cancelPressDelayTimeout() {
        if (this._pressDelayTimeout != null) {
          clearTimeout(this._pressDelayTimeout);
          this._pressDelayTimeout = null;
        }
      }
    }, {
      key: "_cancelPressOutDelayTimeout",
      value: function _cancelPressOutDelayTimeout() {
        if (this._pressOutDelayTimeout != null) {
          clearTimeout(this._pressOutDelayTimeout);
          this._pressOutDelayTimeout = null;
        }
      }
    }]);
    return Pressability;
  }();

  exports.default = Pressability;

  function normalizeDelay(delay) {
    var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    return Math.max(min, delay != null ? delay : fallback);
  }

  var getTouchFromPressEvent = function getTouchFromPressEvent(event) {
    var _event$nativeEvent = event.nativeEvent,
        changedTouches = _event$nativeEvent.changedTouches,
        touches = _event$nativeEvent.touches;

    if (touches != null && touches.length > 0) {
      return touches[0];
    }

    if (changedTouches != null && changedTouches.length > 0) {
      return changedTouches[0];
    }

    return event.nativeEvent;
  };
},"node_modules/react-native/Libraries/Pressability/Pressability.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/Components/Sound/SoundManager.js","node_modules/react-native/Libraries/Pressability/PressabilityPerformanceEventEmitter.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/ReactNative/UIManager.js","node_modules/react/index.js","node_modules/react-native/Libraries/Pressability/HoverState.js","node_modules/react-native/Libraries/StyleSheet/Rect.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _NativeSoundManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var SoundManager = {
    playTouchSound: function playTouchSound() {
      if (_NativeSoundManager.default) {
        _NativeSoundManager.default.playTouchSound();
      }
    }
  };
  module.exports = SoundManager;
},"node_modules/react-native/Libraries/Components/Sound/SoundManager.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Components/Sound/NativeSoundManager.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('SoundManager');

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/Sound/NativeSoundManager.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var PressabilityPerformanceEventEmitter = function () {
    function PressabilityPerformanceEventEmitter() {
      (0, _classCallCheck2.default)(this, PressabilityPerformanceEventEmitter);
      this._listeners = [];
    }

    (0, _createClass2.default)(PressabilityPerformanceEventEmitter, [{
      key: "addListener",
      value: function addListener(listener) {
        this._listeners.push(listener);
      }
    }, {
      key: "removeListener",
      value: function removeListener(listener) {
        var index = this._listeners.indexOf(listener);

        if (index > -1) {
          this._listeners.splice(index, 1);
        }
      }
    }, {
      key: "emitEvent",
      value: function emitEvent(constructEvent) {
        if (this._listeners.length === 0) {
          return;
        }

        var event = constructEvent();

        this._listeners.forEach(function (listener) {
          return listener(event);
        });
      }
    }]);
    return PressabilityPerformanceEventEmitter;
  }();

  var PressabilityPerformanceEventEmitterSingleton = new PressabilityPerformanceEventEmitter();
  var _default = PressabilityPerformanceEventEmitterSingleton;
  exports.default = _default;
},"node_modules/react-native/Libraries/Pressability/PressabilityPerformanceEventEmitter.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isHoverEnabled = isHoverEnabled;

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var isEnabled = false;

  if (_Platform.default.OS === 'web') {
    var canUseDOM = Boolean(typeof window !== 'undefined' && window.document && window.document.createElement);

    if (canUseDOM) {
      var HOVER_THRESHOLD_MS = 1000;
      var lastTouchTimestamp = 0;

      var enableHover = function enableHover() {
        if (isEnabled || Date.now() - lastTouchTimestamp < HOVER_THRESHOLD_MS) {
          return;
        }

        isEnabled = true;
      };

      var disableHover = function disableHover() {
        lastTouchTimestamp = Date.now();

        if (isEnabled) {
          isEnabled = false;
        }
      };

      document.addEventListener('touchstart', disableHover, true);
      document.addEventListener('touchmove', disableHover, true);
      document.addEventListener('mousemove', enableHover, true);
    }
  }

  function isHoverEnabled() {
    return isEnabled;
  }
},"node_modules/react-native/Libraries/Pressability/HoverState.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createSquare = createSquare;
  exports.normalizeRect = normalizeRect;

  function createSquare(size) {
    return {
      bottom: size,
      left: size,
      right: size,
      top: size
    };
  }

  function normalizeRect(rectOrSize) {
    return typeof rectOrSize === 'number' ? createSquare(rectOrSize) : rectOrSize;
  }
},"node_modules/react-native/Libraries/StyleSheet/Rect.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NativeVirtualText = exports.NativeText = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _ReactNativeViewAttributes = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _UIManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createReactNativeComponentClass = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var NativeText = (0, _createReactNativeComponentClass.default)('RCTText', function () {
    return {
      validAttributes: (0, _extends2.default)({}, _ReactNativeViewAttributes.default.UIView, {
        isHighlighted: true,
        isPressable: true,
        numberOfLines: true,
        ellipsizeMode: true,
        allowFontScaling: true,
        maxFontSizeMultiplier: true,
        disabled: true,
        selectable: true,
        selectionColor: true,
        adjustsFontSizeToFit: true,
        minimumFontScale: true,
        textBreakStrategy: true,
        onTextLayout: true,
        onInlineViewLayout: true,
        dataDetectorType: true,
        android_hyphenationFrequency: true
      }),
      directEventTypes: {
        topTextLayout: {
          registrationName: 'onTextLayout'
        },
        topInlineViewLayout: {
          registrationName: 'onInlineViewLayout'
        }
      },
      uiViewClassName: 'RCTText'
    };
  });
  exports.NativeText = NativeText;
  var NativeVirtualText = !global.RN$Bridgeless && !_UIManager.default.hasViewManagerConfig('RCTVirtualText') ? NativeText : (0, _createReactNativeComponentClass.default)('RCTVirtualText', function () {
    return {
      validAttributes: (0, _extends2.default)({}, _ReactNativeViewAttributes.default.UIView, {
        isHighlighted: true,
        isPressable: true,
        maxFontSizeMultiplier: true
      }),
      uiViewClassName: 'RCTVirtualText'
    };
  });
  exports.NativeVirtualText = NativeVirtualText;
},"node_modules/react-native/Libraries/Text/TextNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Components/View/ReactNativeViewAttributes.js","node_modules/react-native/Libraries/ReactNative/UIManager.js","node_modules/react-native/Libraries/Renderer/shims/createReactNativeComponentClass.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _ReactNativeStyleAttributes = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var UIView = {
    pointerEvents: true,
    accessible: true,
    accessibilityActions: true,
    accessibilityLabel: true,
    accessibilityLiveRegion: true,
    accessibilityRole: true,
    accessibilityState: true,
    accessibilityValue: true,
    accessibilityHint: true,
    importantForAccessibility: true,
    nativeID: true,
    testID: true,
    renderToHardwareTextureAndroid: true,
    shouldRasterizeIOS: true,
    onLayout: true,
    onAccessibilityAction: true,
    onAccessibilityTap: true,
    onMagicTap: true,
    onAccessibilityEscape: true,
    collapsable: true,
    needsOffscreenAlphaCompositing: true,
    style: _ReactNativeStyleAttributes.default
  };
  var RCTView = (0, _extends2.default)({}, UIView, {
    removeClippedSubviews: true
  });
  var ReactNativeViewAttributes = {
    UIView: UIView,
    RCTView: RCTView
  };
  module.exports = ReactNativeViewAttributes;
},"node_modules/react-native/Libraries/Components/View/ReactNativeViewAttributes.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = {
    get ColorPropType() {
      return _$$_REQUIRE(_dependencyMap[0]);
    },

    get EdgeInsetsPropType() {
      return _$$_REQUIRE(_dependencyMap[1]);
    },

    get ImagePropTypes() {
      return _$$_REQUIRE(_dependencyMap[2]);
    },

    get PointPropType() {
      return _$$_REQUIRE(_dependencyMap[3]);
    },

    get TextInputPropTypes() {
      return _$$_REQUIRE(_dependencyMap[4]);
    },

    get TextPropTypes() {
      return _$$_REQUIRE(_dependencyMap[5]);
    },

    get ViewPropTypes() {
      return _$$_REQUIRE(_dependencyMap[6]);
    }

  };
},"node_modules/deprecated-react-native-prop-types/index.js",["node_modules/deprecated-react-native-prop-types/DeprecatedColorPropType.js","node_modules/deprecated-react-native-prop-types/DeprecatedEdgeInsetsPropType.js","node_modules/deprecated-react-native-prop-types/DeprecatedImagePropType.js","node_modules/deprecated-react-native-prop-types/DeprecatedPointPropType.js","node_modules/deprecated-react-native-prop-types/DeprecatedTextInputPropTypes.js","node_modules/deprecated-react-native-prop-types/DeprecatedTextPropTypes.js","node_modules/deprecated-react-native-prop-types/DeprecatedViewPropTypes.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var colorPropType = function colorPropType(isRequired, props, propName, componentName, location, propFullName) {
    var color = props[propName];

    if (color == null) {
      if (isRequired) {
        return new Error('Required ' + location + ' `' + (propFullName || propName) + '` was not specified in `' + componentName + '`.');
      }

      return;
    }

    if (typeof color === 'number') {
      return;
    }

    if (typeof color === 'string' && _$$_REQUIRE(_dependencyMap[0])(color) === null) {
      return new Error('Invalid ' + location + ' `' + (propFullName || propName) + '` supplied to `' + componentName + '`: ' + color + '\n' + "Valid color formats are\n  - '#f0f' (#rgb)\n  - '#f0fc' (#rgba)\n  - '#ff00ff' (#rrggbb)\n  - '#ff00ff00' (#rrggbbaa)\n  - 'rgb(255, 255, 255)'\n  - 'rgba(255, 255, 255, 1.0)'\n  - 'hsl(360, 100%, 100%)'\n  - 'hsla(360, 100%, 100%, 1.0)'\n  - 'transparent'\n  - 'red'\n  - 0xff00ff00 (0xrrggbbaa)\n");
    }
  };

  var ColorPropType = colorPropType.bind(null, false);
  ColorPropType.isRequired = colorPropType.bind(null, true);
  module.exports = ColorPropType;
},"node_modules/deprecated-react-native-prop-types/DeprecatedColorPropType.js",["node_modules/@react-native/normalize-color/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var DeprecatedEdgeInsetsPropType = _$$_REQUIRE(_dependencyMap[0]).shape({
    top: _$$_REQUIRE(_dependencyMap[0]).number,
    left: _$$_REQUIRE(_dependencyMap[0]).number,
    bottom: _$$_REQUIRE(_dependencyMap[0]).number,
    right: _$$_REQUIRE(_dependencyMap[0]).number
  });

  module.exports = DeprecatedEdgeInsetsPropType;
},"node_modules/deprecated-react-native-prop-types/DeprecatedEdgeInsetsPropType.js",["node_modules/prop-types/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  {
    module.exports = _$$_REQUIRE(_dependencyMap[0])();
  }
},"node_modules/prop-types/index.js",["node_modules/prop-types/factoryWithThrowingShims.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function emptyFunction() {}

  function emptyFunctionWithReset() {}

  emptyFunctionWithReset.resetWarningCache = emptyFunction;

  module.exports = function () {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === _$$_REQUIRE(_dependencyMap[0])) {
        return;
      }

      var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
      err.name = 'Invariant Violation';
      throw err;
    }

    ;
    shim.isRequired = shim;

    function getShim() {
      return shim;
    }

    ;
    var ReactPropTypes = {
      array: shim,
      bigint: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
},"node_modules/prop-types/factoryWithThrowingShims.js",["node_modules/prop-types/lib/ReactPropTypesSecret.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
  module.exports = ReactPropTypesSecret;
},"node_modules/prop-types/lib/ReactPropTypesSecret.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = {
    style: _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1])),
    source: _$$_REQUIRE(_dependencyMap[2]),
    defaultSource: _$$_REQUIRE(_dependencyMap[3]).oneOfType([_$$_REQUIRE(_dependencyMap[3]).shape({
      uri: _$$_REQUIRE(_dependencyMap[3]).string,
      width: _$$_REQUIRE(_dependencyMap[3]).number,
      height: _$$_REQUIRE(_dependencyMap[3]).number,
      scale: _$$_REQUIRE(_dependencyMap[3]).number
    }), _$$_REQUIRE(_dependencyMap[3]).number]),
    accessible: _$$_REQUIRE(_dependencyMap[3]).bool,
    accessibilityLabel: _$$_REQUIRE(_dependencyMap[3]).node,
    blurRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    capInsets: _$$_REQUIRE(_dependencyMap[4]),
    resizeMethod: _$$_REQUIRE(_dependencyMap[3]).oneOf(['auto', 'resize', 'scale']),
    resizeMode: _$$_REQUIRE(_dependencyMap[3]).oneOf(['cover', 'contain', 'stretch', 'repeat', 'center']),
    testID: _$$_REQUIRE(_dependencyMap[3]).string,
    onLayout: _$$_REQUIRE(_dependencyMap[3]).func,
    onLoadStart: _$$_REQUIRE(_dependencyMap[3]).func,
    onProgress: _$$_REQUIRE(_dependencyMap[3]).func,
    onError: _$$_REQUIRE(_dependencyMap[3]).func,
    onPartialLoad: _$$_REQUIRE(_dependencyMap[3]).func,
    onLoad: _$$_REQUIRE(_dependencyMap[3]).func,
    onLoadEnd: _$$_REQUIRE(_dependencyMap[3]).func
  };
},"node_modules/deprecated-react-native-prop-types/DeprecatedImagePropType.js",["node_modules/deprecated-react-native-prop-types/DeprecatedStyleSheetPropType.js","node_modules/deprecated-react-native-prop-types/DeprecatedImageStylePropTypes.js","node_modules/deprecated-react-native-prop-types/DeprecatedImageSourcePropType.js","node_modules/prop-types/index.js","node_modules/deprecated-react-native-prop-types/DeprecatedEdgeInsetsPropType.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function DeprecatedStyleSheetPropType(shape) {
    var shapePropType = _$$_REQUIRE(_dependencyMap[0])(shape);

    return function (props, propName, componentName, location) {
      var newProps = props;

      if (props[propName]) {
        newProps = {};
        newProps[propName] = flattenStyle(props[propName]);
      }

      for (var _len = arguments.length, rest = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
        rest[_key - 4] = arguments[_key];
      }

      return shapePropType.apply(undefined, [newProps, propName, componentName, location].concat(rest));
    };
  }

  function flattenStyle(style) {
    if (style === null || typeof style !== 'object') {
      return undefined;
    }

    if (!Array.isArray(style)) {
      return style;
    }

    var result = {};

    for (var i = 0, styleLength = style.length; i < styleLength; ++i) {
      var computedStyle = flattenStyle(style[i]);

      if (computedStyle) {
        for (var key in computedStyle) {
          result[key] = computedStyle[key];
        }
      }
    }

    return result;
  }

  module.exports = DeprecatedStyleSheetPropType;
},"node_modules/deprecated-react-native-prop-types/DeprecatedStyleSheetPropType.js",["node_modules/deprecated-react-native-prop-types/deprecatedCreateStrictShapeTypeChecker.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function deprecatedCreateStrictShapeTypeChecker(shapeTypes) {
    function checkType(isRequired, props, propName, componentName, location) {
      if (!props[propName]) {
        if (isRequired) {
          _$$_REQUIRE(_dependencyMap[0])(false, "Required object `" + propName + "` was not specified in " + ("`" + componentName + "`."));
        }

        return;
      }

      var propValue = props[propName];
      var propType = typeof propValue;
      var locationName = location || '(unknown)';

      if (propType !== 'object') {
        _$$_REQUIRE(_dependencyMap[0])(false, "Invalid " + locationName + " `" + propName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
      }

      var allKeys = _$$_REQUIRE(_dependencyMap[1])({}, props[propName], shapeTypes);

      for (var _len = arguments.length, rest = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
        rest[_key - 5] = arguments[_key];
      }

      for (var key in allKeys) {
        var checker = shapeTypes[key];

        if (!checker) {
          _$$_REQUIRE(_dependencyMap[0])(false, "Invalid props." + propName + " key `" + key + "` supplied to `" + componentName + "`." + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }

        var error = checker.apply(undefined, [propValue, key, componentName, location].concat(rest));

        if (error) {
          _$$_REQUIRE(_dependencyMap[0])(false, error.message + '\nBad object: ' + JSON.stringify(props[propName], null, '  '));
        }
      }
    }

    function chainedCheckType(props, propName, componentName, location) {
      for (var _len2 = arguments.length, rest = new Array(_len2 > 4 ? _len2 - 4 : 0), _key2 = 4; _key2 < _len2; _key2++) {
        rest[_key2 - 4] = arguments[_key2];
      }

      return checkType.apply(undefined, [false, props, propName, componentName, location].concat(rest));
    }

    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
  }

  module.exports = deprecatedCreateStrictShapeTypeChecker;
},"node_modules/deprecated-react-native-prop-types/deprecatedCreateStrictShapeTypeChecker.js",["node_modules/invariant/browser.js","node_modules/@babel/runtime/helpers/extends.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ImageStylePropTypes = _$$_REQUIRE(_dependencyMap[0])({}, _$$_REQUIRE(_dependencyMap[1]), _$$_REQUIRE(_dependencyMap[2]), _$$_REQUIRE(_dependencyMap[3]), {
    resizeMode: _$$_REQUIRE(_dependencyMap[4]).oneOf(['center', 'contain', 'cover', 'repeat', 'stretch']),
    backfaceVisibility: _$$_REQUIRE(_dependencyMap[4]).oneOf(['visible', 'hidden']),
    backgroundColor: _$$_REQUIRE(_dependencyMap[5]),
    borderColor: _$$_REQUIRE(_dependencyMap[5]),
    borderWidth: _$$_REQUIRE(_dependencyMap[4]).number,
    borderRadius: _$$_REQUIRE(_dependencyMap[4]).number,
    overflow: _$$_REQUIRE(_dependencyMap[4]).oneOf(['visible', 'hidden']),
    tintColor: _$$_REQUIRE(_dependencyMap[5]),
    opacity: _$$_REQUIRE(_dependencyMap[4]).number,
    overlayColor: _$$_REQUIRE(_dependencyMap[4]).string,
    borderTopLeftRadius: _$$_REQUIRE(_dependencyMap[4]).number,
    borderTopRightRadius: _$$_REQUIRE(_dependencyMap[4]).number,
    borderBottomLeftRadius: _$$_REQUIRE(_dependencyMap[4]).number,
    borderBottomRightRadius: _$$_REQUIRE(_dependencyMap[4]).number
  });

  module.exports = ImageStylePropTypes;
},"node_modules/deprecated-react-native-prop-types/DeprecatedImageStylePropTypes.js",["node_modules/@babel/runtime/helpers/extends.js","node_modules/deprecated-react-native-prop-types/DeprecatedLayoutPropTypes.js","node_modules/deprecated-react-native-prop-types/DeprecatedShadowPropTypesIOS.js","node_modules/deprecated-react-native-prop-types/DeprecatedTransformPropTypes.js","node_modules/prop-types/index.js","node_modules/deprecated-react-native-prop-types/DeprecatedColorPropType.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var LayoutPropTypes = {
    display: _$$_REQUIRE(_dependencyMap[0]).oneOf(['none', 'flex']),
    width: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    height: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    start: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    end: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    top: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    left: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    right: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    bottom: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    minWidth: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    maxWidth: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    minHeight: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    maxHeight: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    margin: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    marginVertical: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    marginHorizontal: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    marginTop: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    marginBottom: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    marginLeft: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    marginRight: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    marginStart: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    marginEnd: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    padding: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    paddingVertical: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    paddingHorizontal: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    paddingTop: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    paddingBottom: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    paddingLeft: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    paddingRight: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    paddingStart: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    paddingEnd: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    borderWidth: _$$_REQUIRE(_dependencyMap[0]).number,
    borderTopWidth: _$$_REQUIRE(_dependencyMap[0]).number,
    borderStartWidth: _$$_REQUIRE(_dependencyMap[0]).number,
    borderEndWidth: _$$_REQUIRE(_dependencyMap[0]).number,
    borderRightWidth: _$$_REQUIRE(_dependencyMap[0]).number,
    borderBottomWidth: _$$_REQUIRE(_dependencyMap[0]).number,
    borderLeftWidth: _$$_REQUIRE(_dependencyMap[0]).number,
    position: _$$_REQUIRE(_dependencyMap[0]).oneOf(['absolute', 'relative']),
    flexDirection: _$$_REQUIRE(_dependencyMap[0]).oneOf(['row', 'row-reverse', 'column', 'column-reverse']),
    flexWrap: _$$_REQUIRE(_dependencyMap[0]).oneOf(['wrap', 'nowrap', 'wrap-reverse']),
    justifyContent: _$$_REQUIRE(_dependencyMap[0]).oneOf(['flex-start', 'flex-end', 'center', 'space-between', 'space-around', 'space-evenly']),
    alignItems: _$$_REQUIRE(_dependencyMap[0]).oneOf(['flex-start', 'flex-end', 'center', 'stretch', 'baseline']),
    alignSelf: _$$_REQUIRE(_dependencyMap[0]).oneOf(['auto', 'flex-start', 'flex-end', 'center', 'stretch', 'baseline']),
    alignContent: _$$_REQUIRE(_dependencyMap[0]).oneOf(['flex-start', 'flex-end', 'center', 'stretch', 'space-between', 'space-around']),
    overflow: _$$_REQUIRE(_dependencyMap[0]).oneOf(['visible', 'hidden', 'scroll']),
    flex: _$$_REQUIRE(_dependencyMap[0]).number,
    flexGrow: _$$_REQUIRE(_dependencyMap[0]).number,
    flexShrink: _$$_REQUIRE(_dependencyMap[0]).number,
    flexBasis: _$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).string]),
    aspectRatio: _$$_REQUIRE(_dependencyMap[0]).number,
    zIndex: _$$_REQUIRE(_dependencyMap[0]).number,
    direction: _$$_REQUIRE(_dependencyMap[0]).oneOf(['inherit', 'ltr', 'rtl'])
  };
  module.exports = LayoutPropTypes;
},"node_modules/deprecated-react-native-prop-types/DeprecatedLayoutPropTypes.js",["node_modules/prop-types/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var DeprecatedShadowPropTypesIOS = {
    shadowColor: _$$_REQUIRE(_dependencyMap[0]),
    shadowOffset: _$$_REQUIRE(_dependencyMap[1]).shape({
      width: _$$_REQUIRE(_dependencyMap[1]).number,
      height: _$$_REQUIRE(_dependencyMap[1]).number
    }),
    shadowOpacity: _$$_REQUIRE(_dependencyMap[1]).number,
    shadowRadius: _$$_REQUIRE(_dependencyMap[1]).number
  };
  module.exports = DeprecatedShadowPropTypesIOS;
},"node_modules/deprecated-react-native-prop-types/DeprecatedShadowPropTypesIOS.js",["node_modules/deprecated-react-native-prop-types/DeprecatedColorPropType.js","node_modules/prop-types/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var TransformMatrixPropType = function TransformMatrixPropType(props, propName, componentName) {
    if (props[propName]) {
      return new Error("The transformMatrix style property is deprecated. Use `transform: [{ matrix: ... }]` instead.");
    }
  };

  var DecomposedMatrixPropType = function DecomposedMatrixPropType(props, propName, componentName) {
    if (props[propName]) {
      return new Error("The decomposedMatrix style property is deprecated. Use `transform: [...]` instead.");
    }
  };

  var DeprecatedTransformPropTypes = {
    transform: _$$_REQUIRE(_dependencyMap[0]).arrayOf(_$$_REQUIRE(_dependencyMap[0]).oneOfType([_$$_REQUIRE(_dependencyMap[0]).shape({
      perspective: _$$_REQUIRE(_dependencyMap[0]).number
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      rotate: _$$_REQUIRE(_dependencyMap[0]).string
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      rotateX: _$$_REQUIRE(_dependencyMap[0]).string
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      rotateY: _$$_REQUIRE(_dependencyMap[0]).string
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      rotateZ: _$$_REQUIRE(_dependencyMap[0]).string
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      scale: _$$_REQUIRE(_dependencyMap[0]).number
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      scaleX: _$$_REQUIRE(_dependencyMap[0]).number
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      scaleY: _$$_REQUIRE(_dependencyMap[0]).number
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      translateX: _$$_REQUIRE(_dependencyMap[0]).number
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      translateY: _$$_REQUIRE(_dependencyMap[0]).number
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      skewX: _$$_REQUIRE(_dependencyMap[0]).string
    }), _$$_REQUIRE(_dependencyMap[0]).shape({
      skewY: _$$_REQUIRE(_dependencyMap[0]).string
    })])),
    transformMatrix: TransformMatrixPropType,
    decomposedMatrix: DecomposedMatrixPropType,
    scaleX: deprecatedPropType(_$$_REQUIRE(_dependencyMap[0]).number, 'Use the transform prop instead.'),
    scaleY: deprecatedPropType(_$$_REQUIRE(_dependencyMap[0]).number, 'Use the transform prop instead.'),
    rotation: deprecatedPropType(_$$_REQUIRE(_dependencyMap[0]).number, 'Use the transform prop instead.'),
    translateX: deprecatedPropType(_$$_REQUIRE(_dependencyMap[0]).number, 'Use the transform prop instead.'),
    translateY: deprecatedPropType(_$$_REQUIRE(_dependencyMap[0]).number, 'Use the transform prop instead.')
  };

  function deprecatedPropType(propType, explanation) {
    return function validate(props, propName, componentName) {
      if (props[propName] !== undefined) {
        console.warn("`" + propName + "` supplied to `" + componentName + "` has been deprecated. " + explanation);
      }

      for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        rest[_key - 3] = arguments[_key];
      }

      return propType.apply(undefined, [props, propName, componentName].concat(rest));
    };
  }

  module.exports = DeprecatedTransformPropTypes;
},"node_modules/deprecated-react-native-prop-types/DeprecatedTransformPropTypes.js",["node_modules/prop-types/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ImageURISourcePropType = _$$_REQUIRE(_dependencyMap[0]).shape({
    uri: _$$_REQUIRE(_dependencyMap[0]).string,
    bundle: _$$_REQUIRE(_dependencyMap[0]).string,
    method: _$$_REQUIRE(_dependencyMap[0]).string,
    headers: _$$_REQUIRE(_dependencyMap[0]).objectOf(_$$_REQUIRE(_dependencyMap[0]).string),
    body: _$$_REQUIRE(_dependencyMap[0]).string,
    cache: _$$_REQUIRE(_dependencyMap[0]).oneOf(['default', 'reload', 'force-cache', 'only-if-cached']),
    width: _$$_REQUIRE(_dependencyMap[0]).number,
    height: _$$_REQUIRE(_dependencyMap[0]).number,
    scale: _$$_REQUIRE(_dependencyMap[0]).number
  });

  var ImageSourcePropType = _$$_REQUIRE(_dependencyMap[0]).oneOfType([ImageURISourcePropType, _$$_REQUIRE(_dependencyMap[0]).number, _$$_REQUIRE(_dependencyMap[0]).arrayOf(ImageURISourcePropType)]);

  module.exports = ImageSourcePropType;
},"node_modules/deprecated-react-native-prop-types/DeprecatedImageSourcePropType.js",["node_modules/prop-types/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var PointPropType = _$$_REQUIRE(_dependencyMap[0]).shape({
    x: _$$_REQUIRE(_dependencyMap[0]).number,
    y: _$$_REQUIRE(_dependencyMap[0]).number
  });

  module.exports = PointPropType;
},"node_modules/deprecated-react-native-prop-types/DeprecatedPointPropType.js",["node_modules/prop-types/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var DataDetectorTypes = ['phoneNumber', 'link', 'address', 'calendarEvent', 'none', 'all'];
  module.exports = _$$_REQUIRE(_dependencyMap[0])({}, _$$_REQUIRE(_dependencyMap[1]), {
    autoCapitalize: _$$_REQUIRE(_dependencyMap[2]).oneOf(['none', 'sentences', 'words', 'characters']),
    autoCompleteType: _$$_REQUIRE(_dependencyMap[2]).oneOf(['cc-csc', 'cc-exp', 'cc-exp-month', 'cc-exp-year', 'cc-number', 'email', 'name', 'password', 'postal-code', 'street-address', 'tel', 'username', 'off']),
    autoCorrect: _$$_REQUIRE(_dependencyMap[2]).bool,
    spellCheck: _$$_REQUIRE(_dependencyMap[2]).bool,
    autoFocus: _$$_REQUIRE(_dependencyMap[2]).bool,
    allowFontScaling: _$$_REQUIRE(_dependencyMap[2]).bool,
    maxFontSizeMultiplier: _$$_REQUIRE(_dependencyMap[2]).number,
    editable: _$$_REQUIRE(_dependencyMap[2]).bool,
    keyboardType: _$$_REQUIRE(_dependencyMap[2]).oneOf(['default', 'email-address', 'numeric', 'phone-pad', 'number-pad', 'ascii-capable', 'numbers-and-punctuation', 'url', 'name-phone-pad', 'decimal-pad', 'twitter', 'web-search', 'ascii-capable-number-pad', 'visible-password']),
    keyboardAppearance: _$$_REQUIRE(_dependencyMap[2]).oneOf(['default', 'light', 'dark']),
    returnKeyType: _$$_REQUIRE(_dependencyMap[2]).oneOf(['done', 'go', 'next', 'search', 'send', 'none', 'previous', 'default', 'emergency-call', 'google', 'join', 'route', 'yahoo']),
    returnKeyLabel: _$$_REQUIRE(_dependencyMap[2]).string,
    maxLength: _$$_REQUIRE(_dependencyMap[2]).number,
    numberOfLines: _$$_REQUIRE(_dependencyMap[2]).number,
    disableFullscreenUI: _$$_REQUIRE(_dependencyMap[2]).bool,
    enablesReturnKeyAutomatically: _$$_REQUIRE(_dependencyMap[2]).bool,
    multiline: _$$_REQUIRE(_dependencyMap[2]).bool,
    textBreakStrategy: _$$_REQUIRE(_dependencyMap[2]).oneOf(['simple', 'highQuality', 'balanced']),
    onBlur: _$$_REQUIRE(_dependencyMap[2]).func,
    onFocus: _$$_REQUIRE(_dependencyMap[2]).func,
    onChange: _$$_REQUIRE(_dependencyMap[2]).func,
    onChangeText: _$$_REQUIRE(_dependencyMap[2]).func,
    onContentSizeChange: _$$_REQUIRE(_dependencyMap[2]).func,
    onTextInput: _$$_REQUIRE(_dependencyMap[2]).func,
    onEndEditing: _$$_REQUIRE(_dependencyMap[2]).func,
    onSelectionChange: _$$_REQUIRE(_dependencyMap[2]).func,
    onSubmitEditing: _$$_REQUIRE(_dependencyMap[2]).func,
    onKeyPress: _$$_REQUIRE(_dependencyMap[2]).func,
    onLayout: _$$_REQUIRE(_dependencyMap[2]).func,
    onScroll: _$$_REQUIRE(_dependencyMap[2]).func,
    placeholder: _$$_REQUIRE(_dependencyMap[2]).string,
    placeholderTextColor: _$$_REQUIRE(_dependencyMap[3]),
    scrollEnabled: _$$_REQUIRE(_dependencyMap[2]).bool,
    secureTextEntry: _$$_REQUIRE(_dependencyMap[2]).bool,
    selectionColor: _$$_REQUIRE(_dependencyMap[3]),
    selection: _$$_REQUIRE(_dependencyMap[2]).shape({
      start: _$$_REQUIRE(_dependencyMap[2]).number.isRequired,
      end: _$$_REQUIRE(_dependencyMap[2]).number
    }),
    value: _$$_REQUIRE(_dependencyMap[2]).string,
    defaultValue: _$$_REQUIRE(_dependencyMap[2]).string,
    clearButtonMode: _$$_REQUIRE(_dependencyMap[2]).oneOf(['never', 'while-editing', 'unless-editing', 'always']),
    clearTextOnFocus: _$$_REQUIRE(_dependencyMap[2]).bool,
    selectTextOnFocus: _$$_REQUIRE(_dependencyMap[2]).bool,
    blurOnSubmit: _$$_REQUIRE(_dependencyMap[2]).bool,
    style: _$$_REQUIRE(_dependencyMap[4]).style,
    underlineColorAndroid: _$$_REQUIRE(_dependencyMap[3]),
    inlineImageLeft: _$$_REQUIRE(_dependencyMap[2]).string,
    inlineImagePadding: _$$_REQUIRE(_dependencyMap[2]).number,
    rejectResponderTermination: _$$_REQUIRE(_dependencyMap[2]).bool,
    dataDetectorTypes: _$$_REQUIRE(_dependencyMap[2]).oneOfType([_$$_REQUIRE(_dependencyMap[2]).oneOf(DataDetectorTypes), _$$_REQUIRE(_dependencyMap[2]).arrayOf(_$$_REQUIRE(_dependencyMap[2]).oneOf(DataDetectorTypes))]),
    caretHidden: _$$_REQUIRE(_dependencyMap[2]).bool,
    contextMenuHidden: _$$_REQUIRE(_dependencyMap[2]).bool,
    inputAccessoryViewID: _$$_REQUIRE(_dependencyMap[2]).string,
    textContentType: _$$_REQUIRE(_dependencyMap[2]).oneOf(['none', 'URL', 'addressCity', 'addressCityAndState', 'addressState', 'countryName', 'creditCardNumber', 'emailAddress', 'familyName', 'fullStreetAddress', 'givenName', 'jobTitle', 'location', 'middleName', 'name', 'namePrefix', 'nameSuffix', 'nickname', 'organizationName', 'postalCode', 'streetAddressLine1', 'streetAddressLine2', 'sublocality', 'telephoneNumber', 'username', 'password', 'newPassword', 'oneTimeCode']),
    showSoftInputOnFocus: _$$_REQUIRE(_dependencyMap[2]).bool
  });
},"node_modules/deprecated-react-native-prop-types/DeprecatedTextInputPropTypes.js",["node_modules/@babel/runtime/helpers/extends.js","node_modules/deprecated-react-native-prop-types/DeprecatedViewPropTypes.js","node_modules/prop-types/index.js","node_modules/deprecated-react-native-prop-types/DeprecatedColorPropType.js","node_modules/deprecated-react-native-prop-types/DeprecatedTextPropTypes.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var stylePropType = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  module.exports = {
    accessible: _$$_REQUIRE(_dependencyMap[2]).bool,
    accessibilityLabel: _$$_REQUIRE(_dependencyMap[2]).node,
    accessibilityHint: _$$_REQUIRE(_dependencyMap[2]).string,
    accessibilityActions: _$$_REQUIRE(_dependencyMap[2]).arrayOf(_$$_REQUIRE(_dependencyMap[2]).string),
    accessibilityIgnoresInvertColors: _$$_REQUIRE(_dependencyMap[2]).bool,
    accessibilityRole: _$$_REQUIRE(_dependencyMap[2]).oneOf(_$$_REQUIRE(_dependencyMap[3]).DeprecatedAccessibilityRoles),
    accessibilityState: _$$_REQUIRE(_dependencyMap[2]).object,
    accessibilityValue: _$$_REQUIRE(_dependencyMap[2]).object,
    accessibilityLiveRegion: _$$_REQUIRE(_dependencyMap[2]).oneOf(['none', 'polite', 'assertive']),
    importantForAccessibility: _$$_REQUIRE(_dependencyMap[2]).oneOf(['auto', 'yes', 'no', 'no-hide-descendants']),
    accessibilityViewIsModal: _$$_REQUIRE(_dependencyMap[2]).bool,
    accessibilityElementsHidden: _$$_REQUIRE(_dependencyMap[2]).bool,
    onAccessibilityAction: _$$_REQUIRE(_dependencyMap[2]).func,
    onAccessibilityTap: _$$_REQUIRE(_dependencyMap[2]).func,
    onMagicTap: _$$_REQUIRE(_dependencyMap[2]).func,
    testID: _$$_REQUIRE(_dependencyMap[2]).string,
    nativeID: _$$_REQUIRE(_dependencyMap[2]).string,
    onResponderGrant: _$$_REQUIRE(_dependencyMap[2]).func,
    onResponderMove: _$$_REQUIRE(_dependencyMap[2]).func,
    onResponderReject: _$$_REQUIRE(_dependencyMap[2]).func,
    onResponderRelease: _$$_REQUIRE(_dependencyMap[2]).func,
    onResponderTerminate: _$$_REQUIRE(_dependencyMap[2]).func,
    onResponderTerminationRequest: _$$_REQUIRE(_dependencyMap[2]).func,
    onStartShouldSetResponder: _$$_REQUIRE(_dependencyMap[2]).func,
    onStartShouldSetResponderCapture: _$$_REQUIRE(_dependencyMap[2]).func,
    onMoveShouldSetResponder: _$$_REQUIRE(_dependencyMap[2]).func,
    onMoveShouldSetResponderCapture: _$$_REQUIRE(_dependencyMap[2]).func,
    hitSlop: _$$_REQUIRE(_dependencyMap[4]),
    onLayout: _$$_REQUIRE(_dependencyMap[2]).func,
    pointerEvents: _$$_REQUIRE(_dependencyMap[2]).oneOf(['box-none', 'none', 'box-only', 'auto']),
    style: stylePropType,
    removeClippedSubviews: _$$_REQUIRE(_dependencyMap[2]).bool,
    renderToHardwareTextureAndroid: _$$_REQUIRE(_dependencyMap[2]).bool,
    shouldRasterizeIOS: _$$_REQUIRE(_dependencyMap[2]).bool,
    collapsable: _$$_REQUIRE(_dependencyMap[2]).bool,
    needsOffscreenAlphaCompositing: _$$_REQUIRE(_dependencyMap[2]).bool
  };
},"node_modules/deprecated-react-native-prop-types/DeprecatedViewPropTypes.js",["node_modules/deprecated-react-native-prop-types/DeprecatedStyleSheetPropType.js","node_modules/deprecated-react-native-prop-types/DeprecatedViewStylePropTypes.js","node_modules/prop-types/index.js","node_modules/deprecated-react-native-prop-types/DeprecatedViewAccessibility.js","node_modules/deprecated-react-native-prop-types/DeprecatedEdgeInsetsPropType.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var DeprecatedViewStylePropTypes = _$$_REQUIRE(_dependencyMap[0])({}, _$$_REQUIRE(_dependencyMap[1]), _$$_REQUIRE(_dependencyMap[2]), _$$_REQUIRE(_dependencyMap[3]), {
    backfaceVisibility: _$$_REQUIRE(_dependencyMap[4]).oneOf(['visible', 'hidden']),
    backgroundColor: _$$_REQUIRE(_dependencyMap[5]),
    borderColor: _$$_REQUIRE(_dependencyMap[5]),
    borderTopColor: _$$_REQUIRE(_dependencyMap[5]),
    borderRightColor: _$$_REQUIRE(_dependencyMap[5]),
    borderBottomColor: _$$_REQUIRE(_dependencyMap[5]),
    borderLeftColor: _$$_REQUIRE(_dependencyMap[5]),
    borderStartColor: _$$_REQUIRE(_dependencyMap[5]),
    borderEndColor: _$$_REQUIRE(_dependencyMap[5]),
    borderRadius: _$$_REQUIRE(_dependencyMap[4]).number,
    borderTopLeftRadius: _$$_REQUIRE(_dependencyMap[4]).number,
    borderTopRightRadius: _$$_REQUIRE(_dependencyMap[4]).number,
    borderTopStartRadius: _$$_REQUIRE(_dependencyMap[4]).number,
    borderTopEndRadius: _$$_REQUIRE(_dependencyMap[4]).number,
    borderBottomLeftRadius: _$$_REQUIRE(_dependencyMap[4]).number,
    borderBottomRightRadius: _$$_REQUIRE(_dependencyMap[4]).number,
    borderBottomStartRadius: _$$_REQUIRE(_dependencyMap[4]).number,
    borderBottomEndRadius: _$$_REQUIRE(_dependencyMap[4]).number,
    borderStyle: _$$_REQUIRE(_dependencyMap[4]).oneOf(['solid', 'dotted', 'dashed']),
    borderWidth: _$$_REQUIRE(_dependencyMap[4]).number,
    borderTopWidth: _$$_REQUIRE(_dependencyMap[4]).number,
    borderRightWidth: _$$_REQUIRE(_dependencyMap[4]).number,
    borderBottomWidth: _$$_REQUIRE(_dependencyMap[4]).number,
    borderLeftWidth: _$$_REQUIRE(_dependencyMap[4]).number,
    opacity: _$$_REQUIRE(_dependencyMap[4]).number,
    elevation: _$$_REQUIRE(_dependencyMap[4]).number
  });

  module.exports = DeprecatedViewStylePropTypes;
},"node_modules/deprecated-react-native-prop-types/DeprecatedViewStylePropTypes.js",["node_modules/@babel/runtime/helpers/extends.js","node_modules/deprecated-react-native-prop-types/DeprecatedLayoutPropTypes.js","node_modules/deprecated-react-native-prop-types/DeprecatedShadowPropTypesIOS.js","node_modules/deprecated-react-native-prop-types/DeprecatedTransformPropTypes.js","node_modules/prop-types/index.js","node_modules/deprecated-react-native-prop-types/DeprecatedColorPropType.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = {
    DeprecatedAccessibilityRoles: ['none', 'button', 'togglebutton', 'link', 'search', 'image', 'keyboardkey', 'text', 'adjustable', 'imagebutton', 'header', 'summary', 'alert', 'checkbox', 'combobox', 'menu', 'menubar', 'menuitem', 'progressbar', 'radio', 'radiogroup', 'scrollbar', 'spinbutton', 'switch', 'tab', 'tablist', 'timer', 'toolbar']
  };
},"node_modules/deprecated-react-native-prop-types/DeprecatedViewAccessibility.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var stylePropType = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var DataDetectorTypes = ['phoneNumber', 'link', 'email', 'none', 'all'];
  module.exports = {
    ellipsizeMode: _$$_REQUIRE(_dependencyMap[2]).oneOf(['head', 'middle', 'tail', 'clip']),
    numberOfLines: _$$_REQUIRE(_dependencyMap[2]).number,
    textBreakStrategy: _$$_REQUIRE(_dependencyMap[2]).oneOf(['simple', 'highQuality', 'balanced']),
    onLayout: _$$_REQUIRE(_dependencyMap[2]).func,
    onPress: _$$_REQUIRE(_dependencyMap[2]).func,
    onLongPress: _$$_REQUIRE(_dependencyMap[2]).func,
    pressRetentionOffset: _$$_REQUIRE(_dependencyMap[3]),
    selectable: _$$_REQUIRE(_dependencyMap[2]).bool,
    selectionColor: _$$_REQUIRE(_dependencyMap[4]),
    suppressHighlighting: _$$_REQUIRE(_dependencyMap[2]).bool,
    style: stylePropType,
    testID: _$$_REQUIRE(_dependencyMap[2]).string,
    nativeID: _$$_REQUIRE(_dependencyMap[2]).string,
    allowFontScaling: _$$_REQUIRE(_dependencyMap[2]).bool,
    maxFontSizeMultiplier: _$$_REQUIRE(_dependencyMap[2]).number,
    accessible: _$$_REQUIRE(_dependencyMap[2]).bool,
    adjustsFontSizeToFit: _$$_REQUIRE(_dependencyMap[2]).bool,
    minimumFontScale: _$$_REQUIRE(_dependencyMap[2]).number,
    disabled: _$$_REQUIRE(_dependencyMap[2]).bool,
    dataDetectorType: _$$_REQUIRE(_dependencyMap[2]).oneOf(DataDetectorTypes)
  };
},"node_modules/deprecated-react-native-prop-types/DeprecatedTextPropTypes.js",["node_modules/deprecated-react-native-prop-types/DeprecatedStyleSheetPropType.js","node_modules/deprecated-react-native-prop-types/DeprecatedTextStylePropTypes.js","node_modules/prop-types/index.js","node_modules/deprecated-react-native-prop-types/DeprecatedEdgeInsetsPropType.js","node_modules/deprecated-react-native-prop-types/DeprecatedColorPropType.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var DeprecatedTextStylePropTypes = _$$_REQUIRE(_dependencyMap[0])({}, _$$_REQUIRE(_dependencyMap[1]), {
    color: _$$_REQUIRE(_dependencyMap[2]),
    fontFamily: _$$_REQUIRE(_dependencyMap[3]).string,
    fontSize: _$$_REQUIRE(_dependencyMap[3]).number,
    fontStyle: _$$_REQUIRE(_dependencyMap[3]).oneOf(['normal', 'italic']),
    fontWeight: _$$_REQUIRE(_dependencyMap[3]).oneOf(['normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900']),
    fontVariant: _$$_REQUIRE(_dependencyMap[3]).arrayOf(_$$_REQUIRE(_dependencyMap[3]).oneOf(['small-caps', 'oldstyle-nums', 'lining-nums', 'tabular-nums', 'proportional-nums'])),
    textShadowOffset: _$$_REQUIRE(_dependencyMap[3]).shape({
      width: _$$_REQUIRE(_dependencyMap[3]).number,
      height: _$$_REQUIRE(_dependencyMap[3]).number
    }),
    textShadowRadius: _$$_REQUIRE(_dependencyMap[3]).number,
    textShadowColor: _$$_REQUIRE(_dependencyMap[2]),
    letterSpacing: _$$_REQUIRE(_dependencyMap[3]).number,
    lineHeight: _$$_REQUIRE(_dependencyMap[3]).number,
    textAlign: _$$_REQUIRE(_dependencyMap[3]).oneOf(['auto', 'left', 'right', 'center', 'justify']),
    textAlignVertical: _$$_REQUIRE(_dependencyMap[3]).oneOf(['auto', 'top', 'bottom', 'center']),
    includeFontPadding: _$$_REQUIRE(_dependencyMap[3]).bool,
    textDecorationLine: _$$_REQUIRE(_dependencyMap[3]).oneOf(['none', 'underline', 'line-through', 'underline line-through']),
    textDecorationStyle: _$$_REQUIRE(_dependencyMap[3]).oneOf(['solid', 'double', 'dotted', 'dashed']),
    textDecorationColor: _$$_REQUIRE(_dependencyMap[2]),
    textTransform: _$$_REQUIRE(_dependencyMap[3]).oneOf(['none', 'capitalize', 'uppercase', 'lowercase']),
    writingDirection: _$$_REQUIRE(_dependencyMap[3]).oneOf(['auto', 'ltr', 'rtl'])
  });

  module.exports = DeprecatedTextStylePropTypes;
},"node_modules/deprecated-react-native-prop-types/DeprecatedTextStylePropTypes.js",["node_modules/@babel/runtime/helpers/extends.js","node_modules/deprecated-react-native-prop-types/DeprecatedViewStylePropTypes.js","node_modules/deprecated-react-native-prop-types/DeprecatedColorPropType.js","node_modules/prop-types/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _Pressability = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _ReactNative = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _View = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _processColor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[13]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[14]));

  var _excluded = ["onBlur", "onFocus"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TouchableNativeFeedback = function (_React$Component) {
    (0, _inherits2.default)(TouchableNativeFeedback, _React$Component);

    var _super = _createSuper(TouchableNativeFeedback);

    function TouchableNativeFeedback() {
      var _this;

      (0, _classCallCheck2.default)(this, TouchableNativeFeedback);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        pressability: new _Pressability.default(_this._createPressabilityConfig())
      };
      return _this;
    }

    (0, _createClass2.default)(TouchableNativeFeedback, [{
      key: "_createPressabilityConfig",
      value: function _createPressabilityConfig() {
        var _this$props$accessibi,
            _this2 = this;

        return {
          cancelable: !this.props.rejectResponderTermination,
          disabled: this.props.disabled != null ? this.props.disabled : (_this$props$accessibi = this.props.accessibilityState) == null ? undefined : _this$props$accessibi.disabled,
          hitSlop: this.props.hitSlop,
          delayLongPress: this.props.delayLongPress,
          delayPressIn: this.props.delayPressIn,
          delayPressOut: this.props.delayPressOut,
          minPressDuration: 0,
          pressRectOffset: this.props.pressRetentionOffset,
          android_disableSound: this.props.touchSoundDisabled,
          onLongPress: this.props.onLongPress,
          onPress: this.props.onPress,
          onPressIn: function onPressIn(event) {
            if (_Platform.default.OS === 'android') {
              _this2._dispatchHotspotUpdate(event);

              _this2._dispatchPressedStateChange(true);
            }

            if (_this2.props.onPressIn != null) {
              _this2.props.onPressIn(event);
            }
          },
          onPressMove: function onPressMove(event) {
            if (_Platform.default.OS === 'android') {
              _this2._dispatchHotspotUpdate(event);
            }
          },
          onPressOut: function onPressOut(event) {
            if (_Platform.default.OS === 'android') {
              _this2._dispatchPressedStateChange(false);
            }

            if (_this2.props.onPressOut != null) {
              _this2.props.onPressOut(event);
            }
          }
        };
      }
    }, {
      key: "_dispatchPressedStateChange",
      value: function _dispatchPressedStateChange(pressed) {
        if (_Platform.default.OS === 'android') {
          var hostComponentRef = _ReactNative.default.findHostInstance_DEPRECATED(this);

          if (hostComponentRef == null) {
            console.warn("Touchable: Unable to find HostComponent instance. Has your Touchable component been unmounted?");
          } else {
            _$$_REQUIRE(_dependencyMap[15]).Commands.setPressed(hostComponentRef, pressed);
          }
        }
      }
    }, {
      key: "_dispatchHotspotUpdate",
      value: function _dispatchHotspotUpdate(event) {
        if (_Platform.default.OS === 'android') {
          var _event$nativeEvent = event.nativeEvent,
              locationX = _event$nativeEvent.locationX,
              locationY = _event$nativeEvent.locationY;

          var hostComponentRef = _ReactNative.default.findHostInstance_DEPRECATED(this);

          if (hostComponentRef == null) {
            console.warn("Touchable: Unable to find HostComponent instance. Has your Touchable component been unmounted?");
          } else {
            _$$_REQUIRE(_dependencyMap[15]).Commands.hotspotUpdate(hostComponentRef, locationX != null ? locationX : 0, locationY != null ? locationY : 0);
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        var element = React.Children.only(this.props.children);
        var children = [element.props.children];

        var _this$state$pressabil = this.state.pressability.getEventHandlers(),
            onBlur = _this$state$pressabil.onBlur,
            onFocus = _this$state$pressabil.onFocus,
            eventHandlersWithoutBlurAndFocus = (0, _objectWithoutProperties2.default)(_this$state$pressabil, _excluded);

        var accessibilityState = this.props.disabled != null ? (0, _extends2.default)({}, this.props.accessibilityState, {
          disabled: this.props.disabled
        }) : this.props.accessibilityState;
        return React.cloneElement.apply(React, [element, (0, _extends2.default)({}, eventHandlersWithoutBlurAndFocus, getBackgroundProp(this.props.background === undefined ? TouchableNativeFeedback.SelectableBackground() : this.props.background, this.props.useForeground === true), {
          accessible: this.props.accessible !== false,
          accessibilityHint: this.props.accessibilityHint,
          accessibilityLabel: this.props.accessibilityLabel,
          accessibilityRole: this.props.accessibilityRole,
          accessibilityState: accessibilityState,
          accessibilityActions: this.props.accessibilityActions,
          onAccessibilityAction: this.props.onAccessibilityAction,
          accessibilityValue: this.props.accessibilityValue,
          importantForAccessibility: this.props.importantForAccessibility,
          accessibilityLiveRegion: this.props.accessibilityLiveRegion,
          accessibilityViewIsModal: this.props.accessibilityViewIsModal,
          accessibilityElementsHidden: this.props.accessibilityElementsHidden,
          hasTVPreferredFocus: this.props.hasTVPreferredFocus,
          hitSlop: this.props.hitSlop,
          focusable: this.props.focusable !== false && this.props.onPress !== undefined && !this.props.disabled,
          nativeID: this.props.nativeID,
          nextFocusDown: this.props.nextFocusDown,
          nextFocusForward: this.props.nextFocusForward,
          nextFocusLeft: this.props.nextFocusLeft,
          nextFocusRight: this.props.nextFocusRight,
          nextFocusUp: this.props.nextFocusUp,
          onLayout: this.props.onLayout,
          testID: this.props.testID
        })].concat(children));
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        this.state.pressability.configure(this._createPressabilityConfig());
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.state.pressability.reset();
      }
    }]);
    return TouchableNativeFeedback;
  }(React.Component);

  TouchableNativeFeedback.SelectableBackground = function (rippleRadius) {
    return {
      type: 'ThemeAttrAndroid',
      attribute: 'selectableItemBackground',
      rippleRadius: rippleRadius
    };
  };

  TouchableNativeFeedback.SelectableBackgroundBorderless = function (rippleRadius) {
    return {
      type: 'ThemeAttrAndroid',
      attribute: 'selectableItemBackgroundBorderless',
      rippleRadius: rippleRadius
    };
  };

  TouchableNativeFeedback.Ripple = function (color, borderless, rippleRadius) {
    var processedColor = (0, _processColor.default)(color);
    (0, _invariant.default)(processedColor == null || typeof processedColor === 'number', 'Unexpected color given for Ripple color');
    return {
      type: 'RippleAndroid',
      color: processedColor,
      borderless: borderless,
      rippleRadius: rippleRadius
    };
  };

  TouchableNativeFeedback.canUseNativeForeground = function () {
    return _Platform.default.OS === 'android' && _Platform.default.Version >= 23;
  };

  var getBackgroundProp = _Platform.default.OS === 'android' ? function (background, useForeground) {
    return useForeground && TouchableNativeFeedback.canUseNativeForeground() ? {
      nativeForegroundAndroid: background
    } : {
      nativeBackgroundAndroid: background
    };
  } : function (background, useForeground) {
    return null;
  };
  TouchableNativeFeedback.displayName = 'TouchableNativeFeedback';
  module.exports = TouchableNativeFeedback;
},"node_modules/react-native/Libraries/Components/Touchable/TouchableNativeFeedback.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Pressability/Pressability.js","node_modules/react-native/Libraries/Renderer/shims/ReactNative.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/react-native/Libraries/StyleSheet/processColor.js","node_modules/react/index.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/Components/View/ViewNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _Pressability = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _Animated = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _Easing = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _flattenStyle2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[13]));

  var _excluded = ["onBlur", "onFocus"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TouchableOpacity = function (_React$Component) {
    (0, _inherits2.default)(TouchableOpacity, _React$Component);

    var _super = _createSuper(TouchableOpacity);

    function TouchableOpacity() {
      var _this;

      (0, _classCallCheck2.default)(this, TouchableOpacity);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        anim: new _Animated.default.Value(_this._getChildStyleOpacityWithDefault()),
        pressability: new _Pressability.default(_this._createPressabilityConfig())
      };
      return _this;
    }

    (0, _createClass2.default)(TouchableOpacity, [{
      key: "_createPressabilityConfig",
      value: function _createPressabilityConfig() {
        var _this$props$disabled,
            _this$props$accessibi,
            _this2 = this;

        return {
          cancelable: !this.props.rejectResponderTermination,
          disabled: (_this$props$disabled = this.props.disabled) != null ? _this$props$disabled : (_this$props$accessibi = this.props.accessibilityState) == null ? undefined : _this$props$accessibi.disabled,
          hitSlop: this.props.hitSlop,
          delayLongPress: this.props.delayLongPress,
          delayPressIn: this.props.delayPressIn,
          delayPressOut: this.props.delayPressOut,
          minPressDuration: 0,
          pressRectOffset: this.props.pressRetentionOffset,
          onBlur: function onBlur(event) {
            if (_Platform.default.isTV) {
              _this2._opacityInactive(250);
            }

            if (_this2.props.onBlur != null) {
              _this2.props.onBlur(event);
            }
          },
          onFocus: function onFocus(event) {
            if (_Platform.default.isTV) {
              _this2._opacityActive(150);
            }

            if (_this2.props.onFocus != null) {
              _this2.props.onFocus(event);
            }
          },
          onLongPress: this.props.onLongPress,
          onPress: this.props.onPress,
          onPressIn: function onPressIn(event) {
            _this2._opacityActive(event.dispatchConfig.registrationName === 'onResponderGrant' ? 0 : 150);

            if (_this2.props.onPressIn != null) {
              _this2.props.onPressIn(event);
            }
          },
          onPressOut: function onPressOut(event) {
            _this2._opacityInactive(250);

            if (_this2.props.onPressOut != null) {
              _this2.props.onPressOut(event);
            }
          }
        };
      }
    }, {
      key: "_setOpacityTo",
      value: function _setOpacityTo(toValue, duration) {
        _Animated.default.timing(this.state.anim, {
          toValue: toValue,
          duration: duration,
          easing: _Easing.default.inOut(_Easing.default.quad),
          useNativeDriver: true
        }).start();
      }
    }, {
      key: "_opacityActive",
      value: function _opacityActive(duration) {
        var _this$props$activeOpa;

        this._setOpacityTo((_this$props$activeOpa = this.props.activeOpacity) != null ? _this$props$activeOpa : 0.2, duration);
      }
    }, {
      key: "_opacityInactive",
      value: function _opacityInactive(duration) {
        this._setOpacityTo(this._getChildStyleOpacityWithDefault(), duration);
      }
    }, {
      key: "_getChildStyleOpacityWithDefault",
      value: function _getChildStyleOpacityWithDefault() {
        var _flattenStyle;

        var opacity = (_flattenStyle = (0, _flattenStyle2.default)(this.props.style)) == null ? undefined : _flattenStyle.opacity;
        return typeof opacity === 'number' ? opacity : 1;
      }
    }, {
      key: "render",
      value: function render() {
        var _this$state$pressabil = this.state.pressability.getEventHandlers(),
            onBlur = _this$state$pressabil.onBlur,
            onFocus = _this$state$pressabil.onFocus,
            eventHandlersWithoutBlurAndFocus = (0, _objectWithoutProperties2.default)(_this$state$pressabil, _excluded);

        var accessibilityState = this.props.disabled != null ? (0, _extends2.default)({}, this.props.accessibilityState, {
          disabled: this.props.disabled
        }) : this.props.accessibilityState;
        return React.createElement(_Animated.default.View, (0, _extends2.default)({
          accessible: this.props.accessible !== false,
          accessibilityLabel: this.props.accessibilityLabel,
          accessibilityHint: this.props.accessibilityHint,
          accessibilityRole: this.props.accessibilityRole,
          accessibilityState: accessibilityState,
          accessibilityActions: this.props.accessibilityActions,
          onAccessibilityAction: this.props.onAccessibilityAction,
          accessibilityValue: this.props.accessibilityValue,
          importantForAccessibility: this.props.importantForAccessibility,
          accessibilityLiveRegion: this.props.accessibilityLiveRegion,
          accessibilityViewIsModal: this.props.accessibilityViewIsModal,
          accessibilityElementsHidden: this.props.accessibilityElementsHidden,
          style: [this.props.style, {
            opacity: this.state.anim
          }],
          nativeID: this.props.nativeID,
          testID: this.props.testID,
          onLayout: this.props.onLayout,
          nextFocusDown: this.props.nextFocusDown,
          nextFocusForward: this.props.nextFocusForward,
          nextFocusLeft: this.props.nextFocusLeft,
          nextFocusRight: this.props.nextFocusRight,
          nextFocusUp: this.props.nextFocusUp,
          hasTVPreferredFocus: this.props.hasTVPreferredFocus,
          hitSlop: this.props.hitSlop,
          focusable: this.props.focusable !== false && this.props.onPress !== undefined,
          ref: this.props.hostRef
        }, eventHandlersWithoutBlurAndFocus), this.props.children, null);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        this.state.pressability.configure(this._createPressabilityConfig());

        if (this.props.disabled !== prevProps.disabled) {
          this._opacityInactive(250);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.state.pressability.reset();
      }
    }]);
    return TouchableOpacity;
  }(React.Component);

  var Touchable = React.forwardRef(function (props, ref) {
    return React.createElement(TouchableOpacity, (0, _extends2.default)({}, props, {
      hostRef: ref
    }));
  });
  Touchable.displayName = 'TouchableOpacity';
  module.exports = Touchable;
},"node_modules/react-native/Libraries/Components/Touchable/TouchableOpacity.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Pressability/Pressability.js","node_modules/react-native/Libraries/Animated/Animated.js","node_modules/react-native/Libraries/Animated/Easing.js","node_modules/react-native/Libraries/StyleSheet/flattenStyle.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var Animated = _Platform.default.isTesting ? _$$_REQUIRE(_dependencyMap[3]) : _$$_REQUIRE(_dependencyMap[4]);
  module.exports = (0, _extends2.default)({
    get FlatList() {
      return _$$_REQUIRE(_dependencyMap[5]);
    },

    get Image() {
      return _$$_REQUIRE(_dependencyMap[6]);
    },

    get ScrollView() {
      return _$$_REQUIRE(_dependencyMap[7]);
    },

    get SectionList() {
      return _$$_REQUIRE(_dependencyMap[8]);
    },

    get Text() {
      return _$$_REQUIRE(_dependencyMap[9]);
    },

    get View() {
      return _$$_REQUIRE(_dependencyMap[10]);
    }

  }, Animated);
},"node_modules/react-native/Libraries/Animated/Animated.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/Animated/AnimatedMock.js","node_modules/react-native/Libraries/Animated/AnimatedImplementation.js","node_modules/react-native/Libraries/Animated/components/AnimatedFlatList.js","node_modules/react-native/Libraries/Animated/components/AnimatedImage.js","node_modules/react-native/Libraries/Animated/components/AnimatedScrollView.js","node_modules/react-native/Libraries/Animated/components/AnimatedSectionList.js","node_modules/react-native/Libraries/Animated/components/AnimatedText.js","node_modules/react-native/Libraries/Animated/components/AnimatedView.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _AnimatedColor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var inAnimationCallback = false;

  function mockAnimationStart(start) {
    return function (callback) {
      var guardedCallback = callback == null ? callback : function () {
        if (inAnimationCallback) {
          console.warn('Ignoring recursive animation callback when running mock animations');
          return;
        }

        inAnimationCallback = true;

        try {
          callback.apply(undefined, arguments);
        } finally {
          inAnimationCallback = false;
        }
      };
      start(guardedCallback);
    };
  }

  var emptyAnimation = {
    start: function start() {},
    stop: function stop() {},
    reset: function reset() {},
    _startNativeLoop: function _startNativeLoop() {},
    _isUsingNativeDriver: function _isUsingNativeDriver() {
      return false;
    }
  };

  var mockCompositeAnimation = function mockCompositeAnimation(animations) {
    return (0, _extends2.default)({}, emptyAnimation, {
      start: mockAnimationStart(function (callback) {
        animations.forEach(function (animation) {
          return animation.start();
        });
        callback == null ? undefined : callback({
          finished: true
        });
      })
    });
  };

  var spring = function spring(value, config) {
    var anyValue = value;
    return (0, _extends2.default)({}, emptyAnimation, {
      start: mockAnimationStart(function (callback) {
        anyValue.setValue(config.toValue);
        callback == null ? undefined : callback({
          finished: true
        });
      })
    });
  };

  var timing = function timing(value, config) {
    var anyValue = value;
    return (0, _extends2.default)({}, emptyAnimation, {
      start: mockAnimationStart(function (callback) {
        anyValue.setValue(config.toValue);
        callback == null ? undefined : callback({
          finished: true
        });
      })
    });
  };

  var decay = function decay(value, config) {
    return emptyAnimation;
  };

  var sequence = function sequence(animations) {
    return mockCompositeAnimation(animations);
  };

  var parallel = function parallel(animations, config) {
    return mockCompositeAnimation(animations);
  };

  var delay = function delay(time) {
    return emptyAnimation;
  };

  var stagger = function stagger(time, animations) {
    return mockCompositeAnimation(animations);
  };

  var loop = function loop(animation) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$iterations = _ref.iterations,
        iterations = _ref$iterations === undefined ? -1 : _ref$iterations;

    return emptyAnimation;
  };

  module.exports = {
    Value: _$$_REQUIRE(_dependencyMap[3]),
    ValueXY: _$$_REQUIRE(_dependencyMap[4]),
    Color: _AnimatedColor.default,
    Interpolation: _$$_REQUIRE(_dependencyMap[5]),
    Node: _$$_REQUIRE(_dependencyMap[6]),
    decay: decay,
    timing: timing,
    spring: spring,
    add: _$$_REQUIRE(_dependencyMap[7]).add,
    subtract: _$$_REQUIRE(_dependencyMap[7]).subtract,
    divide: _$$_REQUIRE(_dependencyMap[7]).divide,
    multiply: _$$_REQUIRE(_dependencyMap[7]).multiply,
    modulo: _$$_REQUIRE(_dependencyMap[7]).modulo,
    diffClamp: _$$_REQUIRE(_dependencyMap[7]).diffClamp,
    delay: delay,
    sequence: sequence,
    parallel: parallel,
    stagger: stagger,
    loop: loop,
    event: _$$_REQUIRE(_dependencyMap[7]).event,
    createAnimatedComponent: _$$_REQUIRE(_dependencyMap[8]),
    attachNativeEvent: _$$_REQUIRE(_dependencyMap[9]).attachNativeEvent,
    forkEvent: _$$_REQUIRE(_dependencyMap[7]).forkEvent,
    unforkEvent: _$$_REQUIRE(_dependencyMap[7]).unforkEvent,
    Event: _$$_REQUIRE(_dependencyMap[9]).AnimatedEvent
  };
},"node_modules/react-native/Libraries/Animated/AnimatedMock.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedColor.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedValue.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedValueXY.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedInterpolation.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedNode.js","node_modules/react-native/Libraries/Animated/AnimatedImplementation.js","node_modules/react-native/Libraries/Animated/createAnimatedComponent.js","node_modules/react-native/Libraries/Animated/AnimatedEvent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _get2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _AnimatedValue = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _AnimatedWithChildren2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _normalizeColor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var defaultColor = {
    r: 0,
    g: 0,
    b: 0,
    a: 1.0
  };
  var _uniqueId = 1;

  function processColor(color) {
    if (color === undefined || color === null) {
      return null;
    }

    var normalizedColor = (0, _normalizeColor.default)(color);

    if (normalizedColor === undefined || normalizedColor === null) {
      return null;
    }

    if (typeof normalizedColor === 'object') {
      var processedColorObj = (0, _$$_REQUIRE(_dependencyMap[10]).processColorObject)(normalizedColor);

      if (processedColorObj != null) {
        return processedColorObj;
      }
    } else if (typeof normalizedColor === 'number') {
      var r = (normalizedColor & 0xff000000) >>> 24;
      var g = (normalizedColor & 0x00ff0000) >>> 16;
      var b = (normalizedColor & 0x0000ff00) >>> 8;
      var a = (normalizedColor & 0x000000ff) / 255;
      return {
        r: r,
        g: g,
        b: b,
        a: a
      };
    }

    return null;
  }

  function isRgbaValue(value) {
    return value && typeof value.r === 'number' && typeof value.g === 'number' && typeof value.b === 'number' && typeof value.a === 'number';
  }

  function isRgbaAnimatedValue(value) {
    return value && value.r instanceof _AnimatedValue.default && value.g instanceof _AnimatedValue.default && value.b instanceof _AnimatedValue.default && value.a instanceof _AnimatedValue.default;
  }

  var AnimatedColor = function (_AnimatedWithChildren) {
    (0, _inherits2.default)(AnimatedColor, _AnimatedWithChildren);

    var _super = _createSuper(AnimatedColor);

    function AnimatedColor(valueIn) {
      var _this;

      (0, _classCallCheck2.default)(this, AnimatedColor);
      _this = _super.call(this);
      var value = valueIn || defaultColor;

      if (isRgbaAnimatedValue(value)) {
        var rgbaAnimatedValue = value;
        _this.r = rgbaAnimatedValue.r;
        _this.g = rgbaAnimatedValue.g;
        _this.b = rgbaAnimatedValue.b;
        _this.a = rgbaAnimatedValue.a;
      } else {
        if (!isRgbaValue(value)) {
          value = processColor(value) || {
            r: 0,
            g: 0,
            b: 0,
            a: 1.0
          };
        }

        var rgbaValue = value;
        _this.r = new _AnimatedValue.default(rgbaValue.r);
        _this.g = new _AnimatedValue.default(rgbaValue.g);
        _this.b = new _AnimatedValue.default(rgbaValue.b);
        _this.a = new _AnimatedValue.default(rgbaValue.a);
      }

      _this._listeners = {};
      return _this;
    }

    (0, _createClass2.default)(AnimatedColor, [{
      key: "setValue",
      value: function setValue(value) {
        this.r.setValue(value.r);
        this.g.setValue(value.g);
        this.b.setValue(value.b);
        this.a.setValue(value.a);
      }
    }, {
      key: "setOffset",
      value: function setOffset(offset) {
        this.r.setOffset(offset.r);
        this.g.setOffset(offset.g);
        this.b.setOffset(offset.b);
        this.a.setOffset(offset.a);
      }
    }, {
      key: "flattenOffset",
      value: function flattenOffset() {
        this.r.flattenOffset();
        this.g.flattenOffset();
        this.b.flattenOffset();
        this.a.flattenOffset();
      }
    }, {
      key: "extractOffset",
      value: function extractOffset() {
        this.r.extractOffset();
        this.g.extractOffset();
        this.b.extractOffset();
        this.a.extractOffset();
      }
    }, {
      key: "addListener",
      value: function addListener(callback) {
        var _this2 = this;

        var id = String(_uniqueId++);

        var jointCallback = function jointCallback(_ref) {
          var number = _ref.value;
          callback(_this2.__getValue());
        };

        this._listeners[id] = {
          r: this.r.addListener(jointCallback),
          g: this.g.addListener(jointCallback),
          b: this.b.addListener(jointCallback),
          a: this.a.addListener(jointCallback)
        };
        return id;
      }
    }, {
      key: "removeListener",
      value: function removeListener(id) {
        this.r.removeListener(this._listeners[id].r);
        this.g.removeListener(this._listeners[id].g);
        this.b.removeListener(this._listeners[id].b);
        this.a.removeListener(this._listeners[id].a);
        delete this._listeners[id];
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners() {
        this.r.removeAllListeners();
        this.g.removeAllListeners();
        this.b.removeAllListeners();
        this.a.removeAllListeners();
        this._listeners = {};
      }
    }, {
      key: "stopAnimation",
      value: function stopAnimation(callback) {
        this.r.stopAnimation();
        this.g.stopAnimation();
        this.b.stopAnimation();
        this.a.stopAnimation();
        callback && callback(this.__getValue());
      }
    }, {
      key: "resetAnimation",
      value: function resetAnimation(callback) {
        this.r.resetAnimation();
        this.g.resetAnimation();
        this.b.resetAnimation();
        this.a.resetAnimation();
        callback && callback(this.__getValue());
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return "rgba(" + this.r.__getValue() + ", " + this.g.__getValue() + ", " + this.b.__getValue() + ", " + this.a.__getValue() + ")";
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this.r.__addChild(this);

        this.g.__addChild(this);

        this.b.__addChild(this);

        this.a.__addChild(this);

        (0, _get2.default)((0, _getPrototypeOf2.default)(AnimatedColor.prototype), "__attach", this).call(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this.r.__removeChild(this);

        this.g.__removeChild(this);

        this.b.__removeChild(this);

        this.a.__removeChild(this);

        (0, _get2.default)((0, _getPrototypeOf2.default)(AnimatedColor.prototype), "__detach", this).call(this);
      }
    }]);
    return AnimatedColor;
  }(_AnimatedWithChildren2.default);

  exports.default = AnimatedColor;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedColor.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedValue.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js","node_modules/react-native/Libraries/StyleSheet/normalizeColor.js","node_modules/react-native/Libraries/StyleSheet/PlatformColorValueTypes.ios.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _flush(rootNode) {
    var animatedStyles = new Set();

    function findAnimatedStyles(node) {
      if (typeof node.update === 'function') {
        animatedStyles.add(node);
      } else {
        node.__getChildren().forEach(findAnimatedStyles);
      }
    }

    findAnimatedStyles(rootNode);
    animatedStyles.forEach(function (animatedStyle) {
      return animatedStyle.update();
    });
  }

  function _executeAsAnimatedBatch(id, operation) {
    _$$_REQUIRE(_dependencyMap[2]).API.setWaitingForIdentifier(id);

    operation();

    _$$_REQUIRE(_dependencyMap[2]).API.unsetWaitingForIdentifier(id);
  }

  var AnimatedValue = function (_AnimatedWithChildren) {
    _$$_REQUIRE(_dependencyMap[3])(AnimatedValue, _AnimatedWithChildren);

    var _super = _createSuper(AnimatedValue);

    function AnimatedValue(value) {
      var _this;

      _$$_REQUIRE(_dependencyMap[4])(this, AnimatedValue);

      _this = _super.call(this);

      if (typeof value !== 'number') {
        throw new Error('AnimatedValue: Attempting to set value to undefined');
      }

      _this._startingValue = _this._value = value;
      _this._offset = 0;
      _this._animation = null;
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[5])(AnimatedValue, [{
      key: "__detach",
      value: function __detach() {
        var _this2 = this;

        if (this.__isNative) {
          _$$_REQUIRE(_dependencyMap[2]).API.getValue(this.__getNativeTag(), function (value) {
            _this2._value = value - _this2._offset;
          });
        }

        this.stopAnimation();

        _$$_REQUIRE(_dependencyMap[6])(_$$_REQUIRE(_dependencyMap[0])(AnimatedValue.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._value + this._offset;
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        var _this3 = this;

        if (this._animation) {
          this._animation.stop();

          this._animation = null;
        }

        this._updateValue(value, !this.__isNative);

        if (this.__isNative) {
          _executeAsAnimatedBatch(this.__getNativeTag().toString(), function () {
            _$$_REQUIRE(_dependencyMap[2]).API.setAnimatedNodeValue(_this3.__getNativeTag(), value);
          });
        }
      }
    }, {
      key: "setOffset",
      value: function setOffset(offset) {
        this._offset = offset;

        if (this.__isNative) {
          _$$_REQUIRE(_dependencyMap[2]).API.setAnimatedNodeOffset(this.__getNativeTag(), offset);
        }
      }
    }, {
      key: "flattenOffset",
      value: function flattenOffset() {
        this._value += this._offset;
        this._offset = 0;

        if (this.__isNative) {
          _$$_REQUIRE(_dependencyMap[2]).API.flattenAnimatedNodeOffset(this.__getNativeTag());
        }
      }
    }, {
      key: "extractOffset",
      value: function extractOffset() {
        this._offset += this._value;
        this._value = 0;

        if (this.__isNative) {
          _$$_REQUIRE(_dependencyMap[2]).API.extractAnimatedNodeOffset(this.__getNativeTag());
        }
      }
    }, {
      key: "stopAnimation",
      value: function stopAnimation(callback) {
        this.stopTracking();
        this._animation && this._animation.stop();
        this._animation = null;

        if (callback) {
          if (this.__isNative) {
            _$$_REQUIRE(_dependencyMap[2]).API.getValue(this.__getNativeTag(), callback);
          } else {
            callback(this.__getValue());
          }
        }
      }
    }, {
      key: "resetAnimation",
      value: function resetAnimation(callback) {
        this.stopAnimation(callback);
        this._value = this._startingValue;

        if (this.__isNative) {
          _$$_REQUIRE(_dependencyMap[2]).API.setAnimatedNodeValue(this.__getNativeTag(), this._startingValue);
        }
      }
    }, {
      key: "_onAnimatedValueUpdateReceived",
      value: function _onAnimatedValueUpdateReceived(value) {
        this._updateValue(value, false);
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new (_$$_REQUIRE(_dependencyMap[7]))(this, config);
      }
    }, {
      key: "animate",
      value: function animate(animation, callback) {
        var _this4 = this;

        var handle = null;

        if (animation.__isInteraction) {
          handle = _$$_REQUIRE(_dependencyMap[8]).createInteractionHandle();
        }

        var previousAnimation = this._animation;
        this._animation && this._animation.stop();
        this._animation = animation;
        animation.start(this._value, function (value) {
          _this4._updateValue(value, true);
        }, function (result) {
          _this4._animation = null;

          if (handle !== null) {
            _$$_REQUIRE(_dependencyMap[8]).clearInteractionHandle(handle);
          }

          callback && callback(result);
        }, previousAnimation, this);
      }
    }, {
      key: "stopTracking",
      value: function stopTracking() {
        this._tracking && this._tracking.__detach();
        this._tracking = null;
      }
    }, {
      key: "track",
      value: function track(tracking) {
        this.stopTracking();
        this._tracking = tracking;
        this._tracking && this._tracking.update();
      }
    }, {
      key: "_updateValue",
      value: function _updateValue(value, flush) {
        if (value === undefined) {
          throw new Error('AnimatedValue: Attempting to set value to undefined');
        }

        this._value = value;

        if (flush) {
          _flush(this);
        }

        _$$_REQUIRE(_dependencyMap[6])(_$$_REQUIRE(_dependencyMap[0])(AnimatedValue.prototype), "__callListeners", this).call(this, this.__getValue());
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'value',
          value: this._value,
          offset: this._offset
        };
      }
    }]);

    return AnimatedValue;
  }(_$$_REQUIRE(_dependencyMap[9]));

  module.exports = AnimatedValue;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedValue.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/react-native/Libraries/Animated/NativeAnimatedHelper.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedInterpolation.js","node_modules/react-native/Libraries/Interaction/InteractionManager.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _NativeAnimatedModule = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _NativeAnimatedTurboModule = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _NativeEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var NativeAnimatedModule = _Platform.default.OS === 'ios' && global.RN$Bridgeless === true ? _NativeAnimatedTurboModule.default : _NativeAnimatedModule.default;
  var __nativeAnimatedNodeTagCount = 1;
  var __nativeAnimationIdCount = 1;
  var nativeEventEmitter;
  var waitingForQueuedOperations = new Set();
  var queueOperations = false;
  var queue = [];
  var API = {
    getValue: function getValue(tag, saveValueCallback) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        NativeAnimatedModule.getValue(tag, saveValueCallback);
      });
    },
    setWaitingForIdentifier: function setWaitingForIdentifier(id) {
      waitingForQueuedOperations.add(id);
      queueOperations = true;
    },
    unsetWaitingForIdentifier: function unsetWaitingForIdentifier(id) {
      waitingForQueuedOperations.delete(id);

      if (waitingForQueuedOperations.size === 0) {
        queueOperations = false;
        API.disableQueue();
      }
    },
    disableQueue: function disableQueue() {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');

      if (_Platform.default.OS === 'android') {
        NativeAnimatedModule.startOperationBatch();
      }

      for (var q = 0, l = queue.length; q < l; q++) {
        queue[q]();
      }

      queue.length = 0;

      if (_Platform.default.OS === 'android') {
        NativeAnimatedModule.finishOperationBatch();
      }
    },
    queueOperation: function queueOperation(fn) {
      if (queueOperations) {
        queue.push(fn);
      } else {
        fn();
      }
    },
    createAnimatedNode: function createAnimatedNode(tag, config) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.createAnimatedNode(tag, config);
      });
    },
    startListeningToAnimatedNodeValue: function startListeningToAnimatedNodeValue(tag) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.startListeningToAnimatedNodeValue(tag);
      });
    },
    stopListeningToAnimatedNodeValue: function stopListeningToAnimatedNodeValue(tag) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.stopListeningToAnimatedNodeValue(tag);
      });
    },
    connectAnimatedNodes: function connectAnimatedNodes(parentTag, childTag) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.connectAnimatedNodes(parentTag, childTag);
      });
    },
    disconnectAnimatedNodes: function disconnectAnimatedNodes(parentTag, childTag) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.disconnectAnimatedNodes(parentTag, childTag);
      });
    },
    startAnimatingNode: function startAnimatingNode(animationId, nodeTag, config, endCallback) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.startAnimatingNode(animationId, nodeTag, config, endCallback);
      });
    },
    stopAnimation: function stopAnimation(animationId) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.stopAnimation(animationId);
      });
    },
    setAnimatedNodeValue: function setAnimatedNodeValue(nodeTag, value) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.setAnimatedNodeValue(nodeTag, value);
      });
    },
    setAnimatedNodeOffset: function setAnimatedNodeOffset(nodeTag, offset) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.setAnimatedNodeOffset(nodeTag, offset);
      });
    },
    flattenAnimatedNodeOffset: function flattenAnimatedNodeOffset(nodeTag) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.flattenAnimatedNodeOffset(nodeTag);
      });
    },
    extractAnimatedNodeOffset: function extractAnimatedNodeOffset(nodeTag) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.extractAnimatedNodeOffset(nodeTag);
      });
    },
    connectAnimatedNodeToView: function connectAnimatedNodeToView(nodeTag, viewTag) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.connectAnimatedNodeToView(nodeTag, viewTag);
      });
    },
    disconnectAnimatedNodeFromView: function disconnectAnimatedNodeFromView(nodeTag, viewTag) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.disconnectAnimatedNodeFromView(nodeTag, viewTag);
      });
    },
    restoreDefaultValues: function restoreDefaultValues(nodeTag) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');

      if (NativeAnimatedModule.restoreDefaultValues != null) {
        API.queueOperation(function () {
          return NativeAnimatedModule.restoreDefaultValues(nodeTag);
        });
      }
    },
    dropAnimatedNode: function dropAnimatedNode(tag) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.dropAnimatedNode(tag);
      });
    },
    addAnimatedEventToView: function addAnimatedEventToView(viewTag, eventName, eventMapping) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.addAnimatedEventToView(viewTag, eventName, eventMapping);
      });
    },
    removeAnimatedEventFromView: function removeAnimatedEventFromView(viewTag, eventName, animatedNodeTag) {
      (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
      API.queueOperation(function () {
        return NativeAnimatedModule.removeAnimatedEventFromView(viewTag, eventName, animatedNodeTag);
      });
    }
  };
  var SUPPORTED_STYLES = {
    opacity: true,
    transform: true,
    borderRadius: true,
    borderBottomEndRadius: true,
    borderBottomLeftRadius: true,
    borderBottomRightRadius: true,
    borderBottomStartRadius: true,
    borderTopEndRadius: true,
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderTopStartRadius: true,
    elevation: true,
    zIndex: true,
    shadowOpacity: true,
    shadowRadius: true,
    scaleX: true,
    scaleY: true,
    translateX: true,
    translateY: true
  };
  var SUPPORTED_TRANSFORMS = {
    translateX: true,
    translateY: true,
    scale: true,
    scaleX: true,
    scaleY: true,
    rotate: true,
    rotateX: true,
    rotateY: true,
    rotateZ: true,
    perspective: true
  };
  var SUPPORTED_INTERPOLATION_PARAMS = {
    inputRange: true,
    outputRange: true,
    extrapolate: true,
    extrapolateRight: true,
    extrapolateLeft: true
  };

  function addWhitelistedStyleProp(prop) {
    SUPPORTED_STYLES[prop] = true;
  }

  function addWhitelistedTransformProp(prop) {
    SUPPORTED_TRANSFORMS[prop] = true;
  }

  function addWhitelistedInterpolationParam(param) {
    SUPPORTED_INTERPOLATION_PARAMS[param] = true;
  }

  function validateTransform(configs) {
    configs.forEach(function (config) {
      if (!SUPPORTED_TRANSFORMS.hasOwnProperty(config.property)) {
        throw new Error("Property '" + config.property + "' is not supported by native animated module");
      }
    });
  }

  function validateStyles(styles) {
    for (var _key in styles) {
      if (!SUPPORTED_STYLES.hasOwnProperty(_key)) {
        throw new Error("Style property '" + _key + "' is not supported by native animated module");
      }
    }
  }

  function validateInterpolation(config) {
    for (var _key2 in config) {
      if (!SUPPORTED_INTERPOLATION_PARAMS.hasOwnProperty(_key2)) {
        throw new Error("Interpolation property '" + _key2 + "' is not supported by native animated module");
      }
    }
  }

  function generateNewNodeTag() {
    return __nativeAnimatedNodeTagCount++;
  }

  function generateNewAnimationId() {
    return __nativeAnimationIdCount++;
  }

  function assertNativeAnimatedModule() {
    (0, _invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
  }

  var _warnedMissingNativeAnimated = false;

  function shouldUseNativeDriver(config) {
    if (config.useNativeDriver == null) {
      console.warn("Animated: `useNativeDriver` was not specified. This is a required option and must be explicitly set to `true` or `false`");
    }

    if (config.useNativeDriver === true && !NativeAnimatedModule) {
      if (!_warnedMissingNativeAnimated) {
        console.warn("Animated: `useNativeDriver` is not supported because the native animated module is missing. Falling back to JS-based animation. To resolve this, add `RCTAnimation` module to this app, or remove `useNativeDriver`. Make sure to run `bundle exec pod install` first. Read more about autolinking: https://github.com/react-native-community/cli/blob/master/docs/autolinking.md");
        _warnedMissingNativeAnimated = true;
      }

      return false;
    }

    return config.useNativeDriver || false;
  }

  function transformDataType(value) {
    if (typeof value !== 'string') {
      return value;
    }

    if (/deg$/.test(value)) {
      var degrees = parseFloat(value) || 0;
      var radians = degrees * Math.PI / 180.0;
      return radians;
    } else {
      return value;
    }
  }

  module.exports = {
    API: API,
    addWhitelistedStyleProp: addWhitelistedStyleProp,
    addWhitelistedTransformProp: addWhitelistedTransformProp,
    addWhitelistedInterpolationParam: addWhitelistedInterpolationParam,
    validateStyles: validateStyles,
    validateTransform: validateTransform,
    validateInterpolation: validateInterpolation,
    generateNewNodeTag: generateNewNodeTag,
    generateNewAnimationId: generateNewAnimationId,
    assertNativeAnimatedModule: assertNativeAnimatedModule,
    shouldUseNativeDriver: shouldUseNativeDriver,
    transformDataType: transformDataType,

    get nativeEventEmitter() {
      if (!nativeEventEmitter) {
        nativeEventEmitter = new _NativeEventEmitter.default(_Platform.default.OS !== 'ios' ? null : NativeAnimatedModule);
      }

      return nativeEventEmitter;
    }

  };
},"node_modules/react-native/Libraries/Animated/NativeAnimatedHelper.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Animated/NativeAnimatedModule.js","node_modules/react-native/Libraries/Animated/NativeAnimatedTurboModule.js","node_modules/react-native/Libraries/EventEmitter/NativeEventEmitter.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('NativeAnimatedModule');

  exports.default = _default;
},"node_modules/react-native/Libraries/Animated/NativeAnimatedModule.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('NativeAnimatedTurboModule');

  exports.default = _default;
},"node_modules/react-native/Libraries/Animated/NativeAnimatedTurboModule.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var linear = function linear(t) {
    return t;
  };

  function createInterpolation(config) {
    if (config.outputRange && typeof config.outputRange[0] === 'string') {
      return createInterpolationFromStringOutputRange(config);
    }

    var outputRange = config.outputRange;
    checkInfiniteRange('outputRange', outputRange);
    var inputRange = config.inputRange;
    checkInfiniteRange('inputRange', inputRange);
    checkValidInputRange(inputRange);

    _$$_REQUIRE(_dependencyMap[2])(inputRange.length === outputRange.length, 'inputRange (' + inputRange.length + ') and outputRange (' + outputRange.length + ') must have the same length');

    var easing = config.easing || linear;
    var extrapolateLeft = 'extend';

    if (config.extrapolateLeft !== undefined) {
      extrapolateLeft = config.extrapolateLeft;
    } else if (config.extrapolate !== undefined) {
      extrapolateLeft = config.extrapolate;
    }

    var extrapolateRight = 'extend';

    if (config.extrapolateRight !== undefined) {
      extrapolateRight = config.extrapolateRight;
    } else if (config.extrapolate !== undefined) {
      extrapolateRight = config.extrapolate;
    }

    return function (input) {
      _$$_REQUIRE(_dependencyMap[2])(typeof input === 'number', 'Cannot interpolation an input which is not a number');

      var range = findRange(input, inputRange);
      return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight);
    };
  }

  function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {
    var result = input;

    if (result < inputMin) {
      if (extrapolateLeft === 'identity') {
        return result;
      } else if (extrapolateLeft === 'clamp') {
        result = inputMin;
      } else if (extrapolateLeft === 'extend') {}
    }

    if (result > inputMax) {
      if (extrapolateRight === 'identity') {
        return result;
      } else if (extrapolateRight === 'clamp') {
        result = inputMax;
      } else if (extrapolateRight === 'extend') {}
    }

    if (outputMin === outputMax) {
      return outputMin;
    }

    if (inputMin === inputMax) {
      if (input <= inputMin) {
        return outputMin;
      }

      return outputMax;
    }

    if (inputMin === -(1 / 0)) {
      result = -result;
    } else if (inputMax === Infinity) {
      result = result - inputMin;
    } else {
      result = (result - inputMin) / (inputMax - inputMin);
    }

    result = easing(result);

    if (outputMin === -(1 / 0)) {
      result = -result;
    } else if (outputMax === Infinity) {
      result = result + outputMin;
    } else {
      result = result * (outputMax - outputMin) + outputMin;
    }

    return result;
  }

  function colorToRgba(input) {
    var normalizedColor = _$$_REQUIRE(_dependencyMap[3])(input);

    if (normalizedColor === null || typeof normalizedColor !== 'number') {
      return input;
    }

    normalizedColor = normalizedColor || 0;
    var r = (normalizedColor & 0xff000000) >>> 24;
    var g = (normalizedColor & 0x00ff0000) >>> 16;
    var b = (normalizedColor & 0x0000ff00) >>> 8;
    var a = (normalizedColor & 0x000000ff) / 255;
    return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
  }

  var stringShapeRegex = /[+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?/g;

  function createInterpolationFromStringOutputRange(config) {
    var outputRange = config.outputRange;

    _$$_REQUIRE(_dependencyMap[2])(outputRange.length >= 2, 'Bad output range');

    outputRange = outputRange.map(colorToRgba);
    checkPattern(outputRange);
    var outputRanges = outputRange[0].match(stringShapeRegex).map(function () {
      return [];
    });
    outputRange.forEach(function (value) {
      value.match(stringShapeRegex).forEach(function (number, i) {
        outputRanges[i].push(+number);
      });
    });
    var interpolations = outputRange[0].match(stringShapeRegex).map(function (value, i) {
      return createInterpolation(_$$_REQUIRE(_dependencyMap[4])({}, config, {
        outputRange: outputRanges[i]
      }));
    });
    var shouldRound = isRgbOrRgba(outputRange[0]);
    return function (input) {
      var i = 0;
      return outputRange[0].replace(stringShapeRegex, function () {
        var val = +interpolations[i++](input);

        if (shouldRound) {
          val = i < 4 ? Math.round(val) : Math.round(val * 1000) / 1000;
        }

        return String(val);
      });
    };
  }

  function isRgbOrRgba(range) {
    return typeof range === 'string' && range.startsWith('rgb');
  }

  function checkPattern(arr) {
    var pattern = arr[0].replace(stringShapeRegex, '');

    for (var i = 1; i < arr.length; ++i) {
      _$$_REQUIRE(_dependencyMap[2])(pattern === arr[i].replace(stringShapeRegex, ''), 'invalid pattern ' + arr[0] + ' and ' + arr[i]);
    }
  }

  function findRange(input, inputRange) {
    var i;

    for (i = 1; i < inputRange.length - 1; ++i) {
      if (inputRange[i] >= input) {
        break;
      }
    }

    return i - 1;
  }

  function checkValidInputRange(arr) {
    _$$_REQUIRE(_dependencyMap[2])(arr.length >= 2, 'inputRange must have at least 2 elements');

    for (var i = 1; i < arr.length; ++i) {
      _$$_REQUIRE(_dependencyMap[2])(arr[i] >= arr[i - 1], 'inputRange must be monotonically non-decreasing ' + arr);
    }
  }

  function checkInfiniteRange(name, arr) {
    _$$_REQUIRE(_dependencyMap[2])(arr.length >= 2, name + ' must have at least 2 elements');

    _$$_REQUIRE(_dependencyMap[2])(arr.length !== 2 || arr[0] !== -(1 / 0) || arr[1] !== Infinity, name + 'cannot be ]-infinity;+infinity[ ' + arr);
  }

  var AnimatedInterpolation = function (_AnimatedWithChildren) {
    _$$_REQUIRE(_dependencyMap[5])(AnimatedInterpolation, _AnimatedWithChildren);

    var _super = _createSuper(AnimatedInterpolation);

    function AnimatedInterpolation(parent, config) {
      var _this;

      _$$_REQUIRE(_dependencyMap[6])(this, AnimatedInterpolation);

      _this = _super.call(this);
      _this._parent = parent;
      _this._config = config;
      _this._interpolation = createInterpolation(config);
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[7])(AnimatedInterpolation, [{
      key: "__makeNative",
      value: function __makeNative(platformConfig) {
        this._parent.__makeNative(platformConfig);

        _$$_REQUIRE(_dependencyMap[8])(_$$_REQUIRE(_dependencyMap[0])(AnimatedInterpolation.prototype), "__makeNative", this).call(this, platformConfig);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        var parentValue = this._parent.__getValue();

        _$$_REQUIRE(_dependencyMap[2])(typeof parentValue === 'number', 'Cannot interpolate an input which is not a number.');

        return this._interpolation(parentValue);
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new AnimatedInterpolation(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._parent.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._parent.__removeChild(this);

        _$$_REQUIRE(_dependencyMap[8])(_$$_REQUIRE(_dependencyMap[0])(AnimatedInterpolation.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__transformDataType",
      value: function __transformDataType(range) {
        return range.map(_$$_REQUIRE(_dependencyMap[9]).transformDataType);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          inputRange: this._config.inputRange,
          outputRange: this.__transformDataType(this._config.outputRange),
          extrapolateLeft: this._config.extrapolateLeft || this._config.extrapolate || 'extend',
          extrapolateRight: this._config.extrapolateRight || this._config.extrapolate || 'extend',
          type: 'interpolation'
        };
      }
    }]);

    return AnimatedInterpolation;
  }(_$$_REQUIRE(_dependencyMap[10]));

  AnimatedInterpolation.__createInterpolation = createInterpolation;
  module.exports = AnimatedInterpolation;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedInterpolation.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/StyleSheet/normalizeColor.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/react-native/Libraries/Animated/NativeAnimatedHelper.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AnimatedWithChildren = function (_AnimatedNode) {
    _$$_REQUIRE(_dependencyMap[2])(AnimatedWithChildren, _AnimatedNode);

    var _super = _createSuper(AnimatedWithChildren);

    function AnimatedWithChildren() {
      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, AnimatedWithChildren);

      _this = _super.call(this);
      _this._children = [];
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[4])(AnimatedWithChildren, [{
      key: "__makeNative",
      value: function __makeNative(platformConfig) {
        if (!this.__isNative) {
          this.__isNative = true;

          for (var _iterator = _createForOfIteratorHelperLoose(this._children), _step; !(_step = _iterator()).done;) {
            var child = _step.value;

            child.__makeNative(platformConfig);

            _$$_REQUIRE(_dependencyMap[5]).API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
          }
        }

        _$$_REQUIRE(_dependencyMap[6])(_$$_REQUIRE(_dependencyMap[0])(AnimatedWithChildren.prototype), "__makeNative", this).call(this, platformConfig);
      }
    }, {
      key: "__addChild",
      value: function __addChild(child) {
        if (this._children.length === 0) {
          this.__attach();
        }

        this._children.push(child);

        if (this.__isNative) {
          child.__makeNative(this.__getPlatformConfig());

          _$$_REQUIRE(_dependencyMap[5]).API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
        }
      }
    }, {
      key: "__removeChild",
      value: function __removeChild(child) {
        var index = this._children.indexOf(child);

        if (index === -1) {
          console.warn("Trying to remove a child that doesn't exist");
          return;
        }

        if (this.__isNative && child.__isNative) {
          _$$_REQUIRE(_dependencyMap[5]).API.disconnectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
        }

        this._children.splice(index, 1);

        if (this._children.length === 0) {
          this.__detach();
        }
      }
    }, {
      key: "__getChildren",
      value: function __getChildren() {
        return this._children;
      }
    }, {
      key: "__callListeners",
      value: function __callListeners(value) {
        _$$_REQUIRE(_dependencyMap[6])(_$$_REQUIRE(_dependencyMap[0])(AnimatedWithChildren.prototype), "__callListeners", this).call(this, value);

        if (!this.__isNative) {
          for (var _iterator2 = _createForOfIteratorHelperLoose(this._children), _step2; !(_step2 = _iterator2()).done;) {
            var child = _step2.value;

            if (child.__getValue) {
              child.__callListeners(child.__getValue());
            }
          }
        }
      }
    }]);

    return AnimatedWithChildren;
  }(_$$_REQUIRE(_dependencyMap[7]));

  module.exports = AnimatedWithChildren;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Animated/NativeAnimatedHelper.js","node_modules/@babel/runtime/helpers/get.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedNode.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _uniqueId = 1;

  var AnimatedNode = function () {
    function AnimatedNode() {
      _$$_REQUIRE(_dependencyMap[0])(this, AnimatedNode);

      this._listeners = {};
    }

    _$$_REQUIRE(_dependencyMap[1])(AnimatedNode, [{
      key: "__attach",
      value: function __attach() {}
    }, {
      key: "__detach",
      value: function __detach() {
        if (this.__isNative && this.__nativeTag != null) {
          _$$_REQUIRE(_dependencyMap[2]).API.dropAnimatedNode(this.__nativeTag);

          this.__nativeTag = undefined;
        }
      }
    }, {
      key: "__getValue",
      value: function __getValue() {}
    }, {
      key: "__getAnimatedValue",
      value: function __getAnimatedValue() {
        return this.__getValue();
      }
    }, {
      key: "__addChild",
      value: function __addChild(child) {}
    }, {
      key: "__removeChild",
      value: function __removeChild(child) {}
    }, {
      key: "__getChildren",
      value: function __getChildren() {
        return [];
      }
    }, {
      key: "__makeNative",
      value: function __makeNative(platformConfig) {
        if (!this.__isNative) {
          throw new Error('This node cannot be made a "native" animated node');
        }

        this._platformConfig = platformConfig;

        if (this.hasListeners()) {
          this._startListeningToNativeValueUpdates();
        }
      }
    }, {
      key: "addListener",
      value: function addListener(callback) {
        var id = String(_uniqueId++);
        this._listeners[id] = callback;

        if (this.__isNative) {
          this._startListeningToNativeValueUpdates();
        }

        return id;
      }
    }, {
      key: "removeListener",
      value: function removeListener(id) {
        delete this._listeners[id];

        if (this.__isNative && !this.hasListeners()) {
          this._stopListeningForNativeValueUpdates();
        }
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners() {
        this._listeners = {};

        if (this.__isNative) {
          this._stopListeningForNativeValueUpdates();
        }
      }
    }, {
      key: "hasListeners",
      value: function hasListeners() {
        return !!Object.keys(this._listeners).length;
      }
    }, {
      key: "_startListeningToNativeValueUpdates",
      value: function _startListeningToNativeValueUpdates() {
        var _this = this;

        if (this.__nativeAnimatedValueListener && !this.__shouldUpdateListenersForNewNativeTag) {
          return;
        }

        if (this.__shouldUpdateListenersForNewNativeTag) {
          this.__shouldUpdateListenersForNewNativeTag = false;

          this._stopListeningForNativeValueUpdates();
        }

        _$$_REQUIRE(_dependencyMap[2]).API.startListeningToAnimatedNodeValue(this.__getNativeTag());

        this.__nativeAnimatedValueListener = _$$_REQUIRE(_dependencyMap[2]).nativeEventEmitter.addListener('onAnimatedValueUpdate', function (data) {
          if (data.tag !== _this.__getNativeTag()) {
            return;
          }

          _this._onAnimatedValueUpdateReceived(data.value);
        });
      }
    }, {
      key: "_onAnimatedValueUpdateReceived",
      value: function _onAnimatedValueUpdateReceived(value) {
        this.__callListeners(value);
      }
    }, {
      key: "__callListeners",
      value: function __callListeners(value) {
        for (var _key in this._listeners) {
          this._listeners[_key]({
            value: value
          });
        }
      }
    }, {
      key: "_stopListeningForNativeValueUpdates",
      value: function _stopListeningForNativeValueUpdates() {
        if (!this.__nativeAnimatedValueListener) {
          return;
        }

        this.__nativeAnimatedValueListener.remove();

        this.__nativeAnimatedValueListener = null;

        _$$_REQUIRE(_dependencyMap[2]).API.stopListeningToAnimatedNodeValue(this.__getNativeTag());
      }
    }, {
      key: "__getNativeTag",
      value: function __getNativeTag() {
        var _this$__nativeTag;

        _$$_REQUIRE(_dependencyMap[2]).assertNativeAnimatedModule();

        _$$_REQUIRE(_dependencyMap[3])(this.__isNative, 'Attempt to get native tag from node not marked as "native"');

        var nativeTag = (_this$__nativeTag = this.__nativeTag) != null ? _this$__nativeTag : _$$_REQUIRE(_dependencyMap[2]).generateNewNodeTag();

        if (this.__nativeTag == null) {
          this.__nativeTag = nativeTag;

          var config = this.__getNativeConfig();

          if (this._platformConfig) {
            config.platformConfig = this._platformConfig;
          }

          _$$_REQUIRE(_dependencyMap[2]).API.createAnimatedNode(nativeTag, config);

          this.__shouldUpdateListenersForNewNativeTag = true;
        }

        return nativeTag;
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        throw new Error('This JS animated node type cannot be used as native animated node');
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.__getValue();
      }
    }, {
      key: "__getPlatformConfig",
      value: function __getPlatformConfig() {
        return this._platformConfig;
      }
    }, {
      key: "__setPlatformConfig",
      value: function __setPlatformConfig(platformConfig) {
        this._platformConfig = platformConfig;
      }
    }]);

    return AnimatedNode;
  }();

  module.exports = AnimatedNode;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedNode.js",["node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Animated/NativeAnimatedHelper.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _EventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _emitter = new _EventEmitter.default();

  var DEBUG_DELAY = 0;
  var DEBUG = false;
  var InteractionManager = {
    Events: {
      interactionStart: 'interactionStart',
      interactionComplete: 'interactionComplete'
    },
    runAfterInteractions: function runAfterInteractions(task) {
      var tasks = [];
      var promise = new Promise(function (resolve) {
        _scheduleUpdate();

        if (task) {
          tasks.push(task);
        }

        tasks.push({
          run: resolve,
          name: 'resolve ' + (task && task.name || '?')
        });

        _taskQueue.enqueueTasks(tasks);
      });
      return {
        then: promise.then.bind(promise),
        done: function done() {
          if (promise.done) {
            return promise.done.apply(promise, arguments);
          } else {
            console.warn('Tried to call done when not supported by current Promise implementation.');
          }
        },
        cancel: function cancel() {
          _taskQueue.cancelTasks(tasks);
        }
      };
    },
    createInteractionHandle: function createInteractionHandle() {
      DEBUG;

      _scheduleUpdate();

      var handle = ++_inc;

      _addInteractionSet.add(handle);

      return handle;
    },
    clearInteractionHandle: function clearInteractionHandle(handle) {
      DEBUG;

      _$$_REQUIRE(_dependencyMap[2])(!!handle, 'InteractionManager: Must provide a handle to clear.');

      _scheduleUpdate();

      _addInteractionSet.delete(handle);

      _deleteInteractionSet.add(handle);
    },
    addListener: _emitter.addListener.bind(_emitter),
    setDeadline: function setDeadline(deadline) {
      _deadline = deadline;
    }
  };

  var _interactionSet = new Set();

  var _addInteractionSet = new Set();

  var _deleteInteractionSet = new Set();

  var _taskQueue = new (_$$_REQUIRE(_dependencyMap[3]))({
    onMoreTasks: _scheduleUpdate
  });

  var _nextUpdateHandle = 0;
  var _inc = 0;

  var _deadline = -1;

  function _scheduleUpdate() {
    if (!_nextUpdateHandle) {
      if (_deadline > 0) {
        _nextUpdateHandle = setTimeout(_processUpdate, 0);
      } else {
        _nextUpdateHandle = setImmediate(_processUpdate);
      }
    }
  }

  function _processUpdate() {
    _nextUpdateHandle = 0;
    var interactionCount = _interactionSet.size;

    _addInteractionSet.forEach(function (handle) {
      return _interactionSet.add(handle);
    });

    _deleteInteractionSet.forEach(function (handle) {
      return _interactionSet.delete(handle);
    });

    var nextInteractionCount = _interactionSet.size;

    if (interactionCount !== 0 && nextInteractionCount === 0) {
      _emitter.emit(InteractionManager.Events.interactionComplete);
    } else if (interactionCount === 0 && nextInteractionCount !== 0) {
      _emitter.emit(InteractionManager.Events.interactionStart);
    }

    if (nextInteractionCount === 0) {
      while (_taskQueue.hasTasksToProcess()) {
        _taskQueue.processNext();

        if (_deadline > 0 && _$$_REQUIRE(_dependencyMap[4]).getEventLoopRunningTime() >= _deadline) {
          _scheduleUpdate();

          break;
        }
      }
    }

    _addInteractionSet.clear();

    _deleteInteractionSet.clear();
  }

  module.exports = InteractionManager;
},"node_modules/react-native/Libraries/Interaction/InteractionManager.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/vendor/emitter/EventEmitter.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/Interaction/TaskQueue.js","node_modules/react-native/Libraries/BatchedBridge/BatchedBridge.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var DEBUG = false;

  var TaskQueue = function () {
    function TaskQueue(_ref) {
      var onMoreTasks = _ref.onMoreTasks;

      _$$_REQUIRE(_dependencyMap[0])(this, TaskQueue);

      this._onMoreTasks = onMoreTasks;
      this._queueStack = [{
        tasks: [],
        popable: false
      }];
    }

    _$$_REQUIRE(_dependencyMap[1])(TaskQueue, [{
      key: "enqueue",
      value: function enqueue(task) {
        this._getCurrentQueue().push(task);
      }
    }, {
      key: "enqueueTasks",
      value: function enqueueTasks(tasks) {
        var _this = this;

        tasks.forEach(function (task) {
          return _this.enqueue(task);
        });
      }
    }, {
      key: "cancelTasks",
      value: function cancelTasks(tasksToCancel) {
        this._queueStack = this._queueStack.map(function (queue) {
          return _$$_REQUIRE(_dependencyMap[2])({}, queue, {
            tasks: queue.tasks.filter(function (task) {
              return tasksToCancel.indexOf(task) === -1;
            })
          });
        }).filter(function (queue, idx) {
          return queue.tasks.length > 0 || idx === 0;
        });
      }
    }, {
      key: "hasTasksToProcess",
      value: function hasTasksToProcess() {
        return this._getCurrentQueue().length > 0;
      }
    }, {
      key: "processNext",
      value: function processNext() {
        var queue = this._getCurrentQueue();

        if (queue.length) {
          var task = queue.shift();

          try {
            if (typeof task === 'object' && task.gen) {
              DEBUG;

              this._genPromise(task);
            } else if (typeof task === 'object' && task.run) {
              DEBUG;
              task.run();
            } else {
              _$$_REQUIRE(_dependencyMap[3])(typeof task === 'function', 'Expected Function, SimpleTask, or PromiseTask, but got:\n' + JSON.stringify(task, null, 2));

              DEBUG;
              task();
            }
          } catch (e) {
            e.message = 'TaskQueue: Error with task ' + (task.name || '') + ': ' + e.message;
            throw e;
          }
        }
      }
    }, {
      key: "_getCurrentQueue",
      value: function _getCurrentQueue() {
        var stackIdx = this._queueStack.length - 1;
        var queue = this._queueStack[stackIdx];

        if (queue.popable && queue.tasks.length === 0 && this._queueStack.length > 1) {
          this._queueStack.pop();

          DEBUG;
          return this._getCurrentQueue();
        } else {
          return queue.tasks;
        }
      }
    }, {
      key: "_genPromise",
      value: function _genPromise(task) {
        var _this2 = this;

        this._queueStack.push({
          tasks: [],
          popable: false
        });

        var stackIdx = this._queueStack.length - 1;
        var stackItem = this._queueStack[stackIdx];
        DEBUG;
        DEBUG;
        task.gen().then(function () {
          DEBUG;
          stackItem.popable = true;
          _this2.hasTasksToProcess() && _this2._onMoreTasks();
        }).catch(function (ex) {
          ex.message = "TaskQueue: Error resolving Promise in task " + task.name + ": " + ex.message;
          throw ex;
        }).done();
      }
    }]);

    return TaskQueue;
  }();

  module.exports = TaskQueue;
},"node_modules/react-native/Libraries/Interaction/TaskQueue.js",["node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var _uniqueId = 1;

  var AnimatedValueXY = function (_AnimatedWithChildren) {
    _$$_REQUIRE(_dependencyMap[2])(AnimatedValueXY, _AnimatedWithChildren);

    var _super = _createSuper(AnimatedValueXY);

    function AnimatedValueXY(valueIn) {
      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, AnimatedValueXY);

      _this = _super.call(this);
      var value = valueIn || {
        x: 0,
        y: 0
      };

      if (typeof value.x === 'number' && typeof value.y === 'number') {
        _this.x = new (_$$_REQUIRE(_dependencyMap[4]))(value.x);
        _this.y = new (_$$_REQUIRE(_dependencyMap[4]))(value.y);
      } else {
        _$$_REQUIRE(_dependencyMap[5])(value.x instanceof _$$_REQUIRE(_dependencyMap[4]) && value.y instanceof _$$_REQUIRE(_dependencyMap[4]), "AnimatedValueXY must be initialized with an object of numbers or AnimatedValues.");

        _this.x = value.x;
        _this.y = value.y;
      }

      _this._listeners = {};
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[6])(AnimatedValueXY, [{
      key: "setValue",
      value: function setValue(value) {
        this.x.setValue(value.x);
        this.y.setValue(value.y);
      }
    }, {
      key: "setOffset",
      value: function setOffset(offset) {
        this.x.setOffset(offset.x);
        this.y.setOffset(offset.y);
      }
    }, {
      key: "flattenOffset",
      value: function flattenOffset() {
        this.x.flattenOffset();
        this.y.flattenOffset();
      }
    }, {
      key: "extractOffset",
      value: function extractOffset() {
        this.x.extractOffset();
        this.y.extractOffset();
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return {
          x: this.x.__getValue(),
          y: this.y.__getValue()
        };
      }
    }, {
      key: "resetAnimation",
      value: function resetAnimation(callback) {
        this.x.resetAnimation();
        this.y.resetAnimation();
        callback && callback(this.__getValue());
      }
    }, {
      key: "stopAnimation",
      value: function stopAnimation(callback) {
        this.x.stopAnimation();
        this.y.stopAnimation();
        callback && callback(this.__getValue());
      }
    }, {
      key: "addListener",
      value: function addListener(callback) {
        var _this2 = this;

        var id = String(_uniqueId++);

        var jointCallback = function jointCallback(_ref) {
          var number = _ref.value;
          callback(_this2.__getValue());
        };

        this._listeners[id] = {
          x: this.x.addListener(jointCallback),
          y: this.y.addListener(jointCallback)
        };
        return id;
      }
    }, {
      key: "removeListener",
      value: function removeListener(id) {
        this.x.removeListener(this._listeners[id].x);
        this.y.removeListener(this._listeners[id].y);
        delete this._listeners[id];
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners() {
        this.x.removeAllListeners();
        this.y.removeAllListeners();
        this._listeners = {};
      }
    }, {
      key: "getLayout",
      value: function getLayout() {
        return {
          left: this.x,
          top: this.y
        };
      }
    }, {
      key: "getTranslateTransform",
      value: function getTranslateTransform() {
        return [{
          translateX: this.x
        }, {
          translateY: this.y
        }];
      }
    }]);

    return AnimatedValueXY;
  }(_$$_REQUIRE(_dependencyMap[7]));

  module.exports = AnimatedValueXY;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedValueXY.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedValue.js","node_modules/invariant/browser.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _AnimatedColor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var add = function add(a, b) {
    return new (_$$_REQUIRE(_dependencyMap[3]))(a, b);
  };

  var subtract = function subtract(a, b) {
    return new (_$$_REQUIRE(_dependencyMap[4]))(a, b);
  };

  var divide = function divide(a, b) {
    return new (_$$_REQUIRE(_dependencyMap[5]))(a, b);
  };

  var multiply = function multiply(a, b) {
    return new (_$$_REQUIRE(_dependencyMap[6]))(a, b);
  };

  var modulo = function modulo(a, modulus) {
    return new (_$$_REQUIRE(_dependencyMap[7]))(a, modulus);
  };

  var diffClamp = function diffClamp(a, min, max) {
    return new (_$$_REQUIRE(_dependencyMap[8]))(a, min, max);
  };

  var _combineCallbacks = function _combineCallbacks(callback, config) {
    if (callback && config.onComplete) {
      return function () {
        config.onComplete && config.onComplete.apply(config, arguments);
        callback && callback.apply(undefined, arguments);
      };
    } else {
      return callback || config.onComplete;
    }
  };

  var maybeVectorAnim = function maybeVectorAnim(value, config, anim) {
    if (value instanceof _$$_REQUIRE(_dependencyMap[9])) {
      var configX = (0, _extends2.default)({}, config);
      var configY = (0, _extends2.default)({}, config);

      for (var key in config) {
        var _config$key = config[key],
            x = _config$key.x,
            y = _config$key.y;

        if (x !== undefined && y !== undefined) {
          configX[key] = x;
          configY[key] = y;
        }
      }

      var aX = anim(value.x, configX);
      var aY = anim(value.y, configY);
      return parallel([aX, aY], {
        stopTogether: false
      });
    } else if (value instanceof _AnimatedColor.default) {
      var configR = (0, _extends2.default)({}, config);
      var configG = (0, _extends2.default)({}, config);
      var configB = (0, _extends2.default)({}, config);
      var configA = (0, _extends2.default)({}, config);

      for (var _key in config) {
        var _config$_key = config[_key],
            r = _config$_key.r,
            g = _config$_key.g,
            b = _config$_key.b,
            a = _config$_key.a;

        if (r !== undefined && g !== undefined && b !== undefined && a !== undefined) {
          configR[_key] = r;
          configG[_key] = g;
          configB[_key] = b;
          configA[_key] = a;
        }
      }

      var aR = anim(value.r, configR);
      var aG = anim(value.g, configG);
      var aB = anim(value.b, configB);
      var aA = anim(value.a, configA);
      return parallel([aR, aG, aB, aA], {
        stopTogether: false
      });
    }

    return null;
  };

  var spring = function spring(value, config) {
    var _start = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();

      if (configuration.toValue instanceof _$$_REQUIRE(_dependencyMap[10])) {
        singleValue.track(new (_$$_REQUIRE(_dependencyMap[11]))(singleValue, configuration.toValue, _$$_REQUIRE(_dependencyMap[12]), singleConfig, callback));
      } else {
        singleValue.animate(new (_$$_REQUIRE(_dependencyMap[12]))(singleConfig), callback);
      }
    };

    return maybeVectorAnim(value, config, spring) || {
      start: function start(callback) {
        _start(value, config, callback);
      },
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = (0, _extends2.default)({}, config, {
          iterations: iterations
        });

        _start(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };

  var timing = function timing(value, config) {
    var _start2 = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();

      if (configuration.toValue instanceof _$$_REQUIRE(_dependencyMap[10])) {
        singleValue.track(new (_$$_REQUIRE(_dependencyMap[11]))(singleValue, configuration.toValue, _$$_REQUIRE(_dependencyMap[13]), singleConfig, callback));
      } else {
        singleValue.animate(new (_$$_REQUIRE(_dependencyMap[13]))(singleConfig), callback);
      }
    };

    return maybeVectorAnim(value, config, timing) || {
      start: function start(callback) {
        _start2(value, config, callback);
      },
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = (0, _extends2.default)({}, config, {
          iterations: iterations
        });

        _start2(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };

  var decay = function decay(value, config) {
    var _start3 = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();
      singleValue.animate(new (_$$_REQUIRE(_dependencyMap[14]))(singleConfig), callback);
    };

    return maybeVectorAnim(value, config, decay) || {
      start: function start(callback) {
        _start3(value, config, callback);
      },
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = (0, _extends2.default)({}, config, {
          iterations: iterations
        });

        _start3(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };

  var sequence = function sequence(animations) {
    var current = 0;
    return {
      start: function start(callback) {
        var onComplete = function onComplete(result) {
          if (!result.finished) {
            callback && callback(result);
            return;
          }

          current++;

          if (current === animations.length) {
            callback && callback(result);
            return;
          }

          animations[current].start(onComplete);
        };

        if (animations.length === 0) {
          callback && callback({
            finished: true
          });
        } else {
          animations[current].start(onComplete);
        }
      },
      stop: function stop() {
        if (current < animations.length) {
          animations[current].stop();
        }
      },
      reset: function reset() {
        animations.forEach(function (animation, idx) {
          if (idx <= current) {
            animation.reset();
          }
        });
        current = 0;
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.sequence animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return false;
      }
    };
  };

  var parallel = function parallel(animations, config) {
    var doneCount = 0;
    var hasEnded = {};
    var stopTogether = !(config && config.stopTogether === false);
    var result = {
      start: function start(callback) {
        if (doneCount === animations.length) {
          callback && callback({
            finished: true
          });
          return;
        }

        animations.forEach(function (animation, idx) {
          var cb = function cb(endResult) {
            hasEnded[idx] = true;
            doneCount++;

            if (doneCount === animations.length) {
              doneCount = 0;
              callback && callback(endResult);
              return;
            }

            if (!endResult.finished && stopTogether) {
              result.stop();
            }
          };

          if (!animation) {
            cb({
              finished: true
            });
          } else {
            animation.start(cb);
          }
        });
      },
      stop: function stop() {
        animations.forEach(function (animation, idx) {
          !hasEnded[idx] && animation.stop();
          hasEnded[idx] = true;
        });
      },
      reset: function reset() {
        animations.forEach(function (animation, idx) {
          animation.reset();
          hasEnded[idx] = false;
          doneCount = 0;
        });
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.parallel animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return false;
      }
    };
    return result;
  };

  var delay = function delay(time) {
    return timing(new (_$$_REQUIRE(_dependencyMap[15]))(0), {
      toValue: 0,
      delay: time,
      duration: 0,
      useNativeDriver: false
    });
  };

  var stagger = function stagger(time, animations) {
    return parallel(animations.map(function (animation, i) {
      return sequence([delay(time * i), animation]);
    }));
  };

  var loop = function loop(animation) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$iterations = _ref.iterations,
        iterations = _ref$iterations === undefined ? -1 : _ref$iterations,
        _ref$resetBeforeItera = _ref.resetBeforeIteration,
        resetBeforeIteration = _ref$resetBeforeItera === undefined ? true : _ref$resetBeforeItera;

    var isFinished = false;
    var iterationsSoFar = 0;
    return {
      start: function start(callback) {
        var restart = function restart() {
          var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            finished: true
          };

          if (isFinished || iterationsSoFar === iterations || result.finished === false) {
            callback && callback(result);
          } else {
            iterationsSoFar++;
            resetBeforeIteration && animation.reset();
            animation.start(restart);
          }
        };

        if (!animation || iterations === 0) {
          callback && callback({
            finished: true
          });
        } else {
          if (animation._isUsingNativeDriver()) {
            animation._startNativeLoop(iterations);
          } else {
            restart();
          }
        }
      },
      stop: function stop() {
        isFinished = true;
        animation.stop();
      },
      reset: function reset() {
        iterationsSoFar = 0;
        isFinished = false;
        animation.reset();
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.loop animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return animation._isUsingNativeDriver();
      }
    };
  };

  function forkEvent(event, listener) {
    if (!event) {
      return listener;
    } else if (event instanceof _$$_REQUIRE(_dependencyMap[16]).AnimatedEvent) {
      event.__addListener(listener);

      return event;
    } else {
      return function () {
        typeof event === 'function' && event.apply(undefined, arguments);
        listener.apply(undefined, arguments);
      };
    }
  }

  function unforkEvent(event, listener) {
    if (event && event instanceof _$$_REQUIRE(_dependencyMap[16]).AnimatedEvent) {
      event.__removeListener(listener);
    }
  }

  var event = function event(argMapping, config) {
    var animatedEvent = new (_$$_REQUIRE(_dependencyMap[16]).AnimatedEvent)(argMapping, config);

    if (animatedEvent.__isNative) {
      return animatedEvent;
    } else {
      return animatedEvent.__getHandler();
    }
  };

  module.exports = {
    Value: _$$_REQUIRE(_dependencyMap[15]),
    ValueXY: _$$_REQUIRE(_dependencyMap[9]),
    Color: _AnimatedColor.default,
    Interpolation: _$$_REQUIRE(_dependencyMap[17]),
    Node: _$$_REQUIRE(_dependencyMap[10]),
    decay: decay,
    timing: timing,
    spring: spring,
    add: add,
    subtract: subtract,
    divide: divide,
    multiply: multiply,
    modulo: modulo,
    diffClamp: diffClamp,
    delay: delay,
    sequence: sequence,
    parallel: parallel,
    stagger: stagger,
    loop: loop,
    event: event,
    createAnimatedComponent: _$$_REQUIRE(_dependencyMap[18]),
    attachNativeEvent: _$$_REQUIRE(_dependencyMap[16]).attachNativeEvent,
    forkEvent: forkEvent,
    unforkEvent: unforkEvent,
    Event: _$$_REQUIRE(_dependencyMap[16]).AnimatedEvent
  };
},"node_modules/react-native/Libraries/Animated/AnimatedImplementation.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedColor.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedAddition.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedSubtraction.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedDivision.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedMultiplication.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedModulo.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedDiffClamp.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedValueXY.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedNode.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedTracking.js","node_modules/react-native/Libraries/Animated/animations/SpringAnimation.js","node_modules/react-native/Libraries/Animated/animations/TimingAnimation.js","node_modules/react-native/Libraries/Animated/animations/DecayAnimation.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedValue.js","node_modules/react-native/Libraries/Animated/AnimatedEvent.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedInterpolation.js","node_modules/react-native/Libraries/Animated/createAnimatedComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AnimatedAddition = function (_AnimatedWithChildren) {
    _$$_REQUIRE(_dependencyMap[2])(AnimatedAddition, _AnimatedWithChildren);

    var _super = _createSuper(AnimatedAddition);

    function AnimatedAddition(a, b) {
      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, AnimatedAddition);

      _this = _super.call(this);
      _this._a = typeof a === 'number' ? new (_$$_REQUIRE(_dependencyMap[4]))(a) : a;
      _this._b = typeof b === 'number' ? new (_$$_REQUIRE(_dependencyMap[4]))(b) : b;
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[5])(AnimatedAddition, [{
      key: "__makeNative",
      value: function __makeNative(platformConfig) {
        this._a.__makeNative(platformConfig);

        this._b.__makeNative(platformConfig);

        _$$_REQUIRE(_dependencyMap[6])(_$$_REQUIRE(_dependencyMap[0])(AnimatedAddition.prototype), "__makeNative", this).call(this, platformConfig);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._a.__getValue() + this._b.__getValue();
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new (_$$_REQUIRE(_dependencyMap[7]))(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);

        this._b.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        this._b.__removeChild(this);

        _$$_REQUIRE(_dependencyMap[6])(_$$_REQUIRE(_dependencyMap[0])(AnimatedAddition.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'addition',
          input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
        };
      }
    }]);

    return AnimatedAddition;
  }(_$$_REQUIRE(_dependencyMap[8]));

  module.exports = AnimatedAddition;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedAddition.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedValue.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedInterpolation.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AnimatedSubtraction = function (_AnimatedWithChildren) {
    _$$_REQUIRE(_dependencyMap[2])(AnimatedSubtraction, _AnimatedWithChildren);

    var _super = _createSuper(AnimatedSubtraction);

    function AnimatedSubtraction(a, b) {
      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, AnimatedSubtraction);

      _this = _super.call(this);
      _this._a = typeof a === 'number' ? new (_$$_REQUIRE(_dependencyMap[4]))(a) : a;
      _this._b = typeof b === 'number' ? new (_$$_REQUIRE(_dependencyMap[4]))(b) : b;
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[5])(AnimatedSubtraction, [{
      key: "__makeNative",
      value: function __makeNative(platformConfig) {
        this._a.__makeNative(platformConfig);

        this._b.__makeNative(platformConfig);

        _$$_REQUIRE(_dependencyMap[6])(_$$_REQUIRE(_dependencyMap[0])(AnimatedSubtraction.prototype), "__makeNative", this).call(this, platformConfig);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._a.__getValue() - this._b.__getValue();
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new (_$$_REQUIRE(_dependencyMap[7]))(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);

        this._b.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        this._b.__removeChild(this);

        _$$_REQUIRE(_dependencyMap[6])(_$$_REQUIRE(_dependencyMap[0])(AnimatedSubtraction.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'subtraction',
          input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
        };
      }
    }]);

    return AnimatedSubtraction;
  }(_$$_REQUIRE(_dependencyMap[8]));

  module.exports = AnimatedSubtraction;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedSubtraction.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedValue.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedInterpolation.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AnimatedDivision = function (_AnimatedWithChildren) {
    _$$_REQUIRE(_dependencyMap[2])(AnimatedDivision, _AnimatedWithChildren);

    var _super = _createSuper(AnimatedDivision);

    function AnimatedDivision(a, b) {
      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, AnimatedDivision);

      _this = _super.call(this);
      _this._warnedAboutDivideByZero = false;

      if (b === 0 || b instanceof _$$_REQUIRE(_dependencyMap[4]) && b.__getValue() === 0) {
        console.error('Detected potential division by zero in AnimatedDivision');
      }

      _this._a = typeof a === 'number' ? new (_$$_REQUIRE(_dependencyMap[5]))(a) : a;
      _this._b = typeof b === 'number' ? new (_$$_REQUIRE(_dependencyMap[5]))(b) : b;
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[6])(AnimatedDivision, [{
      key: "__makeNative",
      value: function __makeNative(platformConfig) {
        this._a.__makeNative(platformConfig);

        this._b.__makeNative(platformConfig);

        _$$_REQUIRE(_dependencyMap[7])(_$$_REQUIRE(_dependencyMap[0])(AnimatedDivision.prototype), "__makeNative", this).call(this, platformConfig);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        var a = this._a.__getValue();

        var b = this._b.__getValue();

        if (b === 0) {
          if (!this._warnedAboutDivideByZero) {
            console.error('Detected division by zero in AnimatedDivision');
            this._warnedAboutDivideByZero = true;
          }

          return 0;
        }

        this._warnedAboutDivideByZero = false;
        return a / b;
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new (_$$_REQUIRE(_dependencyMap[8]))(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);

        this._b.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        this._b.__removeChild(this);

        _$$_REQUIRE(_dependencyMap[7])(_$$_REQUIRE(_dependencyMap[0])(AnimatedDivision.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'division',
          input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
        };
      }
    }]);

    return AnimatedDivision;
  }(_$$_REQUIRE(_dependencyMap[9]));

  module.exports = AnimatedDivision;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedDivision.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedNode.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedValue.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedInterpolation.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AnimatedMultiplication = function (_AnimatedWithChildren) {
    _$$_REQUIRE(_dependencyMap[2])(AnimatedMultiplication, _AnimatedWithChildren);

    var _super = _createSuper(AnimatedMultiplication);

    function AnimatedMultiplication(a, b) {
      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, AnimatedMultiplication);

      _this = _super.call(this);
      _this._a = typeof a === 'number' ? new (_$$_REQUIRE(_dependencyMap[4]))(a) : a;
      _this._b = typeof b === 'number' ? new (_$$_REQUIRE(_dependencyMap[4]))(b) : b;
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[5])(AnimatedMultiplication, [{
      key: "__makeNative",
      value: function __makeNative(platformConfig) {
        this._a.__makeNative(platformConfig);

        this._b.__makeNative(platformConfig);

        _$$_REQUIRE(_dependencyMap[6])(_$$_REQUIRE(_dependencyMap[0])(AnimatedMultiplication.prototype), "__makeNative", this).call(this, platformConfig);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._a.__getValue() * this._b.__getValue();
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new (_$$_REQUIRE(_dependencyMap[7]))(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);

        this._b.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        this._b.__removeChild(this);

        _$$_REQUIRE(_dependencyMap[6])(_$$_REQUIRE(_dependencyMap[0])(AnimatedMultiplication.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'multiplication',
          input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
        };
      }
    }]);

    return AnimatedMultiplication;
  }(_$$_REQUIRE(_dependencyMap[8]));

  module.exports = AnimatedMultiplication;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedMultiplication.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedValue.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedInterpolation.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AnimatedModulo = function (_AnimatedWithChildren) {
    _$$_REQUIRE(_dependencyMap[2])(AnimatedModulo, _AnimatedWithChildren);

    var _super = _createSuper(AnimatedModulo);

    function AnimatedModulo(a, modulus) {
      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, AnimatedModulo);

      _this = _super.call(this);
      _this._a = a;
      _this._modulus = modulus;
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[4])(AnimatedModulo, [{
      key: "__makeNative",
      value: function __makeNative(platformConfig) {
        this._a.__makeNative(platformConfig);

        _$$_REQUIRE(_dependencyMap[5])(_$$_REQUIRE(_dependencyMap[0])(AnimatedModulo.prototype), "__makeNative", this).call(this, platformConfig);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return (this._a.__getValue() % this._modulus + this._modulus) % this._modulus;
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new (_$$_REQUIRE(_dependencyMap[6]))(this, config);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        _$$_REQUIRE(_dependencyMap[5])(_$$_REQUIRE(_dependencyMap[0])(AnimatedModulo.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'modulus',
          input: this._a.__getNativeTag(),
          modulus: this._modulus
        };
      }
    }]);

    return AnimatedModulo;
  }(_$$_REQUIRE(_dependencyMap[7]));

  module.exports = AnimatedModulo;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedModulo.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedInterpolation.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AnimatedDiffClamp = function (_AnimatedWithChildren) {
    _$$_REQUIRE(_dependencyMap[2])(AnimatedDiffClamp, _AnimatedWithChildren);

    var _super = _createSuper(AnimatedDiffClamp);

    function AnimatedDiffClamp(a, min, max) {
      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, AnimatedDiffClamp);

      _this = _super.call(this);
      _this._a = a;
      _this._min = min;
      _this._max = max;
      _this._value = _this._lastValue = _this._a.__getValue();
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[4])(AnimatedDiffClamp, [{
      key: "__makeNative",
      value: function __makeNative(platformConfig) {
        this._a.__makeNative(platformConfig);

        _$$_REQUIRE(_dependencyMap[5])(_$$_REQUIRE(_dependencyMap[0])(AnimatedDiffClamp.prototype), "__makeNative", this).call(this, platformConfig);
      }
    }, {
      key: "interpolate",
      value: function interpolate(config) {
        return new (_$$_REQUIRE(_dependencyMap[6]))(this, config);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        var value = this._a.__getValue();

        var diff = value - this._lastValue;
        this._lastValue = value;
        this._value = Math.min(Math.max(this._value + diff, this._min), this._max);
        return this._value;
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._a.__addChild(this);
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._a.__removeChild(this);

        _$$_REQUIRE(_dependencyMap[5])(_$$_REQUIRE(_dependencyMap[0])(AnimatedDiffClamp.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        return {
          type: 'diffclamp',
          input: this._a.__getNativeTag(),
          min: this._min,
          max: this._max
        };
      }
    }]);

    return AnimatedDiffClamp;
  }(_$$_REQUIRE(_dependencyMap[7]));

  module.exports = AnimatedDiffClamp;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedDiffClamp.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedInterpolation.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AnimatedTracking = function (_AnimatedNode) {
    _$$_REQUIRE(_dependencyMap[2])(AnimatedTracking, _AnimatedNode);

    var _super = _createSuper(AnimatedTracking);

    function AnimatedTracking(value, parent, animationClass, animationConfig, callback) {
      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, AnimatedTracking);

      _this = _super.call(this);
      _this._value = value;
      _this._parent = parent;
      _this._animationClass = animationClass;
      _this._animationConfig = animationConfig;
      _this._useNativeDriver = _$$_REQUIRE(_dependencyMap[4]).shouldUseNativeDriver(animationConfig);
      _this._callback = callback;

      _this.__attach();

      return _this;
    }

    _$$_REQUIRE(_dependencyMap[5])(AnimatedTracking, [{
      key: "__makeNative",
      value: function __makeNative(platformConfig) {
        this.__isNative = true;

        this._parent.__makeNative(platformConfig);

        _$$_REQUIRE(_dependencyMap[6])(_$$_REQUIRE(_dependencyMap[0])(AnimatedTracking.prototype), "__makeNative", this).call(this, platformConfig);

        this._value.__makeNative(platformConfig);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._parent.__getValue();
      }
    }, {
      key: "__attach",
      value: function __attach() {
        this._parent.__addChild(this);

        if (this._useNativeDriver) {
          var platformConfig = this._animationConfig.platformConfig;

          this.__makeNative(platformConfig);
        }
      }
    }, {
      key: "__detach",
      value: function __detach() {
        this._parent.__removeChild(this);

        _$$_REQUIRE(_dependencyMap[6])(_$$_REQUIRE(_dependencyMap[0])(AnimatedTracking.prototype), "__detach", this).call(this);
      }
    }, {
      key: "update",
      value: function update() {
        this._value.animate(new this._animationClass(_$$_REQUIRE(_dependencyMap[7])({}, this._animationConfig, {
          toValue: this._animationConfig.toValue.__getValue()
        })), this._callback);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        var animation = new this._animationClass(_$$_REQUIRE(_dependencyMap[7])({}, this._animationConfig, {
          toValue: undefined
        }));

        var animationConfig = animation.__getNativeAnimationConfig();

        return {
          type: 'tracking',
          animationId: _$$_REQUIRE(_dependencyMap[4]).generateNewAnimationId(),
          animationConfig: animationConfig,
          toValue: this._parent.__getNativeTag(),
          value: this._value.__getNativeTag()
        };
      }
    }]);

    return AnimatedTracking;
  }(_$$_REQUIRE(_dependencyMap[8]));

  module.exports = AnimatedTracking;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedTracking.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/react-native/Libraries/Animated/NativeAnimatedHelper.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedNode.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _get2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _AnimatedColor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var SpringAnimation = function (_Animation) {
    (0, _inherits2.default)(SpringAnimation, _Animation);

    var _super = _createSuper(SpringAnimation);

    function SpringAnimation(config) {
      var _config$overshootClam, _config$restDisplacem, _config$restSpeedThre, _config$velocity, _config$velocity2, _config$delay, _config$isInteraction, _config$iterations;

      var _this;

      (0, _classCallCheck2.default)(this, SpringAnimation);
      _this = _super.call(this);
      _this._overshootClamping = (_config$overshootClam = config.overshootClamping) != null ? _config$overshootClam : false;
      _this._restDisplacementThreshold = (_config$restDisplacem = config.restDisplacementThreshold) != null ? _config$restDisplacem : 0.001;
      _this._restSpeedThreshold = (_config$restSpeedThre = config.restSpeedThreshold) != null ? _config$restSpeedThre : 0.001;
      _this._initialVelocity = (_config$velocity = config.velocity) != null ? _config$velocity : 0;
      _this._lastVelocity = (_config$velocity2 = config.velocity) != null ? _config$velocity2 : 0;
      _this._toValue = config.toValue;
      _this._delay = (_config$delay = config.delay) != null ? _config$delay : 0;
      _this._useNativeDriver = _$$_REQUIRE(_dependencyMap[8]).shouldUseNativeDriver(config);
      _this._platformConfig = config.platformConfig;
      _this.__isInteraction = (_config$isInteraction = config.isInteraction) != null ? _config$isInteraction : !_this._useNativeDriver;
      _this.__iterations = (_config$iterations = config.iterations) != null ? _config$iterations : 1;

      if (config.stiffness !== undefined || config.damping !== undefined || config.mass !== undefined) {
        var _config$stiffness, _config$damping, _config$mass;

        _$$_REQUIRE(_dependencyMap[9])(config.bounciness === undefined && config.speed === undefined && config.tension === undefined && config.friction === undefined, 'You can define one of bounciness/speed, tension/friction, or stiffness/damping/mass, but not more than one');

        _this._stiffness = (_config$stiffness = config.stiffness) != null ? _config$stiffness : 100;
        _this._damping = (_config$damping = config.damping) != null ? _config$damping : 10;
        _this._mass = (_config$mass = config.mass) != null ? _config$mass : 1;
      } else if (config.bounciness !== undefined || config.speed !== undefined) {
        var _config$bounciness, _config$speed;

        _$$_REQUIRE(_dependencyMap[9])(config.tension === undefined && config.friction === undefined && config.stiffness === undefined && config.damping === undefined && config.mass === undefined, 'You can define one of bounciness/speed, tension/friction, or stiffness/damping/mass, but not more than one');

        var springConfig = _$$_REQUIRE(_dependencyMap[10]).fromBouncinessAndSpeed((_config$bounciness = config.bounciness) != null ? _config$bounciness : 8, (_config$speed = config.speed) != null ? _config$speed : 12);

        _this._stiffness = springConfig.stiffness;
        _this._damping = springConfig.damping;
        _this._mass = 1;
      } else {
        var _config$tension, _config$friction;

        var _springConfig = _$$_REQUIRE(_dependencyMap[10]).fromOrigamiTensionAndFriction((_config$tension = config.tension) != null ? _config$tension : 40, (_config$friction = config.friction) != null ? _config$friction : 7);

        _this._stiffness = _springConfig.stiffness;
        _this._damping = _springConfig.damping;
        _this._mass = 1;
      }

      _$$_REQUIRE(_dependencyMap[9])(_this._stiffness > 0, 'Stiffness value must be greater than 0');

      _$$_REQUIRE(_dependencyMap[9])(_this._damping > 0, 'Damping value must be greater than 0');

      _$$_REQUIRE(_dependencyMap[9])(_this._mass > 0, 'Mass value must be greater than 0');

      return _this;
    }

    (0, _createClass2.default)(SpringAnimation, [{
      key: "__getNativeAnimationConfig",
      value: function __getNativeAnimationConfig() {
        var _this$_initialVelocit;

        return {
          type: 'spring',
          overshootClamping: this._overshootClamping,
          restDisplacementThreshold: this._restDisplacementThreshold,
          restSpeedThreshold: this._restSpeedThreshold,
          stiffness: this._stiffness,
          damping: this._damping,
          mass: this._mass,
          initialVelocity: (_this$_initialVelocit = this._initialVelocity) != null ? _this$_initialVelocit : this._lastVelocity,
          toValue: this._toValue,
          iterations: this.__iterations,
          platformConfig: this._platformConfig
        };
      }
    }, {
      key: "start",
      value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
        var _this2 = this;

        this.__active = true;
        this._startPosition = fromValue;
        this._lastPosition = this._startPosition;
        this._onUpdate = onUpdate;
        this.__onEnd = onEnd;
        this._lastTime = Date.now();
        this._frameTime = 0.0;

        if (previousAnimation instanceof SpringAnimation) {
          var internalState = previousAnimation.getInternalState();
          this._lastPosition = internalState.lastPosition;
          this._lastVelocity = internalState.lastVelocity;
          this._initialVelocity = this._lastVelocity;
          this._lastTime = internalState.lastTime;
        }

        var start = function start() {
          if (_this2._useNativeDriver) {
            _this2.__startNativeAnimation(animatedValue);
          } else {
            _this2.onUpdate();
          }
        };

        if (this._delay) {
          this._timeout = setTimeout(start, this._delay);
        } else {
          start();
        }
      }
    }, {
      key: "getInternalState",
      value: function getInternalState() {
        return {
          lastPosition: this._lastPosition,
          lastVelocity: this._lastVelocity,
          lastTime: this._lastTime
        };
      }
    }, {
      key: "onUpdate",
      value: function onUpdate() {
        var MAX_STEPS = 64;
        var now = Date.now();

        if (now > this._lastTime + MAX_STEPS) {
          now = this._lastTime + MAX_STEPS;
        }

        var deltaTime = (now - this._lastTime) / 1000;
        this._frameTime += deltaTime;
        var c = this._damping;
        var m = this._mass;
        var k = this._stiffness;
        var v0 = -this._initialVelocity;
        var zeta = c / (2 * Math.sqrt(k * m));
        var omega0 = Math.sqrt(k / m);
        var omega1 = omega0 * Math.sqrt(1.0 - zeta * zeta);
        var x0 = this._toValue - this._startPosition;
        var position = 0.0;
        var velocity = 0.0;
        var t = this._frameTime;

        if (zeta < 1) {
          var envelope = Math.exp(-zeta * omega0 * t);
          position = this._toValue - envelope * ((v0 + zeta * omega0 * x0) / omega1 * Math.sin(omega1 * t) + x0 * Math.cos(omega1 * t));
          velocity = zeta * omega0 * envelope * (Math.sin(omega1 * t) * (v0 + zeta * omega0 * x0) / omega1 + x0 * Math.cos(omega1 * t)) - envelope * (Math.cos(omega1 * t) * (v0 + zeta * omega0 * x0) - omega1 * x0 * Math.sin(omega1 * t));
        } else {
          var _envelope = Math.exp(-omega0 * t);

          position = this._toValue - _envelope * (x0 + (v0 + omega0 * x0) * t);
          velocity = _envelope * (v0 * (t * omega0 - 1) + t * x0 * (omega0 * omega0));
        }

        this._lastTime = now;
        this._lastPosition = position;
        this._lastVelocity = velocity;

        this._onUpdate(position);

        if (!this.__active) {
          return;
        }

        var isOvershooting = false;

        if (this._overshootClamping && this._stiffness !== 0) {
          if (this._startPosition < this._toValue) {
            isOvershooting = position > this._toValue;
          } else {
            isOvershooting = position < this._toValue;
          }
        }

        var isVelocity = Math.abs(velocity) <= this._restSpeedThreshold;

        var isDisplacement = true;

        if (this._stiffness !== 0) {
          isDisplacement = Math.abs(this._toValue - position) <= this._restDisplacementThreshold;
        }

        if (isOvershooting || isVelocity && isDisplacement) {
          if (this._stiffness !== 0) {
            this._lastPosition = this._toValue;
            this._lastVelocity = 0;

            this._onUpdate(this._toValue);
          }

          this.__debouncedOnEnd({
            finished: true
          });

          return;
        }

        this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
      }
    }, {
      key: "stop",
      value: function stop() {
        (0, _get2.default)((0, _getPrototypeOf2.default)(SpringAnimation.prototype), "stop", this).call(this);
        this.__active = false;
        clearTimeout(this._timeout);
        global.cancelAnimationFrame(this._animationFrame);

        this.__debouncedOnEnd({
          finished: false
        });
      }
    }]);
    return SpringAnimation;
  }(_$$_REQUIRE(_dependencyMap[11]));

  module.exports = SpringAnimation;
},"node_modules/react-native/Libraries/Animated/animations/SpringAnimation.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedColor.js","node_modules/react-native/Libraries/Animated/NativeAnimatedHelper.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/Animated/SpringConfig.js","node_modules/react-native/Libraries/Animated/animations/Animation.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function stiffnessFromOrigamiValue(oValue) {
    return (oValue - 30) * 3.62 + 194;
  }

  function dampingFromOrigamiValue(oValue) {
    return (oValue - 8) * 3 + 25;
  }

  function fromOrigamiTensionAndFriction(tension, friction) {
    return {
      stiffness: stiffnessFromOrigamiValue(tension),
      damping: dampingFromOrigamiValue(friction)
    };
  }

  function fromBouncinessAndSpeed(bounciness, speed) {
    function normalize(value, startValue, endValue) {
      return (value - startValue) / (endValue - startValue);
    }

    function projectNormal(n, start, end) {
      return start + n * (end - start);
    }

    function linearInterpolation(t, start, end) {
      return t * end + (1 - t) * start;
    }

    function quadraticOutInterpolation(t, start, end) {
      return linearInterpolation(2 * t - t * t, start, end);
    }

    function b3Friction1(x) {
      return 0.0007 * Math.pow(x, 3) - 0.031 * Math.pow(x, 2) + 0.64 * x + 1.28;
    }

    function b3Friction2(x) {
      return 0.000044 * Math.pow(x, 3) - 0.006 * Math.pow(x, 2) + 0.36 * x + 2;
    }

    function b3Friction3(x) {
      return 0.00000045 * Math.pow(x, 3) - 0.000332 * Math.pow(x, 2) + 0.1078 * x + 5.84;
    }

    function b3Nobounce(tension) {
      if (tension <= 18) {
        return b3Friction1(tension);
      } else if (tension > 18 && tension <= 44) {
        return b3Friction2(tension);
      } else {
        return b3Friction3(tension);
      }
    }

    var b = normalize(bounciness / 1.7, 0, 20);
    b = projectNormal(b, 0, 0.8);
    var s = normalize(speed / 1.7, 0, 20);
    var bouncyTension = projectNormal(s, 0.5, 200);
    var bouncyFriction = quadraticOutInterpolation(b, b3Nobounce(bouncyTension), 0.01);
    return {
      stiffness: stiffnessFromOrigamiValue(bouncyTension),
      damping: dampingFromOrigamiValue(bouncyFriction)
    };
  }

  module.exports = {
    fromOrigamiTensionAndFriction: fromOrigamiTensionAndFriction,
    fromBouncinessAndSpeed: fromBouncinessAndSpeed
  };
},"node_modules/react-native/Libraries/Animated/SpringConfig.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var startNativeAnimationNextId = 1;

  var Animation = function () {
    function Animation() {
      _$$_REQUIRE(_dependencyMap[0])(this, Animation);
    }

    _$$_REQUIRE(_dependencyMap[1])(Animation, [{
      key: "start",
      value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {}
    }, {
      key: "stop",
      value: function stop() {
        if (this.__nativeId) {
          _$$_REQUIRE(_dependencyMap[2]).API.stopAnimation(this.__nativeId);
        }
      }
    }, {
      key: "__getNativeAnimationConfig",
      value: function __getNativeAnimationConfig() {
        throw new Error('This animation type cannot be offloaded to native');
      }
    }, {
      key: "__debouncedOnEnd",
      value: function __debouncedOnEnd(result) {
        var onEnd = this.__onEnd;
        this.__onEnd = null;
        onEnd && onEnd(result);
      }
    }, {
      key: "__startNativeAnimation",
      value: function __startNativeAnimation(animatedValue) {
        var startNativeAnimationWaitId = startNativeAnimationNextId + ":startAnimation";
        startNativeAnimationNextId += 1;

        _$$_REQUIRE(_dependencyMap[2]).API.setWaitingForIdentifier(startNativeAnimationWaitId);

        try {
          var config = this.__getNativeAnimationConfig();

          animatedValue.__makeNative(config.platformConfig);

          this.__nativeId = _$$_REQUIRE(_dependencyMap[2]).generateNewAnimationId();

          _$$_REQUIRE(_dependencyMap[2]).API.startAnimatingNode(this.__nativeId, animatedValue.__getNativeTag(), config, this.__debouncedOnEnd.bind(this));
        } catch (e) {
          throw e;
        } finally {
          _$$_REQUIRE(_dependencyMap[2]).API.unsetWaitingForIdentifier(startNativeAnimationWaitId);
        }
      }
    }]);

    return Animation;
  }();

  module.exports = Animation;
},"node_modules/react-native/Libraries/Animated/animations/Animation.js",["node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Animated/NativeAnimatedHelper.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _get2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _AnimatedColor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var _easeInOut;

  function easeInOut() {
    if (!_easeInOut) {
      var Easing = _$$_REQUIRE(_dependencyMap[8]);

      _easeInOut = Easing.inOut(Easing.ease);
    }

    return _easeInOut;
  }

  var TimingAnimation = function (_Animation) {
    (0, _inherits2.default)(TimingAnimation, _Animation);

    var _super = _createSuper(TimingAnimation);

    function TimingAnimation(config) {
      var _config$easing, _config$duration, _config$delay, _config$iterations, _config$isInteraction;

      var _this;

      (0, _classCallCheck2.default)(this, TimingAnimation);
      _this = _super.call(this);
      _this._toValue = config.toValue;
      _this._easing = (_config$easing = config.easing) != null ? _config$easing : easeInOut();
      _this._duration = (_config$duration = config.duration) != null ? _config$duration : 500;
      _this._delay = (_config$delay = config.delay) != null ? _config$delay : 0;
      _this.__iterations = (_config$iterations = config.iterations) != null ? _config$iterations : 1;
      _this._useNativeDriver = _$$_REQUIRE(_dependencyMap[9]).shouldUseNativeDriver(config);
      _this._platformConfig = config.platformConfig;
      _this.__isInteraction = (_config$isInteraction = config.isInteraction) != null ? _config$isInteraction : !_this._useNativeDriver;
      return _this;
    }

    (0, _createClass2.default)(TimingAnimation, [{
      key: "__getNativeAnimationConfig",
      value: function __getNativeAnimationConfig() {
        var frameDuration = 16.666666666666668;
        var frames = [];
        var numFrames = Math.round(this._duration / frameDuration);

        for (var frame = 0; frame < numFrames; frame++) {
          frames.push(this._easing(frame / numFrames));
        }

        frames.push(this._easing(1));
        return {
          type: 'frames',
          frames: frames,
          toValue: this._toValue,
          iterations: this.__iterations,
          platformConfig: this._platformConfig
        };
      }
    }, {
      key: "start",
      value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
        var _this2 = this;

        this.__active = true;
        this._fromValue = fromValue;
        this._onUpdate = onUpdate;
        this.__onEnd = onEnd;

        var start = function start() {
          if (_this2._duration === 0 && !_this2._useNativeDriver) {
            _this2._onUpdate(_this2._toValue);

            _this2.__debouncedOnEnd({
              finished: true
            });
          } else {
            _this2._startTime = Date.now();

            if (_this2._useNativeDriver) {
              _this2.__startNativeAnimation(animatedValue);
            } else {
              _this2._animationFrame = requestAnimationFrame(_this2.onUpdate.bind(_this2));
            }
          }
        };

        if (this._delay) {
          this._timeout = setTimeout(start, this._delay);
        } else {
          start();
        }
      }
    }, {
      key: "onUpdate",
      value: function onUpdate() {
        var now = Date.now();

        if (now >= this._startTime + this._duration) {
          if (this._duration === 0) {
            this._onUpdate(this._toValue);
          } else {
            this._onUpdate(this._fromValue + this._easing(1) * (this._toValue - this._fromValue));
          }

          this.__debouncedOnEnd({
            finished: true
          });

          return;
        }

        this._onUpdate(this._fromValue + this._easing((now - this._startTime) / this._duration) * (this._toValue - this._fromValue));

        if (this.__active) {
          this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
        }
      }
    }, {
      key: "stop",
      value: function stop() {
        (0, _get2.default)((0, _getPrototypeOf2.default)(TimingAnimation.prototype), "stop", this).call(this);
        this.__active = false;
        clearTimeout(this._timeout);
        global.cancelAnimationFrame(this._animationFrame);

        this.__debouncedOnEnd({
          finished: false
        });
      }
    }]);
    return TimingAnimation;
  }(_$$_REQUIRE(_dependencyMap[10]));

  module.exports = TimingAnimation;
},"node_modules/react-native/Libraries/Animated/animations/TimingAnimation.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedColor.js","node_modules/react-native/Libraries/Animated/Easing.js","node_modules/react-native/Libraries/Animated/NativeAnimatedHelper.js","node_modules/react-native/Libraries/Animated/animations/Animation.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _ease;

  var Easing = {
    step0: function step0(n) {
      return n > 0 ? 1 : 0;
    },
    step1: function step1(n) {
      return n >= 1 ? 1 : 0;
    },
    linear: function linear(t) {
      return t;
    },
    ease: function ease(t) {
      if (!_ease) {
        _ease = Easing.bezier(0.42, 0, 1, 1);
      }

      return _ease(t);
    },
    quad: function quad(t) {
      return t * t;
    },
    cubic: function cubic(t) {
      return t * t * t;
    },
    poly: function poly(n) {
      return function (t) {
        return Math.pow(t, n);
      };
    },
    sin: function sin(t) {
      return 1 - Math.cos(t * Math.PI / 2);
    },
    circle: function circle(t) {
      return 1 - Math.sqrt(1 - t * t);
    },
    exp: function exp(t) {
      return Math.pow(2, 10 * (t - 1));
    },
    elastic: function elastic() {
      var bounciness = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var p = bounciness * Math.PI;
      return function (t) {
        return 1 - Math.pow(Math.cos(t * Math.PI / 2), 3) * Math.cos(t * p);
      };
    },
    back: function back() {
      var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.70158;
      return function (t) {
        return t * t * ((s + 1) * t - s);
      };
    },
    bounce: function bounce(t) {
      if (t < 0.36363636363636365) {
        return 7.5625 * t * t;
      }

      if (t < 0.7272727272727273) {
        var _t = t - 0.5454545454545454;

        return 7.5625 * _t * _t + 0.75;
      }

      if (t < 0.9090909090909091) {
        var _t2 = t - 0.8181818181818182;

        return 7.5625 * _t2 * _t2 + 0.9375;
      }

      var t2 = t - 0.9545454545454546;
      return 7.5625 * t2 * t2 + 0.984375;
    },
    bezier: function bezier(x1, y1, x2, y2) {
      var _bezier = _$$_REQUIRE(_dependencyMap[0]);

      return _bezier(x1, y1, x2, y2);
    },
    in: function _in(easing) {
      return easing;
    },
    out: function out(easing) {
      return function (t) {
        return 1 - easing(1 - t);
      };
    },
    inOut: function inOut(easing) {
      return function (t) {
        if (t < 0.5) {
          return easing(t * 2) / 2;
        }

        return 1 - easing((1 - t) * 2) / 2;
      };
    }
  };
  module.exports = Easing;
},"node_modules/react-native/Libraries/Animated/Easing.js",["node_modules/react-native/Libraries/Animated/bezier.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 0.001;
  var SUBDIVISION_PRECISION = 0.0000001;
  var SUBDIVISION_MAX_ITERATIONS = 10;
  var kSplineTableSize = 11;
  var kSampleStepSize = 0.1;
  var float32ArraySupported = typeof Float32Array === 'function';

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  }

  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function binarySubdivide(aX, _aA, _aB, mX1, mX2) {
    var currentX,
        currentT,
        i = 0,
        aA = _aA,
        aB = _aB;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

    return currentT;
  }

  function newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {
    var aGuessT = _aGuessT;

    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  module.exports = function bezier(mX1, mY1, mX2, mY2) {
    if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {
      throw new Error('bezier x values must be in [0, 1] range');
    }

    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {
      var intervalStart = 0.0;
      var currentSample = 1;
      var lastSample = 10;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;
      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= NEWTON_MIN_SLOPE) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }

    return function BezierEasing(x) {
      if (mX1 === mY1 && mX2 === mY2) {
        return x;
      }

      if (x === 0) {
        return 0;
      }

      if (x === 1) {
        return 1;
      }

      return calcBezier(getTForX(x), mY1, mY2);
    };
  };
},"node_modules/react-native/Libraries/Animated/bezier.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var DecayAnimation = function (_Animation) {
    _$$_REQUIRE(_dependencyMap[2])(DecayAnimation, _Animation);

    var _super = _createSuper(DecayAnimation);

    function DecayAnimation(config) {
      var _config$deceleration, _config$isInteraction, _config$iterations;

      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, DecayAnimation);

      _this = _super.call(this);
      _this._deceleration = (_config$deceleration = config.deceleration) != null ? _config$deceleration : 0.998;
      _this._velocity = config.velocity;
      _this._useNativeDriver = _$$_REQUIRE(_dependencyMap[4]).shouldUseNativeDriver(config);
      _this._platformConfig = config.platformConfig;
      _this.__isInteraction = (_config$isInteraction = config.isInteraction) != null ? _config$isInteraction : !_this._useNativeDriver;
      _this.__iterations = (_config$iterations = config.iterations) != null ? _config$iterations : 1;
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[5])(DecayAnimation, [{
      key: "__getNativeAnimationConfig",
      value: function __getNativeAnimationConfig() {
        return {
          type: 'decay',
          deceleration: this._deceleration,
          velocity: this._velocity,
          iterations: this.__iterations,
          platformConfig: this._platformConfig
        };
      }
    }, {
      key: "start",
      value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
        this.__active = true;
        this._lastValue = fromValue;
        this._fromValue = fromValue;
        this._onUpdate = onUpdate;
        this.__onEnd = onEnd;
        this._startTime = Date.now();

        if (this._useNativeDriver) {
          this.__startNativeAnimation(animatedValue);
        } else {
          this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
        }
      }
    }, {
      key: "onUpdate",
      value: function onUpdate() {
        var now = Date.now();
        var value = this._fromValue + this._velocity / (1 - this._deceleration) * (1 - Math.exp(-(1 - this._deceleration) * (now - this._startTime)));

        this._onUpdate(value);

        if (Math.abs(this._lastValue - value) < 0.1) {
          this.__debouncedOnEnd({
            finished: true
          });

          return;
        }

        this._lastValue = value;

        if (this.__active) {
          this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
        }
      }
    }, {
      key: "stop",
      value: function stop() {
        _$$_REQUIRE(_dependencyMap[6])(_$$_REQUIRE(_dependencyMap[0])(DecayAnimation.prototype), "stop", this).call(this);

        this.__active = false;
        global.cancelAnimationFrame(this._animationFrame);

        this.__debouncedOnEnd({
          finished: false
        });
      }
    }]);

    return DecayAnimation;
  }(_$$_REQUIRE(_dependencyMap[7]));

  module.exports = DecayAnimation;
},"node_modules/react-native/Libraries/Animated/animations/DecayAnimation.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/react-native/Libraries/Animated/NativeAnimatedHelper.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/react-native/Libraries/Animated/animations/Animation.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function attachNativeEvent(viewRef, eventName, argMapping, platformConfig) {
    var eventMappings = [];

    var traverse = function traverse(value, path) {
      if (value instanceof _$$_REQUIRE(_dependencyMap[0])) {
        value.__makeNative(platformConfig);

        eventMappings.push({
          nativeEventPath: path,
          animatedValueTag: value.__getNativeTag()
        });
      } else if (value instanceof _$$_REQUIRE(_dependencyMap[1])) {
        traverse(value.x, path.concat('x'));
        traverse(value.y, path.concat('y'));
      } else if (typeof value === 'object') {
        for (var _key in value) {
          traverse(value[_key], path.concat(_key));
        }
      }
    };

    _$$_REQUIRE(_dependencyMap[2])(argMapping[0] && argMapping[0].nativeEvent, 'Native driven events only support animated values contained inside `nativeEvent`.');

    traverse(argMapping[0].nativeEvent, []);

    var viewTag = _$$_REQUIRE(_dependencyMap[3]).findNodeHandle(viewRef);

    if (viewTag != null) {
      eventMappings.forEach(function (mapping) {
        _$$_REQUIRE(_dependencyMap[4]).API.addAnimatedEventToView(viewTag, eventName, mapping);
      });
    }

    return {
      detach: function detach() {
        if (viewTag != null) {
          eventMappings.forEach(function (mapping) {
            _$$_REQUIRE(_dependencyMap[4]).API.removeAnimatedEventFromView(viewTag, eventName, mapping.animatedValueTag);
          });
        }
      }
    };
  }

  var AnimatedEvent = function () {
    function AnimatedEvent(argMapping, config) {
      var _this = this;

      _$$_REQUIRE(_dependencyMap[5])(this, AnimatedEvent);

      this._listeners = [];

      this._callListeners = function () {
        for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
          args[_key2] = arguments[_key2];
        }

        _this._listeners.forEach(function (listener) {
          return listener.apply(undefined, args);
        });
      };

      this._argMapping = argMapping;

      if (config == null) {
        console.warn('Animated.event now requires a second argument for options');
        config = {
          useNativeDriver: false
        };
      }

      if (config.listener) {
        this.__addListener(config.listener);
      }

      this._attachedEvent = null;
      this.__isNative = _$$_REQUIRE(_dependencyMap[4]).shouldUseNativeDriver(config);
      this.__platformConfig = config.platformConfig;
    }

    _$$_REQUIRE(_dependencyMap[6])(AnimatedEvent, [{
      key: "__addListener",
      value: function __addListener(callback) {
        this._listeners.push(callback);
      }
    }, {
      key: "__removeListener",
      value: function __removeListener(callback) {
        this._listeners = this._listeners.filter(function (listener) {
          return listener !== callback;
        });
      }
    }, {
      key: "__attach",
      value: function __attach(viewRef, eventName) {
        _$$_REQUIRE(_dependencyMap[2])(this.__isNative, 'Only native driven events need to be attached.');

        this._attachedEvent = attachNativeEvent(viewRef, eventName, this._argMapping, this.__platformConfig);
      }
    }, {
      key: "__detach",
      value: function __detach(viewTag, eventName) {
        _$$_REQUIRE(_dependencyMap[2])(this.__isNative, 'Only native driven events need to be detached.');

        this._attachedEvent && this._attachedEvent.detach();
      }
    }, {
      key: "__getHandler",
      value: function __getHandler() {
        var _this2 = this;

        if (this.__isNative) {
          {
            return this._callListeners;
          }
        }

        var validatedMapping = false;
        return function () {
          for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
            args[_key4] = arguments[_key4];
          }

          var traverse = function traverse(recMapping, recEvt) {
            if (recMapping instanceof _$$_REQUIRE(_dependencyMap[0])) {
              if (typeof recEvt === 'number') {
                recMapping.setValue(recEvt);
              }
            } else if (recMapping instanceof _$$_REQUIRE(_dependencyMap[1])) {
              if (typeof recEvt === 'object') {
                traverse(recMapping.x, recEvt.x);
                traverse(recMapping.y, recEvt.y);
              }
            } else if (typeof recMapping === 'object') {
              for (var mappingKey in recMapping) {
                traverse(recMapping[mappingKey], recEvt[mappingKey]);
              }
            }
          };

          _this2._argMapping.forEach(function (mapping, idx) {
            traverse(mapping, args[idx]);
          });

          _this2._callListeners.apply(_this2, args);
        };
      }
    }]);

    return AnimatedEvent;
  }();

  module.exports = {
    AnimatedEvent: AnimatedEvent,
    attachNativeEvent: attachNativeEvent
  };
},"node_modules/react-native/Libraries/Animated/AnimatedEvent.js",["node_modules/react-native/Libraries/Animated/nodes/AnimatedValue.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedValueXY.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/Renderer/shims/ReactNative.js","node_modules/react-native/Libraries/Animated/NativeAnimatedHelper.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var createAnimatedComponentInjection = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[8]));

  var _createAnimatedCompon;

  var _excluded = ["style"],
      _excluded2 = ["style"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var React = _$$_REQUIRE(_dependencyMap[9]);

  var animatedComponentNextId = 1;

  function createAnimatedComponent(Component) {
    _$$_REQUIRE(_dependencyMap[10])(typeof Component !== 'function' || Component.prototype && Component.prototype.isReactComponent, "`createAnimatedComponent` does not support stateless functional components; use a class component instead.");

    var AnimatedComponent = function (_React$Component) {
      (0, _inherits2.default)(AnimatedComponent, _React$Component);

      var _super = _createSuper(AnimatedComponent);

      function AnimatedComponent() {
        var _this;

        (0, _classCallCheck2.default)(this, AnimatedComponent);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _super.call.apply(_super, [this].concat(args));
        _this._invokeAnimatedPropsCallbackOnMount = false;
        _this._eventDetachers = [];
        _this._animatedComponentId = animatedComponentNextId++ + ":animatedComponent";

        _this._isFabric = function () {
          var _this$_component$_int, _this$_component$_int2, _this$_component$getN, _this$_component$getN2, _this$_component$getS, _this$_component$getS2;

          if (_this._component == null) {
            return false;
          }

          return ((_this$_component$_int = _this._component['_internalInstanceHandle']) == null ? undefined : (_this$_component$_int2 = _this$_component$_int.stateNode) == null ? undefined : _this$_component$_int2.canonical) != null || _this._component.getNativeScrollRef != null && _this._component.getNativeScrollRef() != null && ((_this$_component$getN = _this._component.getNativeScrollRef()['_internalInstanceHandle']) == null ? undefined : (_this$_component$getN2 = _this$_component$getN.stateNode) == null ? undefined : _this$_component$getN2.canonical) != null || _this._component.getScrollResponder != null && _this._component.getScrollResponder() != null && _this._component.getScrollResponder().getNativeScrollRef != null && _this._component.getScrollResponder().getNativeScrollRef() != null && ((_this$_component$getS = _this._component.getScrollResponder().getNativeScrollRef()['_internalInstanceHandle']) == null ? undefined : (_this$_component$getS2 = _this$_component$getS.stateNode) == null ? undefined : _this$_component$getS2.canonical) != null;
        };

        _this._waitForUpdate = function () {
          if (_this._isFabric()) {
            _$$_REQUIRE(_dependencyMap[11]).API.setWaitingForIdentifier(_this._animatedComponentId);
          }
        };

        _this._markUpdateComplete = function () {
          if (_this._isFabric()) {
            _$$_REQUIRE(_dependencyMap[11]).API.unsetWaitingForIdentifier(_this._animatedComponentId);
          }
        };

        _this._animatedPropsCallback = function () {
          if (_this._component == null) {
            _this._invokeAnimatedPropsCallbackOnMount = true;
          } else if (typeof _this._component.setNativeProps !== 'function' || _this._isFabric()) {
            _this.forceUpdate();
          } else if (!_this._propsAnimated.__isNative) {
            _this._component.setNativeProps(_this._propsAnimated.__getAnimatedValue());
          } else {
            throw new Error("Attempting to run JS driven animation on animated node that has been moved to \"native\" earlier by starting an animation with `useNativeDriver: true`");
          }
        };

        _this._setComponentRef = _$$_REQUIRE(_dependencyMap[12])({
          getForwardedRef: function getForwardedRef() {
            return _this.props.forwardedRef;
          },
          setLocalRef: function setLocalRef(ref) {
            _this._prevComponent = _this._component;
            _this._component = ref;
          }
        });
        return _this;
      }

      (0, _createClass2.default)(AnimatedComponent, [{
        key: "_attachNativeEvents",
        value: function _attachNativeEvents() {
          var _this$_component,
              _this2 = this;

          var scrollableNode = (_this$_component = this._component) != null && _this$_component.getScrollableNode ? this._component.getScrollableNode() : this._component;

          var _loop = function _loop(key) {
            var prop = _this2.props[key];

            if (prop instanceof _$$_REQUIRE(_dependencyMap[13]).AnimatedEvent && prop.__isNative) {
              prop.__attach(scrollableNode, key);

              _this2._eventDetachers.push(function () {
                return prop.__detach(scrollableNode, key);
              });
            }
          };

          for (var key in this.props) {
            _loop(key);
          }
        }
      }, {
        key: "_detachNativeEvents",
        value: function _detachNativeEvents() {
          this._eventDetachers.forEach(function (remove) {
            return remove();
          });

          this._eventDetachers = [];
        }
      }, {
        key: "_attachProps",
        value: function _attachProps(nextProps) {
          var oldPropsAnimated = this._propsAnimated;
          this._propsAnimated = new (_$$_REQUIRE(_dependencyMap[14]))(nextProps, this._animatedPropsCallback);

          this._propsAnimated.__attach();

          if (oldPropsAnimated) {
            oldPropsAnimated.__restoreDefaultValues();

            oldPropsAnimated.__detach();
          }
        }
      }, {
        key: "render",
        value: function render() {
          var _ref = this._propsAnimated.__getValue() || {},
              _ref$style = _ref.style,
              style = _ref$style === undefined ? {} : _ref$style,
              props = (0, _objectWithoutProperties2.default)(_ref, _excluded);

          var _ref2 = this.props.passthroughAnimatedPropExplicitValues || {},
              _ref2$style = _ref2.style,
              passthruStyle = _ref2$style === undefined ? {} : _ref2$style,
              passthruProps = (0, _objectWithoutProperties2.default)(_ref2, _excluded2);

          var mergedStyle = (0, _extends2.default)({}, style, passthruStyle);
          return React.createElement(Component, (0, _extends2.default)({}, props, passthruProps, {
            collapsable: false,
            style: mergedStyle,
            ref: this._setComponentRef
          }));
        }
      }, {
        key: "UNSAFE_componentWillMount",
        value: function UNSAFE_componentWillMount() {
          this._waitForUpdate();

          this._attachProps(this.props);
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          if (this._invokeAnimatedPropsCallbackOnMount) {
            this._invokeAnimatedPropsCallbackOnMount = false;

            this._animatedPropsCallback();
          }

          this._propsAnimated.setNativeView(this._component);

          this._attachNativeEvents();

          this._markUpdateComplete();
        }
      }, {
        key: "UNSAFE_componentWillReceiveProps",
        value: function UNSAFE_componentWillReceiveProps(newProps) {
          this._waitForUpdate();

          this._attachProps(newProps);
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          if (this._component !== this._prevComponent) {
            this._propsAnimated.setNativeView(this._component);
          }

          if (this._component !== this._prevComponent || prevProps !== this.props) {
            this._detachNativeEvents();

            this._attachNativeEvents();
          }

          this._markUpdateComplete();
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this._propsAnimated && this._propsAnimated.__detach();

          this._detachNativeEvents();

          this._markUpdateComplete();

          this._component = null;
          this._prevComponent = null;
        }
      }]);
      return AnimatedComponent;
    }(React.Component);

    return React.forwardRef(function AnimatedComponentWrapper(props, ref) {
      return React.createElement(AnimatedComponent, (0, _extends2.default)({}, props, ref == null ? null : {
        forwardedRef: ref
      }));
    });
  }

  module.exports = (_createAnimatedCompon = createAnimatedComponentInjection.recordAndRetrieve()) != null ? _createAnimatedCompon : createAnimatedComponent;
},"node_modules/react-native/Libraries/Animated/createAnimatedComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Animated/createAnimatedComponentInjection.js","node_modules/react/index.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/Animated/NativeAnimatedHelper.js","node_modules/react-native/Libraries/Utilities/setAndForwardRef.js","node_modules/react-native/Libraries/Animated/AnimatedEvent.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedProps.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.inject = inject;
  exports.recordAndRetrieve = recordAndRetrieve;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var injected;

  function inject(newInjected) {
    if (injected !== undefined) {
      return;
    }

    injected = newInjected;
  }

  function recordAndRetrieve() {
    if (injected === undefined) {
      injected = null;
    }

    return injected;
  }
},"node_modules/react-native/Libraries/Animated/createAnimatedComponentInjection.js",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function setAndForwardRef(_ref) {
    var getForwardedRef = _ref.getForwardedRef,
        setLocalRef = _ref.setLocalRef;
    return function forwardRef(ref) {
      var forwardedRef = getForwardedRef();
      setLocalRef(ref);

      if (typeof forwardedRef === 'function') {
        forwardedRef(ref);
      } else if (typeof forwardedRef === 'object' && forwardedRef != null) {
        forwardedRef.current = ref;
      }
    };
  }

  module.exports = setAndForwardRef;
},"node_modules/react-native/Libraries/Utilities/setAndForwardRef.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AnimatedProps = function (_AnimatedNode) {
    _$$_REQUIRE(_dependencyMap[2])(AnimatedProps, _AnimatedNode);

    var _super = _createSuper(AnimatedProps);

    function AnimatedProps(props, callback) {
      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, AnimatedProps);

      _this = _super.call(this);

      if (props.style) {
        props = _$$_REQUIRE(_dependencyMap[4])({}, props, {
          style: new (_$$_REQUIRE(_dependencyMap[5]))(props.style)
        });
      }

      _this._props = props;
      _this._callback = callback;
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[6])(AnimatedProps, [{
      key: "__getValue",
      value: function __getValue() {
        var props = {};

        for (var key in this._props) {
          var value = this._props[key];

          if (value instanceof _$$_REQUIRE(_dependencyMap[7])) {
            if (!value.__isNative || value instanceof _$$_REQUIRE(_dependencyMap[5])) {
              props[key] = value.__getValue();
            }
          } else if (value instanceof _$$_REQUIRE(_dependencyMap[8]).AnimatedEvent) {
            props[key] = value.__getHandler();
          } else {
            props[key] = value;
          }
        }

        return props;
      }
    }, {
      key: "__getAnimatedValue",
      value: function __getAnimatedValue() {
        var props = {};

        for (var key in this._props) {
          var value = this._props[key];

          if (value instanceof _$$_REQUIRE(_dependencyMap[7])) {
            props[key] = value.__getAnimatedValue();
          }
        }

        return props;
      }
    }, {
      key: "__attach",
      value: function __attach() {
        for (var key in this._props) {
          var value = this._props[key];

          if (value instanceof _$$_REQUIRE(_dependencyMap[7])) {
            value.__addChild(this);
          }
        }
      }
    }, {
      key: "__detach",
      value: function __detach() {
        if (this.__isNative && this._animatedView) {
          this.__disconnectAnimatedView();
        }

        for (var key in this._props) {
          var value = this._props[key];

          if (value instanceof _$$_REQUIRE(_dependencyMap[7])) {
            value.__removeChild(this);
          }
        }

        _$$_REQUIRE(_dependencyMap[9])(_$$_REQUIRE(_dependencyMap[0])(AnimatedProps.prototype), "__detach", this).call(this);
      }
    }, {
      key: "update",
      value: function update() {
        this._callback();
      }
    }, {
      key: "__makeNative",
      value: function __makeNative(platformConfig) {
        if (!this.__isNative) {
          this.__isNative = true;

          for (var key in this._props) {
            var value = this._props[key];

            if (value instanceof _$$_REQUIRE(_dependencyMap[7])) {
              value.__makeNative(platformConfig);
            }
          }

          _$$_REQUIRE(_dependencyMap[9])(_$$_REQUIRE(_dependencyMap[0])(AnimatedProps.prototype), "__setPlatformConfig", this).call(this, platformConfig);

          if (this._animatedView) {
            this.__connectAnimatedView();
          }
        }
      }
    }, {
      key: "setNativeView",
      value: function setNativeView(animatedView) {
        if (this._animatedView === animatedView) {
          return;
        }

        this._animatedView = animatedView;

        if (this.__isNative) {
          this.__connectAnimatedView();
        }
      }
    }, {
      key: "__connectAnimatedView",
      value: function __connectAnimatedView() {
        _$$_REQUIRE(_dependencyMap[10])(this.__isNative, 'Expected node to be marked as "native"');

        var nativeViewTag = _$$_REQUIRE(_dependencyMap[11]).findNodeHandle(this._animatedView);

        _$$_REQUIRE(_dependencyMap[10])(nativeViewTag != null, 'Unable to locate attached view in the native tree');

        _$$_REQUIRE(_dependencyMap[12]).API.connectAnimatedNodeToView(this.__getNativeTag(), nativeViewTag);
      }
    }, {
      key: "__disconnectAnimatedView",
      value: function __disconnectAnimatedView() {
        _$$_REQUIRE(_dependencyMap[10])(this.__isNative, 'Expected node to be marked as "native"');

        var nativeViewTag = _$$_REQUIRE(_dependencyMap[11]).findNodeHandle(this._animatedView);

        _$$_REQUIRE(_dependencyMap[10])(nativeViewTag != null, 'Unable to locate attached view in the native tree');

        _$$_REQUIRE(_dependencyMap[12]).API.disconnectAnimatedNodeFromView(this.__getNativeTag(), nativeViewTag);
      }
    }, {
      key: "__restoreDefaultValues",
      value: function __restoreDefaultValues() {
        if (this.__isNative) {
          _$$_REQUIRE(_dependencyMap[12]).API.restoreDefaultValues(this.__getNativeTag());
        }
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        var propsConfig = {};

        for (var propKey in this._props) {
          var value = this._props[propKey];

          if (value instanceof _$$_REQUIRE(_dependencyMap[7])) {
            value.__makeNative(this.__getPlatformConfig());

            propsConfig[propKey] = value.__getNativeTag();
          }
        }

        return {
          type: 'props',
          props: propsConfig
        };
      }
    }]);

    return AnimatedProps;
  }(_$$_REQUIRE(_dependencyMap[7]));

  module.exports = AnimatedProps;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedProps.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedStyle.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedNode.js","node_modules/react-native/Libraries/Animated/AnimatedEvent.js","node_modules/@babel/runtime/helpers/get.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/Renderer/shims/ReactNative.js","node_modules/react-native/Libraries/Animated/NativeAnimatedHelper.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AnimatedStyle = function (_AnimatedWithChildren) {
    _$$_REQUIRE(_dependencyMap[2])(AnimatedStyle, _AnimatedWithChildren);

    var _super = _createSuper(AnimatedStyle);

    function AnimatedStyle(style) {
      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, AnimatedStyle);

      _this = _super.call(this);
      style = _$$_REQUIRE(_dependencyMap[4])(style) || {};

      if (style.transform) {
        style = _$$_REQUIRE(_dependencyMap[5])({}, style, {
          transform: new (_$$_REQUIRE(_dependencyMap[6]))(style.transform)
        });
      }

      _this._style = style;
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[7])(AnimatedStyle, [{
      key: "_walkStyleAndGetValues",
      value: function _walkStyleAndGetValues(style) {
        var updatedStyle = {};

        for (var key in style) {
          var value = style[key];

          if (value instanceof _$$_REQUIRE(_dependencyMap[8])) {
            if (!value.__isNative) {
              updatedStyle[key] = value.__getValue();
            }
          } else if (value && !Array.isArray(value) && typeof value === 'object') {
            updatedStyle[key] = this._walkStyleAndGetValues(value);
          } else {
            updatedStyle[key] = value;
          }
        }

        return updatedStyle;
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._walkStyleAndGetValues(this._style);
      }
    }, {
      key: "_walkStyleAndGetAnimatedValues",
      value: function _walkStyleAndGetAnimatedValues(style) {
        var updatedStyle = {};

        for (var key in style) {
          var value = style[key];

          if (value instanceof _$$_REQUIRE(_dependencyMap[8])) {
            updatedStyle[key] = value.__getAnimatedValue();
          } else if (value && !Array.isArray(value) && typeof value === 'object') {
            updatedStyle[key] = this._walkStyleAndGetAnimatedValues(value);
          }
        }

        return updatedStyle;
      }
    }, {
      key: "__getAnimatedValue",
      value: function __getAnimatedValue() {
        return this._walkStyleAndGetAnimatedValues(this._style);
      }
    }, {
      key: "__attach",
      value: function __attach() {
        for (var key in this._style) {
          var value = this._style[key];

          if (value instanceof _$$_REQUIRE(_dependencyMap[8])) {
            value.__addChild(this);
          }
        }
      }
    }, {
      key: "__detach",
      value: function __detach() {
        for (var key in this._style) {
          var value = this._style[key];

          if (value instanceof _$$_REQUIRE(_dependencyMap[8])) {
            value.__removeChild(this);
          }
        }

        _$$_REQUIRE(_dependencyMap[9])(_$$_REQUIRE(_dependencyMap[0])(AnimatedStyle.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__makeNative",
      value: function __makeNative(platformConfig) {
        for (var key in this._style) {
          var value = this._style[key];

          if (value instanceof _$$_REQUIRE(_dependencyMap[8])) {
            value.__makeNative(platformConfig);
          }
        }

        _$$_REQUIRE(_dependencyMap[9])(_$$_REQUIRE(_dependencyMap[0])(AnimatedStyle.prototype), "__makeNative", this).call(this, platformConfig);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        var styleConfig = {};

        for (var styleKey in this._style) {
          if (this._style[styleKey] instanceof _$$_REQUIRE(_dependencyMap[8])) {
            var style = this._style[styleKey];

            style.__makeNative(this.__getPlatformConfig());

            styleConfig[styleKey] = style.__getNativeTag();
          }
        }

        _$$_REQUIRE(_dependencyMap[10]).validateStyles(styleConfig);

        return {
          type: 'style',
          style: styleConfig
        };
      }
    }]);

    return AnimatedStyle;
  }(_$$_REQUIRE(_dependencyMap[11]));

  module.exports = AnimatedStyle;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedStyle.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/react-native/Libraries/StyleSheet/flattenStyle.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedTransform.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedNode.js","node_modules/@babel/runtime/helpers/get.js","node_modules/react-native/Libraries/Animated/NativeAnimatedHelper.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AnimatedTransform = function (_AnimatedWithChildren) {
    _$$_REQUIRE(_dependencyMap[2])(AnimatedTransform, _AnimatedWithChildren);

    var _super = _createSuper(AnimatedTransform);

    function AnimatedTransform(transforms) {
      var _this;

      _$$_REQUIRE(_dependencyMap[3])(this, AnimatedTransform);

      _this = _super.call(this);
      _this._transforms = transforms;
      return _this;
    }

    _$$_REQUIRE(_dependencyMap[4])(AnimatedTransform, [{
      key: "__makeNative",
      value: function __makeNative(platformConfig) {
        this._transforms.forEach(function (transform) {
          for (var key in transform) {
            var value = transform[key];

            if (value instanceof _$$_REQUIRE(_dependencyMap[5])) {
              value.__makeNative(platformConfig);
            }
          }
        });

        _$$_REQUIRE(_dependencyMap[6])(_$$_REQUIRE(_dependencyMap[0])(AnimatedTransform.prototype), "__makeNative", this).call(this, platformConfig);
      }
    }, {
      key: "__getValue",
      value: function __getValue() {
        return this._transforms.map(function (transform) {
          var result = {};

          for (var key in transform) {
            var value = transform[key];

            if (value instanceof _$$_REQUIRE(_dependencyMap[5])) {
              result[key] = value.__getValue();
            } else {
              result[key] = value;
            }
          }

          return result;
        });
      }
    }, {
      key: "__getAnimatedValue",
      value: function __getAnimatedValue() {
        return this._transforms.map(function (transform) {
          var result = {};

          for (var key in transform) {
            var value = transform[key];

            if (value instanceof _$$_REQUIRE(_dependencyMap[5])) {
              result[key] = value.__getAnimatedValue();
            } else {
              result[key] = value;
            }
          }

          return result;
        });
      }
    }, {
      key: "__attach",
      value: function __attach() {
        var _this2 = this;

        this._transforms.forEach(function (transform) {
          for (var key in transform) {
            var value = transform[key];

            if (value instanceof _$$_REQUIRE(_dependencyMap[5])) {
              value.__addChild(_this2);
            }
          }
        });
      }
    }, {
      key: "__detach",
      value: function __detach() {
        var _this3 = this;

        this._transforms.forEach(function (transform) {
          for (var key in transform) {
            var value = transform[key];

            if (value instanceof _$$_REQUIRE(_dependencyMap[5])) {
              value.__removeChild(_this3);
            }
          }
        });

        _$$_REQUIRE(_dependencyMap[6])(_$$_REQUIRE(_dependencyMap[0])(AnimatedTransform.prototype), "__detach", this).call(this);
      }
    }, {
      key: "__getNativeConfig",
      value: function __getNativeConfig() {
        var transConfigs = [];

        this._transforms.forEach(function (transform) {
          for (var key in transform) {
            var value = transform[key];

            if (value instanceof _$$_REQUIRE(_dependencyMap[5])) {
              transConfigs.push({
                type: 'animated',
                property: key,
                nodeTag: value.__getNativeTag()
              });
            } else {
              transConfigs.push({
                type: 'static',
                property: key,
                value: _$$_REQUIRE(_dependencyMap[7]).transformDataType(value)
              });
            }
          }
        });

        _$$_REQUIRE(_dependencyMap[7]).validateTransform(transConfigs);

        return {
          type: 'transform',
          transforms: transConfigs
        };
      }
    }]);

    return AnimatedTransform;
  }(_$$_REQUIRE(_dependencyMap[8]));

  module.exports = AnimatedTransform;
},"node_modules/react-native/Libraries/Animated/nodes/AnimatedTransform.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedNode.js","node_modules/@babel/runtime/helpers/get.js","node_modules/react-native/Libraries/Animated/NativeAnimatedHelper.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedWithChildren.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var FlatListWithEventThrottle = React.forwardRef(function (props, ref) {
    return React.createElement(_$$_REQUIRE(_dependencyMap[3]), (0, _extends2.default)({
      scrollEventThrottle: 0.0001
    }, props, {
      ref: ref
    }));
  });
  module.exports = _$$_REQUIRE(_dependencyMap[4])(FlatListWithEventThrottle);
},"node_modules/react-native/Libraries/Animated/components/AnimatedFlatList.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/react-native/Libraries/Lists/FlatList.js","node_modules/react-native/Libraries/Animated/createAnimatedComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _defineProperty2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _excluded = ["numColumns", "columnWrapperStyle", "removeClippedSubviews"];

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var React = _$$_REQUIRE(_dependencyMap[9]);

  function removeClippedSubviewsOrDefault(removeClippedSubviews) {
    return removeClippedSubviews != null ? removeClippedSubviews : false;
  }

  function numColumnsOrDefault(numColumns) {
    return numColumns != null ? numColumns : 1;
  }

  var FlatList = function (_React$PureComponent) {
    (0, _inherits2.default)(FlatList, _React$PureComponent);

    var _super = _createSuper(FlatList);

    function FlatList(_props) {
      var _this;

      (0, _classCallCheck2.default)(this, FlatList);
      _this = _super.call(this, _props);
      _this._virtualizedListPairs = [];

      _this._captureRef = function (ref) {
        _this._listRef = ref;
      };

      _this._getItem = function (data, index) {
        var numColumns = numColumnsOrDefault(_this.props.numColumns);

        if (numColumns > 1) {
          var ret = [];

          for (var kk = 0; kk < numColumns; kk++) {
            var _item = data[index * numColumns + kk];

            if (_item != null) {
              ret.push(_item);
            }
          }

          return ret;
        } else {
          return data[index];
        }
      };

      _this._getItemCount = function (data) {
        if (data) {
          var numColumns = numColumnsOrDefault(_this.props.numColumns);
          return numColumns > 1 ? Math.ceil(data.length / numColumns) : data.length;
        } else {
          return 0;
        }
      };

      _this._keyExtractor = function (items, index) {
        var _this$props$keyExtrac;

        var numColumns = numColumnsOrDefault(_this.props.numColumns);
        var keyExtractor = (_this$props$keyExtrac = _this.props.keyExtractor) != null ? _this$props$keyExtrac : _$$_REQUIRE(_dependencyMap[10]).keyExtractor;

        if (numColumns > 1) {
          if (Array.isArray(items)) {
            return items.map(function (item, kk) {
              return keyExtractor(item, index * numColumns + kk);
            }).join(':');
          } else {
            _$$_REQUIRE(_dependencyMap[11])(Array.isArray(items), "FlatList: Encountered internal consistency error, expected each item to consist of an array with 1-%s columns; instead, received a single item.", numColumns);
          }
        } else {
          return keyExtractor(items, index);
        }
      };

      _this._renderer = function () {
        var _this$props = _this.props,
            ListItemComponent = _this$props.ListItemComponent,
            renderItem = _this$props.renderItem,
            columnWrapperStyle = _this$props.columnWrapperStyle;
        var numColumns = numColumnsOrDefault(_this.props.numColumns);
        var virtualizedListRenderKey = ListItemComponent ? 'ListItemComponent' : 'renderItem';

        var renderer = function renderer(props) {
          if (ListItemComponent) {
            return React.createElement(ListItemComponent, props);
          } else if (renderItem) {
            return renderItem(props);
          } else {
            return null;
          }
        };

        return (0, _defineProperty2.default)({}, virtualizedListRenderKey, function (info) {
          if (numColumns > 1) {
            var _item2 = info.item,
                _index = info.index;

            _$$_REQUIRE(_dependencyMap[11])(Array.isArray(_item2), 'Expected array of items with numColumns > 1');

            return React.createElement(_$$_REQUIRE(_dependencyMap[12]), {
              style: _$$_REQUIRE(_dependencyMap[13]).compose(styles.row, columnWrapperStyle)
            }, _item2.map(function (it, kk) {
              var element = renderer({
                item: it,
                index: _index * numColumns + kk,
                separators: info.separators
              });
              return element != null ? React.createElement(React.Fragment, {
                key: kk
              }, element) : null;
            }));
          } else {
            return renderer(info);
          }
        });
      };

      _this._checkProps(_this.props);

      if (_this.props.viewabilityConfigCallbackPairs) {
        _this._virtualizedListPairs = _this.props.viewabilityConfigCallbackPairs.map(function (pair) {
          return {
            viewabilityConfig: pair.viewabilityConfig,
            onViewableItemsChanged: _this._createOnViewableItemsChanged(pair.onViewableItemsChanged)
          };
        });
      } else if (_this.props.onViewableItemsChanged) {
        _this._virtualizedListPairs.push({
          viewabilityConfig: _this.props.viewabilityConfig,
          onViewableItemsChanged: _this._createOnViewableItemsChanged(_this.props.onViewableItemsChanged)
        });
      }

      return _this;
    }

    (0, _createClass2.default)(FlatList, [{
      key: "scrollToEnd",
      value: function scrollToEnd(params) {
        if (this._listRef) {
          this._listRef.scrollToEnd(params);
        }
      }
    }, {
      key: "scrollToIndex",
      value: function scrollToIndex(params) {
        if (this._listRef) {
          this._listRef.scrollToIndex(params);
        }
      }
    }, {
      key: "scrollToItem",
      value: function scrollToItem(params) {
        if (this._listRef) {
          this._listRef.scrollToItem(params);
        }
      }
    }, {
      key: "scrollToOffset",
      value: function scrollToOffset(params) {
        if (this._listRef) {
          this._listRef.scrollToOffset(params);
        }
      }
    }, {
      key: "recordInteraction",
      value: function recordInteraction() {
        if (this._listRef) {
          this._listRef.recordInteraction();
        }
      }
    }, {
      key: "flashScrollIndicators",
      value: function flashScrollIndicators() {
        if (this._listRef) {
          this._listRef.flashScrollIndicators();
        }
      }
    }, {
      key: "getScrollResponder",
      value: function getScrollResponder() {
        if (this._listRef) {
          return this._listRef.getScrollResponder();
        }
      }
    }, {
      key: "getNativeScrollRef",
      value: function getNativeScrollRef() {
        if (this._listRef) {
          return this._listRef.getScrollRef();
        }
      }
    }, {
      key: "getScrollableNode",
      value: function getScrollableNode() {
        if (this._listRef) {
          return this._listRef.getScrollableNode();
        }
      }
    }, {
      key: "setNativeProps",
      value: function setNativeProps(props) {
        if (this._listRef) {
          this._listRef.setNativeProps(props);
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        _$$_REQUIRE(_dependencyMap[11])(prevProps.numColumns === this.props.numColumns, "Changing numColumns on the fly is not supported. Change the key prop on FlatList when changing the number of columns to force a fresh render of the component.");

        _$$_REQUIRE(_dependencyMap[11])(prevProps.onViewableItemsChanged === this.props.onViewableItemsChanged, 'Changing onViewableItemsChanged on the fly is not supported');

        _$$_REQUIRE(_dependencyMap[11])(!_$$_REQUIRE(_dependencyMap[14])(prevProps.viewabilityConfig, this.props.viewabilityConfig), 'Changing viewabilityConfig on the fly is not supported');

        _$$_REQUIRE(_dependencyMap[11])(prevProps.viewabilityConfigCallbackPairs === this.props.viewabilityConfigCallbackPairs, 'Changing viewabilityConfigCallbackPairs on the fly is not supported');

        this._checkProps(this.props);
      }
    }, {
      key: "_checkProps",
      value: function _checkProps(props) {
        var getItem = props.getItem,
            getItemCount = props.getItemCount,
            horizontal = props.horizontal,
            columnWrapperStyle = props.columnWrapperStyle,
            onViewableItemsChanged = props.onViewableItemsChanged,
            viewabilityConfigCallbackPairs = props.viewabilityConfigCallbackPairs;
        var numColumns = numColumnsOrDefault(this.props.numColumns);

        _$$_REQUIRE(_dependencyMap[11])(!getItem && !getItemCount, 'FlatList does not support custom data formats.');

        if (numColumns > 1) {
          _$$_REQUIRE(_dependencyMap[11])(!horizontal, 'numColumns does not support horizontal.');
        } else {
          _$$_REQUIRE(_dependencyMap[11])(!columnWrapperStyle, 'columnWrapperStyle not supported for single column lists');
        }

        _$$_REQUIRE(_dependencyMap[11])(!(onViewableItemsChanged && viewabilityConfigCallbackPairs), "FlatList does not support setting both onViewableItemsChanged and viewabilityConfigCallbackPairs.");
      }
    }, {
      key: "_pushMultiColumnViewable",
      value: function _pushMultiColumnViewable(arr, v) {
        var _this$props$keyExtrac2;

        var numColumns = numColumnsOrDefault(this.props.numColumns);
        var keyExtractor = (_this$props$keyExtrac2 = this.props.keyExtractor) != null ? _this$props$keyExtrac2 : _$$_REQUIRE(_dependencyMap[10]).keyExtractor;
        v.item.forEach(function (item, ii) {
          _$$_REQUIRE(_dependencyMap[11])(v.index != null, 'Missing index!');

          var index = v.index * numColumns + ii;
          arr.push((0, _extends2.default)({}, v, {
            item: item,
            key: keyExtractor(item, index),
            index: index
          }));
        });
      }
    }, {
      key: "_createOnViewableItemsChanged",
      value: function _createOnViewableItemsChanged(onViewableItemsChanged) {
        var _this2 = this;

        return function (info) {
          var numColumns = numColumnsOrDefault(_this2.props.numColumns);

          if (onViewableItemsChanged) {
            if (numColumns > 1) {
              var changed = [];
              var viewableItems = [];
              info.viewableItems.forEach(function (v) {
                return _this2._pushMultiColumnViewable(viewableItems, v);
              });
              info.changed.forEach(function (v) {
                return _this2._pushMultiColumnViewable(changed, v);
              });
              onViewableItemsChanged({
                viewableItems: viewableItems,
                changed: changed
              });
            } else {
              onViewableItemsChanged(info);
            }
          }
        };
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            numColumns = _this$props2.numColumns,
            columnWrapperStyle = _this$props2.columnWrapperStyle,
            _removeClippedSubviews = _this$props2.removeClippedSubviews,
            restProps = (0, _objectWithoutProperties2.default)(_this$props2, _excluded);
        return React.createElement(_$$_REQUIRE(_dependencyMap[15]), (0, _extends2.default)({}, restProps, {
          getItem: this._getItem,
          getItemCount: this._getItemCount,
          keyExtractor: this._keyExtractor,
          ref: this._captureRef,
          viewabilityConfigCallbackPairs: this._virtualizedListPairs,
          removeClippedSubviews: removeClippedSubviewsOrDefault(_removeClippedSubviews)
        }, this._renderer()));
      }
    }]);
    return FlatList;
  }(React.PureComponent);

  var styles = _$$_REQUIRE(_dependencyMap[13]).create({
    row: {
      flexDirection: 'row'
    }
  });

  module.exports = FlatList;
},"node_modules/react-native/Libraries/Lists/FlatList.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/defineProperty.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react/index.js","node_modules/react-native/Libraries/Lists/VirtualizeUtils.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Utilities/differ/deepDiffer.js","node_modules/react-native/Libraries/Lists/VirtualizedList.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
},"node_modules/@babel/runtime/helpers/defineProperty.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.computeWindowedRenderLimits = computeWindowedRenderLimits;
  exports.elementsThatOverlapOffsets = elementsThatOverlapOffsets;
  exports.keyExtractor = keyExtractor;
  exports.newRangeCount = newRangeCount;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  function elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {
    var out = [];
    var outLength = 0;

    for (var ii = 0; ii < itemCount; ii++) {
      var frame = getFrameMetrics(ii);
      var trailingOffset = frame.offset + frame.length;

      for (var kk = 0; kk < offsets.length; kk++) {
        if (out[kk] == null && trailingOffset >= offsets[kk]) {
          out[kk] = ii;
          outLength++;

          if (kk === offsets.length - 1) {
            (0, _invariant.default)(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));
            return out;
          }
        }
      }
    }

    return out;
  }

  function newRangeCount(prev, next) {
    return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));
  }

  function computeWindowedRenderLimits(data, getItemCount, maxToRenderPerBatch, windowSize, prev, getFrameMetricsApprox, scrollMetrics) {
    var itemCount = getItemCount(data);

    if (itemCount === 0) {
      return prev;
    }

    var offset = scrollMetrics.offset,
        velocity = scrollMetrics.velocity,
        visibleLength = scrollMetrics.visibleLength;
    var visibleBegin = Math.max(0, offset);
    var visibleEnd = visibleBegin + visibleLength;
    var overscanLength = (windowSize - 1) * visibleLength;
    var leadFactor = 0.5;
    var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';
    var overscanBegin = Math.max(0, visibleBegin - 0.5 * overscanLength);
    var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);
    var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;

    if (lastItemOffset < overscanBegin) {
      return {
        first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),
        last: itemCount - 1
      };
    }

    var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], itemCount, getFrameMetricsApprox),
        _elementsThatOverlapO2 = (0, _slicedToArray2.default)(_elementsThatOverlapO, 4),
        overscanFirst = _elementsThatOverlapO2[0],
        first = _elementsThatOverlapO2[1],
        last = _elementsThatOverlapO2[2],
        overscanLast = _elementsThatOverlapO2[3];

    overscanFirst = overscanFirst == null ? 0 : overscanFirst;
    first = first == null ? Math.max(0, overscanFirst) : first;
    overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;
    last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;
    var visible = {
      first: first,
      last: last
    };
    var newCellCount = newRangeCount(prev, visible);

    while (true) {
      if (first <= overscanFirst && last >= overscanLast) {
        break;
      }

      var maxNewCells = newCellCount >= maxToRenderPerBatch;
      var firstWillAddMore = first <= prev.first || first > prev.last;
      var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);
      var lastWillAddMore = last >= prev.last || last < prev.first;
      var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);

      if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {
        break;
      }

      if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {
        if (firstWillAddMore) {
          newCellCount++;
        }

        first--;
      }

      if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {
        if (lastWillAddMore) {
          newCellCount++;
        }

        last++;
      }
    }

    if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {
      throw new Error('Bad window calculation ' + JSON.stringify({
        first: first,
        last: last,
        itemCount: itemCount,
        overscanFirst: overscanFirst,
        overscanLast: overscanLast,
        visible: visible
      }));
    }

    return {
      first: first,
      last: last
    };
  }

  function keyExtractor(item, index) {
    if (typeof item === 'object' && (item == null ? undefined : item.key) != null) {
      return item.key;
    }

    if (typeof item === 'object' && (item == null ? undefined : item.id) != null) {
      return item.id;
    }

    return String(index);
  }
},"node_modules/react-native/Libraries/Lists/VirtualizeUtils.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _defineProperty2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _assertThisInitialized2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[9]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var _usedIndexForKey = false;
  var _keylessItemComponentName = '';

  function horizontalOrDefault(horizontal) {
    return horizontal != null ? horizontal : false;
  }

  function initialNumToRenderOrDefault(initialNumToRender) {
    return initialNumToRender != null ? initialNumToRender : 10;
  }

  function maxToRenderPerBatchOrDefault(maxToRenderPerBatch) {
    return maxToRenderPerBatch != null ? maxToRenderPerBatch : 10;
  }

  function onEndReachedThresholdOrDefault(onEndReachedThreshold) {
    return onEndReachedThreshold != null ? onEndReachedThreshold : 2;
  }

  function scrollEventThrottleOrDefault(scrollEventThrottle) {
    return scrollEventThrottle != null ? scrollEventThrottle : 50;
  }

  function windowSizeOrDefault(windowSize) {
    return windowSize != null ? windowSize : 21;
  }

  var VirtualizedList = function (_React$PureComponent) {
    (0, _inherits2.default)(VirtualizedList, _React$PureComponent);

    var _super = _createSuper(VirtualizedList);

    function VirtualizedList(_props) {
      var _this$props$updateCel;

      var _this;

      (0, _classCallCheck2.default)(this, VirtualizedList);
      _this = _super.call(this, _props);

      _this._getScrollMetrics = function () {
        return _this._scrollMetrics;
      };

      _this._getOutermostParentListRef = function () {
        if (_this._isNestedWithSameOrientation()) {
          return _this.context.getOutermostParentListRef();
        } else {
          return (0, _assertThisInitialized2.default)(_this);
        }
      };

      _this._getNestedChildState = function (key) {
        var existingChildData = _this._nestedChildLists.get(key);

        return existingChildData && existingChildData.state;
      };

      _this._registerAsNestedChild = function (childList) {
        var childListsInCell = _this._cellKeysToChildListKeys.get(childList.cellKey) || new Set();
        childListsInCell.add(childList.key);

        _this._cellKeysToChildListKeys.set(childList.cellKey, childListsInCell);

        var existingChildData = _this._nestedChildLists.get(childList.key);

        if (existingChildData && existingChildData.ref !== null) {
          console.error("A VirtualizedList contains a cell which itself contains more than one VirtualizedList of the same orientation as the parent list. You must pass a unique listKey prop to each sibling list.\n\n" + describeNestedLists((0, _extends2.default)({}, childList, {
            horizontal: !!childList.ref.props.horizontal
          })));
        }

        _this._nestedChildLists.set(childList.key, {
          ref: childList.ref,
          state: null
        });

        if (_this._hasInteracted) {
          childList.ref.recordInteraction();
        }
      };

      _this._unregisterAsNestedChild = function (childList) {
        _this._nestedChildLists.set(childList.key, {
          ref: null,
          state: childList.state
        });
      };

      _this._onUpdateSeparators = function (keys, newProps) {
        keys.forEach(function (key) {
          var ref = key != null && _this._cellRefs[key];
          ref && ref.updateSeparatorProps(newProps);
        });
      };

      _this._getSpacerKey = function (isVertical) {
        return isVertical ? 'height' : 'width';
      };

      _this._averageCellLength = 0;
      _this._cellKeysToChildListKeys = new Map();
      _this._cellRefs = {};
      _this._frames = {};
      _this._footerLength = 0;
      _this._hasDoneInitialScroll = false;
      _this._hasInteracted = false;
      _this._hasMore = false;
      _this._hasWarned = {};
      _this._headerLength = 0;
      _this._hiPriInProgress = false;
      _this._highestMeasuredFrameIndex = 0;
      _this._indicesToKeys = new Map();
      _this._nestedChildLists = new Map();
      _this._offsetFromParentVirtualizedList = 0;
      _this._prevParentOffset = 0;
      _this._scrollMetrics = {
        contentLength: 0,
        dOffset: 0,
        dt: 10,
        offset: 0,
        timestamp: 0,
        velocity: 0,
        visibleLength: 0
      };
      _this._scrollRef = null;
      _this._sentEndForContentLength = 0;
      _this._totalCellLength = 0;
      _this._totalCellsMeasured = 0;
      _this._viewabilityTuples = [];

      _this._captureScrollRef = function (ref) {
        _this._scrollRef = ref;
      };

      _this._defaultRenderScrollComponent = function (props) {
        var onRefresh = props.onRefresh;

        if (_this._isNestedWithSameOrientation()) {
          return React.createElement(_$$_REQUIRE(_dependencyMap[10]), props);
        } else if (onRefresh) {
          var _props$refreshing;

          _$$_REQUIRE(_dependencyMap[11])(typeof props.refreshing === 'boolean', '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' + JSON.stringify((_props$refreshing = props.refreshing) != null ? _props$refreshing : 'undefined') + '`');

          return React.createElement(_$$_REQUIRE(_dependencyMap[12]), (0, _extends2.default)({}, props, {
            refreshControl: props.refreshControl == null ? React.createElement(_$$_REQUIRE(_dependencyMap[13]), {
              refreshing: props.refreshing,
              onRefresh: onRefresh,
              progressViewOffset: props.progressViewOffset
            }) : props.refreshControl
          }));
        } else {
          return React.createElement(_$$_REQUIRE(_dependencyMap[12]), props);
        }
      };

      _this._onCellUnmount = function (cellKey) {
        var curr = _this._frames[cellKey];

        if (curr) {
          _this._frames[cellKey] = (0, _extends2.default)({}, curr, {
            inLayout: false
          });
        }
      };

      _this._onLayout = function (e) {
        if (_this._isNestedWithSameOrientation()) {
          _this.measureLayoutRelativeToContainingList();
        } else {
          _this._scrollMetrics.visibleLength = _this._selectLength(e.nativeEvent.layout);
        }

        _this.props.onLayout && _this.props.onLayout(e);

        _this._scheduleCellsToRenderUpdate();

        _this._maybeCallOnEndReached();
      };

      _this._onLayoutEmpty = function (e) {
        _this.props.onLayout && _this.props.onLayout(e);
      };

      _this._onLayoutFooter = function (e) {
        _this._triggerRemeasureForChildListsInCell(_this._getFooterCellKey());

        _this._footerLength = _this._selectLength(e.nativeEvent.layout);
      };

      _this._onLayoutHeader = function (e) {
        _this._headerLength = _this._selectLength(e.nativeEvent.layout);
      };

      _this._onContentSizeChange = function (width, height) {
        if (width > 0 && height > 0 && _this.props.initialScrollIndex != null && _this.props.initialScrollIndex > 0 && !_this._hasDoneInitialScroll) {
          if (_this.props.contentOffset == null) {
            _this.scrollToIndex({
              animated: false,
              index: _this.props.initialScrollIndex
            });
          }

          _this._hasDoneInitialScroll = true;
        }

        if (_this.props.onContentSizeChange) {
          _this.props.onContentSizeChange(width, height);
        }

        _this._scrollMetrics.contentLength = _this._selectLength({
          height: height,
          width: width
        });

        _this._scheduleCellsToRenderUpdate();

        _this._maybeCallOnEndReached();
      };

      _this._convertParentScrollMetrics = function (metrics) {
        var offset = metrics.offset - _this._offsetFromParentVirtualizedList;
        var visibleLength = metrics.visibleLength;
        var dOffset = offset - _this._scrollMetrics.offset;
        var contentLength = _this._scrollMetrics.contentLength;
        return {
          visibleLength: visibleLength,
          contentLength: contentLength,
          offset: offset,
          dOffset: dOffset
        };
      };

      _this._onScroll = function (e) {
        _this._nestedChildLists.forEach(function (childList) {
          childList.ref && childList.ref._onScroll(e);
        });

        if (_this.props.onScroll) {
          _this.props.onScroll(e);
        }

        var timestamp = e.timeStamp;

        var visibleLength = _this._selectLength(e.nativeEvent.layoutMeasurement);

        var contentLength = _this._selectLength(e.nativeEvent.contentSize);

        var offset = _this._selectOffset(e.nativeEvent.contentOffset);

        var dOffset = offset - _this._scrollMetrics.offset;

        if (_this._isNestedWithSameOrientation()) {
          if (_this._scrollMetrics.contentLength === 0) {
            return;
          }

          var _this$_convertParentS = _this._convertParentScrollMetrics({
            visibleLength: visibleLength,
            offset: offset
          });

          visibleLength = _this$_convertParentS.visibleLength;
          contentLength = _this$_convertParentS.contentLength;
          offset = _this$_convertParentS.offset;
          dOffset = _this$_convertParentS.dOffset;
        }

        var dt = _this._scrollMetrics.timestamp ? Math.max(1, timestamp - _this._scrollMetrics.timestamp) : 1;
        var velocity = dOffset / dt;

        if (dt > 500 && _this._scrollMetrics.dt > 500 && contentLength > 5 * visibleLength && !_this._hasWarned.perf) {
          _$$_REQUIRE(_dependencyMap[14])("VirtualizedList: You have a large list that is slow to update - make sure your renderItem function renders components that follow React performance best practices like PureComponent, shouldComponentUpdate, etc.", {
            dt: dt,
            prevDt: _this._scrollMetrics.dt,
            contentLength: contentLength
          });

          _this._hasWarned.perf = true;
        }

        _this._scrollMetrics = {
          contentLength: contentLength,
          dt: dt,
          dOffset: dOffset,
          offset: offset,
          timestamp: timestamp,
          velocity: velocity,
          visibleLength: visibleLength
        };

        _this._updateViewableItems(_this.props.data);

        if (!_this.props) {
          return;
        }

        _this._maybeCallOnEndReached();

        if (velocity !== 0) {
          _this._fillRateHelper.activate();
        }

        _this._computeBlankness();

        _this._scheduleCellsToRenderUpdate();
      };

      _this._onScrollBeginDrag = function (e) {
        _this._nestedChildLists.forEach(function (childList) {
          childList.ref && childList.ref._onScrollBeginDrag(e);
        });

        _this._viewabilityTuples.forEach(function (tuple) {
          tuple.viewabilityHelper.recordInteraction();
        });

        _this._hasInteracted = true;
        _this.props.onScrollBeginDrag && _this.props.onScrollBeginDrag(e);
      };

      _this._onScrollEndDrag = function (e) {
        _this._nestedChildLists.forEach(function (childList) {
          childList.ref && childList.ref._onScrollEndDrag(e);
        });

        var velocity = e.nativeEvent.velocity;

        if (velocity) {
          _this._scrollMetrics.velocity = _this._selectOffset(velocity);
        }

        _this._computeBlankness();

        _this.props.onScrollEndDrag && _this.props.onScrollEndDrag(e);
      };

      _this._onMomentumScrollBegin = function (e) {
        _this._nestedChildLists.forEach(function (childList) {
          childList.ref && childList.ref._onMomentumScrollBegin(e);
        });

        _this.props.onMomentumScrollBegin && _this.props.onMomentumScrollBegin(e);
      };

      _this._onMomentumScrollEnd = function (e) {
        _this._nestedChildLists.forEach(function (childList) {
          childList.ref && childList.ref._onMomentumScrollEnd(e);
        });

        _this._scrollMetrics.velocity = 0;

        _this._computeBlankness();

        _this.props.onMomentumScrollEnd && _this.props.onMomentumScrollEnd(e);
      };

      _this._updateCellsToRender = function () {
        var _this$props = _this.props,
            data = _this$props.data,
            getItemCount = _this$props.getItemCount,
            _onEndReachedThreshold = _this$props.onEndReachedThreshold;
        var onEndReachedThreshold = onEndReachedThresholdOrDefault(_onEndReachedThreshold);

        var isVirtualizationDisabled = _this._isVirtualizationDisabled();

        _this._updateViewableItems(data);

        if (!data) {
          return;
        }

        _this.setState(function (state) {
          var newState;
          var _this$_scrollMetrics = _this._scrollMetrics,
              contentLength = _this$_scrollMetrics.contentLength,
              offset = _this$_scrollMetrics.offset,
              visibleLength = _this$_scrollMetrics.visibleLength;

          if (!isVirtualizationDisabled) {
            if (visibleLength > 0 && contentLength > 0) {
              if (!_this.props.initialScrollIndex || _this._scrollMetrics.offset) {
                newState = (0, _$$_REQUIRE(_dependencyMap[15]).computeWindowedRenderLimits)(_this.props.data, _this.props.getItemCount, maxToRenderPerBatchOrDefault(_this.props.maxToRenderPerBatch), windowSizeOrDefault(_this.props.windowSize), state, _this._getFrameMetricsApprox, _this._scrollMetrics);
              }
            }
          } else {
            var distanceFromEnd = contentLength - visibleLength - offset;
            var renderAhead = distanceFromEnd < onEndReachedThreshold * visibleLength ? maxToRenderPerBatchOrDefault(_this.props.maxToRenderPerBatch) : 0;
            newState = {
              first: 0,
              last: Math.min(state.last + renderAhead, getItemCount(data) - 1)
            };
          }

          if (newState && _this._nestedChildLists.size > 0) {
            var newFirst = newState.first;
            var newLast = newState.last;

            for (var ii = newFirst; ii <= newLast; ii++) {
              var cellKeyForIndex = _this._indicesToKeys.get(ii);

              var childListKeys = cellKeyForIndex && _this._cellKeysToChildListKeys.get(cellKeyForIndex);

              if (!childListKeys) {
                continue;
              }

              var someChildHasMore = false;

              for (var _iterator = _createForOfIteratorHelperLoose(childListKeys), _step; !(_step = _iterator()).done;) {
                var childKey = _step.value;

                var childList = _this._nestedChildLists.get(childKey);

                if (childList && childList.ref && childList.ref.hasMore()) {
                  someChildHasMore = true;
                  break;
                }
              }

              if (someChildHasMore) {
                newState.last = ii;
                break;
              }
            }
          }

          if (newState != null && newState.first === state.first && newState.last === state.last) {
            newState = null;
          }

          return newState;
        });
      };

      _this._createViewToken = function (index, isViewable) {
        var _this$props2 = _this.props,
            data = _this$props2.data,
            getItem = _this$props2.getItem;
        var item = getItem(data, index);
        return {
          index: index,
          item: item,
          key: _this._keyExtractor(item, index),
          isViewable: isViewable
        };
      };

      _this._getFrameMetricsApprox = function (index) {
        var frame = _this._getFrameMetrics(index);

        if (frame && frame.index === index) {
          return frame;
        } else {
          var getItemLayout = _this.props.getItemLayout;

          _$$_REQUIRE(_dependencyMap[11])(!getItemLayout, 'Should not have to estimate frames when a measurement metrics function is provided');

          return {
            length: _this._averageCellLength,
            offset: _this._averageCellLength * index
          };
        }
      };

      _this._getFrameMetrics = function (index) {
        var _this$props3 = _this.props,
            data = _this$props3.data,
            getItem = _this$props3.getItem,
            getItemCount = _this$props3.getItemCount,
            getItemLayout = _this$props3.getItemLayout;

        _$$_REQUIRE(_dependencyMap[11])(getItemCount(data) > index, 'Tried to get frame for out of range index ' + index);

        var item = getItem(data, index);

        var frame = item && _this._frames[_this._keyExtractor(item, index)];

        if (!frame || frame.index !== index) {
          if (getItemLayout) {
            frame = getItemLayout(data, index);
          }
        }

        return frame;
      };

      _$$_REQUIRE(_dependencyMap[11])(!_props.onScroll || !_props.onScroll.__isNative, "Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent to support native onScroll events with useNativeDriver");

      _$$_REQUIRE(_dependencyMap[11])(windowSizeOrDefault(_props.windowSize) > 0, 'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.');

      _this._fillRateHelper = new (_$$_REQUIRE(_dependencyMap[16]))(_this._getFrameMetrics);
      _this._updateCellsToRenderBatcher = new (_$$_REQUIRE(_dependencyMap[17]))(_this._updateCellsToRender, (_this$props$updateCel = _this.props.updateCellsBatchingPeriod) != null ? _this$props$updateCel : 50);

      if (_this.props.viewabilityConfigCallbackPairs) {
        _this._viewabilityTuples = _this.props.viewabilityConfigCallbackPairs.map(function (pair) {
          return {
            viewabilityHelper: new (_$$_REQUIRE(_dependencyMap[18]))(pair.viewabilityConfig),
            onViewableItemsChanged: pair.onViewableItemsChanged
          };
        });
      } else {
        var _this$props4 = _this.props,
            onViewableItemsChanged = _this$props4.onViewableItemsChanged,
            viewabilityConfig = _this$props4.viewabilityConfig;

        if (onViewableItemsChanged) {
          _this._viewabilityTuples.push({
            viewabilityHelper: new (_$$_REQUIRE(_dependencyMap[18]))(viewabilityConfig),
            onViewableItemsChanged: onViewableItemsChanged
          });
        }
      }

      var initialState = {
        first: _this.props.initialScrollIndex || 0,
        last: Math.min(_this.props.getItemCount(_this.props.data), (_this.props.initialScrollIndex || 0) + initialNumToRenderOrDefault(_this.props.initialNumToRender)) - 1
      };

      if (_this._isNestedWithSameOrientation()) {
        var storedState = _this.context.getNestedChildState(_this._getListKey());

        if (storedState) {
          initialState = storedState;
          _this.state = storedState;
          _this._frames = storedState.frames;
        }
      }

      _this.state = initialState;
      return _this;
    }

    (0, _createClass2.default)(VirtualizedList, [{
      key: "scrollToEnd",
      value: function scrollToEnd(params) {
        var animated = params ? params.animated : true;
        var veryLast = this.props.getItemCount(this.props.data) - 1;

        var frame = this._getFrameMetricsApprox(veryLast);

        var offset = Math.max(0, frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength);

        if (this._scrollRef == null) {
          return;
        }

        if (this._scrollRef.scrollTo == null) {
          console.warn("No scrollTo method provided. This may be because you have two nested VirtualizedLists with the same orientation, or because you are using a custom component that does not implement scrollTo.");
          return;
        }

        this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {
          x: offset,
          animated: animated
        } : {
          y: offset,
          animated: animated
        });
      }
    }, {
      key: "scrollToIndex",
      value: function scrollToIndex(params) {
        var _this$props5 = this.props,
            data = _this$props5.data,
            horizontal = _this$props5.horizontal,
            getItemCount = _this$props5.getItemCount,
            getItemLayout = _this$props5.getItemLayout,
            onScrollToIndexFailed = _this$props5.onScrollToIndexFailed;
        var animated = params.animated,
            index = params.index,
            viewOffset = params.viewOffset,
            viewPosition = params.viewPosition;

        _$$_REQUIRE(_dependencyMap[11])(index >= 0, "scrollToIndex out of range: requested index " + index + " but minimum is 0");

        _$$_REQUIRE(_dependencyMap[11])(getItemCount(data) >= 1, "scrollToIndex out of range: item length " + getItemCount(data) + " but minimum is 1");

        _$$_REQUIRE(_dependencyMap[11])(index < getItemCount(data), "scrollToIndex out of range: requested index " + index + " is out of 0 to " + (getItemCount(data) - 1));

        if (!getItemLayout && index > this._highestMeasuredFrameIndex) {
          _$$_REQUIRE(_dependencyMap[11])(!!onScrollToIndexFailed, "scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, otherwise there is no way to know the location of offscreen indices or handle failures.");

          onScrollToIndexFailed({
            averageItemLength: this._averageCellLength,
            highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,
            index: index
          });
          return;
        }

        var frame = this._getFrameMetricsApprox(index);

        var offset = Math.max(0, frame.offset - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)) - (viewOffset || 0);

        if (this._scrollRef == null) {
          return;
        }

        if (this._scrollRef.scrollTo == null) {
          console.warn("No scrollTo method provided. This may be because you have two nested VirtualizedLists with the same orientation, or because you are using a custom component that does not implement scrollTo.");
          return;
        }

        this._scrollRef.scrollTo(horizontal ? {
          x: offset,
          animated: animated
        } : {
          y: offset,
          animated: animated
        });
      }
    }, {
      key: "scrollToItem",
      value: function scrollToItem(params) {
        var item = params.item;
        var _this$props6 = this.props,
            data = _this$props6.data,
            getItem = _this$props6.getItem,
            getItemCount = _this$props6.getItemCount;
        var itemCount = getItemCount(data);

        for (var _index = 0; _index < itemCount; _index++) {
          if (getItem(data, _index) === item) {
            this.scrollToIndex((0, _extends2.default)({}, params, {
              index: _index
            }));
            break;
          }
        }
      }
    }, {
      key: "scrollToOffset",
      value: function scrollToOffset(params) {
        var animated = params.animated,
            offset = params.offset;

        if (this._scrollRef == null) {
          return;
        }

        if (this._scrollRef.scrollTo == null) {
          console.warn("No scrollTo method provided. This may be because you have two nested VirtualizedLists with the same orientation, or because you are using a custom component that does not implement scrollTo.");
          return;
        }

        this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {
          x: offset,
          animated: animated
        } : {
          y: offset,
          animated: animated
        });
      }
    }, {
      key: "recordInteraction",
      value: function recordInteraction() {
        this._nestedChildLists.forEach(function (childList) {
          childList.ref && childList.ref.recordInteraction();
        });

        this._viewabilityTuples.forEach(function (t) {
          t.viewabilityHelper.recordInteraction();
        });

        this._updateViewableItems(this.props.data);
      }
    }, {
      key: "flashScrollIndicators",
      value: function flashScrollIndicators() {
        if (this._scrollRef == null) {
          return;
        }

        this._scrollRef.flashScrollIndicators();
      }
    }, {
      key: "getScrollResponder",
      value: function getScrollResponder() {
        if (this._scrollRef && this._scrollRef.getScrollResponder) {
          return this._scrollRef.getScrollResponder();
        }
      }
    }, {
      key: "getScrollableNode",
      value: function getScrollableNode() {
        if (this._scrollRef && this._scrollRef.getScrollableNode) {
          return this._scrollRef.getScrollableNode();
        } else {
          return _$$_REQUIRE(_dependencyMap[19]).findNodeHandle(this._scrollRef);
        }
      }
    }, {
      key: "getScrollRef",
      value: function getScrollRef() {
        if (this._scrollRef && this._scrollRef.getScrollRef) {
          return this._scrollRef.getScrollRef();
        } else {
          return this._scrollRef;
        }
      }
    }, {
      key: "setNativeProps",
      value: function setNativeProps(props) {
        if (this._scrollRef) {
          this._scrollRef.setNativeProps(props);
        }
      }
    }, {
      key: "_getCellKey",
      value: function _getCellKey() {
        var _this$context;

        return ((_this$context = this.context) == null ? undefined : _this$context.cellKey) || 'rootList';
      }
    }, {
      key: "_getListKey",
      value: function _getListKey() {
        return this.props.listKey || this._getCellKey();
      }
    }, {
      key: "_getDebugInfo",
      value: function _getDebugInfo() {
        var _this$context2;

        return {
          listKey: this._getListKey(),
          cellKey: this._getCellKey(),
          horizontal: horizontalOrDefault(this.props.horizontal),
          parent: (_this$context2 = this.context) == null ? undefined : _this$context2.debugInfo
        };
      }
    }, {
      key: "hasMore",
      value: function hasMore() {
        return this._hasMore;
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        if (this._isNestedWithSameOrientation()) {
          this.context.registerAsNestedChild({
            cellKey: this._getCellKey(),
            key: this._getListKey(),
            ref: this,
            parentDebugInfo: this.context.debugInfo
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._isNestedWithSameOrientation()) {
          this.context.unregisterAsNestedChild({
            key: this._getListKey(),
            state: {
              first: this.state.first,
              last: this.state.last,
              frames: this._frames
            }
          });
        }

        this._updateViewableItems(null);

        this._updateCellsToRenderBatcher.dispose({
          abort: true
        });

        this._viewabilityTuples.forEach(function (tuple) {
          tuple.viewabilityHelper.dispose();
        });

        this._fillRateHelper.deactivateAndFlush();
      }
    }, {
      key: "_pushCells",
      value: function _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {
        var _this2 = this;

        var _this$props7 = this.props,
            CellRendererComponent = _this$props7.CellRendererComponent,
            ItemSeparatorComponent = _this$props7.ItemSeparatorComponent,
            data = _this$props7.data,
            getItem = _this$props7.getItem,
            getItemCount = _this$props7.getItemCount,
            horizontal = _this$props7.horizontal;
        var stickyOffset = this.props.ListHeaderComponent ? 1 : 0;
        var end = getItemCount(data) - 1;
        var prevCellKey;
        last = Math.min(end, last);

        var _loop = function _loop(ii) {
          var item = getItem(data, ii);

          var key = _this2._keyExtractor(item, ii);

          _this2._indicesToKeys.set(ii, key);

          if (stickyIndicesFromProps.has(ii + stickyOffset)) {
            stickyHeaderIndices.push(cells.length);
          }

          cells.push(React.createElement(CellRenderer, {
            CellRendererComponent: CellRendererComponent,
            ItemSeparatorComponent: ii < end ? ItemSeparatorComponent : undefined,
            cellKey: key,
            fillRateHelper: _this2._fillRateHelper,
            horizontal: horizontal,
            index: ii,
            inversionStyle: inversionStyle,
            item: item,
            key: key,
            prevCellKey: prevCellKey,
            onUpdateSeparators: _this2._onUpdateSeparators,
            onLayout: function onLayout(e) {
              return _this2._onCellLayout(e, key, ii);
            },
            onUnmount: _this2._onCellUnmount,
            parentProps: _this2.props,
            ref: function ref(_ref) {
              _this2._cellRefs[key] = _ref;
            }
          }));
          prevCellKey = key;
        };

        for (var ii = first; ii <= last; ii++) {
          _loop(ii);
        }
      }
    }, {
      key: "_isVirtualizationDisabled",
      value: function _isVirtualizationDisabled() {
        return this.props.disableVirtualization || false;
      }
    }, {
      key: "_isNestedWithSameOrientation",
      value: function _isNestedWithSameOrientation() {
        var nestedContext = this.context;
        return !!(nestedContext && !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal));
      }
    }, {
      key: "_keyExtractor",
      value: function _keyExtractor(item, index) {
        if (this.props.keyExtractor != null) {
          return this.props.keyExtractor(item, index);
        }

        var key = (0, _$$_REQUIRE(_dependencyMap[15]).keyExtractor)(item, index);

        if (key === String(index)) {
          _usedIndexForKey = true;

          if (item.type && item.type.displayName) {
            _keylessItemComponentName = item.type.displayName;
          }
        }

        return key;
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        var _this$props8 = this.props,
            ListEmptyComponent = _this$props8.ListEmptyComponent,
            ListFooterComponent = _this$props8.ListFooterComponent,
            ListHeaderComponent = _this$props8.ListHeaderComponent;
        var _this$props9 = this.props,
            data = _this$props9.data,
            horizontal = _this$props9.horizontal;

        var isVirtualizationDisabled = this._isVirtualizationDisabled();

        var inversionStyle = this.props.inverted ? horizontalOrDefault(this.props.horizontal) ? styles.horizontallyInverted : styles.verticallyInverted : null;
        var cells = [];
        var stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);
        var stickyHeaderIndices = [];

        if (ListHeaderComponent) {
          if (stickyIndicesFromProps.has(0)) {
            stickyHeaderIndices.push(0);
          }

          var element = React.isValidElement(ListHeaderComponent) ? ListHeaderComponent : React.createElement(ListHeaderComponent, null);
          cells.push(React.createElement(_$$_REQUIRE(_dependencyMap[20]).VirtualizedListCellContextProvider, {
            cellKey: this._getCellKey() + '-header',
            key: "$header"
          }, React.createElement(_$$_REQUIRE(_dependencyMap[10]), {
            onLayout: this._onLayoutHeader,
            style: _$$_REQUIRE(_dependencyMap[21]).compose(inversionStyle, this.props.ListHeaderComponentStyle)
          }, element)));
        }

        var itemCount = this.props.getItemCount(data);

        if (itemCount > 0) {
          _usedIndexForKey = false;
          _keylessItemComponentName = '';

          var spacerKey = this._getSpacerKey(!horizontal);

          var lastInitialIndex = this.props.initialScrollIndex ? -1 : initialNumToRenderOrDefault(this.props.initialNumToRender) - 1;
          var _this$state = this.state,
              first = _this$state.first,
              last = _this$state.last;

          this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, 0, lastInitialIndex, inversionStyle);

          var firstAfterInitial = Math.max(lastInitialIndex + 1, first);

          if (!isVirtualizationDisabled && first > lastInitialIndex + 1) {
            var insertedStickySpacer = false;

            if (stickyIndicesFromProps.size > 0) {
              var stickyOffset = ListHeaderComponent ? 1 : 0;

              for (var ii = firstAfterInitial - 1; ii > lastInitialIndex; ii--) {
                if (stickyIndicesFromProps.has(ii + stickyOffset)) {
                  var initBlock = this._getFrameMetricsApprox(lastInitialIndex);

                  var stickyBlock = this._getFrameMetricsApprox(ii);

                  var leadSpace = stickyBlock.offset - initBlock.offset - (this.props.initialScrollIndex ? 0 : initBlock.length);
                  cells.push(React.createElement(_$$_REQUIRE(_dependencyMap[10]), {
                    key: "$sticky_lead",
                    style: (0, _defineProperty2.default)({}, spacerKey, leadSpace)
                  }));

                  this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, ii, ii, inversionStyle);

                  var trailSpace = this._getFrameMetricsApprox(first).offset - (stickyBlock.offset + stickyBlock.length);
                  cells.push(React.createElement(_$$_REQUIRE(_dependencyMap[10]), {
                    key: "$sticky_trail",
                    style: (0, _defineProperty2.default)({}, spacerKey, trailSpace)
                  }));
                  insertedStickySpacer = true;
                  break;
                }
              }
            }

            if (!insertedStickySpacer) {
              var _initBlock = this._getFrameMetricsApprox(lastInitialIndex);

              var firstSpace = this._getFrameMetricsApprox(first).offset - (_initBlock.offset + _initBlock.length);

              cells.push(React.createElement(_$$_REQUIRE(_dependencyMap[10]), {
                key: "$lead_spacer",
                style: (0, _defineProperty2.default)({}, spacerKey, firstSpace)
              }));
            }
          }

          this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, firstAfterInitial, last, inversionStyle);

          if (!this._hasWarned.keys && _usedIndexForKey) {
            console.warn("VirtualizedList: missing keys for items, make sure to specify a key or id property on each item or provide a custom keyExtractor.", _keylessItemComponentName);
            this._hasWarned.keys = true;
          }

          if (!isVirtualizationDisabled && last < itemCount - 1) {
            var lastFrame = this._getFrameMetricsApprox(last);

            var end = this.props.getItemLayout ? itemCount - 1 : Math.min(itemCount - 1, this._highestMeasuredFrameIndex);

            var endFrame = this._getFrameMetricsApprox(end);

            var tailSpacerLength = endFrame.offset + endFrame.length - (lastFrame.offset + lastFrame.length);
            cells.push(React.createElement(_$$_REQUIRE(_dependencyMap[10]), {
              key: "$tail_spacer",
              style: (0, _defineProperty2.default)({}, spacerKey, tailSpacerLength)
            }));
          }
        } else if (ListEmptyComponent) {
          var _element = React.isValidElement(ListEmptyComponent) ? ListEmptyComponent : React.createElement(ListEmptyComponent, null);

          cells.push(React.cloneElement(_element, {
            key: '$empty',
            onLayout: function onLayout(event) {
              _this3._onLayoutEmpty(event);

              if (_element.props.onLayout) {
                _element.props.onLayout(event);
              }
            },
            style: _$$_REQUIRE(_dependencyMap[21]).compose(inversionStyle, _element.props.style)
          }));
        }

        if (ListFooterComponent) {
          var _element2 = React.isValidElement(ListFooterComponent) ? ListFooterComponent : React.createElement(ListFooterComponent, null);

          cells.push(React.createElement(_$$_REQUIRE(_dependencyMap[20]).VirtualizedListCellContextProvider, {
            cellKey: this._getFooterCellKey(),
            key: "$footer"
          }, React.createElement(_$$_REQUIRE(_dependencyMap[10]), {
            onLayout: this._onLayoutFooter,
            style: _$$_REQUIRE(_dependencyMap[21]).compose(inversionStyle, this.props.ListFooterComponentStyle)
          }, _element2)));
        }

        var scrollProps = (0, _extends2.default)({}, this.props, {
          onContentSizeChange: this._onContentSizeChange,
          onLayout: this._onLayout,
          onScroll: this._onScroll,
          onScrollBeginDrag: this._onScrollBeginDrag,
          onScrollEndDrag: this._onScrollEndDrag,
          onMomentumScrollBegin: this._onMomentumScrollBegin,
          onMomentumScrollEnd: this._onMomentumScrollEnd,
          scrollEventThrottle: scrollEventThrottleOrDefault(this.props.scrollEventThrottle),
          invertStickyHeaders: this.props.invertStickyHeaders !== undefined ? this.props.invertStickyHeaders : this.props.inverted,
          stickyHeaderIndices: stickyHeaderIndices,
          style: inversionStyle ? [inversionStyle, this.props.style] : this.props.style
        });
        this._hasMore = this.state.last < this.props.getItemCount(this.props.data) - 1;
        var innerRet = React.createElement(_$$_REQUIRE(_dependencyMap[20]).VirtualizedListContextProvider, {
          value: {
            cellKey: null,
            getScrollMetrics: this._getScrollMetrics,
            horizontal: horizontalOrDefault(this.props.horizontal),
            getOutermostParentListRef: this._getOutermostParentListRef,
            getNestedChildState: this._getNestedChildState,
            registerAsNestedChild: this._registerAsNestedChild,
            unregisterAsNestedChild: this._unregisterAsNestedChild,
            debugInfo: this._getDebugInfo()
          }
        }, React.cloneElement((this.props.renderScrollComponent || this._defaultRenderScrollComponent)(scrollProps), {
          ref: this._captureScrollRef
        }, cells));
        var ret = innerRet;

        if (this.props.debug) {
          return React.createElement(_$$_REQUIRE(_dependencyMap[10]), {
            style: styles.debug
          }, ret, this._renderDebugOverlay());
        } else {
          return ret;
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this$props10 = this.props,
            data = _this$props10.data,
            extraData = _this$props10.extraData;

        if (data !== prevProps.data || extraData !== prevProps.extraData) {
          this._viewabilityTuples.forEach(function (tuple) {
            tuple.viewabilityHelper.resetViewableIndices();
          });
        }

        var hiPriInProgress = this._hiPriInProgress;

        this._scheduleCellsToRenderUpdate();

        if (hiPriInProgress) {
          this._hiPriInProgress = false;
        }
      }
    }, {
      key: "_computeBlankness",
      value: function _computeBlankness() {
        this._fillRateHelper.computeBlankness(this.props, this.state, this._scrollMetrics);
      }
    }, {
      key: "_onCellLayout",
      value: function _onCellLayout(e, cellKey, index) {
        var layout = e.nativeEvent.layout;
        var next = {
          offset: this._selectOffset(layout),
          length: this._selectLength(layout),
          index: index,
          inLayout: true
        };
        var curr = this._frames[cellKey];

        if (!curr || next.offset !== curr.offset || next.length !== curr.length || index !== curr.index) {
          this._totalCellLength += next.length - (curr ? curr.length : 0);
          this._totalCellsMeasured += curr ? 0 : 1;
          this._averageCellLength = this._totalCellLength / this._totalCellsMeasured;
          this._frames[cellKey] = next;
          this._highestMeasuredFrameIndex = Math.max(this._highestMeasuredFrameIndex, index);

          this._scheduleCellsToRenderUpdate();
        } else {
          this._frames[cellKey].inLayout = true;
        }

        this._triggerRemeasureForChildListsInCell(cellKey);

        this._computeBlankness();

        this._updateViewableItems(this.props.data);
      }
    }, {
      key: "_triggerRemeasureForChildListsInCell",
      value: function _triggerRemeasureForChildListsInCell(cellKey) {
        var childListKeys = this._cellKeysToChildListKeys.get(cellKey);

        if (childListKeys) {
          for (var _iterator2 = _createForOfIteratorHelperLoose(childListKeys), _step2; !(_step2 = _iterator2()).done;) {
            var childKey = _step2.value;

            var childList = this._nestedChildLists.get(childKey);

            childList && childList.ref && childList.ref.measureLayoutRelativeToContainingList();
          }
        }
      }
    }, {
      key: "measureLayoutRelativeToContainingList",
      value: function measureLayoutRelativeToContainingList() {
        var _this4 = this;

        try {
          if (!this._scrollRef) {
            return;
          }

          this._scrollRef.measureLayout(this.context.getOutermostParentListRef().getScrollRef(), function (x, y, width, height) {
            _this4._offsetFromParentVirtualizedList = _this4._selectOffset({
              x: x,
              y: y
            });
            _this4._scrollMetrics.contentLength = _this4._selectLength({
              width: width,
              height: height
            });

            var scrollMetrics = _this4._convertParentScrollMetrics(_this4.context.getScrollMetrics());

            var metricsChanged = _this4._scrollMetrics.visibleLength !== scrollMetrics.visibleLength || _this4._scrollMetrics.offset !== scrollMetrics.offset;

            if (metricsChanged) {
              _this4._scrollMetrics.visibleLength = scrollMetrics.visibleLength;
              _this4._scrollMetrics.offset = scrollMetrics.offset;

              _this4._cellKeysToChildListKeys.forEach(function (childListKeys) {
                if (childListKeys) {
                  for (var _iterator3 = _createForOfIteratorHelperLoose(childListKeys), _step3; !(_step3 = _iterator3()).done;) {
                    var childKey = _step3.value;

                    var childList = _this4._nestedChildLists.get(childKey);

                    childList && childList.ref && childList.ref.measureLayoutRelativeToContainingList();
                  }
                }
              });
            }
          }, function (error) {
            console.warn("VirtualizedList: Encountered an error while measuring a list's offset from its containing VirtualizedList.");
          });
        } catch (error) {
          console.warn('measureLayoutRelativeToContainingList threw an error', error.stack);
        }
      }
    }, {
      key: "_getFooterCellKey",
      value: function _getFooterCellKey() {
        return this._getCellKey() + '-footer';
      }
    }, {
      key: "_renderDebugOverlay",
      value: function _renderDebugOverlay() {
        var normalize = this._scrollMetrics.visibleLength / (this._scrollMetrics.contentLength || 1);
        var framesInLayout = [];
        var itemCount = this.props.getItemCount(this.props.data);

        for (var ii = 0; ii < itemCount; ii++) {
          var frame = this._getFrameMetricsApprox(ii);

          if (frame.inLayout) {
            framesInLayout.push(frame);
          }
        }

        var windowTop = this._getFrameMetricsApprox(this.state.first).offset;

        var frameLast = this._getFrameMetricsApprox(this.state.last);

        var windowLen = frameLast.offset + frameLast.length - windowTop;
        var visTop = this._scrollMetrics.offset;
        var visLen = this._scrollMetrics.visibleLength;
        return React.createElement(_$$_REQUIRE(_dependencyMap[10]), {
          style: [styles.debugOverlayBase, styles.debugOverlay]
        }, framesInLayout.map(function (f, ii) {
          return React.createElement(_$$_REQUIRE(_dependencyMap[10]), {
            key: 'f' + ii,
            style: [styles.debugOverlayBase, styles.debugOverlayFrame, {
              top: f.offset * normalize,
              height: f.length * normalize
            }]
          });
        }), React.createElement(_$$_REQUIRE(_dependencyMap[10]), {
          style: [styles.debugOverlayBase, styles.debugOverlayFrameLast, {
            top: windowTop * normalize,
            height: windowLen * normalize
          }]
        }), React.createElement(_$$_REQUIRE(_dependencyMap[10]), {
          style: [styles.debugOverlayBase, styles.debugOverlayFrameVis, {
            top: visTop * normalize,
            height: visLen * normalize
          }]
        }));
      }
    }, {
      key: "_selectLength",
      value: function _selectLength(metrics) {
        return !horizontalOrDefault(this.props.horizontal) ? metrics.height : metrics.width;
      }
    }, {
      key: "_selectOffset",
      value: function _selectOffset(metrics) {
        return !horizontalOrDefault(this.props.horizontal) ? metrics.y : metrics.x;
      }
    }, {
      key: "_maybeCallOnEndReached",
      value: function _maybeCallOnEndReached() {
        var _this$props11 = this.props,
            data = _this$props11.data,
            getItemCount = _this$props11.getItemCount,
            onEndReached = _this$props11.onEndReached,
            onEndReachedThreshold = _this$props11.onEndReachedThreshold;
        var _this$_scrollMetrics2 = this._scrollMetrics,
            contentLength = _this$_scrollMetrics2.contentLength,
            visibleLength = _this$_scrollMetrics2.visibleLength,
            offset = _this$_scrollMetrics2.offset;
        var distanceFromEnd = contentLength - visibleLength - offset;
        var threshold = onEndReachedThreshold != null ? onEndReachedThreshold * visibleLength : 2;

        if (onEndReached && this.state.last === getItemCount(data) - 1 && distanceFromEnd < threshold && this._scrollMetrics.contentLength !== this._sentEndForContentLength) {
          this._sentEndForContentLength = this._scrollMetrics.contentLength;
          onEndReached({
            distanceFromEnd: distanceFromEnd
          });
        } else if (distanceFromEnd > threshold) {
          this._sentEndForContentLength = 0;
        }
      }
    }, {
      key: "_scheduleCellsToRenderUpdate",
      value: function _scheduleCellsToRenderUpdate() {
        var _this$state2 = this.state,
            first = _this$state2.first,
            last = _this$state2.last;
        var _this$_scrollMetrics3 = this._scrollMetrics,
            offset = _this$_scrollMetrics3.offset,
            visibleLength = _this$_scrollMetrics3.visibleLength,
            velocity = _this$_scrollMetrics3.velocity;
        var itemCount = this.props.getItemCount(this.props.data);
        var hiPri = false;
        var onEndReachedThreshold = onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold);
        var scrollingThreshold = onEndReachedThreshold * visibleLength / 2;

        if (first > 0) {
          var distTop = offset - this._getFrameMetricsApprox(first).offset;

          hiPri = hiPri || distTop < 0 || velocity < -2 && distTop < scrollingThreshold;
        }

        if (last < itemCount - 1) {
          var distBottom = this._getFrameMetricsApprox(last).offset - (offset + visibleLength);
          hiPri = hiPri || distBottom < 0 || velocity > 2 && distBottom < scrollingThreshold;
        }

        if (hiPri && (this._averageCellLength || this.props.getItemLayout) && !this._hiPriInProgress) {
          this._hiPriInProgress = true;

          this._updateCellsToRenderBatcher.dispose({
            abort: true
          });

          this._updateCellsToRender();

          return;
        } else {
          this._updateCellsToRenderBatcher.schedule();
        }
      }
    }, {
      key: "_updateViewableItems",
      value: function _updateViewableItems(data) {
        var _this5 = this;

        var getItemCount = this.props.getItemCount;

        this._viewabilityTuples.forEach(function (tuple) {
          tuple.viewabilityHelper.onUpdate(getItemCount(data), _this5._scrollMetrics.offset, _this5._scrollMetrics.visibleLength, _this5._getFrameMetrics, _this5._createViewToken, tuple.onViewableItemsChanged, _this5.state);
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(newProps, prevState) {
        var data = newProps.data,
            getItemCount = newProps.getItemCount;
        var maxToRenderPerBatch = maxToRenderPerBatchOrDefault(newProps.maxToRenderPerBatch);
        return {
          first: Math.max(0, Math.min(prevState.first, getItemCount(data) - 1 - maxToRenderPerBatch)),
          last: Math.max(0, Math.min(prevState.last, getItemCount(data) - 1))
        };
      }
    }]);
    return VirtualizedList;
  }(React.PureComponent);

  VirtualizedList.contextType = _$$_REQUIRE(_dependencyMap[20]).VirtualizedListContext;

  var CellRenderer = function (_React$Component) {
    (0, _inherits2.default)(CellRenderer, _React$Component);

    var _super2 = _createSuper(CellRenderer);

    function CellRenderer() {
      var _this6;

      (0, _classCallCheck2.default)(this, CellRenderer);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this6 = _super2.call.apply(_super2, [this].concat(args));
      _this6.state = {
        separatorProps: {
          highlighted: false,
          leadingItem: _this6.props.item
        }
      };
      _this6._separators = {
        highlight: function highlight() {
          var _this6$props = _this6.props,
              cellKey = _this6$props.cellKey,
              prevCellKey = _this6$props.prevCellKey;

          _this6.props.onUpdateSeparators([cellKey, prevCellKey], {
            highlighted: true
          });
        },
        unhighlight: function unhighlight() {
          var _this6$props2 = _this6.props,
              cellKey = _this6$props2.cellKey,
              prevCellKey = _this6$props2.prevCellKey;

          _this6.props.onUpdateSeparators([cellKey, prevCellKey], {
            highlighted: false
          });
        },
        updateProps: function updateProps(select, newProps) {
          var _this6$props3 = _this6.props,
              cellKey = _this6$props3.cellKey,
              prevCellKey = _this6$props3.prevCellKey;

          _this6.props.onUpdateSeparators([select === 'leading' ? prevCellKey : cellKey], newProps);
        }
      };
      return _this6;
    }

    (0, _createClass2.default)(CellRenderer, [{
      key: "updateSeparatorProps",
      value: function updateSeparatorProps(newProps) {
        this.setState(function (state) {
          return {
            separatorProps: (0, _extends2.default)({}, state.separatorProps, newProps)
          };
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.props.onUnmount(this.props.cellKey);
      }
    }, {
      key: "_renderElement",
      value: function _renderElement(renderItem, ListItemComponent, item, index) {
        if (renderItem && ListItemComponent) {
          console.warn("VirtualizedList: Both ListItemComponent and renderItem props are present. ListItemComponent will take precedence over renderItem.");
        }

        if (ListItemComponent) {
          return React.createElement(ListItemComponent, {
            item: item,
            index: index,
            separators: this._separators
          });
        }

        if (renderItem) {
          return renderItem({
            item: item,
            index: index,
            separators: this._separators
          });
        }

        _$$_REQUIRE(_dependencyMap[11])(false, 'VirtualizedList: Either ListItemComponent or renderItem props are required but none were found.');
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props12 = this.props,
            CellRendererComponent = _this$props12.CellRendererComponent,
            ItemSeparatorComponent = _this$props12.ItemSeparatorComponent,
            fillRateHelper = _this$props12.fillRateHelper,
            horizontal = _this$props12.horizontal,
            item = _this$props12.item,
            index = _this$props12.index,
            inversionStyle = _this$props12.inversionStyle,
            parentProps = _this$props12.parentProps;
        var renderItem = parentProps.renderItem,
            getItemLayout = parentProps.getItemLayout,
            ListItemComponent = parentProps.ListItemComponent;

        var element = this._renderElement(renderItem, ListItemComponent, item, index);

        var onLayout = getItemLayout && !parentProps.debug && !fillRateHelper.enabled() ? undefined : this.props.onLayout;
        var itemSeparator = ItemSeparatorComponent && React.createElement(ItemSeparatorComponent, this.state.separatorProps);
        var cellStyle = inversionStyle ? horizontal ? [styles.rowReverse, inversionStyle] : [styles.columnReverse, inversionStyle] : horizontal ? [styles.row, inversionStyle] : inversionStyle;
        var result = !CellRendererComponent ? React.createElement(_$$_REQUIRE(_dependencyMap[10]), {
          style: cellStyle,
          onLayout: onLayout
        }, element, itemSeparator) : React.createElement(CellRendererComponent, (0, _extends2.default)({}, this.props, {
          style: cellStyle,
          onLayout: onLayout
        }), element, itemSeparator);
        return React.createElement(_$$_REQUIRE(_dependencyMap[20]).VirtualizedListCellContextProvider, {
          cellKey: this.props.cellKey
        }, result);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(props, prevState) {
        return {
          separatorProps: (0, _extends2.default)({}, prevState.separatorProps, {
            leadingItem: props.item
          })
        };
      }
    }]);
    return CellRenderer;
  }(React.Component);

  function describeNestedLists(childList) {
    var trace = 'VirtualizedList trace:\n' + ("  Child (" + (childList.horizontal ? 'horizontal' : 'vertical') + "):\n") + ("    listKey: " + childList.key + "\n") + ("    cellKey: " + childList.cellKey);
    var debugInfo = childList.parentDebugInfo;

    while (debugInfo) {
      trace += "\n  Parent (" + (debugInfo.horizontal ? 'horizontal' : 'vertical') + "):\n" + ("    listKey: " + debugInfo.listKey + "\n") + ("    cellKey: " + debugInfo.cellKey);
      debugInfo = debugInfo.parent;
    }

    return trace;
  }

  var styles = _$$_REQUIRE(_dependencyMap[21]).create({
    verticallyInverted: {
      transform: [{
        scaleY: -1
      }]
    },
    horizontallyInverted: {
      transform: [{
        scaleX: -1
      }]
    },
    row: {
      flexDirection: 'row'
    },
    rowReverse: {
      flexDirection: 'row-reverse'
    },
    columnReverse: {
      flexDirection: 'column-reverse'
    },
    debug: {
      flex: 1
    },
    debugOverlayBase: {
      position: 'absolute',
      top: 0,
      right: 0
    },
    debugOverlay: {
      bottom: 0,
      width: 20,
      borderColor: 'blue',
      borderWidth: 1
    },
    debugOverlayFrame: {
      left: 0,
      backgroundColor: 'orange'
    },
    debugOverlayFrameLast: {
      left: 0,
      borderColor: 'green',
      borderWidth: 2
    },
    debugOverlayFrameVis: {
      left: 0,
      borderColor: 'red',
      borderWidth: 2
    }
  });

  module.exports = VirtualizedList;
},"node_modules/react-native/Libraries/Lists/VirtualizedList.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/defineProperty.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/assertThisInitialized.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react/index.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js","node_modules/react-native/Libraries/Components/RefreshControl/RefreshControl.js","node_modules/react-native/Libraries/Utilities/infoLog.js","node_modules/react-native/Libraries/Lists/VirtualizeUtils.js","node_modules/react-native/Libraries/Lists/FillRateHelper.js","node_modules/react-native/Libraries/Interaction/Batchinator.js","node_modules/react-native/Libraries/Lists/ViewabilityHelper.js","node_modules/react-native/Libraries/Renderer/shims/ReactNative.js","node_modules/react-native/Libraries/Lists/VirtualizedListContext.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _assertThisInitialized2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _AnimatedImplementation = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _Dimensions = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[12]));

  var _ReactNative = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[13]));

  var _ScrollViewStickyHeader = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[14]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[15]));

  var _View = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[16]));

  var _UIManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[17]));

  var _Keyboard = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[18]));

  var _FrameRateLogger = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[19]));

  var _TextInputState = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[20]));

  var _dismissKeyboard = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[21]));

  var _flattenStyle = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[22]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[23]));

  var _processDecelerationRate = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[24]));

  var _splitLayoutProps2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[25]));

  var _setAndForwardRef = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[26]));

  var _ScrollViewContext = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[27]));

  var _ScrollViewCommands = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[28]));

  var _AndroidHorizontalScrollContentViewNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[29]));

  var _AndroidHorizontalScrollViewNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[30]));

  var _ScrollContentViewNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[31]));

  var _ScrollViewNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[32]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  _$$_REQUIRE(_dependencyMap[13]);

  var _ref = _Platform.default.OS === 'android' ? {
    NativeHorizontalScrollViewTuple: [_AndroidHorizontalScrollViewNativeComponent.default, _AndroidHorizontalScrollContentViewNativeComponent.default],
    NativeVerticalScrollViewTuple: [_ScrollViewNativeComponent.default, _View.default]
  } : {
    NativeHorizontalScrollViewTuple: [_ScrollViewNativeComponent.default, _ScrollContentViewNativeComponent.default],
    NativeVerticalScrollViewTuple: [_ScrollViewNativeComponent.default, _ScrollContentViewNativeComponent.default]
  },
      NativeHorizontalScrollViewTuple = _ref.NativeHorizontalScrollViewTuple,
      NativeVerticalScrollViewTuple = _ref.NativeVerticalScrollViewTuple;

  var IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;

  var ScrollView = function (_React$Component) {
    (0, _inherits2.default)(ScrollView, _React$Component);

    var _super = _createSuper(ScrollView);

    function ScrollView(props) {
      var _this$props$contentOf, _this$props$contentOf2, _this$props$contentIn, _this$props$contentIn2;

      var _this;

      (0, _classCallCheck2.default)(this, ScrollView);
      _this = _super.call(this, props);
      _this._scrollAnimatedValueAttachment = null;
      _this._stickyHeaderRefs = new Map();
      _this._headerLayoutYs = new Map();
      _this._keyboardWillOpenTo = null;
      _this._additionalScrollOffset = 0;
      _this._isTouching = false;
      _this._lastMomentumScrollBeginTime = 0;
      _this._lastMomentumScrollEndTime = 0;
      _this._observedScrollSinceBecomingResponder = false;
      _this._becameResponderWhileAnimating = false;
      _this._preventNegativeScrollOffset = null;
      _this._animated = null;
      _this._subscriptionKeyboardWillShow = null;
      _this._subscriptionKeyboardWillHide = null;
      _this._subscriptionKeyboardDidShow = null;
      _this._subscriptionKeyboardDidHide = null;
      _this.state = {
        layoutHeight: null
      };
      _this._setNativeRef = (0, _setAndForwardRef.default)({
        getForwardedRef: function getForwardedRef() {
          return _this.props.scrollViewRef;
        },
        setLocalRef: function setLocalRef(ref) {
          _this._scrollViewRef = ref;

          if (ref) {
            ref.getScrollResponder = _this.getScrollResponder;
            ref.getScrollableNode = _this.getScrollableNode;
            ref.getInnerViewNode = _this.getInnerViewNode;
            ref.getInnerViewRef = _this.getInnerViewRef;
            ref.getNativeScrollRef = _this.getNativeScrollRef;
            ref.scrollTo = _this.scrollTo;
            ref.scrollToEnd = _this.scrollToEnd;
            ref.flashScrollIndicators = _this.flashScrollIndicators;
            ref.scrollResponderZoomTo = _this.scrollResponderZoomTo;
            ref.scrollResponderScrollNativeHandleToKeyboard = _this.scrollResponderScrollNativeHandleToKeyboard;
          }
        }
      });

      _this.getScrollResponder = function () {
        return (0, _assertThisInitialized2.default)(_this);
      };

      _this.getScrollableNode = function () {
        return _ReactNative.default.findNodeHandle(_this._scrollViewRef);
      };

      _this.getInnerViewNode = function () {
        return _ReactNative.default.findNodeHandle(_this._innerViewRef);
      };

      _this.getInnerViewRef = function () {
        return _this._innerViewRef;
      };

      _this.getNativeScrollRef = function () {
        return _this._scrollViewRef;
      };

      _this.scrollTo = function (options, deprecatedX, deprecatedAnimated) {
        var x, y, animated;

        if (typeof options === 'number') {
          console.warn("`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead.");
          y = options;
          x = deprecatedX;
          animated = deprecatedAnimated;
        } else if (options) {
          y = options.y;
          x = options.x;
          animated = options.animated;
        }

        if (_this._scrollViewRef == null) {
          return;
        }

        _ScrollViewCommands.default.scrollTo(_this._scrollViewRef, x || 0, y || 0, animated !== false);
      };

      _this.scrollToEnd = function (options) {
        var animated = (options && options.animated) !== false;

        if (_this._scrollViewRef == null) {
          return;
        }

        _ScrollViewCommands.default.scrollToEnd(_this._scrollViewRef, animated);
      };

      _this.flashScrollIndicators = function () {
        if (_this._scrollViewRef == null) {
          return;
        }

        _ScrollViewCommands.default.flashScrollIndicators(_this._scrollViewRef);
      };

      _this.scrollResponderScrollNativeHandleToKeyboard = function (nodeHandle, additionalOffset, preventNegativeScrollOffset) {
        _this._additionalScrollOffset = additionalOffset || 0;
        _this._preventNegativeScrollOffset = !!preventNegativeScrollOffset;

        if (_this._innerViewRef == null) {
          return;
        }

        if (typeof nodeHandle === 'number') {
          _UIManager.default.measureLayout(nodeHandle, _ReactNative.default.findNodeHandle((0, _assertThisInitialized2.default)(_this)), _this._textInputFocusError, _this._inputMeasureAndScrollToKeyboard);
        } else {
          nodeHandle.measureLayout(_this._innerViewRef, _this._inputMeasureAndScrollToKeyboard, _this._textInputFocusError);
        }
      };

      _this.scrollResponderZoomTo = function (rect, animated) {
        (0, _invariant.default)(_Platform.default.OS === 'ios', 'zoomToRect is not implemented');

        if ('animated' in rect) {
          _this._animated = rect.animated;
          delete rect.animated;
        } else if (typeof animated !== 'undefined') {
          console.warn('`scrollResponderZoomTo` `animated` argument is deprecated. Use `options.animated` instead');
        }

        if (_this._scrollViewRef == null) {
          return;
        }

        _ScrollViewCommands.default.zoomToRect(_this._scrollViewRef, rect, animated !== false);
      };

      _this._inputMeasureAndScrollToKeyboard = function (left, top, width, height) {
        var keyboardScreenY = _Dimensions.default.get('window').height;

        var scrollTextInputIntoVisibleRect = function scrollTextInputIntoVisibleRect() {
          if (_this._keyboardWillOpenTo != null) {
            keyboardScreenY = _this._keyboardWillOpenTo.endCoordinates.screenY;
          }

          var scrollOffsetY = top - keyboardScreenY + height + _this._additionalScrollOffset;

          if (_this._preventNegativeScrollOffset === true) {
            scrollOffsetY = Math.max(0, scrollOffsetY);
          }

          _this.scrollTo({
            x: 0,
            y: scrollOffsetY,
            animated: true
          });

          _this._additionalScrollOffset = 0;
          _this._preventNegativeScrollOffset = false;
        };

        if (_this._keyboardWillOpenTo == null) {
          setTimeout(function () {
            scrollTextInputIntoVisibleRect();
          }, 0);
        } else {
          scrollTextInputIntoVisibleRect();
        }
      };

      _this._handleScroll = function (e) {
        _this._observedScrollSinceBecomingResponder = true;
        _this.props.onScroll && _this.props.onScroll(e);
      };

      _this._handleLayout = function (e) {
        if (_this.props.invertStickyHeaders === true) {
          _this.setState({
            layoutHeight: e.nativeEvent.layout.height
          });
        }

        if (_this.props.onLayout) {
          _this.props.onLayout(e);
        }
      };

      _this._handleContentOnLayout = function (e) {
        var _e$nativeEvent$layout = e.nativeEvent.layout,
            width = _e$nativeEvent$layout.width,
            height = _e$nativeEvent$layout.height;
        _this.props.onContentSizeChange && _this.props.onContentSizeChange(width, height);
      };

      _this._scrollViewRef = null;
      _this._innerViewRef = null;
      _this._setInnerViewRef = (0, _setAndForwardRef.default)({
        getForwardedRef: function getForwardedRef() {
          return _this.props.innerViewRef;
        },
        setLocalRef: function setLocalRef(ref) {
          _this._innerViewRef = ref;
        }
      });

      _this.scrollResponderKeyboardWillShow = function (e) {
        _this._keyboardWillOpenTo = e;
        _this.props.onKeyboardWillShow && _this.props.onKeyboardWillShow(e);
      };

      _this.scrollResponderKeyboardWillHide = function (e) {
        _this._keyboardWillOpenTo = null;
        _this.props.onKeyboardWillHide && _this.props.onKeyboardWillHide(e);
      };

      _this.scrollResponderKeyboardDidShow = function (e) {
        if (e) {
          _this._keyboardWillOpenTo = e;
        }

        _this.props.onKeyboardDidShow && _this.props.onKeyboardDidShow(e);
      };

      _this.scrollResponderKeyboardDidHide = function (e) {
        _this._keyboardWillOpenTo = null;
        _this.props.onKeyboardDidHide && _this.props.onKeyboardDidHide(e);
      };

      _this._handleMomentumScrollBegin = function (e) {
        _this._lastMomentumScrollBeginTime = global.performance.now();
        _this.props.onMomentumScrollBegin && _this.props.onMomentumScrollBegin(e);
      };

      _this._handleMomentumScrollEnd = function (e) {
        _FrameRateLogger.default.endScroll();

        _this._lastMomentumScrollEndTime = global.performance.now();
        _this.props.onMomentumScrollEnd && _this.props.onMomentumScrollEnd(e);
      };

      _this._handleScrollBeginDrag = function (e) {
        _FrameRateLogger.default.beginScroll();

        if (_Platform.default.OS === 'android' && _this.props.keyboardDismissMode === 'on-drag') {
          (0, _dismissKeyboard.default)();
        }

        _this.props.onScrollBeginDrag && _this.props.onScrollBeginDrag(e);
      };

      _this._handleScrollEndDrag = function (e) {
        var velocity = e.nativeEvent.velocity;

        if (!_this._isAnimating() && (!velocity || velocity.x === 0 && velocity.y === 0)) {
          _FrameRateLogger.default.endScroll();
        }

        _this.props.onScrollEndDrag && _this.props.onScrollEndDrag(e);
      };

      _this._isAnimating = function () {
        var now = global.performance.now();
        var timeSinceLastMomentumScrollEnd = now - _this._lastMomentumScrollEndTime;
        var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || _this._lastMomentumScrollEndTime < _this._lastMomentumScrollBeginTime;
        return isAnimating;
      };

      _this._handleResponderGrant = function (e) {
        _this._observedScrollSinceBecomingResponder = false;
        _this.props.onResponderGrant && _this.props.onResponderGrant(e);
        _this._becameResponderWhileAnimating = _this._isAnimating();
      };

      _this._handleResponderReject = function () {};

      _this._handleResponderRelease = function (e) {
        _this._isTouching = e.nativeEvent.touches.length !== 0;
        _this.props.onResponderRelease && _this.props.onResponderRelease(e);

        if (typeof e.target === 'number') {
          return;
        }

        var currentlyFocusedTextInput = _TextInputState.default.currentlyFocusedInput();

        if (_this.props.keyboardShouldPersistTaps !== true && _this.props.keyboardShouldPersistTaps !== 'always' && _this._keyboardIsDismissible() && e.target !== currentlyFocusedTextInput && !_this._observedScrollSinceBecomingResponder && !_this._becameResponderWhileAnimating) {
          _TextInputState.default.blurTextInput(currentlyFocusedTextInput);
        }
      };

      _this._handleResponderTerminationRequest = function () {
        return !_this._observedScrollSinceBecomingResponder;
      };

      _this._handleScrollShouldSetResponder = function () {
        if (_this.props.disableScrollViewPanResponder === true) {
          return false;
        }

        return _this._isTouching;
      };

      _this._handleStartShouldSetResponder = function (e) {
        if (_this.props.disableScrollViewPanResponder === true) {
          return false;
        }

        var currentlyFocusedInput = _TextInputState.default.currentlyFocusedInput();

        if (_this.props.keyboardShouldPersistTaps === 'handled' && _this._keyboardIsDismissible() && e.target !== currentlyFocusedInput) {
          return true;
        }

        return false;
      };

      _this._handleStartShouldSetResponderCapture = function (e) {
        if (_this._isAnimating()) {
          return true;
        }

        if (_this.props.disableScrollViewPanResponder === true) {
          return false;
        }

        var keyboardShouldPersistTaps = _this.props.keyboardShouldPersistTaps;
        var keyboardNeverPersistTaps = !keyboardShouldPersistTaps || keyboardShouldPersistTaps === 'never';

        if (typeof e.target === 'number') {
          return false;
        }

        if (keyboardNeverPersistTaps && _this._keyboardIsDismissible() && e.target != null && !_TextInputState.default.isTextInput(e.target)) {
          return true;
        }

        return false;
      };

      _this._keyboardIsDismissible = function () {
        var currentlyFocusedInput = _TextInputState.default.currentlyFocusedInput();

        var hasFocusedTextInput = currentlyFocusedInput != null && _TextInputState.default.isTextInput(currentlyFocusedInput);

        var softKeyboardMayBeOpen = _this._keyboardWillOpenTo != null || _Platform.default.OS === 'android';
        return hasFocusedTextInput && softKeyboardMayBeOpen;
      };

      _this._handleTouchEnd = function (e) {
        var nativeEvent = e.nativeEvent;
        _this._isTouching = nativeEvent.touches.length !== 0;
        _this.props.onTouchEnd && _this.props.onTouchEnd(e);
      };

      _this._handleTouchCancel = function (e) {
        _this._isTouching = false;
        _this.props.onTouchCancel && _this.props.onTouchCancel(e);
      };

      _this._handleTouchStart = function (e) {
        _this._isTouching = true;
        _this.props.onTouchStart && _this.props.onTouchStart(e);
      };

      _this._handleTouchMove = function (e) {
        _this.props.onTouchMove && _this.props.onTouchMove(e);
      };

      _this._scrollAnimatedValue = new _AnimatedImplementation.default.Value((_this$props$contentOf = (_this$props$contentOf2 = _this.props.contentOffset) == null ? undefined : _this$props$contentOf2.y) != null ? _this$props$contentOf : 0);

      _this._scrollAnimatedValue.setOffset((_this$props$contentIn = (_this$props$contentIn2 = _this.props.contentInset) == null ? undefined : _this$props$contentIn2.top) != null ? _this$props$contentIn : 0);

      return _this;
    }

    (0, _createClass2.default)(ScrollView, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        if (typeof this.props.keyboardShouldPersistTaps === 'boolean') {
          console.warn("'keyboardShouldPersistTaps={" + (this.props.keyboardShouldPersistTaps === true ? 'true' : 'false') + "}' is deprecated. " + ("Use 'keyboardShouldPersistTaps=\"" + (this.props.keyboardShouldPersistTaps ? 'always' : 'never') + "\"' instead"));
        }

        this._keyboardWillOpenTo = null;
        this._additionalScrollOffset = 0;
        this._subscriptionKeyboardWillShow = _Keyboard.default.addListener('keyboardWillShow', this.scrollResponderKeyboardWillShow);
        this._subscriptionKeyboardWillHide = _Keyboard.default.addListener('keyboardWillHide', this.scrollResponderKeyboardWillHide);
        this._subscriptionKeyboardDidShow = _Keyboard.default.addListener('keyboardDidShow', this.scrollResponderKeyboardDidShow);
        this._subscriptionKeyboardDidHide = _Keyboard.default.addListener('keyboardDidHide', this.scrollResponderKeyboardDidHide);

        this._updateAnimatedNodeAttachment();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var prevContentInsetTop = prevProps.contentInset ? prevProps.contentInset.top : 0;
        var newContentInsetTop = this.props.contentInset ? this.props.contentInset.top : 0;

        if (prevContentInsetTop !== newContentInsetTop) {
          this._scrollAnimatedValue.setOffset(newContentInsetTop || 0);
        }

        this._updateAnimatedNodeAttachment();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._subscriptionKeyboardWillShow != null) {
          this._subscriptionKeyboardWillShow.remove();
        }

        if (this._subscriptionKeyboardWillHide != null) {
          this._subscriptionKeyboardWillHide.remove();
        }

        if (this._subscriptionKeyboardDidShow != null) {
          this._subscriptionKeyboardDidShow.remove();
        }

        if (this._subscriptionKeyboardDidHide != null) {
          this._subscriptionKeyboardDidHide.remove();
        }

        if (this._scrollAnimatedValueAttachment) {
          this._scrollAnimatedValueAttachment.detach();
        }
      }
    }, {
      key: "_textInputFocusError",
      value: function _textInputFocusError() {
        console.warn('Error measuring text field.');
      }
    }, {
      key: "_getKeyForIndex",
      value: function _getKeyForIndex(index, childArray) {
        var child = childArray[index];
        return child && child.key;
      }
    }, {
      key: "_updateAnimatedNodeAttachment",
      value: function _updateAnimatedNodeAttachment() {
        if (this._scrollAnimatedValueAttachment) {
          this._scrollAnimatedValueAttachment.detach();
        }

        if (this.props.stickyHeaderIndices && this.props.stickyHeaderIndices.length > 0) {
          this._scrollAnimatedValueAttachment = _AnimatedImplementation.default.attachNativeEvent(this._scrollViewRef, 'onScroll', [{
            nativeEvent: {
              contentOffset: {
                y: this._scrollAnimatedValue
              }
            }
          }]);
        }
      }
    }, {
      key: "_setStickyHeaderRef",
      value: function _setStickyHeaderRef(key, ref) {
        if (ref) {
          this._stickyHeaderRefs.set(key, ref);
        } else {
          this._stickyHeaderRefs.delete(key);
        }
      }
    }, {
      key: "_onStickyHeaderLayout",
      value: function _onStickyHeaderLayout(index, event, key) {
        var stickyHeaderIndices = this.props.stickyHeaderIndices;

        if (!stickyHeaderIndices) {
          return;
        }

        var childArray = React.Children.toArray(this.props.children);

        if (key !== this._getKeyForIndex(index, childArray)) {
          return;
        }

        var layoutY = event.nativeEvent.layout.y;

        this._headerLayoutYs.set(key, layoutY);

        var indexOfIndex = stickyHeaderIndices.indexOf(index);
        var previousHeaderIndex = stickyHeaderIndices[indexOfIndex - 1];

        if (previousHeaderIndex != null) {
          var previousHeader = this._stickyHeaderRefs.get(this._getKeyForIndex(previousHeaderIndex, childArray));

          previousHeader && previousHeader.setNextHeaderY && previousHeader.setNextHeaderY(layoutY);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _ref2 = this.props.horizontal === true ? NativeHorizontalScrollViewTuple : NativeVerticalScrollViewTuple,
            _ref3 = (0, _slicedToArray2.default)(_ref2, 2),
            NativeDirectionalScrollView = _ref3[0],
            NativeDirectionalScrollContentView = _ref3[1];

        var contentContainerStyle = [this.props.horizontal === true && styles.contentContainerHorizontal, this.props.contentContainerStyle];
        var contentSizeChangeProps = this.props.onContentSizeChange == null ? null : {
          onLayout: this._handleContentOnLayout
        };
        var stickyHeaderIndices = this.props.stickyHeaderIndices;
        var children = this.props.children;

        if (stickyHeaderIndices != null && stickyHeaderIndices.length > 0) {
          var childArray = React.Children.toArray(this.props.children);
          children = childArray.map(function (child, index) {
            var indexOfIndex = child ? stickyHeaderIndices.indexOf(index) : -1;

            if (indexOfIndex > -1) {
              var key = child.key;
              var nextIndex = stickyHeaderIndices[indexOfIndex + 1];
              var StickyHeaderComponent = _this2.props.StickyHeaderComponent || _ScrollViewStickyHeader.default;
              return React.createElement(StickyHeaderComponent, {
                key: key,
                nativeID: 'StickyHeader-' + key,
                ref: function ref(_ref4) {
                  return _this2._setStickyHeaderRef(key, _ref4);
                },
                nextHeaderLayoutY: _this2._headerLayoutYs.get(_this2._getKeyForIndex(nextIndex, childArray)),
                onLayout: function onLayout(event) {
                  return _this2._onStickyHeaderLayout(index, event, key);
                },
                scrollAnimatedValue: _this2._scrollAnimatedValue,
                inverted: _this2.props.invertStickyHeaders,
                hiddenOnScroll: _this2.props.stickyHeaderHiddenOnScroll,
                scrollViewHeight: _this2.state.layoutHeight
              }, child);
            } else {
              return child;
            }
          });
        }

        children = React.createElement(_ScrollViewContext.default.Provider, {
          value: this.props.horizontal === true ? _ScrollViewContext.HORIZONTAL : _ScrollViewContext.VERTICAL
        }, children);
        var hasStickyHeaders = Array.isArray(stickyHeaderIndices) && stickyHeaderIndices.length > 0;
        var contentContainer = React.createElement(NativeDirectionalScrollContentView, (0, _extends2.default)({}, contentSizeChangeProps, {
          ref: this._setInnerViewRef,
          style: contentContainerStyle,
          removeClippedSubviews: _Platform.default.OS === 'android' && hasStickyHeaders ? false : this.props.removeClippedSubviews,
          collapsable: false
        }), children);
        var alwaysBounceHorizontal = this.props.alwaysBounceHorizontal !== undefined ? this.props.alwaysBounceHorizontal : this.props.horizontal;
        var alwaysBounceVertical = this.props.alwaysBounceVertical !== undefined ? this.props.alwaysBounceVertical : !this.props.horizontal;
        var baseStyle = this.props.horizontal === true ? styles.baseHorizontal : styles.baseVertical;
        var props = (0, _extends2.default)({}, this.props, {
          alwaysBounceHorizontal: alwaysBounceHorizontal,
          alwaysBounceVertical: alwaysBounceVertical,
          style: _StyleSheet.default.compose(baseStyle, this.props.style),
          onContentSizeChange: null,
          onLayout: this._handleLayout,
          onMomentumScrollBegin: this._handleMomentumScrollBegin,
          onMomentumScrollEnd: this._handleMomentumScrollEnd,
          onResponderGrant: this._handleResponderGrant,
          onResponderReject: this._handleResponderReject,
          onResponderRelease: this._handleResponderRelease,
          onResponderTerminationRequest: this._handleResponderTerminationRequest,
          onScrollBeginDrag: this._handleScrollBeginDrag,
          onScrollEndDrag: this._handleScrollEndDrag,
          onScrollShouldSetResponder: this._handleScrollShouldSetResponder,
          onStartShouldSetResponder: this._handleStartShouldSetResponder,
          onStartShouldSetResponderCapture: this._handleStartShouldSetResponderCapture,
          onTouchEnd: this._handleTouchEnd,
          onTouchMove: this._handleTouchMove,
          onTouchStart: this._handleTouchStart,
          onTouchCancel: this._handleTouchCancel,
          onScroll: this._handleScroll,
          scrollEventThrottle: hasStickyHeaders ? 1 : this.props.scrollEventThrottle,
          sendMomentumEvents: this.props.onMomentumScrollBegin || this.props.onMomentumScrollEnd ? true : false,
          snapToStart: this.props.snapToStart !== false,
          snapToEnd: this.props.snapToEnd !== false,
          pagingEnabled: _Platform.default.select({
            ios: this.props.pagingEnabled === true && this.props.snapToInterval == null && this.props.snapToOffsets == null,
            android: this.props.pagingEnabled === true || this.props.snapToInterval != null || this.props.snapToOffsets != null
          })
        });
        var decelerationRate = this.props.decelerationRate;

        if (decelerationRate != null) {
          props.decelerationRate = (0, _processDecelerationRate.default)(decelerationRate);
        }

        var refreshControl = this.props.refreshControl;

        if (refreshControl) {
          if (_Platform.default.OS === 'ios') {
            return React.createElement(NativeDirectionalScrollView, (0, _extends2.default)({}, props, {
              ref: this._setNativeRef
            }), refreshControl, contentContainer);
          } else if (_Platform.default.OS === 'android') {
            var _splitLayoutProps = (0, _splitLayoutProps2.default)((0, _flattenStyle.default)(props.style)),
                outer = _splitLayoutProps.outer,
                inner = _splitLayoutProps.inner;

            return React.cloneElement(refreshControl, {
              style: _StyleSheet.default.compose(baseStyle, outer)
            }, React.createElement(NativeDirectionalScrollView, (0, _extends2.default)({}, props, {
              style: _StyleSheet.default.compose(baseStyle, inner),
              ref: this._setNativeRef
            }), contentContainer));
          }
        }

        return React.createElement(NativeDirectionalScrollView, (0, _extends2.default)({}, props, {
          ref: this._setNativeRef
        }), contentContainer);
      }
    }]);
    return ScrollView;
  }(React.Component);

  ScrollView.Context = _ScrollViewContext.default;

  var styles = _StyleSheet.default.create({
    baseVertical: {
      flexGrow: 1,
      flexShrink: 1,
      flexDirection: 'column',
      overflow: 'scroll'
    },
    baseHorizontal: {
      flexGrow: 1,
      flexShrink: 1,
      flexDirection: 'row',
      overflow: 'scroll'
    },
    contentContainerHorizontal: {
      flexDirection: 'row'
    }
  });

  function Wrapper(props, ref) {
    return React.createElement(ScrollView, (0, _extends2.default)({}, props, {
      scrollViewRef: ref
    }));
  }

  Wrapper.displayName = 'ScrollView';
  var ForwardedScrollView = React.forwardRef(Wrapper);
  ForwardedScrollView.Context = _ScrollViewContext.default;
  ForwardedScrollView.displayName = 'ScrollView';
  module.exports = ForwardedScrollView;
},"node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/assertThisInitialized.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Animated/AnimatedImplementation.js","node_modules/react-native/Libraries/Utilities/Dimensions.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react/index.js","node_modules/react-native/Libraries/Renderer/shims/ReactNative.js","node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/react-native/Libraries/ReactNative/UIManager.js","node_modules/react-native/Libraries/Components/Keyboard/Keyboard.js","node_modules/react-native/Libraries/Interaction/FrameRateLogger.js","node_modules/react-native/Libraries/Components/TextInput/TextInputState.js","node_modules/react-native/Libraries/Utilities/dismissKeyboard.js","node_modules/react-native/Libraries/StyleSheet/flattenStyle.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/Components/ScrollView/processDecelerationRate.js","node_modules/react-native/Libraries/StyleSheet/splitLayoutProps.js","node_modules/react-native/Libraries/Utilities/setAndForwardRef.js","node_modules/react-native/Libraries/Components/ScrollView/ScrollViewContext.js","node_modules/react-native/Libraries/Components/ScrollView/ScrollViewCommands.js","node_modules/react-native/Libraries/Components/ScrollView/AndroidHorizontalScrollContentViewNativeComponent.js","node_modules/react-native/Libraries/Components/ScrollView/AndroidHorizontalScrollViewNativeComponent.js","node_modules/react-native/Libraries/Components/ScrollView/ScrollContentViewNativeComponent.js","node_modules/react-native/Libraries/Components/ScrollView/ScrollViewNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _AnimatedImplementation = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _AnimatedAddition = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _AnimatedDiffClamp = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _AnimatedNode = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[10]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _View = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[13]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AnimatedView = _AnimatedImplementation.default.createAnimatedComponent(_View.default);

  var ScrollViewStickyHeader = function (_React$Component) {
    (0, _inherits2.default)(ScrollViewStickyHeader, _React$Component);

    var _super = _createSuper(ScrollViewStickyHeader);

    function ScrollViewStickyHeader() {
      var _this;

      (0, _classCallCheck2.default)(this, ScrollViewStickyHeader);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        measured: false,
        layoutY: 0,
        layoutHeight: 0,
        nextHeaderLayoutY: _this.props.nextHeaderLayoutY,
        translateY: null
      };
      _this._translateY = null;
      _this._shouldRecreateTranslateY = true;
      _this._haveReceivedInitialZeroTranslateY = true;
      _this._debounceTimeout = _Platform.default.OS === 'android' ? 15 : 64;

      _this.setNextHeaderY = function (y) {
        _this._shouldRecreateTranslateY = true;

        _this.setState({
          nextHeaderLayoutY: y
        });
      };

      _this._onLayout = function (event) {
        var layoutY = event.nativeEvent.layout.y;
        var layoutHeight = event.nativeEvent.layout.height;
        var measured = true;

        if (layoutY !== _this.state.layoutY || layoutHeight !== _this.state.layoutHeight || measured !== _this.state.measured) {
          _this._shouldRecreateTranslateY = true;
        }

        _this.setState({
          measured: measured,
          layoutY: layoutY,
          layoutHeight: layoutHeight
        });

        _this.props.onLayout(event);

        var child = React.Children.only(_this.props.children);

        if (child.props.onLayout) {
          child.props.onLayout(event);
        }
      };

      _this._setComponentRef = function (ref) {
        _this._ref = ref;
      };

      return _this;
    }

    (0, _createClass2.default)(ScrollViewStickyHeader, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._translateY != null && this._animatedValueListenerId != null) {
          this._translateY.removeListener(this._animatedValueListenerId);
        }

        if (this._timer) {
          clearTimeout(this._timer);
        }
      }
    }, {
      key: "UNSAFE_componentWillReceiveProps",
      value: function UNSAFE_componentWillReceiveProps(nextProps) {
        if (nextProps.scrollViewHeight !== this.props.scrollViewHeight || nextProps.scrollAnimatedValue !== this.props.scrollAnimatedValue || nextProps.inverted !== this.props.inverted) {
          this._shouldRecreateTranslateY = true;
        }
      }
    }, {
      key: "updateTranslateListener",
      value: function updateTranslateListener(translateY, isFabric, offset) {
        var _this2 = this;

        if (this._translateY != null && this._animatedValueListenerId != null) {
          this._translateY.removeListener(this._animatedValueListenerId);
        }

        offset ? this._translateY = new _AnimatedAddition.default(translateY, offset) : this._translateY = translateY;
        this._shouldRecreateTranslateY = false;

        if (!isFabric) {
          return;
        }

        if (!this._animatedValueListener) {
          this._animatedValueListener = function (_ref) {
            var value = _ref.value;

            if (value === 0 && !_this2._haveReceivedInitialZeroTranslateY) {
              _this2._haveReceivedInitialZeroTranslateY = true;
              return;
            }

            if (_this2._timer) {
              clearTimeout(_this2._timer);
            }

            _this2._timer = setTimeout(function () {
              if (value !== _this2.state.translateY) {
                _this2.setState({
                  translateY: value
                });
              }
            }, _this2._debounceTimeout);
          };
        }

        if (this.state.translateY !== 0 && this.state.translateY != null) {
          this._haveReceivedInitialZeroTranslateY = false;
        }

        this._animatedValueListenerId = translateY.addListener(this._animatedValueListener);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$_ref$_internalI, _this$_ref$_internalI2;

        var isFabric = !!(this._ref && (_this$_ref$_internalI = this._ref['_internalInstanceHandle']) != null && (_this$_ref$_internalI2 = _this$_ref$_internalI.stateNode) != null && _this$_ref$_internalI2.canonical);

        if (this._shouldRecreateTranslateY) {
          var _this$props = this.props,
              inverted = _this$props.inverted,
              scrollViewHeight = _this$props.scrollViewHeight;
          var _this$state = this.state,
              measured = _this$state.measured,
              layoutHeight = _this$state.layoutHeight,
              layoutY = _this$state.layoutY,
              nextHeaderLayoutY = _this$state.nextHeaderLayoutY;
          var inputRange = [-1, 0];
          var outputRange = [0, 0];

          if (measured) {
            if (inverted) {
              if (scrollViewHeight != null) {
                var stickStartPoint = layoutY + layoutHeight - scrollViewHeight;

                if (stickStartPoint > 0) {
                  inputRange.push(stickStartPoint);
                  outputRange.push(0);
                  inputRange.push(stickStartPoint + 1);
                  outputRange.push(1);
                  var collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;

                  if (collisionPoint > stickStartPoint) {
                    inputRange.push(collisionPoint, collisionPoint + 1);
                    outputRange.push(collisionPoint - stickStartPoint, collisionPoint - stickStartPoint);
                  }
                }
              }
            } else {
              inputRange.push(layoutY);
              outputRange.push(0);

              var _collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;

              if (_collisionPoint >= layoutY) {
                inputRange.push(_collisionPoint, _collisionPoint + 1);
                outputRange.push(_collisionPoint - layoutY, _collisionPoint - layoutY);
              } else {
                inputRange.push(layoutY + 1);
                outputRange.push(1);
              }
            }
          }

          this.updateTranslateListener(this.props.scrollAnimatedValue.interpolate({
            inputRange: inputRange,
            outputRange: outputRange
          }), isFabric, this.props.hiddenOnScroll ? new _AnimatedDiffClamp.default(this.props.scrollAnimatedValue.interpolate({
            extrapolateLeft: 'clamp',
            inputRange: [layoutY, layoutY + 1],
            outputRange: [0, 1]
          }).interpolate({
            inputRange: [0, 1],
            outputRange: [0, -1]
          }), -this.state.layoutHeight, 0) : null);
        }

        var child = React.Children.only(this.props.children);
        var passthroughAnimatedPropExplicitValues = isFabric && this.state.translateY != null ? {
          style: {
            transform: [{
              translateY: this.state.translateY
            }]
          }
        } : null;
        return React.createElement(AnimatedView, {
          collapsable: false,
          nativeID: this.props.nativeID,
          onLayout: this._onLayout,
          ref: this._setComponentRef,
          style: [child.props.style, styles.header, {
            transform: [{
              translateY: this._translateY
            }]
          }],
          passthroughAnimatedPropExplicitValues: passthroughAnimatedPropExplicitValues
        }, React.cloneElement(child, {
          style: styles.fill,
          onLayout: undefined
        }));
      }
    }]);
    return ScrollViewStickyHeader;
  }(React.Component);

  var styles = _StyleSheet.default.create({
    header: {
      zIndex: 10,
      position: 'relative'
    },
    fill: {
      flex: 1
    }
  });

  module.exports = ScrollViewStickyHeader;
},"node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Animated/AnimatedImplementation.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedAddition.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedDiffClamp.js","node_modules/react-native/Libraries/Animated/nodes/AnimatedNode.js","node_modules/react/index.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _NativeEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _LayoutAnimation = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _dismissKeyboard = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _NativeKeyboardObserver = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var Keyboard = function () {
    function Keyboard() {
      (0, _classCallCheck2.default)(this, Keyboard);
      this._emitter = new _NativeEventEmitter.default(_Platform.default.OS !== 'ios' ? null : _NativeKeyboardObserver.default);
    }

    (0, _createClass2.default)(Keyboard, [{
      key: "addListener",
      value: function addListener(eventType, listener, context) {
        return this._emitter.addListener(eventType, listener);
      }
    }, {
      key: "removeListener",
      value: function removeListener(eventType, listener) {
        this._emitter.removeListener(eventType, listener);
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners(eventType) {
        this._emitter.removeAllListeners(eventType);
      }
    }, {
      key: "dismiss",
      value: function dismiss() {
        (0, _dismissKeyboard.default)();
      }
    }, {
      key: "scheduleLayoutAnimation",
      value: function scheduleLayoutAnimation(event) {
        var duration = event.duration,
            easing = event.easing;

        if (duration != null && duration !== 0) {
          _LayoutAnimation.default.configureNext({
            duration: duration,
            update: {
              duration: duration,
              type: easing != null && _LayoutAnimation.default.Types[easing] || 'keyboard'
            }
          });
        }
      }
    }]);
    return Keyboard;
  }();

  module.exports = new Keyboard();
},"node_modules/react-native/Libraries/Components/Keyboard/Keyboard.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/EventEmitter/NativeEventEmitter.js","node_modules/react-native/Libraries/LayoutAnimation/LayoutAnimation.js","node_modules/react-native/Libraries/Utilities/dismissKeyboard.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/Components/Keyboard/NativeKeyboardObserver.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  function configureNext(config, onAnimationDidEnd, onAnimationDidFail) {
    var _config$duration, _global;

    if (_Platform.default.isTesting) {
      return;
    }

    var animationCompletionHasRun = false;

    var onAnimationComplete = function onAnimationComplete() {
      if (animationCompletionHasRun) {
        return;
      }

      animationCompletionHasRun = true;
      clearTimeout(raceWithAnimationId);
      onAnimationDidEnd == null ? undefined : onAnimationDidEnd();
    };

    var raceWithAnimationId = setTimeout(onAnimationComplete, ((_config$duration = config.duration) != null ? _config$duration : 0) + 17);
    var FabricUIManager = (_global = global) == null ? undefined : _global.nativeFabricUIManager;

    if (FabricUIManager != null && FabricUIManager.configureNextLayoutAnimation) {
      var _global2, _global2$nativeFabric;

      (_global2 = global) == null ? undefined : (_global2$nativeFabric = _global2.nativeFabricUIManager) == null ? undefined : _global2$nativeFabric.configureNextLayoutAnimation(config, onAnimationComplete, onAnimationDidFail != null ? onAnimationDidFail : function () {});
      return;
    }

    if (_$$_REQUIRE(_dependencyMap[2]) != null && _$$_REQUIRE(_dependencyMap[2]).configureNextLayoutAnimation) {
      _$$_REQUIRE(_dependencyMap[2]).configureNextLayoutAnimation(config, onAnimationComplete != null ? onAnimationComplete : function () {}, onAnimationDidFail != null ? onAnimationDidFail : function () {});
    }
  }

  function create(duration, type, property) {
    return {
      duration: duration,
      create: {
        type: type,
        property: property
      },
      update: {
        type: type
      },
      delete: {
        type: type,
        property: property
      }
    };
  }

  var Presets = {
    easeInEaseOut: create(300, 'easeInEaseOut', 'opacity'),
    linear: create(500, 'linear', 'opacity'),
    spring: {
      duration: 700,
      create: {
        type: 'linear',
        property: 'opacity'
      },
      update: {
        type: 'spring',
        springDamping: 0.4
      },
      delete: {
        type: 'linear',
        property: 'opacity'
      }
    }
  };
  var LayoutAnimation = {
    configureNext: configureNext,
    create: create,
    Types: Object.freeze({
      spring: 'spring',
      linear: 'linear',
      easeInEaseOut: 'easeInEaseOut',
      easeIn: 'easeIn',
      easeOut: 'easeOut',
      keyboard: 'keyboard'
    }),
    Properties: Object.freeze({
      opacity: 'opacity',
      scaleX: 'scaleX',
      scaleY: 'scaleY',
      scaleXY: 'scaleXY'
    }),
    checkConfig: function checkConfig() {
      console.error('LayoutAnimation.checkConfig(...) has been disabled.');
    },
    Presets: Presets,
    easeInEaseOut: configureNext.bind(null, Presets.easeInEaseOut),
    linear: configureNext.bind(null, Presets.linear),
    spring: configureNext.bind(null, Presets.spring)
  };
  module.exports = LayoutAnimation;
},"node_modules/react-native/Libraries/LayoutAnimation/LayoutAnimation.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/ReactNative/UIManager.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function dismissKeyboard() {
    _$$_REQUIRE(_dependencyMap[0]).blurTextInput(_$$_REQUIRE(_dependencyMap[0]).currentlyFocusedInput());
  }

  module.exports = dismissKeyboard;
},"node_modules/react-native/Libraries/Utilities/dismissKeyboard.js",["node_modules/react-native/Libraries/Components/TextInput/TextInputState.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('KeyboardObserver');

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/Keyboard/NativeKeyboardObserver.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _NativeFrameRateLogger = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var FrameRateLogger = {
    setGlobalOptions: function setGlobalOptions(options) {
      if (options.debug !== undefined) {
        _$$_REQUIRE(_dependencyMap[2])(_NativeFrameRateLogger.default, 'Trying to debug FrameRateLogger without the native module!');
      }

      if (_NativeFrameRateLogger.default) {
        var optionsClone = {
          debug: !!options.debug,
          reportStackTraces: !!options.reportStackTraces
        };

        _NativeFrameRateLogger.default.setGlobalOptions(optionsClone);
      }
    },
    setContext: function setContext(context) {
      _NativeFrameRateLogger.default && _NativeFrameRateLogger.default.setContext(context);
    },
    beginScroll: function beginScroll() {
      _NativeFrameRateLogger.default && _NativeFrameRateLogger.default.beginScroll();
    },
    endScroll: function endScroll() {
      _NativeFrameRateLogger.default && _NativeFrameRateLogger.default.endScroll();
    }
  };
  module.exports = FrameRateLogger;
},"node_modules/react-native/Libraries/Interaction/FrameRateLogger.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Interaction/NativeFrameRateLogger.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('FrameRateLogger');

  exports.default = _default;
},"node_modules/react-native/Libraries/Interaction/NativeFrameRateLogger.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  function processDecelerationRate(decelerationRate) {
    if (decelerationRate === 'normal') {
      return _Platform.default.select({
        ios: 0.998,
        android: 0.985
      });
    } else if (decelerationRate === 'fast') {
      return _Platform.default.select({
        ios: 0.99,
        android: 0.9
      });
    }

    return decelerationRate;
  }

  module.exports = processDecelerationRate;
},"node_modules/react-native/Libraries/Components/ScrollView/processDecelerationRate.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = splitLayoutProps;

  function splitLayoutProps(props) {
    var outer = null;
    var inner = null;

    if (props != null) {
      outer = {};
      inner = {};

      for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
        var prop = _Object$keys[_i];

        switch (prop) {
          case 'margin':
          case 'marginHorizontal':
          case 'marginVertical':
          case 'marginBottom':
          case 'marginTop':
          case 'marginLeft':
          case 'marginRight':
          case 'flex':
          case 'flexGrow':
          case 'flexShrink':
          case 'flexBasis':
          case 'alignSelf':
          case 'height':
          case 'minHeight':
          case 'maxHeight':
          case 'width':
          case 'minWidth':
          case 'maxWidth':
          case 'position':
          case 'left':
          case 'right':
          case 'bottom':
          case 'top':
          case 'transform':
            outer[prop] = props[prop];
            break;

          default:
            inner[prop] = props[prop];
            break;
        }
      }
    }

    return {
      outer: outer,
      inner: inner
    };
  }
},"node_modules/react-native/Libraries/StyleSheet/splitLayoutProps.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.VERTICAL = exports.HORIZONTAL = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var ScrollViewContext = React.createContext(null);
  var _default = ScrollViewContext;
  exports.default = _default;
  var HORIZONTAL = Object.freeze({
    horizontal: true
  });
  exports.HORIZONTAL = HORIZONTAL;
  var VERTICAL = Object.freeze({
    horizontal: false
  });
  exports.VERTICAL = VERTICAL;
},"node_modules/react-native/Libraries/Components/ScrollView/ScrollViewContext.js",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _codegenNativeCommands = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = (0, _codegenNativeCommands.default)({
    supportedCommands: ['flashScrollIndicators', 'scrollTo', 'scrollToEnd', 'zoomToRect']
  });

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/ScrollView/ScrollViewCommands.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeCommands.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _default = (0, _codegenNativeComponent.default)('AndroidHorizontalScrollContentView');

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/ScrollView/AndroidHorizontalScrollContentViewNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var NativeComponentRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var AndroidHorizontalScrollViewNativeComponent = NativeComponentRegistry.get('AndroidHorizontalScrollView', function () {
    return {
      uiViewClassName: 'AndroidHorizontalScrollView',
      bubblingEventTypes: {},
      directEventTypes: {},
      validAttributes: {
        decelerationRate: true,
        disableIntervalMomentum: true,
        endFillColor: {
          process: _$$_REQUIRE(_dependencyMap[1])
        },
        fadingEdgeLength: true,
        nestedScrollEnabled: true,
        overScrollMode: true,
        pagingEnabled: true,
        persistentScrollbar: true,
        scrollEnabled: true,
        scrollPerfTag: true,
        sendMomentumEvents: true,
        showsHorizontalScrollIndicator: true,
        snapToAlignment: true,
        snapToEnd: true,
        snapToInterval: true,
        snapToStart: true,
        snapToOffsets: true,
        contentOffset: true,
        borderBottomLeftRadius: true,
        borderBottomRightRadius: true,
        borderRadius: true,
        borderStyle: true,
        borderRightColor: {
          process: _$$_REQUIRE(_dependencyMap[1])
        },
        borderColor: {
          process: _$$_REQUIRE(_dependencyMap[1])
        },
        borderBottomColor: {
          process: _$$_REQUIRE(_dependencyMap[1])
        },
        borderTopLeftRadius: true,
        borderTopColor: {
          process: _$$_REQUIRE(_dependencyMap[1])
        },
        removeClippedSubviews: true,
        borderTopRightRadius: true,
        borderLeftColor: {
          process: _$$_REQUIRE(_dependencyMap[1])
        }
      }
    };
  });
  var _default = AndroidHorizontalScrollViewNativeComponent;
  exports.default = _default;
},"node_modules/react-native/Libraries/Components/ScrollView/AndroidHorizontalScrollViewNativeComponent.js",["node_modules/react-native/Libraries/NativeComponent/NativeComponentRegistry.js","node_modules/react-native/Libraries/StyleSheet/processColor.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var NativeComponentRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var ScrollContentViewNativeComponent = NativeComponentRegistry.get('RCTScrollContentView', function () {
    return {
      uiViewClassName: 'RCTScrollContentView',
      bubblingEventTypes: {},
      directEventTypes: {},
      validAttributes: {}
    };
  });
  var _default = ScrollContentViewNativeComponent;
  exports.default = _default;
},"node_modules/react-native/Libraries/Components/ScrollView/ScrollContentViewNativeComponent.js",["node_modules/react-native/Libraries/NativeComponent/NativeComponentRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var NativeComponentRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _Platform = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var RCTScrollViewViewConfig = _Platform.default.OS === 'android' ? {
    uiViewClassName: 'RCTScrollView',
    bubblingEventTypes: {},
    directEventTypes: {
      topMomentumScrollBegin: {
        registrationName: 'onMomentumScrollBegin'
      },
      topMomentumScrollEnd: {
        registrationName: 'onMomentumScrollEnd'
      },
      topScroll: {
        registrationName: 'onScroll'
      },
      topScrollBeginDrag: {
        registrationName: 'onScrollBeginDrag'
      },
      topScrollEndDrag: {
        registrationName: 'onScrollEndDrag'
      }
    },
    validAttributes: {
      contentOffset: {
        diff: _$$_REQUIRE(_dependencyMap[3])
      },
      decelerationRate: true,
      disableIntervalMomentum: true,
      pagingEnabled: true,
      scrollEnabled: true,
      showsVerticalScrollIndicator: true,
      snapToAlignment: true,
      snapToEnd: true,
      snapToInterval: true,
      snapToOffsets: true,
      snapToStart: true,
      borderBottomLeftRadius: true,
      borderBottomRightRadius: true,
      sendMomentumEvents: true,
      borderRadius: true,
      nestedScrollEnabled: true,
      borderStyle: true,
      borderRightColor: {
        process: _$$_REQUIRE(_dependencyMap[4])
      },
      borderColor: {
        process: _$$_REQUIRE(_dependencyMap[4])
      },
      borderBottomColor: {
        process: _$$_REQUIRE(_dependencyMap[4])
      },
      persistentScrollbar: true,
      endFillColor: {
        process: _$$_REQUIRE(_dependencyMap[4])
      },
      fadingEdgeLength: true,
      overScrollMode: true,
      borderTopLeftRadius: true,
      scrollPerfTag: true,
      borderTopColor: {
        process: _$$_REQUIRE(_dependencyMap[4])
      },
      removeClippedSubviews: true,
      borderTopRightRadius: true,
      borderLeftColor: {
        process: _$$_REQUIRE(_dependencyMap[4])
      }
    }
  } : {
    uiViewClassName: 'RCTScrollView',
    bubblingEventTypes: {},
    directEventTypes: {
      topMomentumScrollBegin: {
        registrationName: 'onMomentumScrollBegin'
      },
      topMomentumScrollEnd: {
        registrationName: 'onMomentumScrollEnd'
      },
      topScroll: {
        registrationName: 'onScroll'
      },
      topScrollBeginDrag: {
        registrationName: 'onScrollBeginDrag'
      },
      topScrollEndDrag: {
        registrationName: 'onScrollEndDrag'
      },
      topScrollToTop: {
        registrationName: 'onScrollToTop'
      }
    },
    validAttributes: {
      alwaysBounceHorizontal: true,
      alwaysBounceVertical: true,
      automaticallyAdjustContentInsets: true,
      automaticallyAdjustKeyboardInsets: true,
      automaticallyAdjustsScrollIndicatorInsets: true,
      bounces: true,
      bouncesZoom: true,
      canCancelContentTouches: true,
      centerContent: true,
      contentInset: {
        diff: _$$_REQUIRE(_dependencyMap[5])
      },
      contentOffset: {
        diff: _$$_REQUIRE(_dependencyMap[3])
      },
      contentInsetAdjustmentBehavior: true,
      decelerationRate: true,
      directionalLockEnabled: true,
      disableIntervalMomentum: true,
      indicatorStyle: true,
      inverted: true,
      keyboardDismissMode: true,
      maintainVisibleContentPosition: true,
      maximumZoomScale: true,
      minimumZoomScale: true,
      pagingEnabled: true,
      pinchGestureEnabled: true,
      scrollEnabled: true,
      scrollEventThrottle: true,
      scrollIndicatorInsets: {
        diff: _$$_REQUIRE(_dependencyMap[5])
      },
      scrollToOverflowEnabled: true,
      scrollsToTop: true,
      showsHorizontalScrollIndicator: true,
      showsVerticalScrollIndicator: true,
      snapToAlignment: true,
      snapToEnd: true,
      snapToInterval: true,
      snapToOffsets: true,
      snapToStart: true,
      zoomScale: true
    }
  };
  var ScrollViewNativeComponent = NativeComponentRegistry.get('RCTScrollView', function () {
    return RCTScrollViewViewConfig;
  });
  var _default = ScrollViewNativeComponent;
  exports.default = _default;
},"node_modules/react-native/Libraries/Components/ScrollView/ScrollViewNativeComponent.js",["node_modules/react-native/Libraries/NativeComponent/NativeComponentRegistry.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/Utilities/differ/pointsDiffer.js","node_modules/react-native/Libraries/StyleSheet/processColor.js","node_modules/react-native/Libraries/Utilities/differ/insetsDiffer.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _AndroidSwipeRefreshLayoutNativeComponent = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[8]));

  var _PullToRefreshViewNativeComponent = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[9]));

  var _excluded = ["enabled", "colors", "progressBackgroundColor", "size"],
      _excluded2 = ["tintColor", "titleColor", "title"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var React = _$$_REQUIRE(_dependencyMap[10]);

  var RefreshControl = function (_React$Component) {
    (0, _inherits2.default)(RefreshControl, _React$Component);

    var _super = _createSuper(RefreshControl);

    function RefreshControl() {
      var _this;

      (0, _classCallCheck2.default)(this, RefreshControl);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this._lastNativeRefreshing = false;

      _this._onRefresh = function () {
        _this._lastNativeRefreshing = true;
        _this.props.onRefresh && _this.props.onRefresh();

        _this.forceUpdate();
      };

      _this._setNativeRef = function (ref) {
        _this._nativeRef = ref;
      };

      return _this;
    }

    (0, _createClass2.default)(RefreshControl, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this._lastNativeRefreshing = this.props.refreshing;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (this.props.refreshing !== prevProps.refreshing) {
          this._lastNativeRefreshing = this.props.refreshing;
        } else if (this.props.refreshing !== this._lastNativeRefreshing && this._nativeRef) {
          {
            _PullToRefreshViewNativeComponent.Commands.setNativeRefreshing(this._nativeRef, this.props.refreshing);
          }
          this._lastNativeRefreshing = this.props.refreshing;
        }
      }
    }, {
      key: "render",
      value: function render() {
        {
          var _this$props = this.props,
              enabled = _this$props.enabled,
              colors = _this$props.colors,
              progressBackgroundColor = _this$props.progressBackgroundColor,
              size = _this$props.size,
              props = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
          return React.createElement(_PullToRefreshViewNativeComponent.default, (0, _extends2.default)({}, props, {
            ref: this._setNativeRef,
            onRefresh: this._onRefresh
          }));
        }
      }
    }]);
    return RefreshControl;
  }(React.Component);

  module.exports = RefreshControl;
},"node_modules/react-native/Libraries/Components/RefreshControl/RefreshControl.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Components/RefreshControl/AndroidSwipeRefreshLayoutNativeComponent.js","node_modules/react-native/Libraries/Components/RefreshControl/PullToRefreshViewNativeComponent.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.Commands = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _codegenNativeCommands = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var Commands = (0, _codegenNativeCommands.default)({
    supportedCommands: ['setNativeRefreshing']
  });
  exports.Commands = Commands;

  var _default = (0, _codegenNativeComponent.default)('AndroidSwipeRefreshLayout');

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/RefreshControl/AndroidSwipeRefreshLayoutNativeComponent.js",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeCommands.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.Commands = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  var _codegenNativeCommands = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var Commands = (0, _codegenNativeCommands.default)({
    supportedCommands: ['setNativeRefreshing']
  });
  exports.Commands = Commands;

  var _default = (0, _codegenNativeComponent.default)('PullToRefreshView', {
    paperComponentName: 'RCTRefreshControl',
    excludedPlatforms: ['android']
  });

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/RefreshControl/PullToRefreshViewNativeComponent.js",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js","node_modules/react-native/Libraries/Utilities/codegenNativeCommands.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function infoLog() {
    var _console;

    return (_console = console).log.apply(_console, arguments);
  }

  module.exports = infoLog;
},"node_modules/react-native/Libraries/Utilities/infoLog.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Info = _$$_REQUIRE(_dependencyMap[0])(function Info() {
    _$$_REQUIRE(_dependencyMap[1])(this, Info);

    this.any_blank_count = 0;
    this.any_blank_ms = 0;
    this.any_blank_speed_sum = 0;
    this.mostly_blank_count = 0;
    this.mostly_blank_ms = 0;
    this.pixels_blank = 0;
    this.pixels_sampled = 0;
    this.pixels_scrolled = 0;
    this.total_time_spent = 0;
    this.sample_count = 0;
  });

  var DEBUG = false;
  var _listeners = [];
  var _minSampleCount = 10;
  var _sampleRate = null;

  var FillRateHelper = function () {
    function FillRateHelper(getFrameMetrics) {
      _$$_REQUIRE(_dependencyMap[1])(this, FillRateHelper);

      this._anyBlankStartTime = null;
      this._enabled = false;
      this._info = new Info();
      this._mostlyBlankStartTime = null;
      this._samplesStartTime = null;
      this._getFrameMetrics = getFrameMetrics;
      this._enabled = (_sampleRate || 0) > Math.random();

      this._resetData();
    }

    _$$_REQUIRE(_dependencyMap[0])(FillRateHelper, [{
      key: "activate",
      value: function activate() {
        if (this._enabled && this._samplesStartTime == null) {
          DEBUG;
          this._samplesStartTime = global.performance.now();
        }
      }
    }, {
      key: "deactivateAndFlush",
      value: function deactivateAndFlush() {
        if (!this._enabled) {
          return;
        }

        var start = this._samplesStartTime;

        if (start == null) {
          DEBUG;
          return;
        }

        if (this._info.sample_count < _minSampleCount) {
          this._resetData();

          return;
        }

        var total_time_spent = global.performance.now() - start;

        var info = _$$_REQUIRE(_dependencyMap[2])({}, this._info, {
          total_time_spent: total_time_spent
        });

        _listeners.forEach(function (listener) {
          return listener(info);
        });

        this._resetData();
      }
    }, {
      key: "computeBlankness",
      value: function computeBlankness(props, state, scrollMetrics) {
        if (!this._enabled || props.getItemCount(props.data) === 0 || this._samplesStartTime == null) {
          return 0;
        }

        var dOffset = scrollMetrics.dOffset,
            offset = scrollMetrics.offset,
            velocity = scrollMetrics.velocity,
            visibleLength = scrollMetrics.visibleLength;
        this._info.sample_count++;
        this._info.pixels_sampled += Math.round(visibleLength);
        this._info.pixels_scrolled += Math.round(Math.abs(dOffset));
        var scrollSpeed = Math.round(Math.abs(velocity) * 1000);
        var now = global.performance.now();

        if (this._anyBlankStartTime != null) {
          this._info.any_blank_ms += now - this._anyBlankStartTime;
        }

        this._anyBlankStartTime = null;

        if (this._mostlyBlankStartTime != null) {
          this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;
        }

        this._mostlyBlankStartTime = null;
        var blankTop = 0;
        var first = state.first;

        var firstFrame = this._getFrameMetrics(first);

        while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {
          firstFrame = this._getFrameMetrics(first);
          first++;
        }

        if (firstFrame && first > 0) {
          blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));
        }

        var blankBottom = 0;
        var last = state.last;

        var lastFrame = this._getFrameMetrics(last);

        while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {
          lastFrame = this._getFrameMetrics(last);
          last--;
        }

        if (lastFrame && last < props.getItemCount(props.data) - 1) {
          var bottomEdge = lastFrame.offset + lastFrame.length;
          blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));
        }

        var pixels_blank = Math.round(blankTop + blankBottom);
        var blankness = pixels_blank / visibleLength;

        if (blankness > 0) {
          this._anyBlankStartTime = now;
          this._info.any_blank_speed_sum += scrollSpeed;
          this._info.any_blank_count++;
          this._info.pixels_blank += pixels_blank;

          if (blankness > 0.5) {
            this._mostlyBlankStartTime = now;
            this._info.mostly_blank_count++;
          }
        } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {
          this.deactivateAndFlush();
        }

        return blankness;
      }
    }, {
      key: "enabled",
      value: function enabled() {
        return this._enabled;
      }
    }, {
      key: "_resetData",
      value: function _resetData() {
        this._anyBlankStartTime = null;
        this._info = new Info();
        this._mostlyBlankStartTime = null;
        this._samplesStartTime = null;
      }
    }], [{
      key: "addListener",
      value: function addListener(callback) {
        if (_sampleRate === null) {
          console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');
        }

        _listeners.push(callback);

        return {
          remove: function remove() {
            _listeners = _listeners.filter(function (listener) {
              return callback !== listener;
            });
          }
        };
      }
    }, {
      key: "setSampleRate",
      value: function setSampleRate(sampleRate) {
        _sampleRate = sampleRate;
      }
    }, {
      key: "setMinSampleCount",
      value: function setMinSampleCount(minSampleCount) {
        _minSampleCount = minSampleCount;
      }
    }]);

    return FillRateHelper;
  }();

  module.exports = FillRateHelper;
},"node_modules/react-native/Libraries/Lists/FillRateHelper.js",["node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/extends.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var Batchinator = function () {
    function Batchinator(callback, delayMS) {
      _$$_REQUIRE(_dependencyMap[0])(this, Batchinator);

      this._delay = delayMS;
      this._callback = callback;
    }

    _$$_REQUIRE(_dependencyMap[1])(Batchinator, [{
      key: "dispose",
      value: function dispose() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
          abort: false
        };

        if (this._taskHandle) {
          this._taskHandle.cancel();

          if (!options.abort) {
            this._callback();
          }

          this._taskHandle = null;
        }
      }
    }, {
      key: "schedule",
      value: function schedule() {
        var _this = this;

        if (this._taskHandle) {
          return;
        }

        var timeoutHandle = setTimeout(function () {
          _this._taskHandle = _$$_REQUIRE(_dependencyMap[2]).runAfterInteractions(function () {
            _this._taskHandle = null;

            _this._callback();
          });
        }, this._delay);
        this._taskHandle = {
          cancel: function cancel() {
            return clearTimeout(timeoutHandle);
          }
        };
      }
    }]);

    return Batchinator;
  }();

  module.exports = Batchinator;
},"node_modules/react-native/Libraries/Interaction/Batchinator.js",["node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/Interaction/InteractionManager.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var ViewabilityHelper = function () {
    function ViewabilityHelper() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        viewAreaCoveragePercentThreshold: 0
      };

      _$$_REQUIRE(_dependencyMap[0])(this, ViewabilityHelper);

      this._hasInteracted = false;
      this._timers = new Set();
      this._viewableIndices = [];
      this._viewableItems = new Map();
      this._config = config;
    }

    _$$_REQUIRE(_dependencyMap[1])(ViewabilityHelper, [{
      key: "dispose",
      value: function dispose() {
        this._timers.forEach(clearTimeout);
      }
    }, {
      key: "computeViewableItems",
      value: function computeViewableItems(itemCount, scrollOffset, viewportHeight, getFrameMetrics, renderRange) {
        var _this$_config = this._config,
            itemVisiblePercentThreshold = _this$_config.itemVisiblePercentThreshold,
            viewAreaCoveragePercentThreshold = _this$_config.viewAreaCoveragePercentThreshold;
        var viewAreaMode = viewAreaCoveragePercentThreshold != null;
        var viewablePercentThreshold = viewAreaMode ? viewAreaCoveragePercentThreshold : itemVisiblePercentThreshold;

        _$$_REQUIRE(_dependencyMap[2])(viewablePercentThreshold != null && itemVisiblePercentThreshold != null !== (viewAreaCoveragePercentThreshold != null), 'Must set exactly one of itemVisiblePercentThreshold or viewAreaCoveragePercentThreshold');

        var viewableIndices = [];

        if (itemCount === 0) {
          return viewableIndices;
        }

        var firstVisible = -1;

        var _ref = renderRange || {
          first: 0,
          last: itemCount - 1
        },
            first = _ref.first,
            last = _ref.last;

        if (last >= itemCount) {
          console.warn('Invalid render range computing viewability ' + JSON.stringify({
            renderRange: renderRange,
            itemCount: itemCount
          }));
          return [];
        }

        for (var idx = first; idx <= last; idx++) {
          var metrics = getFrameMetrics(idx);

          if (!metrics) {
            continue;
          }

          var top = metrics.offset - scrollOffset;
          var bottom = top + metrics.length;

          if (top < viewportHeight && bottom > 0) {
            firstVisible = idx;

            if (_isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, metrics.length)) {
              viewableIndices.push(idx);
            }
          } else if (firstVisible >= 0) {
            break;
          }
        }

        return viewableIndices;
      }
    }, {
      key: "onUpdate",
      value: function onUpdate(itemCount, scrollOffset, viewportHeight, getFrameMetrics, createViewToken, onViewableItemsChanged, renderRange) {
        var _this = this;

        if (this._config.waitForInteraction && !this._hasInteracted || itemCount === 0 || !getFrameMetrics(0)) {
          return;
        }

        var viewableIndices = [];

        if (itemCount) {
          viewableIndices = this.computeViewableItems(itemCount, scrollOffset, viewportHeight, getFrameMetrics, renderRange);
        }

        if (this._viewableIndices.length === viewableIndices.length && this._viewableIndices.every(function (v, ii) {
          return v === viewableIndices[ii];
        })) {
          return;
        }

        this._viewableIndices = viewableIndices;

        if (this._config.minimumViewTime) {
          var handle = setTimeout(function () {
            _this._timers.delete(handle);

            _this._onUpdateSync(viewableIndices, onViewableItemsChanged, createViewToken);
          }, this._config.minimumViewTime);

          this._timers.add(handle);
        } else {
          this._onUpdateSync(viewableIndices, onViewableItemsChanged, createViewToken);
        }
      }
    }, {
      key: "resetViewableIndices",
      value: function resetViewableIndices() {
        this._viewableIndices = [];
      }
    }, {
      key: "recordInteraction",
      value: function recordInteraction() {
        this._hasInteracted = true;
      }
    }, {
      key: "_onUpdateSync",
      value: function _onUpdateSync(viewableIndicesToCheck, onViewableItemsChanged, createViewToken) {
        var _this2 = this;

        viewableIndicesToCheck = viewableIndicesToCheck.filter(function (ii) {
          return _this2._viewableIndices.includes(ii);
        });
        var prevItems = this._viewableItems;
        var nextItems = new Map(viewableIndicesToCheck.map(function (ii) {
          var viewable = createViewToken(ii, true);
          return [viewable.key, viewable];
        }));
        var changed = [];

        for (var _iterator = _createForOfIteratorHelperLoose(nextItems), _step; !(_step = _iterator()).done;) {
          var _ref2 = _step.value;

          var _ref3 = _$$_REQUIRE(_dependencyMap[3])(_ref2, 2);

          var key = _ref3[0];
          var viewable = _ref3[1];

          if (!prevItems.has(key)) {
            changed.push(viewable);
          }
        }

        for (var _iterator2 = _createForOfIteratorHelperLoose(prevItems), _step2; !(_step2 = _iterator2()).done;) {
          var _ref4 = _step2.value;

          var _ref5 = _$$_REQUIRE(_dependencyMap[3])(_ref4, 2);

          var _key = _ref5[0];
          var _viewable = _ref5[1];

          if (!nextItems.has(_key)) {
            changed.push(_$$_REQUIRE(_dependencyMap[4])({}, _viewable, {
              isViewable: false
            }));
          }
        }

        if (changed.length > 0) {
          this._viewableItems = nextItems;
          onViewableItemsChanged({
            viewableItems: Array.from(nextItems.values()),
            changed: changed,
            viewabilityConfig: this._config
          });
        }
      }
    }]);

    return ViewabilityHelper;
  }();

  function _isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, itemLength) {
    if (_isEntirelyVisible(top, bottom, viewportHeight)) {
      return true;
    } else {
      var pixels = _getPixelsVisible(top, bottom, viewportHeight);

      var percent = 100 * (viewAreaMode ? pixels / viewportHeight : pixels / itemLength);
      return percent >= viewablePercentThreshold;
    }
  }

  function _getPixelsVisible(top, bottom, viewportHeight) {
    var visibleHeight = Math.min(bottom, viewportHeight) - Math.max(top, 0);
    return Math.max(0, visibleHeight);
  }

  function _isEntirelyVisible(top, bottom, viewportHeight) {
    return top >= 0 && bottom <= viewportHeight && bottom > top;
  }

  module.exports = ViewabilityHelper;
},"node_modules/react-native/Libraries/Lists/ViewabilityHelper.js",["node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/invariant/browser.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/extends.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VirtualizedListCellContextProvider = VirtualizedListCellContextProvider;
  exports.VirtualizedListContext = undefined;
  exports.VirtualizedListContextProvider = VirtualizedListContextProvider;
  exports.VirtualizedListContextResetter = VirtualizedListContextResetter;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var VirtualizedListContext = React.createContext(null);
  exports.VirtualizedListContext = VirtualizedListContext;

  function VirtualizedListContextResetter(_ref) {
    var children = _ref.children;
    return React.createElement(VirtualizedListContext.Provider, {
      value: null
    }, children);
  }

  function VirtualizedListContextProvider(_ref2) {
    var children = _ref2.children,
        value = _ref2.value;
    var context = (0, React.useMemo)(function () {
      return {
        cellKey: null,
        getScrollMetrics: value.getScrollMetrics,
        horizontal: value.horizontal,
        getOutermostParentListRef: value.getOutermostParentListRef,
        getNestedChildState: value.getNestedChildState,
        registerAsNestedChild: value.registerAsNestedChild,
        unregisterAsNestedChild: value.unregisterAsNestedChild,
        debugInfo: {
          cellKey: value.debugInfo.cellKey,
          horizontal: value.debugInfo.horizontal,
          listKey: value.debugInfo.listKey,
          parent: value.debugInfo.parent
        }
      };
    }, [value.getScrollMetrics, value.horizontal, value.getOutermostParentListRef, value.getNestedChildState, value.registerAsNestedChild, value.unregisterAsNestedChild, value.debugInfo.cellKey, value.debugInfo.horizontal, value.debugInfo.listKey, value.debugInfo.parent]);
    return React.createElement(VirtualizedListContext.Provider, {
      value: context
    }, children);
  }

  function VirtualizedListCellContextProvider(_ref3) {
    var cellKey = _ref3.cellKey,
        children = _ref3.children;
    var context = (0, React.useContext)(VirtualizedListContext);
    return React.createElement(VirtualizedListContext.Provider, {
      value: context == null ? null : (0, _extends2.default)({}, context, {
        cellKey: cellKey
      })
    }, children);
  }
},"node_modules/react-native/Libraries/Lists/VirtualizedListContext.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  module.exports = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));
},"node_modules/react-native/Libraries/Animated/components/AnimatedImage.js",["node_modules/react/index.js","node_modules/react-native/Libraries/Animated/createAnimatedComponent.js","node_modules/react-native/Libraries/Image/Image.ios.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _regenerator = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _ImageInjection = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _ImageAnalyticsTagContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _flattenStyle = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _resolveAssetSource = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _NativeImageLoaderIOS = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _ImageViewNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function getSize(uri, success, failure) {
    _NativeImageLoaderIOS.default.getSize(uri).then(function (_ref) {
      var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
          width = _ref2[0],
          height = _ref2[1];

      return success(width, height);
    }).catch(failure || function () {
      console.warn('Failed to get size for image ' + uri);
    });
  }

  function getSizeWithHeaders(uri, headers, success, failure) {
    return _NativeImageLoaderIOS.default.getSizeWithHeaders(uri, headers).then(function (sizes) {
      success(sizes.width, sizes.height);
    }).catch(failure || function () {
      console.warn('Failed to get size for image: ' + uri);
    });
  }

  function prefetchWithMetadata(url, queryRootName, rootTag) {
    if (_NativeImageLoaderIOS.default.prefetchImageWithMetadata) {
      return _NativeImageLoaderIOS.default.prefetchImageWithMetadata(url, queryRootName, rootTag ? rootTag : 0);
    } else {
      return _NativeImageLoaderIOS.default.prefetchImage(url);
    }
  }

  function prefetch(url) {
    return _NativeImageLoaderIOS.default.prefetchImage(url);
  }

  function queryCache(urls) {
    return _regenerator.default.async(function queryCache$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return _regenerator.default.awrap(_NativeImageLoaderIOS.default.queryCache(urls));

          case 2:
            return _context.abrupt("return", _context.sent);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, null, null, null, Promise);
  }

  var Image = function Image(props, forwardedRef) {
    var source = (0, _resolveAssetSource.default)(props.source) || {
      uri: undefined,
      width: undefined,
      height: undefined
    };
    var sources;
    var style;

    if (Array.isArray(source)) {
      style = (0, _flattenStyle.default)([styles.base, props.style]) || {};
      sources = source;
    } else {
      var _width = source.width,
          _height = source.height,
          uri = source.uri;
      style = (0, _flattenStyle.default)([{
        width: _width,
        height: _height
      }, styles.base, props.style]) || {};
      sources = [source];

      if (uri === '') {
        console.warn('source.uri should not be an empty string');
      }
    }

    var resizeMode = props.resizeMode || style.resizeMode || 'cover';
    var tintColor = style.tintColor;

    if (props.src != null) {
      console.warn('The <Image> component requires a `source` property rather than `src`.');
    }

    if (props.children != null) {
      throw new Error('The <Image> component cannot contain children. If you want to render content on top of the image, consider using the <ImageBackground> component or absolute positioning.');
    }

    return React.createElement(_ImageAnalyticsTagContext.default.Consumer, null, function (analyticTag) {
      return React.createElement(_ImageViewNativeComponent.default, (0, _extends2.default)({}, props, {
        ref: forwardedRef,
        style: style,
        resizeMode: resizeMode,
        tintColor: tintColor,
        source: sources,
        internal_analyticTag: analyticTag
      }));
    });
  };

  Image = React.forwardRef(Image);

  if (_ImageInjection.default.unstable_createImageComponent != null) {
    Image = _ImageInjection.default.unstable_createImageComponent(Image);
  }

  Image.displayName = 'Image';
  Image.getSize = getSize;
  Image.getSizeWithHeaders = getSizeWithHeaders;
  Image.prefetch = prefetch;
  Image.prefetchWithMetadata = prefetchWithMetadata;
  Image.queryCache = queryCache;
  Image.resolveAssetSource = _resolveAssetSource.default;
  Image.propTypes = _$$_REQUIRE(_dependencyMap[12]).ImagePropTypes;

  var styles = _StyleSheet.default.create({
    base: {
      overflow: 'hidden'
    }
  });

  module.exports = Image;
},"node_modules/react-native/Libraries/Image/Image.ios.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/regenerator/index.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react/index.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Image/ImageInjection.js","node_modules/react-native/Libraries/Image/ImageAnalyticsTagContext.js","node_modules/react-native/Libraries/StyleSheet/flattenStyle.js","node_modules/react-native/Libraries/Image/resolveAssetSource.js","node_modules/react-native/Libraries/Image/NativeImageLoaderIOS.js","node_modules/react-native/Libraries/Image/ImageViewNativeComponent.js","node_modules/deprecated-react-native-prop-types/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _ImageViewNativeComponent = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  var _TextInlineImageNativeComponent = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = {
    unstable_createImageComponent: null
  };
  exports.default = _default;
},"node_modules/react-native/Libraries/Image/ImageInjection.js",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Image/ImageViewNativeComponent.js","node_modules/react-native/Libraries/Image/TextInlineImageNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var NativeComponentRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _Platform = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var ImageViewViewConfig = _Platform.default.OS === 'android' ? {
    uiViewClassName: 'RCTImageView',
    bubblingEventTypes: {},
    directEventTypes: {
      topLoadStart: {
        registrationName: 'onLoadStart'
      },
      topProgress: {
        registrationName: 'onProgress'
      },
      topError: {
        registrationName: 'onError'
      },
      topLoad: {
        registrationName: 'onLoad'
      },
      topLoadEnd: {
        registrationName: 'onLoadEnd'
      }
    },
    validAttributes: {
      blurRadius: true,
      internal_analyticTag: true,
      resizeMode: true,
      tintColor: {
        process: _$$_REQUIRE(_dependencyMap[3])
      },
      borderBottomLeftRadius: true,
      borderTopLeftRadius: true,
      resizeMethod: true,
      src: true,
      borderRadius: true,
      headers: true,
      shouldNotifyLoadEvents: true,
      defaultSrc: true,
      overlayColor: {
        process: _$$_REQUIRE(_dependencyMap[3])
      },
      borderColor: {
        process: _$$_REQUIRE(_dependencyMap[3])
      },
      accessible: true,
      progressiveRenderingEnabled: true,
      fadeDuration: true,
      borderBottomRightRadius: true,
      borderTopRightRadius: true,
      loadingIndicatorSrc: true
    }
  } : {
    uiViewClassName: 'RCTImageView',
    bubblingEventTypes: {},
    directEventTypes: {
      topLoadStart: {
        registrationName: 'onLoadStart'
      },
      topProgress: {
        registrationName: 'onProgress'
      },
      topError: {
        registrationName: 'onError'
      },
      topPartialLoad: {
        registrationName: 'onPartialLoad'
      },
      topLoad: {
        registrationName: 'onLoad'
      },
      topLoadEnd: {
        registrationName: 'onLoadEnd'
      }
    },
    validAttributes: {
      blurRadius: true,
      capInsets: {
        diff: _$$_REQUIRE(_dependencyMap[4])
      },
      defaultSource: {
        process: _$$_REQUIRE(_dependencyMap[5])
      },
      internal_analyticTag: true,
      resizeMode: true,
      source: true,
      tintColor: {
        process: _$$_REQUIRE(_dependencyMap[3])
      }
    }
  };
  var ImageViewNativeComponent = NativeComponentRegistry.get('RCTImageView', function () {
    return ImageViewViewConfig;
  });
  var _default = ImageViewNativeComponent;
  exports.default = _default;
},"node_modules/react-native/Libraries/Image/ImageViewNativeComponent.js",["node_modules/react-native/Libraries/NativeComponent/NativeComponentRegistry.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/StyleSheet/processColor.js","node_modules/react-native/Libraries/Utilities/differ/insetsDiffer.js","node_modules/react-native/Libraries/Image/resolveAssetSource.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var NativeComponentRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var TextInlineImage = NativeComponentRegistry.get('RCTTextInlineImage', function () {
    return {
      uiViewClassName: 'RCTTextInlineImage',
      bubblingEventTypes: {},
      directEventTypes: {},
      validAttributes: {
        resizeMode: true,
        src: true,
        tintColor: {
          process: _$$_REQUIRE(_dependencyMap[1])
        },
        headers: true
      }
    };
  });
  module.exports = TextInlineImage;
},"node_modules/react-native/Libraries/Image/TextInlineImageNativeComponent.js",["node_modules/react-native/Libraries/NativeComponent/NativeComponentRegistry.js","node_modules/react-native/Libraries/StyleSheet/processColor.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var Context = React.createContext(null);
  var _default = Context;
  exports.default = _default;
},"node_modules/react-native/Libraries/Image/ImageAnalyticsTagContext.js",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.getEnforcing('ImageLoader');

  exports.default = _default;
},"node_modules/react-native/Libraries/Image/NativeImageLoaderIOS.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var ScrollViewWithEventThrottle = React.forwardRef(function (props, ref) {
    return React.createElement(_$$_REQUIRE(_dependencyMap[3]), (0, _extends2.default)({
      scrollEventThrottle: 0.0001
    }, props, {
      ref: ref
    }));
  });
  module.exports = _$$_REQUIRE(_dependencyMap[4])(ScrollViewWithEventThrottle);
},"node_modules/react-native/Libraries/Animated/components/AnimatedScrollView.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js","node_modules/react-native/Libraries/Animated/createAnimatedComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _SectionList = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var SectionListWithEventThrottle = React.forwardRef(function (props, ref) {
    return React.createElement(_SectionList.default, (0, _extends2.default)({
      scrollEventThrottle: 0.0001
    }, props, {
      ref: ref
    }));
  });
  module.exports = _$$_REQUIRE(_dependencyMap[4])(SectionListWithEventThrottle);
},"node_modules/react-native/Libraries/Animated/components/AnimatedSectionList.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/react-native/Libraries/Lists/SectionList.js","node_modules/react-native/Libraries/Animated/createAnimatedComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[9]));

  var _VirtualizedSectionList = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _excluded = ["stickySectionHeadersEnabled"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var SectionList = function (_React$PureComponent) {
    (0, _inherits2.default)(SectionList, _React$PureComponent);

    var _super = _createSuper(SectionList);

    function SectionList() {
      var _this;

      (0, _classCallCheck2.default)(this, SectionList);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _this._captureRef = function (ref) {
        _this._wrapperListRef = ref;
      };

      return _this;
    }

    (0, _createClass2.default)(SectionList, [{
      key: "scrollToLocation",
      value: function scrollToLocation(params) {
        if (this._wrapperListRef != null) {
          this._wrapperListRef.scrollToLocation(params);
        }
      }
    }, {
      key: "recordInteraction",
      value: function recordInteraction() {
        var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

        listRef && listRef.recordInteraction();
      }
    }, {
      key: "flashScrollIndicators",
      value: function flashScrollIndicators() {
        var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

        listRef && listRef.flashScrollIndicators();
      }
    }, {
      key: "getScrollResponder",
      value: function getScrollResponder() {
        var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

        if (listRef) {
          return listRef.getScrollResponder();
        }
      }
    }, {
      key: "getScrollableNode",
      value: function getScrollableNode() {
        var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

        if (listRef) {
          return listRef.getScrollableNode();
        }
      }
    }, {
      key: "setNativeProps",
      value: function setNativeProps(props) {
        var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();

        if (listRef) {
          listRef.setNativeProps(props);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            _stickySectionHeadersEnabled = _this$props.stickySectionHeadersEnabled,
            restProps = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
        var stickySectionHeadersEnabled = _stickySectionHeadersEnabled != null ? _stickySectionHeadersEnabled : _Platform.default.OS === 'ios';
        return React.createElement(_VirtualizedSectionList.default, (0, _extends2.default)({}, restProps, {
          stickySectionHeadersEnabled: stickySectionHeadersEnabled,
          ref: this._captureRef,
          getItemCount: function getItemCount(items) {
            return items.length;
          },
          getItem: function getItem(items, index) {
            return items[index];
          }
        }));
      }
    }]);
    return SectionList;
  }(React.PureComponent);

  exports.default = SectionList;
},"node_modules/react-native/Libraries/Lists/SectionList.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react/index.js","node_modules/react-native/Libraries/Lists/VirtualizedSectionList.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _assertThisInitialized2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[11]);

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[12]));

  var _excluded = ["ItemSeparatorComponent", "SectionSeparatorComponent", "renderItem", "renderSectionFooter", "renderSectionHeader", "sections", "stickySectionHeadersEnabled"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var VirtualizedSectionList = function (_React$PureComponent) {
    (0, _inherits2.default)(VirtualizedSectionList, _React$PureComponent);

    var _super = _createSuper(VirtualizedSectionList);

    function VirtualizedSectionList() {
      var _this;

      (0, _classCallCheck2.default)(this, VirtualizedSectionList);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _this._keyExtractor = function (item, index) {
        var info = _this._subExtractor(index);

        return info && info.key || String(index);
      };

      _this._convertViewable = function (viewable) {
        var _info$index;

        (0, _invariant.default)(viewable.index != null, 'Received a broken ViewToken');

        var info = _this._subExtractor(viewable.index);

        if (!info) {
          return null;
        }

        var keyExtractorWithNullableIndex = info.section.keyExtractor;

        var keyExtractorWithNonNullableIndex = _this.props.keyExtractor || _$$_REQUIRE(_dependencyMap[13]).keyExtractor;

        var key = keyExtractorWithNullableIndex != null ? keyExtractorWithNullableIndex(viewable.item, info.index) : keyExtractorWithNonNullableIndex(viewable.item, (_info$index = info.index) != null ? _info$index : 0);
        return (0, _extends2.default)({}, viewable, {
          index: info.index,
          key: key,
          section: info.section
        });
      };

      _this._onViewableItemsChanged = function (_ref) {
        var viewableItems = _ref.viewableItems,
            changed = _ref.changed;
        var onViewableItemsChanged = _this.props.onViewableItemsChanged;

        if (onViewableItemsChanged != null) {
          onViewableItemsChanged({
            viewableItems: viewableItems.map(_this._convertViewable, (0, _assertThisInitialized2.default)(_this)).filter(Boolean),
            changed: changed.map(_this._convertViewable, (0, _assertThisInitialized2.default)(_this)).filter(Boolean)
          });
        }
      };

      _this._renderItem = function (listItemCount) {
        return function (_ref2) {
          var item = _ref2.item,
              index = _ref2.index;

          var info = _this._subExtractor(index);

          if (!info) {
            return null;
          }

          var infoIndex = info.index;

          if (infoIndex == null) {
            var section = info.section;

            if (info.header === true) {
              var renderSectionHeader = _this.props.renderSectionHeader;
              return renderSectionHeader ? renderSectionHeader({
                section: section
              }) : null;
            } else {
              var renderSectionFooter = _this.props.renderSectionFooter;
              return renderSectionFooter ? renderSectionFooter({
                section: section
              }) : null;
            }
          } else {
            var renderItem = info.section.renderItem || _this.props.renderItem;

            var SeparatorComponent = _this._getSeparatorComponent(index, info, listItemCount);

            (0, _invariant.default)(renderItem, 'no renderItem!');
            return React.createElement(ItemWithSeparator, {
              SeparatorComponent: SeparatorComponent,
              LeadingSeparatorComponent: infoIndex === 0 ? _this.props.SectionSeparatorComponent : undefined,
              cellKey: info.key,
              index: infoIndex,
              item: item,
              leadingItem: info.leadingItem,
              leadingSection: info.leadingSection,
              prevCellKey: (_this._subExtractor(index - 1) || {}).key,
              setSelfHighlightCallback: _this._setUpdateHighlightFor,
              setSelfUpdatePropsCallback: _this._setUpdatePropsFor,
              updateHighlightFor: _this._updateHighlightFor,
              updatePropsFor: _this._updatePropsFor,
              renderItem: renderItem,
              section: info.section,
              trailingItem: info.trailingItem,
              trailingSection: info.trailingSection,
              inverted: !!_this.props.inverted
            });
          }
        };
      };

      _this._updatePropsFor = function (cellKey, value) {
        var updateProps = _this._updatePropsMap[cellKey];

        if (updateProps != null) {
          updateProps(value);
        }
      };

      _this._updateHighlightFor = function (cellKey, value) {
        var updateHighlight = _this._updateHighlightMap[cellKey];

        if (updateHighlight != null) {
          updateHighlight(value);
        }
      };

      _this._setUpdateHighlightFor = function (cellKey, updateHighlightFn) {
        if (updateHighlightFn != null) {
          _this._updateHighlightMap[cellKey] = updateHighlightFn;
        } else {
          delete _this._updateHighlightFor[cellKey];
        }
      };

      _this._setUpdatePropsFor = function (cellKey, updatePropsFn) {
        if (updatePropsFn != null) {
          _this._updatePropsMap[cellKey] = updatePropsFn;
        } else {
          delete _this._updatePropsMap[cellKey];
        }
      };

      _this._updateHighlightMap = {};
      _this._updatePropsMap = {};

      _this._captureRef = function (ref) {
        _this._listRef = ref;
      };

      return _this;
    }

    (0, _createClass2.default)(VirtualizedSectionList, [{
      key: "scrollToLocation",
      value: function scrollToLocation(params) {
        var index = params.itemIndex;

        for (var i = 0; i < params.sectionIndex; i++) {
          index += this.props.getItemCount(this.props.sections[i].data) + 2;
        }

        var viewOffset = params.viewOffset || 0;

        if (this._listRef == null) {
          return;
        }

        if (params.itemIndex > 0 && this.props.stickySectionHeadersEnabled) {
          var frame = this._listRef._getFrameMetricsApprox(index - params.itemIndex);

          viewOffset += frame.length;
        }

        var toIndexParams = (0, _extends2.default)({}, params, {
          viewOffset: viewOffset,
          index: index
        });

        this._listRef.scrollToIndex(toIndexParams);
      }
    }, {
      key: "getListRef",
      value: function getListRef() {
        return this._listRef;
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            ItemSeparatorComponent = _this$props.ItemSeparatorComponent,
            SectionSeparatorComponent = _this$props.SectionSeparatorComponent,
            _renderItem = _this$props.renderItem,
            renderSectionFooter = _this$props.renderSectionFooter,
            renderSectionHeader = _this$props.renderSectionHeader,
            _sections = _this$props.sections,
            stickySectionHeadersEnabled = _this$props.stickySectionHeadersEnabled,
            passThroughProps = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
        var listHeaderOffset = this.props.ListHeaderComponent ? 1 : 0;
        var stickyHeaderIndices = this.props.stickySectionHeadersEnabled ? [] : undefined;
        var itemCount = 0;

        for (var _iterator = _createForOfIteratorHelperLoose(this.props.sections), _step; !(_step = _iterator()).done;) {
          var section = _step.value;

          if (stickyHeaderIndices != null) {
            stickyHeaderIndices.push(itemCount + listHeaderOffset);
          }

          itemCount += 2;
          itemCount += this.props.getItemCount(section.data);
        }

        var renderItem = this._renderItem(itemCount);

        return React.createElement(_reactNative.VirtualizedList, (0, _extends2.default)({}, passThroughProps, {
          keyExtractor: this._keyExtractor,
          stickyHeaderIndices: stickyHeaderIndices,
          renderItem: renderItem,
          data: this.props.sections,
          getItem: function getItem(sections, index) {
            return _this2._getItem(_this2.props, sections, index);
          },
          getItemCount: function getItemCount() {
            return itemCount;
          },
          onViewableItemsChanged: this.props.onViewableItemsChanged ? this._onViewableItemsChanged : undefined,
          ref: this._captureRef
        }));
      }
    }, {
      key: "_getItem",
      value: function _getItem(props, sections, index) {
        if (!sections) {
          return null;
        }

        var itemIdx = index - 1;

        for (var i = 0; i < sections.length; i++) {
          var section = sections[i];
          var sectionData = section.data;
          var itemCount = props.getItemCount(sectionData);

          if (itemIdx === -1 || itemIdx === itemCount) {
            return section;
          } else if (itemIdx < itemCount) {
            return props.getItem(sectionData, itemIdx);
          } else {
            itemIdx -= itemCount + 2;
          }
        }

        return null;
      }
    }, {
      key: "_subExtractor",
      value: function _subExtractor(index) {
        var itemIndex = index;
        var _this$props2 = this.props,
            getItem = _this$props2.getItem,
            getItemCount = _this$props2.getItemCount,
            keyExtractor = _this$props2.keyExtractor,
            sections = _this$props2.sections;

        for (var i = 0; i < sections.length; i++) {
          var section = sections[i];
          var sectionData = section.data;
          var key = section.key || String(i);
          itemIndex -= 1;

          if (itemIndex >= getItemCount(sectionData) + 1) {
            itemIndex -= getItemCount(sectionData) + 1;
          } else if (itemIndex === -1) {
            return {
              section: section,
              key: key + ':header',
              index: null,
              header: true,
              trailingSection: sections[i + 1]
            };
          } else if (itemIndex === getItemCount(sectionData)) {
            return {
              section: section,
              key: key + ':footer',
              index: null,
              header: false,
              trailingSection: sections[i + 1]
            };
          } else {
            var extractor = section.keyExtractor || keyExtractor || _$$_REQUIRE(_dependencyMap[13]).keyExtractor;

            return {
              section: section,
              key: key + ':' + extractor(getItem(sectionData, itemIndex), itemIndex),
              index: itemIndex,
              leadingItem: getItem(sectionData, itemIndex - 1),
              leadingSection: sections[i - 1],
              trailingItem: getItem(sectionData, itemIndex + 1),
              trailingSection: sections[i + 1]
            };
          }
        }
      }
    }, {
      key: "_getSeparatorComponent",
      value: function _getSeparatorComponent(index, info, listItemCount) {
        info = info || this._subExtractor(index);

        if (!info) {
          return null;
        }

        var ItemSeparatorComponent = info.section.ItemSeparatorComponent || this.props.ItemSeparatorComponent;
        var SectionSeparatorComponent = this.props.SectionSeparatorComponent;
        var isLastItemInList = index === listItemCount - 1;
        var isLastItemInSection = info.index === this.props.getItemCount(info.section.data) - 1;

        if (SectionSeparatorComponent && isLastItemInSection) {
          return SectionSeparatorComponent;
        }

        if (ItemSeparatorComponent && !isLastItemInSection && !isLastItemInList) {
          return ItemSeparatorComponent;
        }

        return null;
      }
    }]);
    return VirtualizedSectionList;
  }(React.PureComponent);

  function ItemWithSeparator(props) {
    var LeadingSeparatorComponent = props.LeadingSeparatorComponent,
        SeparatorComponent = props.SeparatorComponent,
        cellKey = props.cellKey,
        prevCellKey = props.prevCellKey,
        setSelfHighlightCallback = props.setSelfHighlightCallback,
        updateHighlightFor = props.updateHighlightFor,
        setSelfUpdatePropsCallback = props.setSelfUpdatePropsCallback,
        updatePropsFor = props.updatePropsFor,
        item = props.item,
        index = props.index,
        section = props.section,
        inverted = props.inverted;

    var _React$useState = React.useState(false),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
        leadingSeparatorHiglighted = _React$useState2[0],
        setLeadingSeparatorHighlighted = _React$useState2[1];

    var _React$useState3 = React.useState(false),
        _React$useState4 = (0, _slicedToArray2.default)(_React$useState3, 2),
        separatorHighlighted = _React$useState4[0],
        setSeparatorHighlighted = _React$useState4[1];

    var _React$useState5 = React.useState({
      leadingItem: props.leadingItem,
      leadingSection: props.leadingSection,
      section: props.section,
      trailingItem: props.item,
      trailingSection: props.trailingSection
    }),
        _React$useState6 = (0, _slicedToArray2.default)(_React$useState5, 2),
        leadingSeparatorProps = _React$useState6[0],
        setLeadingSeparatorProps = _React$useState6[1];

    var _React$useState7 = React.useState({
      leadingItem: props.item,
      leadingSection: props.leadingSection,
      section: props.section,
      trailingItem: props.trailingItem,
      trailingSection: props.trailingSection
    }),
        _React$useState8 = (0, _slicedToArray2.default)(_React$useState7, 2),
        separatorProps = _React$useState8[0],
        setSeparatorProps = _React$useState8[1];

    React.useEffect(function () {
      setSelfHighlightCallback(cellKey, setSeparatorHighlighted);
      setSelfUpdatePropsCallback(cellKey, setSeparatorProps);
      return function () {
        setSelfUpdatePropsCallback(cellKey, null);
        setSelfHighlightCallback(cellKey, null);
      };
    }, [cellKey, setSelfHighlightCallback, setSeparatorProps, setSelfUpdatePropsCallback]);
    var separators = {
      highlight: function highlight() {
        setLeadingSeparatorHighlighted(true);
        setSeparatorHighlighted(true);

        if (prevCellKey != null) {
          updateHighlightFor(prevCellKey, true);
        }
      },
      unhighlight: function unhighlight() {
        setLeadingSeparatorHighlighted(false);
        setSeparatorHighlighted(false);

        if (prevCellKey != null) {
          updateHighlightFor(prevCellKey, false);
        }
      },
      updateProps: function updateProps(select, newProps) {
        if (select === 'leading') {
          if (LeadingSeparatorComponent != null) {
            setLeadingSeparatorProps((0, _extends2.default)({}, leadingSeparatorProps, newProps));
          } else if (prevCellKey != null) {
            updatePropsFor(prevCellKey, (0, _extends2.default)({}, leadingSeparatorProps, newProps));
          }
        } else if (select === 'trailing' && SeparatorComponent != null) {
          setSeparatorProps((0, _extends2.default)({}, separatorProps, newProps));
        }
      }
    };
    var element = props.renderItem({
      item: item,
      index: index,
      section: section,
      separators: separators
    });
    var leadingSeparator = LeadingSeparatorComponent != null && React.createElement(LeadingSeparatorComponent, (0, _extends2.default)({
      highlighted: leadingSeparatorHiglighted
    }, leadingSeparatorProps));
    var separator = SeparatorComponent != null && React.createElement(SeparatorComponent, (0, _extends2.default)({
      highlighted: separatorHighlighted
    }, separatorProps));
    return leadingSeparator || separator ? React.createElement(_reactNative.View, null, inverted === false ? leadingSeparator : separator, element, inverted === false ? separator : leadingSeparator) : element;
  }

  module.exports = VirtualizedSectionList;
},"node_modules/react-native/Libraries/Lists/VirtualizedSectionList.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/assertThisInitialized.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/invariant/browser.js","node_modules/react-native/index.js","node_modules/react/index.js","node_modules/react-native/Libraries/Lists/VirtualizeUtils.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  module.exports = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));
},"node_modules/react-native/Libraries/Animated/components/AnimatedText.js",["node_modules/react/index.js","node_modules/react-native/Libraries/Animated/createAnimatedComponent.js","node_modules/react-native/Libraries/Text/Text.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  module.exports = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));
},"node_modules/react-native/Libraries/Animated/components/AnimatedView.js",["node_modules/react/index.js","node_modules/react-native/Libraries/Animated/createAnimatedComponent.js","node_modules/react-native/Libraries/Components/View/View.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var warnedKeys = {};

  function warnOnce(key, message) {
    if (warnedKeys[key]) {
      return;
    }

    console.warn(message);
    warnedKeys[key] = true;
  }

  module.exports = warnOnce;
},"node_modules/react-native/Libraries/Utilities/warnOnce.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[6]));

  var _RCTDatePickerNativeComponent = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[7]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _View = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var DatePickerIOS = function (_React$Component) {
    (0, _inherits2.default)(DatePickerIOS, _React$Component);

    var _super = _createSuper(DatePickerIOS);

    function DatePickerIOS() {
      var _this;

      (0, _classCallCheck2.default)(this, DatePickerIOS);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this._picker = null;

      _this._onChange = function (event) {
        var nativeTimeStamp = event.nativeEvent.timestamp;
        _this.props.onDateChange && _this.props.onDateChange(new Date(nativeTimeStamp));
        _this.props.onChange && _this.props.onChange(event);

        _this.forceUpdate();
      };

      return _this;
    }

    (0, _createClass2.default)(DatePickerIOS, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        if (this.props.date) {
          var propsTimeStamp = this.props.date.getTime();

          if (this._picker) {
            _RCTDatePickerNativeComponent.Commands.setNativeDate(this._picker, propsTimeStamp);
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _props$mode,
            _this2 = this;

        var props = this.props;
        var mode = (_props$mode = props.mode) != null ? _props$mode : 'datetime';
        (0, _invariant.default)(props.date || props.initialDate, 'A selected date or initial date should be specified.');
        return React.createElement(_View.default, {
          style: props.style
        }, React.createElement(_RCTDatePickerNativeComponent.default, {
          testID: props.testID,
          ref: function ref(picker) {
            _this2._picker = picker;
          },
          style: getHeight(props.pickerStyle, mode),
          date: props.date ? props.date.getTime() : props.initialDate ? props.initialDate.getTime() : undefined,
          locale: props.locale != null && props.locale !== '' ? props.locale : undefined,
          maximumDate: props.maximumDate ? props.maximumDate.getTime() : undefined,
          minimumDate: props.minimumDate ? props.minimumDate.getTime() : undefined,
          mode: mode,
          minuteInterval: props.minuteInterval,
          timeZoneOffsetInMinutes: props.timeZoneOffsetInMinutes,
          onChange: this._onChange,
          onStartShouldSetResponder: function onStartShouldSetResponder() {
            return true;
          },
          onResponderTerminationRequest: function onResponderTerminationRequest() {
            return false;
          },
          pickerStyle: props.pickerStyle
        }));
      }
    }]);
    return DatePickerIOS;
  }(React.Component);

  var inlineHeightForDatePicker = 318.5;
  var inlineHeightForTimePicker = 49.5;
  var compactHeight = 40;
  var spinnerHeight = 216;

  var styles = _StyleSheet.default.create({
    datePickerIOS: {
      height: spinnerHeight
    },
    datePickerIOSCompact: {
      height: compactHeight
    },
    datePickerIOSInline: {
      height: 417.5
    },
    datePickerIOSInlineDate: {
      height: 368
    },
    datePickerIOSInlineTime: {
      height: inlineHeightForTimePicker
    }
  });

  function getHeight(pickerStyle, mode) {
    if (pickerStyle === 'compact') {
      return styles.datePickerIOSCompact;
    }

    if (pickerStyle === 'inline') {
      switch (mode) {
        case 'date':
          return styles.datePickerIOSInlineDate;

        case 'time':
          return styles.datePickerIOSInlineTime;

        default:
          return styles.datePickerIOSInline;
      }
    }

    return styles.datePickerIOS;
  }

  module.exports = DatePickerIOS;
},"node_modules/react-native/Libraries/Components/DatePicker/DatePickerIOS.ios.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react/index.js","node_modules/react-native/Libraries/Components/DatePicker/RCTDatePickerNativeComponent.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.Commands = undefined;

  var _codegenNativeCommands = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var Commands = (0, _codegenNativeCommands.default)({
    supportedCommands: ['setNativeDate']
  });
  exports.Commands = Commands;

  var _default = (0, _codegenNativeComponent.default)('DatePicker', {
    paperComponentName: 'RCTDatePicker',
    excludedPlatforms: ['android']
  });

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/DatePicker/RCTDatePickerNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeCommands.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = _$$_REQUIRE(_dependencyMap[0]);
},"node_modules/react-native/Libraries/Components/DrawerAndroid/DrawerLayoutAndroid.ios.js",["node_modules/react-native/Libraries/Components/UnimplementedViews/UnimplementedView.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _Image = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[9]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _flattenStyle = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _View = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var _excluded = ["children", "style", "imageStyle", "imageRef"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ImageBackground = function (_React$Component) {
    (0, _inherits2.default)(ImageBackground, _React$Component);

    var _super = _createSuper(ImageBackground);

    function ImageBackground() {
      var _this;

      (0, _classCallCheck2.default)(this, ImageBackground);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this._viewRef = null;

      _this._captureRef = function (ref) {
        _this._viewRef = ref;
      };

      return _this;
    }

    (0, _createClass2.default)(ImageBackground, [{
      key: "setNativeProps",
      value: function setNativeProps(props) {
        var viewRef = this._viewRef;

        if (viewRef) {
          viewRef.setNativeProps(props);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            children = _this$props.children,
            style = _this$props.style,
            imageStyle = _this$props.imageStyle,
            imageRef = _this$props.imageRef,
            props = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
        var flattenedStyle = (0, _flattenStyle.default)(style);
        return React.createElement(_View.default, {
          accessibilityIgnoresInvertColors: true,
          style: style,
          ref: this._captureRef
        }, React.createElement(_Image.default, (0, _extends2.default)({}, props, {
          style: [_StyleSheet.default.absoluteFill, {
            width: flattenedStyle == null ? undefined : flattenedStyle.width,
            height: flattenedStyle == null ? undefined : flattenedStyle.height
          }, imageStyle],
          ref: imageRef
        })), children);
      }
    }]);
    return ImageBackground;
  }(React.Component);

  module.exports = ImageBackground;
},"node_modules/react-native/Libraries/Image/ImageBackground.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Image/Image.ios.js","node_modules/react/index.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/StyleSheet/flattenStyle.js","node_modules/react-native/Libraries/Components/View/View.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[6]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _RCTInputAccessoryViewNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var InputAccessoryView = function (_React$Component) {
    (0, _inherits2.default)(InputAccessoryView, _React$Component);

    var _super = _createSuper(InputAccessoryView);

    function InputAccessoryView() {
      (0, _classCallCheck2.default)(this, InputAccessoryView);
      return _super.apply(this, arguments);
    }

    (0, _createClass2.default)(InputAccessoryView, [{
      key: "render",
      value: function render() {
        if (_Platform.default.OS !== 'ios') {
          console.warn('<InputAccessoryView> is only supported on iOS.');
        }

        if (React.Children.count(this.props.children) === 0) {
          return null;
        }

        return React.createElement(_RCTInputAccessoryViewNativeComponent.default, {
          style: [this.props.style, styles.container],
          nativeID: this.props.nativeID,
          backgroundColor: this.props.backgroundColor
        }, this.props.children);
      }
    }]);
    return InputAccessoryView;
  }(React.Component);

  var styles = _StyleSheet.default.create({
    container: {
      position: 'absolute'
    }
  });

  module.exports = InputAccessoryView;
},"node_modules/react-native/Libraries/Components/TextInput/InputAccessoryView.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react/index.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Components/TextInput/RCTInputAccessoryViewNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _default = (0, _codegenNativeComponent.default)('InputAccessory', {
    interfaceOnly: true,
    paperComponentName: 'RCTInputAccessoryView',
    excludedPlatforms: ['android']
  });

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/TextInput/RCTInputAccessoryViewNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _Keyboard = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _LayoutAnimation = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[11]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var _View = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[13]));

  var _excluded = ["behavior", "children", "contentContainerStyle", "enabled", "keyboardVerticalOffset", "style", "onLayout"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var KeyboardAvoidingView = function (_React$Component) {
    (0, _inherits2.default)(KeyboardAvoidingView, _React$Component);

    var _super = _createSuper(KeyboardAvoidingView);

    function KeyboardAvoidingView(props) {
      var _this;

      (0, _classCallCheck2.default)(this, KeyboardAvoidingView);
      _this = _super.call(this, props);
      _this._frame = null;
      _this._keyboardEvent = null;
      _this._subscriptions = [];
      _this._initialFrameHeight = 0;

      _this._onKeyboardChange = function (event) {
        _this._keyboardEvent = event;

        _this._updateBottomIfNecessary();
      };

      _this._onLayout = function (event) {
        var wasFrameNull = _this._frame == null;
        _this._frame = event.nativeEvent.layout;

        if (!_this._initialFrameHeight) {
          _this._initialFrameHeight = _this._frame.height;
        }

        if (wasFrameNull) {
          _this._updateBottomIfNecessary();
        }

        if (_this.props.onLayout) {
          _this.props.onLayout(event);
        }
      };

      _this._updateBottomIfNecessary = function () {
        if (_this._keyboardEvent == null) {
          _this.setState({
            bottom: 0
          });

          return;
        }

        var _this$_keyboardEvent = _this._keyboardEvent,
            duration = _this$_keyboardEvent.duration,
            easing = _this$_keyboardEvent.easing,
            endCoordinates = _this$_keyboardEvent.endCoordinates;

        var height = _this._relativeKeyboardHeight(endCoordinates);

        if (_this.state.bottom === height) {
          return;
        }

        if (duration && easing) {
          _LayoutAnimation.default.configureNext({
            duration: duration > 10 ? duration : 10,
            update: {
              duration: duration > 10 ? duration : 10,
              type: _LayoutAnimation.default.Types[easing] || 'keyboard'
            }
          });
        }

        _this.setState({
          bottom: height
        });
      };

      _this.state = {
        bottom: 0
      };
      _this.viewRef = React.createRef();
      return _this;
    }

    (0, _createClass2.default)(KeyboardAvoidingView, [{
      key: "_relativeKeyboardHeight",
      value: function _relativeKeyboardHeight(keyboardFrame) {
        var _this$props$keyboardV;

        var frame = this._frame;

        if (!frame || !keyboardFrame) {
          return 0;
        }

        var keyboardY = keyboardFrame.screenY - ((_this$props$keyboardV = this.props.keyboardVerticalOffset) != null ? _this$props$keyboardV : 0);
        return Math.max(frame.y + frame.height - keyboardY, 0);
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        if (_Platform.default.OS === 'ios') {
          this._subscriptions = [_Keyboard.default.addListener('keyboardWillChangeFrame', this._onKeyboardChange)];
        } else {
          this._subscriptions = [_Keyboard.default.addListener('keyboardDidHide', this._onKeyboardChange), _Keyboard.default.addListener('keyboardDidShow', this._onKeyboardChange)];
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this._subscriptions.forEach(function (subscription) {
          subscription.remove();
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            behavior = _this$props.behavior,
            children = _this$props.children,
            contentContainerStyle = _this$props.contentContainerStyle,
            _this$props$enabled = _this$props.enabled,
            enabled = _this$props$enabled === undefined ? true : _this$props$enabled,
            _this$props$keyboardV2 = _this$props.keyboardVerticalOffset,
            keyboardVerticalOffset = _this$props$keyboardV2 === undefined ? 0 : _this$props$keyboardV2,
            style = _this$props.style,
            onLayout = _this$props.onLayout,
            props = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
        var bottomHeight = enabled === true ? this.state.bottom : 0;

        switch (behavior) {
          case 'height':
            var heightStyle;

            if (this._frame != null && this.state.bottom > 0) {
              heightStyle = {
                height: this._initialFrameHeight - bottomHeight,
                flex: 0
              };
            }

            return React.createElement(_View.default, (0, _extends2.default)({
              ref: this.viewRef,
              style: _StyleSheet.default.compose(style, heightStyle),
              onLayout: this._onLayout
            }, props), children);

          case 'position':
            return React.createElement(_View.default, (0, _extends2.default)({
              ref: this.viewRef,
              style: style,
              onLayout: this._onLayout
            }, props), React.createElement(_View.default, {
              style: _StyleSheet.default.compose(contentContainerStyle, {
                bottom: bottomHeight
              })
            }, children));

          case 'padding':
            return React.createElement(_View.default, (0, _extends2.default)({
              ref: this.viewRef,
              style: _StyleSheet.default.compose(style, {
                paddingBottom: bottomHeight
              }),
              onLayout: this._onLayout
            }, props), children);

          default:
            return React.createElement(_View.default, (0, _extends2.default)({
              ref: this.viewRef,
              onLayout: this._onLayout,
              style: style
            }, props), children);
        }
      }
    }]);
    return KeyboardAvoidingView;
  }(React.Component);

  var _default = KeyboardAvoidingView;
  exports.default = _default;
},"node_modules/react-native/Libraries/Components/Keyboard/KeyboardAvoidingView.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Components/Keyboard/Keyboard.js","node_modules/react-native/Libraries/LayoutAnimation/LayoutAnimation.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react/index.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Components/View/View.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[7]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _View = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _RCTMaskedViewNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _excluded = ["maskElement", "children"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var MaskedViewIOS = function (_React$Component) {
    (0, _inherits2.default)(MaskedViewIOS, _React$Component);

    var _super = _createSuper(MaskedViewIOS);

    function MaskedViewIOS() {
      var _this;

      (0, _classCallCheck2.default)(this, MaskedViewIOS);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this._hasWarnedInvalidRenderMask = false;
      return _this;
    }

    (0, _createClass2.default)(MaskedViewIOS, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            maskElement = _this$props.maskElement,
            children = _this$props.children,
            otherViewProps = (0, _objectWithoutProperties2.default)(_this$props, _excluded);

        if (!React.isValidElement(maskElement)) {
          if (!this._hasWarnedInvalidRenderMask) {
            console.warn("MaskedView: Invalid `maskElement` prop was passed to MaskedView. Expected a React Element. No mask will render.");
            this._hasWarnedInvalidRenderMask = true;
          }

          return React.createElement(_View.default, otherViewProps, children);
        }

        return React.createElement(_RCTMaskedViewNativeComponent.default, otherViewProps, React.createElement(_View.default, {
          pointerEvents: "none",
          style: _StyleSheet.default.absoluteFill
        }, maskElement), children);
      }
    }]);
    return MaskedViewIOS;
  }(React.Component);

  module.exports = MaskedViewIOS;
},"node_modules/react-native/Libraries/Components/MaskedView/MaskedViewIOS.ios.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react/index.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/react-native/Libraries/Components/MaskedView/RCTMaskedViewNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _default = (0, _codegenNativeComponent.default)('RCTMaskedView');

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/MaskedView/RCTMaskedViewNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _defineProperty2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _ModalInjection = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _NativeEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _NativeModalManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _RCTModalHostViewNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _container, _ModalInjection$unsta;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var React = _$$_REQUIRE(_dependencyMap[11]);

  var ModalEventEmitter = _NativeModalManager.default != null ? new _NativeEventEmitter.default(_NativeModalManager.default) : null;
  var uniqueModalIdentifier = 0;

  var Modal = function (_React$Component) {
    (0, _inherits2.default)(Modal, _React$Component);

    var _super = _createSuper(Modal);

    function Modal(props) {
      var _this;

      (0, _classCallCheck2.default)(this, Modal);
      _this = _super.call(this, props);
      _this._identifier = uniqueModalIdentifier++;
      return _this;
    }

    (0, _createClass2.default)(Modal, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        if (ModalEventEmitter) {
          this._eventSubscription = ModalEventEmitter.addListener('modalDismissed', function (event) {
            if (event.modalID === _this2._identifier && _this2.props.onDismiss) {
              _this2.props.onDismiss();
            }
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._eventSubscription) {
          this._eventSubscription.remove();
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {}
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        if (this.props.visible !== true) {
          return null;
        }

        var containerStyles = {
          backgroundColor: this.props.transparent === true ? 'transparent' : 'white'
        };
        var animationType = this.props.animationType || 'none';
        var presentationStyle = this.props.presentationStyle;

        if (!presentationStyle) {
          presentationStyle = 'fullScreen';

          if (this.props.transparent === true) {
            presentationStyle = 'overFullScreen';
          }
        }

        var innerChildren = this.props.children;
        return React.createElement(_RCTModalHostViewNativeComponent.default, {
          animationType: animationType,
          presentationStyle: presentationStyle,
          transparent: this.props.transparent,
          hardwareAccelerated: this.props.hardwareAccelerated,
          onRequestClose: this.props.onRequestClose,
          onShow: this.props.onShow,
          onDismiss: function onDismiss() {
            if (_this3.props.onDismiss) {
              _this3.props.onDismiss();
            }
          },
          visible: this.props.visible,
          statusBarTranslucent: this.props.statusBarTranslucent,
          identifier: this._identifier,
          style: styles.modal,
          onStartShouldSetResponder: this._shouldSetResponder,
          supportedOrientations: this.props.supportedOrientations,
          onOrientationChange: this.props.onOrientationChange,
          testID: this.props.testID
        }, React.createElement(_$$_REQUIRE(_dependencyMap[12]).VirtualizedListContextResetter, null, React.createElement(_$$_REQUIRE(_dependencyMap[13]).Context.Provider, {
          value: null
        }, React.createElement(_$$_REQUIRE(_dependencyMap[14]), {
          style: [styles.container, containerStyles],
          collapsable: false
        }, innerChildren))));
      }
    }, {
      key: "_shouldSetResponder",
      value: function _shouldSetResponder() {
        return true;
      }
    }]);
    return Modal;
  }(React.Component);

  Modal.defaultProps = {
    visible: true,
    hardwareAccelerated: false
  };
  Modal.contextType = _$$_REQUIRE(_dependencyMap[15]).RootTagContext;
  var side = _$$_REQUIRE(_dependencyMap[16]).getConstants().isRTL ? 'right' : 'left';

  var styles = _$$_REQUIRE(_dependencyMap[17]).create({
    modal: {
      position: 'absolute'
    },
    container: (_container = {}, (0, _defineProperty2.default)(_container, side, 0), (0, _defineProperty2.default)(_container, "top", 0), (0, _defineProperty2.default)(_container, "flex", 1), _container)
  });

  var ExportedModal = (_ModalInjection$unsta = _ModalInjection.default.unstable_Modal) != null ? _ModalInjection$unsta : Modal;
  module.exports = ExportedModal;
},"node_modules/react-native/Libraries/Modal/Modal.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/defineProperty.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Modal/ModalInjection.js","node_modules/react-native/Libraries/EventEmitter/NativeEventEmitter.js","node_modules/react-native/Libraries/Modal/NativeModalManager.js","node_modules/react-native/Libraries/Modal/RCTModalHostViewNativeComponent.js","node_modules/react/index.js","node_modules/react-native/Libraries/Lists/VirtualizedListContext.js","node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/react-native/Libraries/ReactNative/RootTag.js","node_modules/react-native/Libraries/ReactNative/I18nManager.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = {
    unstable_Modal: null
  };
  exports.default = _default;
},"node_modules/react-native/Libraries/Modal/ModalInjection.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('ModalManager');

  exports.default = _default;
},"node_modules/react-native/Libraries/Modal/NativeModalManager.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _default = (0, _codegenNativeComponent.default)('ModalHostView', {
    interfaceOnly: true,
    paperComponentName: 'RCTModalHostView'
  });

  exports.default = _default;
},"node_modules/react-native/Libraries/Modal/RCTModalHostViewNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.RootTagContext = undefined;
  exports.createRootTag = createRootTag;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var RootTagContext = React.createContext(0);
  exports.RootTagContext = RootTagContext;

  function createRootTag(rootTag) {
    return rootTag;
  }
},"node_modules/react-native/Libraries/ReactNative/RootTag.js",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _NativeI18nManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var i18nConstants = getI18nManagerConstants();

  function getI18nManagerConstants() {
    if (_NativeI18nManager.default) {
      var _NativeI18nManager$ge = _NativeI18nManager.default.getConstants(),
          isRTL = _NativeI18nManager$ge.isRTL,
          doLeftAndRightSwapInRTL = _NativeI18nManager$ge.doLeftAndRightSwapInRTL,
          localeIdentifier = _NativeI18nManager$ge.localeIdentifier;

      return {
        isRTL: isRTL,
        doLeftAndRightSwapInRTL: doLeftAndRightSwapInRTL,
        localeIdentifier: localeIdentifier
      };
    }

    return {
      isRTL: false,
      doLeftAndRightSwapInRTL: true
    };
  }

  module.exports = {
    getConstants: function getConstants() {
      return i18nConstants;
    },
    allowRTL: function allowRTL(shouldAllow) {
      if (!_NativeI18nManager.default) {
        return;
      }

      _NativeI18nManager.default.allowRTL(shouldAllow);
    },
    forceRTL: function forceRTL(shouldForce) {
      if (!_NativeI18nManager.default) {
        return;
      }

      _NativeI18nManager.default.forceRTL(shouldForce);
    },
    swapLeftAndRightInRTL: function swapLeftAndRightInRTL(flipStyles) {
      if (!_NativeI18nManager.default) {
        return;
      }

      _NativeI18nManager.default.swapLeftAndRightInRTL(flipStyles);
    },
    isRTL: i18nConstants.isRTL,
    doLeftAndRightSwapInRTL: i18nConstants.doLeftAndRightSwapInRTL
  };
},"node_modules/react-native/Libraries/ReactNative/I18nManager.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/ReactNative/NativeI18nManager.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('I18nManager');

  exports.default = _default;
},"node_modules/react-native/Libraries/ReactNative/NativeI18nManager.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  var _useAndroidRippleForView = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _usePressability = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _View = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _excluded = ["accessible", "android_disableSound", "android_ripple", "cancelable", "children", "delayHoverIn", "delayHoverOut", "delayLongPress", "disabled", "focusable", "onHoverIn", "onHoverOut", "onLongPress", "onPress", "onPressIn", "onPressOut", "pressRetentionOffset", "style", "testOnly_pressed", "unstable_pressDelay"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function Pressable(props, forwardedRef) {
    var accessible = props.accessible,
        android_disableSound = props.android_disableSound,
        android_ripple = props.android_ripple,
        cancelable = props.cancelable,
        children = props.children,
        delayHoverIn = props.delayHoverIn,
        delayHoverOut = props.delayHoverOut,
        delayLongPress = props.delayLongPress,
        disabled = props.disabled,
        focusable = props.focusable,
        onHoverIn = props.onHoverIn,
        onHoverOut = props.onHoverOut,
        onLongPress = props.onLongPress,
        onPress = props.onPress,
        _onPressIn = props.onPressIn,
        _onPressOut = props.onPressOut,
        pressRetentionOffset = props.pressRetentionOffset,
        style = props.style,
        testOnly_pressed = props.testOnly_pressed,
        unstable_pressDelay = props.unstable_pressDelay,
        restProps = (0, _objectWithoutProperties2.default)(props, _excluded);
    var viewRef = (0, React.useRef)(null);
    (0, React.useImperativeHandle)(forwardedRef, function () {
      return viewRef.current;
    });
    var android_rippleConfig = (0, _useAndroidRippleForView.default)(android_ripple, viewRef);

    var _usePressState = usePressState(testOnly_pressed === true),
        _usePressState2 = (0, _slicedToArray2.default)(_usePressState, 2),
        pressed = _usePressState2[0],
        setPressed = _usePressState2[1];

    var hitSlop = (0, _$$_REQUIRE(_dependencyMap[8]).normalizeRect)(props.hitSlop);
    var accessibilityState = disabled != null ? (0, _extends2.default)({}, props.accessibilityState, {
      disabled: disabled
    }) : props.accessibilityState;
    var restPropsWithDefaults = (0, _extends2.default)({}, restProps, android_rippleConfig == null ? undefined : android_rippleConfig.viewProps, {
      accessible: accessible !== false,
      accessibilityState: accessibilityState,
      focusable: focusable !== false,
      hitSlop: hitSlop
    });
    var config = (0, React.useMemo)(function () {
      return {
        cancelable: cancelable,
        disabled: disabled,
        hitSlop: hitSlop,
        pressRectOffset: pressRetentionOffset,
        android_disableSound: android_disableSound,
        delayHoverIn: delayHoverIn,
        delayHoverOut: delayHoverOut,
        delayLongPress: delayLongPress,
        delayPressIn: unstable_pressDelay,
        onHoverIn: onHoverIn,
        onHoverOut: onHoverOut,
        onLongPress: onLongPress,
        onPress: onPress,
        onPressIn: function onPressIn(event) {
          if (android_rippleConfig != null) {
            android_rippleConfig.onPressIn(event);
          }

          setPressed(true);

          if (_onPressIn != null) {
            _onPressIn(event);
          }
        },
        onPressMove: android_rippleConfig == null ? undefined : android_rippleConfig.onPressMove,
        onPressOut: function onPressOut(event) {
          if (android_rippleConfig != null) {
            android_rippleConfig.onPressOut(event);
          }

          setPressed(false);

          if (_onPressOut != null) {
            _onPressOut(event);
          }
        }
      };
    }, [android_disableSound, android_rippleConfig, cancelable, delayHoverIn, delayHoverOut, delayLongPress, disabled, hitSlop, onHoverIn, onHoverOut, onLongPress, onPress, _onPressIn, _onPressOut, pressRetentionOffset, setPressed, unstable_pressDelay]);
    var eventHandlers = (0, _usePressability.default)(config);
    return React.createElement(_View.default, (0, _extends2.default)({}, restPropsWithDefaults, eventHandlers, {
      ref: viewRef,
      style: typeof style === 'function' ? style({
        pressed: pressed
      }) : style,
      collapsable: false
    }), typeof children === 'function' ? children({
      pressed: pressed
    }) : children, null);
  }

  function usePressState(forcePressed) {
    var _useState = (0, React.useState)(false),
        _useState2 = (0, _slicedToArray2.default)(_useState, 2),
        pressed = _useState2[0],
        setPressed = _useState2[1];

    return [pressed || forcePressed, setPressed];
  }

  var MemoedPressable = React.memo(React.forwardRef(Pressable));
  MemoedPressable.displayName = 'Pressable';
  var _default = MemoedPressable;
  exports.default = _default;
},"node_modules/react-native/Libraries/Components/Pressable/Pressable.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/react-native/Libraries/Components/Pressable/useAndroidRippleForView.js","node_modules/react-native/Libraries/Pressability/usePressability.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/react-native/Libraries/StyleSheet/Rect.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useAndroidRippleForView;

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[2]);

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useAndroidRippleForView(rippleConfig, viewRef) {
    var _ref = rippleConfig != null ? rippleConfig : {},
        color = _ref.color,
        borderless = _ref.borderless,
        radius = _ref.radius,
        foreground = _ref.foreground;

    return (0, React.useMemo)(function () {
      if (_reactNative.Platform.OS === 'android' && _reactNative.Platform.Version >= 21 && (color != null || borderless != null || radius != null)) {
        var processedColor = (0, _reactNative.processColor)(color);
        (0, _invariant.default)(processedColor == null || typeof processedColor === 'number', 'Unexpected color given for Ripple color');
        var nativeRippleValue = {
          type: 'RippleAndroid',
          color: processedColor,
          borderless: borderless === true,
          rippleRadius: radius
        };
        return {
          viewProps: foreground === true ? {
            nativeForegroundAndroid: nativeRippleValue
          } : {
            nativeBackgroundAndroid: nativeRippleValue
          },
          onPressIn: function onPressIn(event) {
            var view = viewRef.current;

            if (view != null) {
              var _event$nativeEvent$lo, _event$nativeEvent$lo2;

              _$$_REQUIRE(_dependencyMap[4]).Commands.hotspotUpdate(view, (_event$nativeEvent$lo = event.nativeEvent.locationX) != null ? _event$nativeEvent$lo : 0, (_event$nativeEvent$lo2 = event.nativeEvent.locationY) != null ? _event$nativeEvent$lo2 : 0);

              _$$_REQUIRE(_dependencyMap[4]).Commands.setPressed(view, true);
            }
          },
          onPressMove: function onPressMove(event) {
            var view = viewRef.current;

            if (view != null) {
              var _event$nativeEvent$lo3, _event$nativeEvent$lo4;

              _$$_REQUIRE(_dependencyMap[4]).Commands.hotspotUpdate(view, (_event$nativeEvent$lo3 = event.nativeEvent.locationX) != null ? _event$nativeEvent$lo3 : 0, (_event$nativeEvent$lo4 = event.nativeEvent.locationY) != null ? _event$nativeEvent$lo4 : 0);
            }
          },
          onPressOut: function onPressOut(event) {
            var view = viewRef.current;

            if (view != null) {
              _$$_REQUIRE(_dependencyMap[4]).Commands.setPressed(view, false);
            }
          }
        };
      }

      return null;
    }, [borderless, color, foreground, radius, viewRef]);
  }
},"node_modules/react-native/Libraries/Components/Pressable/useAndroidRippleForView.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/invariant/browser.js","node_modules/react-native/index.js","node_modules/react/index.js","node_modules/react-native/Libraries/Components/View/ViewNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _RCTProgressViewNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var ProgressViewIOS = function ProgressViewIOS(props, forwardedRef) {
    return React.createElement(_RCTProgressViewNativeComponent.default, (0, _extends2.default)({}, props, {
      style: [styles.progressView, props.style],
      ref: forwardedRef
    }));
  };

  var styles = _StyleSheet.default.create({
    progressView: {
      height: 2
    }
  });

  var ProgressViewIOSWithRef = React.forwardRef(ProgressViewIOS);
  module.exports = ProgressViewIOSWithRef;
},"node_modules/react-native/Libraries/Components/ProgressViewIOS/ProgressViewIOS.ios.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Components/ProgressViewIOS/RCTProgressViewNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _default = (0, _codegenNativeComponent.default)('RCTProgressView');

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/ProgressViewIOS/RCTProgressViewNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  var _View = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _excluded = ["emulateUnlessSupported"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var exported;

  if (_Platform.default.OS === 'android') {
    exported = React.forwardRef(function SafeAreaView(props, forwardedRef) {
      var emulateUnlessSupported = props.emulateUnlessSupported,
          localProps = (0, _objectWithoutProperties2.default)(props, _excluded);
      return React.createElement(_View.default, (0, _extends2.default)({}, localProps, {
        ref: forwardedRef
      }));
    });
  } else {
    var RCTSafeAreaViewNativeComponent = _$$_REQUIRE(_dependencyMap[6]).default;

    exported = React.forwardRef(function SafeAreaView(props, forwardedRef) {
      return React.createElement(RCTSafeAreaViewNativeComponent, (0, _extends2.default)({
        emulateUnlessSupported: true
      }, props, {
        ref: forwardedRef
      }));
    });
  }

  var _default = exported;
  exports.default = _default;
},"node_modules/react-native/Libraries/Components/SafeAreaView/SafeAreaView.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react/index.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/react-native/Libraries/Components/SafeAreaView/RCTSafeAreaViewNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _default = (0, _codegenNativeComponent.default)('SafeAreaView', {
    paperComponentName: 'RCTSafeAreaView',
    interfaceOnly: true
  });

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/SafeAreaView/RCTSafeAreaViewNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[8]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _RCTSegmentedControlNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _excluded = ["enabled", "forwardedRef", "onValueChange", "style", "values"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var SegmentedControlIOS = function (_React$Component) {
    (0, _inherits2.default)(SegmentedControlIOS, _React$Component);

    var _super = _createSuper(SegmentedControlIOS);

    function SegmentedControlIOS() {
      var _this;

      (0, _classCallCheck2.default)(this, SegmentedControlIOS);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _this._onChange = function (event) {
        _this.props.onChange && _this.props.onChange(event);
        _this.props.onValueChange && _this.props.onValueChange(event.nativeEvent.value);
      };

      return _this;
    }

    (0, _createClass2.default)(SegmentedControlIOS, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            enabled = _this$props.enabled,
            forwardedRef = _this$props.forwardedRef,
            onValueChange = _this$props.onValueChange,
            style = _this$props.style,
            values = _this$props.values,
            props = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
        return React.createElement(_RCTSegmentedControlNativeComponent.default, (0, _extends2.default)({}, props, {
          ref: forwardedRef,
          style: [styles.segmentedControl, style],
          enabled: enabled !== false,
          values: values != null ? values : [],
          onChange: this._onChange
        }));
      }
    }]);
    return SegmentedControlIOS;
  }(React.Component);

  var styles = _StyleSheet.default.create({
    segmentedControl: {
      height: 28
    }
  });

  var SegmentedControlIOSWithRef = React.forwardRef(function (props, forwardedRef) {
    return React.createElement(SegmentedControlIOS, (0, _extends2.default)({}, props, {
      forwardedRef: forwardedRef
    }));
  });
  module.exports = SegmentedControlIOSWithRef;
},"node_modules/react-native/Libraries/Components/SegmentedControlIOS/SegmentedControlIOS.ios.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react/index.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Components/SegmentedControlIOS/RCTSegmentedControlNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _default = (0, _codegenNativeComponent.default)('RCTSegmentedControl');

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/SegmentedControlIOS/RCTSegmentedControlNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _SliderNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _excluded = ["value", "minimumValue", "maximumValue", "step", "onValueChange", "onSlidingComplete"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var Slider = function Slider(props, forwardedRef) {
    var _props$accessibilityS;

    var style = _StyleSheet.default.compose(styles.slider, props.style);

    var _props$value = props.value,
        value = _props$value === undefined ? 0.5 : _props$value,
        _props$minimumValue = props.minimumValue,
        minimumValue = _props$minimumValue === undefined ? 0 : _props$minimumValue,
        _props$maximumValue = props.maximumValue,
        maximumValue = _props$maximumValue === undefined ? 1 : _props$maximumValue,
        _props$step = props.step,
        step = _props$step === undefined ? 0 : _props$step,
        onValueChange = props.onValueChange,
        onSlidingComplete = props.onSlidingComplete,
        localProps = (0, _objectWithoutProperties2.default)(props, _excluded);
    var onValueChangeEvent = onValueChange ? function (event) {
      var userEvent = true;

      if (_Platform.default.OS === 'android') {
        userEvent = event.nativeEvent.fromUser != null && event.nativeEvent.fromUser;
      }

      userEvent && onValueChange(event.nativeEvent.value);
    } : null;
    var onChangeEvent = onValueChangeEvent;
    var onSlidingCompleteEvent = onSlidingComplete ? function (event) {
      onSlidingComplete(event.nativeEvent.value);
    } : null;
    var disabled = props.disabled === true || ((_props$accessibilityS = props.accessibilityState) == null ? undefined : _props$accessibilityS.disabled) === true;
    var accessibilityState = disabled ? (0, _extends2.default)({}, props.accessibilityState, {
      disabled: true
    }) : props.accessibilityState;
    return React.createElement(_SliderNativeComponent.default, (0, _extends2.default)({}, localProps, {
      accessibilityState: accessibilityState,
      enabled: !disabled,
      disabled: disabled,
      maximumValue: maximumValue,
      minimumValue: minimumValue,
      onChange: onChangeEvent,
      onResponderTerminationRequest: function onResponderTerminationRequest() {
        return false;
      },
      onSlidingComplete: onSlidingCompleteEvent,
      onStartShouldSetResponder: function onStartShouldSetResponder() {
        return true;
      },
      onValueChange: onValueChangeEvent,
      ref: forwardedRef,
      step: step,
      style: style,
      value: value
    }));
  };

  var SliderWithRef = React.forwardRef(Slider);
  var styles;

  if (_Platform.default.OS === 'ios') {
    styles = _StyleSheet.default.create({
      slider: {
        height: 40
      }
    });
  } else {
    styles = _StyleSheet.default.create({
      slider: {}
    });
  }

  module.exports = SliderWithRef;
},"node_modules/react-native/Libraries/Components/Slider/Slider.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/Components/Slider/SliderNativeComponent.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _default = (0, _codegenNativeComponent.default)('Slider', {
    interfaceOnly: true,
    paperComponentName: 'RCTSlider'
  });

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/Slider/SliderNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[7]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _processColor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _NativeStatusBarManagerAndroid = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _NativeStatusBarManagerIOS = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var _NativeStatusBarManag;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function mergePropsStack(propsStack, defaultValues) {
    return propsStack.reduce(function (prev, cur) {
      for (var prop in cur) {
        if (cur[prop] != null) {
          prev[prop] = cur[prop];
        }
      }

      return prev;
    }, (0, _extends2.default)({}, defaultValues));
  }

  function createStackEntry(props) {
    var _props$animated, _props$showHideTransi;

    var animated = (_props$animated = props.animated) != null ? _props$animated : false;
    var showHideTransition = (_props$showHideTransi = props.showHideTransition) != null ? _props$showHideTransi : 'fade';
    return {
      backgroundColor: props.backgroundColor != null ? {
        value: props.backgroundColor,
        animated: animated
      } : null,
      barStyle: props.barStyle != null ? {
        value: props.barStyle,
        animated: animated
      } : null,
      translucent: props.translucent,
      hidden: props.hidden != null ? {
        value: props.hidden,
        animated: animated,
        transition: showHideTransition
      } : null,
      networkActivityIndicatorVisible: props.networkActivityIndicatorVisible
    };
  }

  var StatusBar = function (_React$Component) {
    (0, _inherits2.default)(StatusBar, _React$Component);

    var _super = _createSuper(StatusBar);

    function StatusBar() {
      var _this;

      (0, _classCallCheck2.default)(this, StatusBar);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this._stackEntry = null;
      return _this;
    }

    (0, _createClass2.default)(StatusBar, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this._stackEntry = StatusBar.pushStackEntry(this.props);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        StatusBar.popStackEntry(this._stackEntry);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this._stackEntry = StatusBar.replaceStackEntry(this._stackEntry, this.props);
      }
    }, {
      key: "render",
      value: function render() {
        return null;
      }
    }], [{
      key: "setHidden",
      value: function setHidden(hidden, animation) {
        animation = animation || 'none';
        StatusBar._defaultProps.hidden.value = hidden;

        if (_Platform.default.OS === 'ios') {
          _NativeStatusBarManagerIOS.default.setHidden(hidden, animation);
        } else if (_Platform.default.OS === 'android') {
          _NativeStatusBarManagerAndroid.default.setHidden(hidden);
        }
      }
    }, {
      key: "setBarStyle",
      value: function setBarStyle(style, animated) {
        animated = animated || false;
        StatusBar._defaultProps.barStyle.value = style;

        if (_Platform.default.OS === 'ios') {
          _NativeStatusBarManagerIOS.default.setStyle(style, animated);
        } else if (_Platform.default.OS === 'android') {
          _NativeStatusBarManagerAndroid.default.setStyle(style);
        }
      }
    }, {
      key: "setNetworkActivityIndicatorVisible",
      value: function setNetworkActivityIndicatorVisible(visible) {
        if (_Platform.default.OS !== 'ios') {
          console.warn('`setNetworkActivityIndicatorVisible` is only available on iOS');
          return;
        }

        StatusBar._defaultProps.networkActivityIndicatorVisible = visible;

        _NativeStatusBarManagerIOS.default.setNetworkActivityIndicatorVisible(visible);
      }
    }, {
      key: "setBackgroundColor",
      value: function setBackgroundColor(color, animated) {
        if (_Platform.default.OS !== 'android') {
          console.warn('`setBackgroundColor` is only available on Android');
          return;
        }

        animated = animated || false;
        StatusBar._defaultProps.backgroundColor.value = color;
        var processedColor = (0, _processColor.default)(color);

        if (processedColor == null) {
          console.warn("`StatusBar.setBackgroundColor`: Color " + color + " parsed to null or undefined");
          return;
        }

        (0, _invariant.default)(typeof processedColor === 'number', 'Unexpected color given for StatusBar.setBackgroundColor');

        _NativeStatusBarManagerAndroid.default.setColor(processedColor, animated);
      }
    }, {
      key: "setTranslucent",
      value: function setTranslucent(translucent) {
        if (_Platform.default.OS !== 'android') {
          console.warn('`setTranslucent` is only available on Android');
          return;
        }

        StatusBar._defaultProps.translucent = translucent;

        _NativeStatusBarManagerAndroid.default.setTranslucent(translucent);
      }
    }, {
      key: "pushStackEntry",
      value: function pushStackEntry(props) {
        var entry = createStackEntry(props);

        StatusBar._propsStack.push(entry);

        StatusBar._updatePropsStack();

        return entry;
      }
    }, {
      key: "popStackEntry",
      value: function popStackEntry(entry) {
        var index = StatusBar._propsStack.indexOf(entry);

        if (index !== -1) {
          StatusBar._propsStack.splice(index, 1);
        }

        StatusBar._updatePropsStack();
      }
    }, {
      key: "replaceStackEntry",
      value: function replaceStackEntry(entry, props) {
        var newEntry = createStackEntry(props);

        var index = StatusBar._propsStack.indexOf(entry);

        if (index !== -1) {
          StatusBar._propsStack[index] = newEntry;
        }

        StatusBar._updatePropsStack();

        return newEntry;
      }
    }]);
    return StatusBar;
  }(React.Component);

  StatusBar._propsStack = [];
  StatusBar._defaultProps = createStackEntry({
    backgroundColor: _Platform.default.OS === 'android' ? (_NativeStatusBarManag = _NativeStatusBarManagerAndroid.default.getConstants().DEFAULT_BACKGROUND_COLOR) != null ? _NativeStatusBarManag : 'black' : 'black',
    barStyle: 'default',
    translucent: false,
    hidden: false,
    networkActivityIndicatorVisible: false
  });
  StatusBar._updateImmediate = null;
  StatusBar._currentValues = null;
  StatusBar.currentHeight = _Platform.default.OS === 'android' ? _NativeStatusBarManagerAndroid.default.getConstants().HEIGHT : null;

  StatusBar._updatePropsStack = function () {
    clearImmediate(StatusBar._updateImmediate);
    StatusBar._updateImmediate = setImmediate(function () {
      var oldProps = StatusBar._currentValues;
      var mergedProps = mergePropsStack(StatusBar._propsStack, StatusBar._defaultProps);

      if (_Platform.default.OS === 'ios') {
        if (!oldProps || oldProps.barStyle.value !== mergedProps.barStyle.value) {
          _NativeStatusBarManagerIOS.default.setStyle(mergedProps.barStyle.value, mergedProps.barStyle.animated || false);
        }

        if (!oldProps || oldProps.hidden.value !== mergedProps.hidden.value) {
          _NativeStatusBarManagerIOS.default.setHidden(mergedProps.hidden.value, mergedProps.hidden.animated ? mergedProps.hidden.transition : 'none');
        }

        if (!oldProps || oldProps.networkActivityIndicatorVisible !== mergedProps.networkActivityIndicatorVisible) {
          _NativeStatusBarManagerIOS.default.setNetworkActivityIndicatorVisible(mergedProps.networkActivityIndicatorVisible);
        }
      } else if (_Platform.default.OS === 'android') {
        _NativeStatusBarManagerAndroid.default.setStyle(mergedProps.barStyle.value);

        var processedColor = (0, _processColor.default)(mergedProps.backgroundColor.value);

        if (processedColor == null) {
          console.warn("`StatusBar._updatePropsStack`: Color " + mergedProps.backgroundColor.value + " parsed to null or undefined");
        } else {
          (0, _invariant.default)(typeof processedColor === 'number', 'Unexpected color given in StatusBar._updatePropsStack');

          _NativeStatusBarManagerAndroid.default.setColor(processedColor, mergedProps.backgroundColor.animated);
        }

        if (!oldProps || oldProps.hidden.value !== mergedProps.hidden.value) {
          _NativeStatusBarManagerAndroid.default.setHidden(mergedProps.hidden.value);
        }

        if (!oldProps || oldProps.translucent !== mergedProps.translucent) {
          _NativeStatusBarManagerAndroid.default.setTranslucent(mergedProps.translucent);
        }
      }

      StatusBar._currentValues = mergedProps;
    });
  };

  module.exports = StatusBar;
},"node_modules/react-native/Libraries/Components/StatusBar/StatusBar.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/StyleSheet/processColor.js","node_modules/react-native/Libraries/Components/StatusBar/NativeStatusBarManagerAndroid.js","node_modules/react-native/Libraries/Components/StatusBar/NativeStatusBarManagerIOS.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var NativeModule = TurboModuleRegistry.getEnforcing('StatusBarManager');
  var constants = null;
  var NativeStatusBarManager = {
    getConstants: function getConstants() {
      if (constants == null) {
        constants = NativeModule.getConstants();
      }

      return constants;
    },
    setColor: function setColor(color, animated) {
      NativeModule.setColor(color, animated);
    },
    setTranslucent: function setTranslucent(translucent) {
      NativeModule.setTranslucent(translucent);
    },
    setStyle: function setStyle(statusBarStyle) {
      NativeModule.setStyle(statusBarStyle);
    },
    setHidden: function setHidden(hidden) {
      NativeModule.setHidden(hidden);
    }
  };
  var _default = NativeStatusBarManager;
  exports.default = _default;
},"node_modules/react-native/Libraries/Components/StatusBar/NativeStatusBarManagerAndroid.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var NativeModule = TurboModuleRegistry.getEnforcing('StatusBarManager');
  var constants = null;
  var NativeStatusBarManager = {
    getConstants: function getConstants() {
      if (constants == null) {
        constants = NativeModule.getConstants();
      }

      return constants;
    },
    getHeight: function getHeight(callback) {
      NativeModule.getHeight(callback);
    },
    setNetworkActivityIndicatorVisible: function setNetworkActivityIndicatorVisible(visible) {
      NativeModule.setNetworkActivityIndicatorVisible(visible);
    },
    addListener: function addListener(eventType) {
      NativeModule.addListener(eventType);
    },
    removeListeners: function removeListeners(count) {
      NativeModule.removeListeners(count);
    },
    setStyle: function setStyle(statusBarStyle, animated) {
      NativeModule.setStyle(statusBarStyle, animated);
    },
    setHidden: function setHidden(hidden, withAnimation) {
      NativeModule.setHidden(hidden, withAnimation);
    }
  };
  var _default = NativeStatusBarManager;
  exports.default = _default;
},"node_modules/react-native/Libraries/Components/StatusBar/NativeStatusBarManagerIOS.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[5]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _useMergeRefs = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _AndroidSwitchNativeComponent = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[8]));

  var _SwitchNativeComponent = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[9]));

  var _excluded = ["disabled", "ios_backgroundColor", "onChange", "onValueChange", "style", "thumbColor", "trackColor", "value"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var returnsFalse = function returnsFalse() {
    return false;
  };

  var returnsTrue = function returnsTrue() {
    return true;
  };

  var SwitchWithForwardedRef = React.forwardRef(function Switch(props, forwardedRef) {
    var disabled = props.disabled,
        ios_backgroundColor = props.ios_backgroundColor,
        onChange = props.onChange,
        onValueChange = props.onValueChange,
        style = props.style,
        thumbColor = props.thumbColor,
        trackColor = props.trackColor,
        value = props.value,
        restProps = (0, _objectWithoutProperties2.default)(props, _excluded);
    var trackColorForFalse = trackColor == null ? undefined : trackColor.false;
    var trackColorForTrue = trackColor == null ? undefined : trackColor.true;
    var nativeSwitchRef = React.useRef(null);
    var ref = (0, _useMergeRefs.default)(nativeSwitchRef, forwardedRef);

    var _React$useState = React.useState({
      value: null
    }),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
        native = _React$useState2[0],
        setNative = _React$useState2[1];

    var handleChange = function handleChange(event) {
      onChange == null ? undefined : onChange(event);
      onValueChange == null ? undefined : onValueChange(event.nativeEvent.value);
      setNative({
        value: event.nativeEvent.value
      });
    };

    React.useLayoutEffect(function () {
      var _nativeSwitchRef$curr;

      var jsValue = value === true;
      var shouldUpdateNativeSwitch = native.value != null && native.value !== jsValue;

      if (shouldUpdateNativeSwitch && ((_nativeSwitchRef$curr = nativeSwitchRef.current) == null ? undefined : _nativeSwitchRef$curr.setNativeProps) != null) {
        if (_Platform.default.OS === 'android') {
          _AndroidSwitchNativeComponent.Commands.setNativeValue(nativeSwitchRef.current, jsValue);
        } else {
          _SwitchNativeComponent.Commands.setValue(nativeSwitchRef.current, jsValue);
        }
      }
    }, [value, native]);

    if (_Platform.default.OS === 'android') {
      var _props$accessibilityR;

      var platformProps = {
        enabled: disabled !== true,
        on: value === true,
        style: style,
        thumbTintColor: thumbColor,
        trackColorForFalse: trackColorForFalse,
        trackColorForTrue: trackColorForTrue,
        trackTintColor: value === true ? trackColorForTrue : trackColorForFalse
      };
      return React.createElement(_AndroidSwitchNativeComponent.default, (0, _extends2.default)({}, restProps, platformProps, {
        accessibilityRole: (_props$accessibilityR = props.accessibilityRole) != null ? _props$accessibilityR : 'switch',
        onChange: handleChange,
        onResponderTerminationRequest: returnsFalse,
        onStartShouldSetResponder: returnsTrue,
        ref: ref
      }));
    } else {
      var _props$accessibilityR2;

      var _platformProps = {
        disabled: disabled,
        onTintColor: trackColorForTrue,
        style: _StyleSheet.default.compose({
          height: 31,
          width: 51
        }, _StyleSheet.default.compose(style, ios_backgroundColor == null ? null : {
          backgroundColor: ios_backgroundColor,
          borderRadius: 16
        })),
        thumbTintColor: thumbColor,
        tintColor: trackColorForFalse,
        value: value === true
      };
      return React.createElement(_SwitchNativeComponent.default, (0, _extends2.default)({}, restProps, _platformProps, {
        accessibilityRole: (_props$accessibilityR2 = props.accessibilityRole) != null ? _props$accessibilityR2 : 'switch',
        onChange: handleChange,
        onResponderTerminationRequest: returnsFalse,
        onStartShouldSetResponder: returnsTrue,
        ref: ref
      }));
    }
  });
  var _default = SwitchWithForwardedRef;
  exports.default = _default;
},"node_modules/react-native/Libraries/Components/Switch/Switch.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react/index.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Utilities/useMergeRefs.js","node_modules/react-native/Libraries/Components/Switch/AndroidSwitchNativeComponent.js","node_modules/react-native/Libraries/Components/Switch/SwitchNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useMergeRefs;

  var _react = _$$_REQUIRE(_dependencyMap[0]);

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function useMergeRefs() {
    for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
      refs[_key] = arguments[_key];
    }

    return (0, _react.useCallback)(function (current) {
      for (var _iterator = _createForOfIteratorHelperLoose(refs), _step; !(_step = _iterator()).done;) {
        var ref = _step.value;

        if (ref != null) {
          if (typeof ref === 'function') {
            ref(current);
          } else {
            ref.current = current;
          }
        }
      }
    }, [].concat(refs));
  }
},"node_modules/react-native/Libraries/Utilities/useMergeRefs.js",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.Commands = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _codegenNativeCommands = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var Commands = (0, _codegenNativeCommands.default)({
    supportedCommands: ['setNativeValue']
  });
  exports.Commands = Commands;

  var _default = (0, _codegenNativeComponent.default)('AndroidSwitch', {
    interfaceOnly: true
  });

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/Switch/AndroidSwitchNativeComponent.js",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeCommands.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.Commands = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  var _codegenNativeCommands = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var Commands = (0, _codegenNativeCommands.default)({
    supportedCommands: ['setValue']
  });
  exports.Commands = Commands;

  var _default = (0, _codegenNativeComponent.default)('Switch', {
    paperComponentName: 'RCTSwitch',
    excludedPlatforms: ['android']
  });

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/Switch/SwitchNativeComponent.js",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js","node_modules/react-native/Libraries/Utilities/codegenNativeCommands.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _Text = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _TextAncestor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _TextInputState = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _nullthrows = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _setAndForwardRef = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var _usePressability = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[13]));

  var _excluded = ["onBlur", "onFocus"],
      _excluded2 = ["allowFontScaling", "rejectResponderTermination", "underlineColorAndroid"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var useLayoutEffect = React.useLayoutEffect,
      useRef = React.useRef,
      useState = React.useState;
  var AndroidTextInput;
  var AndroidTextInputCommands;
  var RCTSinglelineTextInputView;
  var RCTSinglelineTextInputNativeCommands;
  var RCTMultilineTextInputView;
  var RCTMultilineTextInputNativeCommands;

  if (_Platform.default.OS === 'android') {
    AndroidTextInput = _$$_REQUIRE(_dependencyMap[14]).default;
    AndroidTextInputCommands = _$$_REQUIRE(_dependencyMap[14]).Commands;
  } else if (_Platform.default.OS === 'ios') {
    RCTSinglelineTextInputView = _$$_REQUIRE(_dependencyMap[15]).default;
    RCTSinglelineTextInputNativeCommands = _$$_REQUIRE(_dependencyMap[15]).Commands;
    RCTMultilineTextInputView = _$$_REQUIRE(_dependencyMap[16]).default;
    RCTMultilineTextInputNativeCommands = _$$_REQUIRE(_dependencyMap[16]).Commands;
  }

  var emptyFunctionThatReturnsTrue = function emptyFunctionThatReturnsTrue() {
    return true;
  };

  function InternalTextInput(props) {
    var _props$selection$end, _props$blurOnSubmit;

    var inputRef = useRef(null);
    var selection = props.selection == null ? null : {
      start: props.selection.start,
      end: (_props$selection$end = props.selection.end) != null ? _props$selection$end : props.selection.start
    };

    var _useState = useState(0),
        _useState2 = (0, _slicedToArray2.default)(_useState, 2),
        mostRecentEventCount = _useState2[0],
        setMostRecentEventCount = _useState2[1];

    var _useState3 = useState(props.value),
        _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
        lastNativeText = _useState4[0],
        setLastNativeText = _useState4[1];

    var _useState5 = useState({
      selection: selection,
      mostRecentEventCount: mostRecentEventCount
    }),
        _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
        lastNativeSelectionState = _useState6[0],
        setLastNativeSelection = _useState6[1];

    var lastNativeSelection = lastNativeSelectionState.selection;
    var lastNativeSelectionEventCount = lastNativeSelectionState.mostRecentEventCount;

    if (lastNativeSelectionEventCount < mostRecentEventCount) {
      selection = null;
    }

    var viewCommands;

    if (AndroidTextInputCommands) {
      viewCommands = AndroidTextInputCommands;
    } else {
      viewCommands = props.multiline === true ? RCTMultilineTextInputNativeCommands : RCTSinglelineTextInputNativeCommands;
    }

    var text = typeof props.value === 'string' ? props.value : typeof props.defaultValue === 'string' ? props.defaultValue : '';
    useLayoutEffect(function () {
      var nativeUpdate = {};

      if (lastNativeText !== props.value && typeof props.value === 'string') {
        nativeUpdate.text = props.value;
        setLastNativeText(props.value);
      }

      if (selection && lastNativeSelection && (lastNativeSelection.start !== selection.start || lastNativeSelection.end !== selection.end)) {
        nativeUpdate.selection = selection;
        setLastNativeSelection({
          selection: selection,
          mostRecentEventCount: mostRecentEventCount
        });
      }

      if (Object.keys(nativeUpdate).length === 0) {
        return;
      }

      if (inputRef.current != null) {
        var _selection$start, _selection, _selection$end, _selection2;

        viewCommands.setTextAndSelection(inputRef.current, mostRecentEventCount, text, (_selection$start = (_selection = selection) == null ? undefined : _selection.start) != null ? _selection$start : -1, (_selection$end = (_selection2 = selection) == null ? undefined : _selection2.end) != null ? _selection$end : -1);
      }
    }, [mostRecentEventCount, inputRef, props.value, props.defaultValue, lastNativeText, selection, lastNativeSelection, text, viewCommands]);
    useLayoutEffect(function () {
      var inputRefValue = inputRef.current;

      if (inputRefValue != null) {
        _TextInputState.default.registerInput(inputRefValue);

        return function () {
          _TextInputState.default.unregisterInput(inputRefValue);

          if (_TextInputState.default.currentlyFocusedInput() === inputRefValue) {
            (0, _nullthrows.default)(inputRefValue).blur();
          }
        };
      }
    }, [inputRef]);

    function clear() {
      if (inputRef.current != null) {
        viewCommands.setTextAndSelection(inputRef.current, mostRecentEventCount, '', 0, 0);
      }
    }

    function setSelection(start, end) {
      if (inputRef.current != null) {
        viewCommands.setTextAndSelection(inputRef.current, mostRecentEventCount, null, start, end);
      }
    }

    function isFocused() {
      return _TextInputState.default.currentlyFocusedInput() === inputRef.current;
    }

    function getNativeRef() {
      return inputRef.current;
    }

    var _setNativeRef = (0, _setAndForwardRef.default)({
      getForwardedRef: function getForwardedRef() {
        return props.forwardedRef;
      },
      setLocalRef: function setLocalRef(ref) {
        inputRef.current = ref;

        if (ref) {
          ref.clear = clear;
          ref.isFocused = isFocused;
          ref.getNativeRef = getNativeRef;
          ref.setSelection = setSelection;
        }
      }
    });

    var _onChange = function _onChange(event) {
      var currentText = event.nativeEvent.text;
      props.onChange && props.onChange(event);
      props.onChangeText && props.onChangeText(currentText);

      if (inputRef.current == null) {
        return;
      }

      setLastNativeText(currentText);
      setMostRecentEventCount(event.nativeEvent.eventCount);
    };

    var _onChangeSync = function _onChangeSync(event) {
      var currentText = event.nativeEvent.text;
      props.unstable_onChangeSync && props.unstable_onChangeSync(event);
      props.unstable_onChangeTextSync && props.unstable_onChangeTextSync(currentText);

      if (inputRef.current == null) {
        return;
      }

      setLastNativeText(currentText);
      setMostRecentEventCount(event.nativeEvent.eventCount);
    };

    var _onSelectionChange = function _onSelectionChange(event) {
      props.onSelectionChange && props.onSelectionChange(event);

      if (inputRef.current == null) {
        return;
      }

      setLastNativeSelection({
        selection: event.nativeEvent.selection,
        mostRecentEventCount: mostRecentEventCount
      });
    };

    var _onFocus = function _onFocus(event) {
      _TextInputState.default.focusInput(inputRef.current);

      if (props.onFocus) {
        props.onFocus(event);
      }
    };

    var _onBlur = function _onBlur(event) {
      _TextInputState.default.blurInput(inputRef.current);

      if (props.onBlur) {
        props.onBlur(event);
      }
    };

    var _onScroll = function _onScroll(event) {
      props.onScroll && props.onScroll(event);
    };

    var textInput = null;
    var blurOnSubmit = (_props$blurOnSubmit = props.blurOnSubmit) != null ? _props$blurOnSubmit : !props.multiline;
    var accessible = props.accessible !== false;
    var focusable = props.focusable !== false;
    var config = React.useMemo(function () {
      return {
        onPress: function onPress(event) {
          if (props.editable !== false) {
            if (inputRef.current != null) {
              inputRef.current.focus();
            }
          }
        },
        onPressIn: props.onPressIn,
        onPressOut: props.onPressOut,
        cancelable: _Platform.default.OS === 'ios' ? !props.rejectResponderTermination : null
      };
    }, [props.editable, props.onPressIn, props.onPressOut, props.rejectResponderTermination]);
    var caretHidden = props.caretHidden;

    if (_Platform.default.isTesting) {
      caretHidden = true;
    }

    var _ref = (0, _usePressability.default)(config) || {},
        onBlur = _ref.onBlur,
        onFocus = _ref.onFocus,
        eventHandlers = (0, _objectWithoutProperties2.default)(_ref, _excluded);

    if (_Platform.default.OS === 'ios') {
      var RCTTextInputView = props.multiline === true ? RCTMultilineTextInputView : RCTSinglelineTextInputView;
      var style = props.multiline === true ? [styles.multilineInput, props.style] : props.style;
      var useOnChangeSync = (props.unstable_onChangeSync || props.unstable_onChangeTextSync) && !(props.onChange || props.onChangeText);
      textInput = React.createElement(RCTTextInputView, (0, _extends2.default)({
        ref: _setNativeRef
      }, props, eventHandlers, {
        accessible: accessible,
        blurOnSubmit: blurOnSubmit,
        caretHidden: caretHidden,
        dataDetectorTypes: props.dataDetectorTypes,
        focusable: focusable,
        mostRecentEventCount: mostRecentEventCount,
        onBlur: _onBlur,
        onKeyPressSync: props.unstable_onKeyPressSync,
        onChange: _onChange,
        onChangeSync: useOnChangeSync === true ? _onChangeSync : null,
        onContentSizeChange: props.onContentSizeChange,
        onFocus: _onFocus,
        onScroll: _onScroll,
        onSelectionChange: _onSelectionChange,
        onSelectionChangeShouldSetResponder: emptyFunctionThatReturnsTrue,
        selection: selection,
        style: style,
        text: text
      }));
    } else if (_Platform.default.OS === 'android') {
      var _props$placeholder;

      var _style = [props.style];
      var autoCapitalize = props.autoCapitalize || 'sentences';
      var placeholder = (_props$placeholder = props.placeholder) != null ? _props$placeholder : '';
      var children = props.children;
      var childCount = React.Children.count(children);
      (0, _invariant.default)(!(props.value != null && childCount), 'Cannot specify both value and children.');

      if (childCount > 1) {
        children = React.createElement(_Text.default, null, children);
      }

      textInput = React.createElement(AndroidTextInput, (0, _extends2.default)({
        ref: _setNativeRef
      }, props, eventHandlers, {
        accessible: accessible,
        autoCapitalize: autoCapitalize,
        blurOnSubmit: blurOnSubmit,
        caretHidden: caretHidden,
        children: children,
        disableFullscreenUI: props.disableFullscreenUI,
        focusable: focusable,
        mostRecentEventCount: mostRecentEventCount,
        onBlur: _onBlur,
        onChange: _onChange,
        onFocus: _onFocus,
        onScroll: _onScroll,
        onSelectionChange: _onSelectionChange,
        placeholder: placeholder,
        selection: selection,
        style: _style,
        text: text,
        textBreakStrategy: props.textBreakStrategy
      }));
    }

    return React.createElement(_TextAncestor.default.Provider, {
      value: true
    }, textInput);
  }

  var ExportedForwardRef = React.forwardRef(function TextInput(_ref2, forwardedRef) {
    var _ref2$allowFontScalin = _ref2.allowFontScaling,
        allowFontScaling = _ref2$allowFontScalin === undefined ? true : _ref2$allowFontScalin,
        _ref2$rejectResponder = _ref2.rejectResponderTermination,
        rejectResponderTermination = _ref2$rejectResponder === undefined ? true : _ref2$rejectResponder,
        _ref2$underlineColorA = _ref2.underlineColorAndroid,
        underlineColorAndroid = _ref2$underlineColorA === undefined ? 'transparent' : _ref2$underlineColorA,
        restProps = (0, _objectWithoutProperties2.default)(_ref2, _excluded2);
    return React.createElement(InternalTextInput, (0, _extends2.default)({
      allowFontScaling: allowFontScaling,
      rejectResponderTermination: rejectResponderTermination,
      underlineColorAndroid: underlineColorAndroid
    }, restProps, {
      forwardedRef: forwardedRef
    }));
  });
  ExportedForwardRef.propTypes = _$$_REQUIRE(_dependencyMap[17]).TextInputPropTypes;
  ExportedForwardRef.State = {
    currentlyFocusedInput: _TextInputState.default.currentlyFocusedInput,
    currentlyFocusedField: _TextInputState.default.currentlyFocusedField,
    focusTextInput: _TextInputState.default.focusTextInput,
    blurTextInput: _TextInputState.default.blurTextInput
  };

  var styles = _StyleSheet.default.create({
    multilineInput: {
      paddingTop: 5
    }
  });

  module.exports = ExportedForwardRef;
},"node_modules/react-native/Libraries/Components/TextInput/TextInput.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react/index.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Text/Text.js","node_modules/react-native/Libraries/Text/TextAncestor.js","node_modules/react-native/Libraries/Components/TextInput/TextInputState.js","node_modules/invariant/browser.js","node_modules/nullthrows/nullthrows.js","node_modules/react-native/Libraries/Utilities/setAndForwardRef.js","node_modules/react-native/Libraries/Pressability/usePressability.js","node_modules/react-native/Libraries/Components/TextInput/AndroidTextInputNativeComponent.js","node_modules/react-native/Libraries/Components/TextInput/RCTSingelineTextInputNativeComponent.js","node_modules/react-native/Libraries/Components/TextInput/RCTMultilineTextInputNativeComponent.js","node_modules/deprecated-react-native-prop-types/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function nullthrows(x, message) {
    if (x != null) {
      return x;
    }

    var error = new Error(message !== undefined ? message : 'Got unexpected ' + x);
    error.framesToPop = 1;
    throw error;
  }

  module.exports = nullthrows;
  module.exports.default = nullthrows;
  Object.defineProperty(module.exports, '__esModule', {
    value: true
  });
},"node_modules/nullthrows/nullthrows.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.Commands = undefined;

  var _codegenNativeCommands = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var NativeComponentRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var Commands = (0, _codegenNativeCommands.default)({
    supportedCommands: ['focus', 'blur', 'setTextAndSelection']
  });
  exports.Commands = Commands;
  var AndroidTextInputNativeComponent = NativeComponentRegistry.get('AndroidTextInput', function () {
    return {
      uiViewClassName: 'AndroidTextInput',
      bubblingEventTypes: {
        topBlur: {
          phasedRegistrationNames: {
            bubbled: 'onBlur',
            captured: 'onBlurCapture'
          }
        },
        topEndEditing: {
          phasedRegistrationNames: {
            bubbled: 'onEndEditing',
            captured: 'onEndEditingCapture'
          }
        },
        topFocus: {
          phasedRegistrationNames: {
            bubbled: 'onFocus',
            captured: 'onFocusCapture'
          }
        },
        topKeyPress: {
          phasedRegistrationNames: {
            bubbled: 'onKeyPress',
            captured: 'onKeyPressCapture'
          }
        },
        topSubmitEditing: {
          phasedRegistrationNames: {
            bubbled: 'onSubmitEditing',
            captured: 'onSubmitEditingCapture'
          }
        },
        topTextInput: {
          phasedRegistrationNames: {
            bubbled: 'onTextInput',
            captured: 'onTextInputCapture'
          }
        }
      },
      directEventTypes: {
        topScroll: {
          registrationName: 'onScroll'
        }
      },
      validAttributes: {
        maxFontSizeMultiplier: true,
        adjustsFontSizeToFit: true,
        minimumFontScale: true,
        autoFocus: true,
        placeholder: true,
        inlineImagePadding: true,
        contextMenuHidden: true,
        textShadowColor: {
          process: _$$_REQUIRE(_dependencyMap[3])
        },
        maxLength: true,
        selectTextOnFocus: true,
        textShadowRadius: true,
        underlineColorAndroid: {
          process: _$$_REQUIRE(_dependencyMap[3])
        },
        textDecorationLine: true,
        blurOnSubmit: true,
        textAlignVertical: true,
        fontStyle: true,
        textShadowOffset: true,
        selectionColor: {
          process: _$$_REQUIRE(_dependencyMap[3])
        },
        selection: true,
        placeholderTextColor: {
          process: _$$_REQUIRE(_dependencyMap[3])
        },
        importantForAutofill: true,
        lineHeight: true,
        textTransform: true,
        returnKeyType: true,
        keyboardType: true,
        multiline: true,
        color: {
          process: _$$_REQUIRE(_dependencyMap[3])
        },
        autoComplete: true,
        numberOfLines: true,
        letterSpacing: true,
        returnKeyLabel: true,
        fontSize: true,
        onKeyPress: true,
        cursorColor: {
          process: _$$_REQUIRE(_dependencyMap[3])
        },
        text: true,
        showSoftInputOnFocus: true,
        textAlign: true,
        autoCapitalize: true,
        autoCorrect: true,
        caretHidden: true,
        secureTextEntry: true,
        textBreakStrategy: true,
        onScroll: true,
        onContentSizeChange: true,
        disableFullscreenUI: true,
        includeFontPadding: true,
        fontWeight: true,
        fontFamily: true,
        allowFontScaling: true,
        onSelectionChange: true,
        mostRecentEventCount: true,
        inlineImageLeft: true,
        editable: true,
        fontVariant: true,
        borderBottomRightRadius: true,
        borderBottomColor: {
          process: _$$_REQUIRE(_dependencyMap[3])
        },
        borderRadius: true,
        borderRightColor: {
          process: _$$_REQUIRE(_dependencyMap[3])
        },
        borderColor: {
          process: _$$_REQUIRE(_dependencyMap[3])
        },
        borderTopRightRadius: true,
        borderStyle: true,
        borderBottomLeftRadius: true,
        borderLeftColor: {
          process: _$$_REQUIRE(_dependencyMap[3])
        },
        borderTopLeftRadius: true,
        borderTopColor: {
          process: _$$_REQUIRE(_dependencyMap[3])
        }
      }
    };
  });
  var _default = AndroidTextInputNativeComponent;
  exports.default = _default;
},"node_modules/react-native/Libraries/Components/TextInput/AndroidTextInputNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeCommands.js","node_modules/react-native/Libraries/NativeComponent/NativeComponentRegistry.js","node_modules/react-native/Libraries/StyleSheet/processColor.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.Commands = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _codegenNativeCommands = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _RCTTextInputViewConfig = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var NativeComponentRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var Commands = (0, _codegenNativeCommands.default)({
    supportedCommands: ['focus', 'blur', 'setTextAndSelection']
  });
  exports.Commands = Commands;
  var MultilineTextInputNativeComponent = NativeComponentRegistry.get('RCTMultilineTextInputView', function () {
    return (0, _extends2.default)({
      uiViewClassName: 'RCTMultilineTextInputView'
    }, _RCTTextInputViewConfig.default, {
      validAttributes: (0, _extends2.default)({}, _RCTTextInputViewConfig.default.validAttributes, {
        dataDetectorTypes: true
      })
    });
  });
  var _default = MultilineTextInputNativeComponent;
  exports.default = _default;
},"node_modules/react-native/Libraries/Components/TextInput/RCTMultilineTextInputNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Utilities/codegenNativeCommands.js","node_modules/react-native/Libraries/Components/TextInput/RCTTextInputViewConfig.js","node_modules/react-native/Libraries/NativeComponent/NativeComponentRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _BoundingDimensions = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _Position = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _UIManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _SoundManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var extractSingleTouch = function extractSingleTouch(nativeEvent) {
    var touches = nativeEvent.touches;
    var changedTouches = nativeEvent.changedTouches;
    var hasTouches = touches && touches.length > 0;
    var hasChangedTouches = changedTouches && changedTouches.length > 0;
    return !hasTouches && hasChangedTouches ? changedTouches[0] : hasTouches ? touches[0] : nativeEvent;
  };

  var States = {
    NOT_RESPONDER: 'NOT_RESPONDER',
    RESPONDER_INACTIVE_PRESS_IN: 'RESPONDER_INACTIVE_PRESS_IN',
    RESPONDER_INACTIVE_PRESS_OUT: 'RESPONDER_INACTIVE_PRESS_OUT',
    RESPONDER_ACTIVE_PRESS_IN: 'RESPONDER_ACTIVE_PRESS_IN',
    RESPONDER_ACTIVE_PRESS_OUT: 'RESPONDER_ACTIVE_PRESS_OUT',
    RESPONDER_ACTIVE_LONG_PRESS_IN: 'RESPONDER_ACTIVE_LONG_PRESS_IN',
    RESPONDER_ACTIVE_LONG_PRESS_OUT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',
    ERROR: 'ERROR'
  };
  var baseStatesConditions = {
    NOT_RESPONDER: false,
    RESPONDER_INACTIVE_PRESS_IN: false,
    RESPONDER_INACTIVE_PRESS_OUT: false,
    RESPONDER_ACTIVE_PRESS_IN: false,
    RESPONDER_ACTIVE_PRESS_OUT: false,
    RESPONDER_ACTIVE_LONG_PRESS_IN: false,
    RESPONDER_ACTIVE_LONG_PRESS_OUT: false,
    ERROR: false
  };
  var IsActive = (0, _extends2.default)({}, baseStatesConditions, {
    RESPONDER_ACTIVE_PRESS_OUT: true,
    RESPONDER_ACTIVE_PRESS_IN: true
  });
  var IsPressingIn = (0, _extends2.default)({}, baseStatesConditions, {
    RESPONDER_INACTIVE_PRESS_IN: true,
    RESPONDER_ACTIVE_PRESS_IN: true,
    RESPONDER_ACTIVE_LONG_PRESS_IN: true
  });
  var IsLongPressingIn = (0, _extends2.default)({}, baseStatesConditions, {
    RESPONDER_ACTIVE_LONG_PRESS_IN: true
  });
  var Signals = {
    DELAY: 'DELAY',
    RESPONDER_GRANT: 'RESPONDER_GRANT',
    RESPONDER_RELEASE: 'RESPONDER_RELEASE',
    RESPONDER_TERMINATED: 'RESPONDER_TERMINATED',
    ENTER_PRESS_RECT: 'ENTER_PRESS_RECT',
    LEAVE_PRESS_RECT: 'LEAVE_PRESS_RECT',
    LONG_PRESS_DETECTED: 'LONG_PRESS_DETECTED'
  };
  var Transitions = {
    NOT_RESPONDER: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
      RESPONDER_RELEASE: States.ERROR,
      RESPONDER_TERMINATED: States.ERROR,
      ENTER_PRESS_RECT: States.ERROR,
      LEAVE_PRESS_RECT: States.ERROR,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_INACTIVE_PRESS_IN: {
      DELAY: States.RESPONDER_ACTIVE_PRESS_IN,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_INACTIVE_PRESS_OUT: {
      DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_ACTIVE_PRESS_IN: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
    },
    RESPONDER_ACTIVE_PRESS_OUT: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_ACTIVE_LONG_PRESS_IN: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
      LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
    },
    RESPONDER_ACTIVE_LONG_PRESS_OUT: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    error: {
      DELAY: States.NOT_RESPONDER,
      RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.NOT_RESPONDER,
      LEAVE_PRESS_RECT: States.NOT_RESPONDER,
      LONG_PRESS_DETECTED: States.NOT_RESPONDER
    }
  };
  var HIGHLIGHT_DELAY_MS = 130;
  var PRESS_EXPAND_PX = 20;
  var LONG_PRESS_THRESHOLD = 500;
  var LONG_PRESS_DELAY_MS = 370;
  var LONG_PRESS_ALLOWED_MOVEMENT = 10;
  var TouchableMixin = {
    componentDidMount: function componentDidMount() {
      if (!_Platform.default.isTV) {
        return;
      }
    },
    componentWillUnmount: function componentWillUnmount() {
      this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
      this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
      this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
    },
    touchableGetInitialState: function touchableGetInitialState() {
      return {
        touchable: {
          touchState: undefined,
          responderID: null
        }
      };
    },
    touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {
      return !this.props.rejectResponderTermination;
    },
    touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {
      return !this.props.disabled;
    },
    touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {
      return true;
    },
    touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {
      var dispatchID = e.currentTarget;
      e.persist();
      this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
      this.pressOutDelayTimeout = null;
      this.state.touchable.touchState = States.NOT_RESPONDER;
      this.state.touchable.responderID = dispatchID;

      this._receiveSignal(Signals.RESPONDER_GRANT, e);

      var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;
      delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;

      if (delayMS !== 0) {
        this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);
      } else {
        this._handleDelay(e);
      }

      var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;
      longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;
      this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);
    },
    touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {
      this.pressInLocation = null;

      this._receiveSignal(Signals.RESPONDER_RELEASE, e);
    },
    touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {
      this.pressInLocation = null;

      this._receiveSignal(Signals.RESPONDER_TERMINATED, e);
    },
    touchableHandleResponderMove: function touchableHandleResponderMove(e) {
      if (!this.state.touchable.positionOnActivate) {
        return;
      }

      var positionOnActivate = this.state.touchable.positionOnActivate;
      var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;
      var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {
        left: PRESS_EXPAND_PX,
        right: PRESS_EXPAND_PX,
        top: PRESS_EXPAND_PX,
        bottom: PRESS_EXPAND_PX
      };
      var pressExpandLeft = pressRectOffset.left;
      var pressExpandTop = pressRectOffset.top;
      var pressExpandRight = pressRectOffset.right;
      var pressExpandBottom = pressRectOffset.bottom;
      var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;

      if (hitSlop) {
        pressExpandLeft += hitSlop.left || 0;
        pressExpandTop += hitSlop.top || 0;
        pressExpandRight += hitSlop.right || 0;
        pressExpandBottom += hitSlop.bottom || 0;
      }

      var touch = extractSingleTouch(e.nativeEvent);
      var pageX = touch && touch.pageX;
      var pageY = touch && touch.pageY;

      if (this.pressInLocation) {
        var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);

        if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {
          this._cancelLongPressDelayTimeout();
        }
      }

      var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;

      if (isTouchWithinActive) {
        var prevState = this.state.touchable.touchState;

        this._receiveSignal(Signals.ENTER_PRESS_RECT, e);

        var curState = this.state.touchable.touchState;

        if (curState === States.RESPONDER_INACTIVE_PRESS_IN && prevState !== States.RESPONDER_INACTIVE_PRESS_IN) {
          this._cancelLongPressDelayTimeout();
        }
      } else {
        this._cancelLongPressDelayTimeout();

        this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);
      }
    },
    touchableHandleFocus: function touchableHandleFocus(e) {
      this.props.onFocus && this.props.onFocus(e);
    },
    touchableHandleBlur: function touchableHandleBlur(e) {
      this.props.onBlur && this.props.onBlur(e);
    },
    _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {
      var responderID = this.state.touchable.responderID;

      if (responderID == null) {
        return;
      }

      if (typeof responderID === 'number') {
        _UIManager.default.measure(responderID, this._handleQueryLayout);
      } else {
        responderID.measure(this._handleQueryLayout);
      }
    },
    _handleQueryLayout: function _handleQueryLayout(l, t, w, h, globalX, globalY) {
      if (!l && !t && !w && !h && !globalX && !globalY) {
        return;
      }

      this.state.touchable.positionOnActivate && _Position.default.release(this.state.touchable.positionOnActivate);
      this.state.touchable.dimensionsOnActivate && _BoundingDimensions.default.release(this.state.touchable.dimensionsOnActivate);
      this.state.touchable.positionOnActivate = _Position.default.getPooled(globalX, globalY);
      this.state.touchable.dimensionsOnActivate = _BoundingDimensions.default.getPooled(w, h);
    },
    _handleDelay: function _handleDelay(e) {
      this.touchableDelayTimeout = null;

      this._receiveSignal(Signals.DELAY, e);
    },
    _handleLongDelay: function _handleLongDelay(e) {
      this.longPressDelayTimeout = null;
      var curState = this.state.touchable.touchState;

      if (curState === States.RESPONDER_ACTIVE_PRESS_IN || curState === States.RESPONDER_ACTIVE_LONG_PRESS_IN) {
        this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);
      }
    },
    _receiveSignal: function _receiveSignal(signal, e) {
      var responderID = this.state.touchable.responderID;
      var curState = this.state.touchable.touchState;
      var nextState = Transitions[curState] && Transitions[curState][signal];

      if (!responderID && signal === Signals.RESPONDER_RELEASE) {
        return;
      }

      if (!nextState) {
        throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + typeof this.state.touchable.responderID === 'number' ? this.state.touchable.responderID : "host component`");
      }

      if (nextState === States.ERROR) {
        throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + typeof this.state.touchable.responderID === 'number' ? this.state.touchable.responderID : "<<host component>>`");
      }

      if (curState !== nextState) {
        this._performSideEffectsForTransition(curState, nextState, signal, e);

        this.state.touchable.touchState = nextState;
      }
    },
    _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {
      this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
      this.longPressDelayTimeout = null;
    },
    _isHighlight: function _isHighlight(state) {
      return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;
    },
    _savePressInLocation: function _savePressInLocation(e) {
      var touch = extractSingleTouch(e.nativeEvent);
      var pageX = touch && touch.pageX;
      var pageY = touch && touch.pageY;
      var locationX = touch && touch.locationX;
      var locationY = touch && touch.locationY;
      this.pressInLocation = {
        pageX: pageX,
        pageY: pageY,
        locationX: locationX,
        locationY: locationY
      };
    },
    _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {
      var deltaX = aX - bX;
      var deltaY = aY - bY;
      return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    },
    _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {
      var curIsHighlight = this._isHighlight(curState);

      var newIsHighlight = this._isHighlight(nextState);

      var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;

      if (isFinalSignal) {
        this._cancelLongPressDelayTimeout();
      }

      var isInitialTransition = curState === States.NOT_RESPONDER && nextState === States.RESPONDER_INACTIVE_PRESS_IN;
      var isActiveTransition = !IsActive[curState] && IsActive[nextState];

      if (isInitialTransition || isActiveTransition) {
        this._remeasureMetricsOnActivation();
      }

      if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {
        this.touchableHandleLongPress && this.touchableHandleLongPress(e);
      }

      if (newIsHighlight && !curIsHighlight) {
        this._startHighlight(e);
      } else if (!newIsHighlight && curIsHighlight) {
        this._endHighlight(e);
      }

      if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {
        var hasLongPressHandler = !!this.props.onLongPress;
        var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && (!hasLongPressHandler || !this.touchableLongPressCancelsPress());
        var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;

        if (shouldInvokePress && this.touchableHandlePress) {
          if (!newIsHighlight && !curIsHighlight) {
            this._startHighlight(e);

            this._endHighlight(e);
          }

          if (_Platform.default.OS === 'android' && !this.props.touchSoundDisabled) {
            _SoundManager.default.playTouchSound();
          }

          this.touchableHandlePress(e);
        }
      }

      this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
      this.touchableDelayTimeout = null;
    },
    _startHighlight: function _startHighlight(e) {
      this._savePressInLocation(e);

      this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);
    },
    _endHighlight: function _endHighlight(e) {
      var _this = this;

      if (this.touchableHandleActivePressOut) {
        if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {
          this.pressOutDelayTimeout = setTimeout(function () {
            _this.touchableHandleActivePressOut(e);
          }, this.touchableGetPressOutDelayMS());
        } else {
          this.touchableHandleActivePressOut(e);
        }
      }
    },
    withoutDefaultFocusAndBlur: {}
  };
  var touchableHandleFocus = TouchableMixin.touchableHandleFocus,
      touchableHandleBlur = TouchableMixin.touchableHandleBlur,
      TouchableMixinWithoutDefaultFocusAndBlur = (0, _objectWithoutProperties2.default)(TouchableMixin, ["touchableHandleFocus", "touchableHandleBlur"]);
  TouchableMixin.withoutDefaultFocusAndBlur = TouchableMixinWithoutDefaultFocusAndBlur;
  var Touchable = {
    Mixin: TouchableMixin,
    renderDebugView: function renderDebugView(_ref) {
      var color = _ref.color,
          hitSlop = _ref.hitSlop;
      return null;
    }
  };
  module.exports = Touchable;
},"node_modules/react-native/Libraries/Components/Touchable/Touchable.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/react-native/Libraries/Components/Touchable/BoundingDimensions.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/Components/Touchable/Position.js","node_modules/react-native/Libraries/ReactNative/UIManager.js","node_modules/react-native/Libraries/Components/Sound/SoundManager.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _PooledClass = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var twoArgumentPooler = _PooledClass.default.twoArgumentPooler;

  function BoundingDimensions(width, height) {
    this.width = width;
    this.height = height;
  }

  BoundingDimensions.prototype.destructor = function () {
    this.width = null;
    this.height = null;
  };

  BoundingDimensions.getPooledFromElement = function (element) {
    return BoundingDimensions.getPooled(element.offsetWidth, element.offsetHeight);
  };

  _PooledClass.default.addPoolingTo(BoundingDimensions, twoArgumentPooler);

  module.exports = BoundingDimensions;
},"node_modules/react-native/Libraries/Components/Touchable/BoundingDimensions.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Components/Touchable/PooledClass.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
    var Klass = this;

    if (Klass.instancePool.length) {
      var _instance = Klass.instancePool.pop();

      Klass.call(_instance, copyFieldsFrom);
      return _instance;
    } else {
      return new Klass(copyFieldsFrom);
    }
  };

  var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
    var Klass = this;

    if (Klass.instancePool.length) {
      var _instance2 = Klass.instancePool.pop();

      Klass.call(_instance2, a1, a2);
      return _instance2;
    } else {
      return new Klass(a1, a2);
    }
  };

  var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
    var Klass = this;

    if (Klass.instancePool.length) {
      var _instance3 = Klass.instancePool.pop();

      Klass.call(_instance3, a1, a2, a3);
      return _instance3;
    } else {
      return new Klass(a1, a2, a3);
    }
  };

  var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
    var Klass = this;

    if (Klass.instancePool.length) {
      var _instance4 = Klass.instancePool.pop();

      Klass.call(_instance4, a1, a2, a3, a4);
      return _instance4;
    } else {
      return new Klass(a1, a2, a3, a4);
    }
  };

  var standardReleaser = function standardReleaser(instance) {
    var Klass = this;
    (0, _invariant.default)(instance instanceof Klass, 'Trying to release an instance into a pool of a different type.');
    instance.destructor();

    if (Klass.instancePool.length < Klass.poolSize) {
      Klass.instancePool.push(instance);
    }
  };

  var DEFAULT_POOL_SIZE = 10;
  var DEFAULT_POOLER = oneArgumentPooler;

  var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
    var NewKlass = CopyConstructor;
    NewKlass.instancePool = [];
    NewKlass.getPooled = pooler || DEFAULT_POOLER;

    if (!NewKlass.poolSize) {
      NewKlass.poolSize = DEFAULT_POOL_SIZE;
    }

    NewKlass.release = standardReleaser;
    return NewKlass;
  };

  var PooledClass = {
    addPoolingTo: addPoolingTo,
    oneArgumentPooler: oneArgumentPooler,
    twoArgumentPooler: twoArgumentPooler,
    threeArgumentPooler: threeArgumentPooler,
    fourArgumentPooler: fourArgumentPooler
  };
  module.exports = PooledClass;
},"node_modules/react-native/Libraries/Components/Touchable/PooledClass.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _PooledClass = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var twoArgumentPooler = _PooledClass.default.twoArgumentPooler;

  function Position(left, top) {
    this.left = left;
    this.top = top;
  }

  Position.prototype.destructor = function () {
    this.left = null;
    this.top = null;
  };

  _PooledClass.default.addPoolingTo(Position, twoArgumentPooler);

  module.exports = Position;
},"node_modules/react-native/Libraries/Components/Touchable/Position.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Components/Touchable/PooledClass.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _Pressability = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _View = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[12]));

  var _excluded = ["onBlur", "onFocus"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TouchableHighlight = function (_React$Component) {
    (0, _inherits2.default)(TouchableHighlight, _React$Component);

    var _super = _createSuper(TouchableHighlight);

    function TouchableHighlight() {
      var _this;

      (0, _classCallCheck2.default)(this, TouchableHighlight);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this._isMounted = false;
      _this.state = {
        pressability: new _Pressability.default(_this._createPressabilityConfig()),
        extraStyles: _this.props.testOnly_pressed === true ? _this._createExtraStyles() : null
      };
      return _this;
    }

    (0, _createClass2.default)(TouchableHighlight, [{
      key: "_createPressabilityConfig",
      value: function _createPressabilityConfig() {
        var _this$props$accessibi,
            _this2 = this;

        return {
          cancelable: !this.props.rejectResponderTermination,
          disabled: this.props.disabled != null ? this.props.disabled : (_this$props$accessibi = this.props.accessibilityState) == null ? undefined : _this$props$accessibi.disabled,
          hitSlop: this.props.hitSlop,
          delayLongPress: this.props.delayLongPress,
          delayPressIn: this.props.delayPressIn,
          delayPressOut: this.props.delayPressOut,
          minPressDuration: 0,
          pressRectOffset: this.props.pressRetentionOffset,
          android_disableSound: this.props.touchSoundDisabled,
          onBlur: function onBlur(event) {
            if (_Platform.default.isTV) {
              _this2._hideUnderlay();
            }

            if (_this2.props.onBlur != null) {
              _this2.props.onBlur(event);
            }
          },
          onFocus: function onFocus(event) {
            if (_Platform.default.isTV) {
              _this2._showUnderlay();
            }

            if (_this2.props.onFocus != null) {
              _this2.props.onFocus(event);
            }
          },
          onLongPress: this.props.onLongPress,
          onPress: function onPress(event) {
            if (_this2._hideTimeout != null) {
              clearTimeout(_this2._hideTimeout);
            }

            if (!_Platform.default.isTV) {
              var _this2$props$delayPre;

              _this2._showUnderlay();

              _this2._hideTimeout = setTimeout(function () {
                _this2._hideUnderlay();
              }, (_this2$props$delayPre = _this2.props.delayPressOut) != null ? _this2$props$delayPre : 0);
            }

            if (_this2.props.onPress != null) {
              _this2.props.onPress(event);
            }
          },
          onPressIn: function onPressIn(event) {
            if (_this2._hideTimeout != null) {
              clearTimeout(_this2._hideTimeout);
              _this2._hideTimeout = null;
            }

            _this2._showUnderlay();

            if (_this2.props.onPressIn != null) {
              _this2.props.onPressIn(event);
            }
          },
          onPressOut: function onPressOut(event) {
            if (_this2._hideTimeout == null) {
              _this2._hideUnderlay();
            }

            if (_this2.props.onPressOut != null) {
              _this2.props.onPressOut(event);
            }
          }
        };
      }
    }, {
      key: "_createExtraStyles",
      value: function _createExtraStyles() {
        var _this$props$activeOpa;

        return {
          child: {
            opacity: (_this$props$activeOpa = this.props.activeOpacity) != null ? _this$props$activeOpa : 0.85
          },
          underlay: {
            backgroundColor: this.props.underlayColor === undefined ? 'black' : this.props.underlayColor
          }
        };
      }
    }, {
      key: "_showUnderlay",
      value: function _showUnderlay() {
        if (!this._isMounted || !this._hasPressHandler()) {
          return;
        }

        this.setState({
          extraStyles: this._createExtraStyles()
        });

        if (this.props.onShowUnderlay != null) {
          this.props.onShowUnderlay();
        }
      }
    }, {
      key: "_hideUnderlay",
      value: function _hideUnderlay() {
        if (this._hideTimeout != null) {
          clearTimeout(this._hideTimeout);
          this._hideTimeout = null;
        }

        if (this.props.testOnly_pressed === true) {
          return;
        }

        if (this._hasPressHandler()) {
          this.setState({
            extraStyles: null
          });

          if (this.props.onHideUnderlay != null) {
            this.props.onHideUnderlay();
          }
        }
      }
    }, {
      key: "_hasPressHandler",
      value: function _hasPressHandler() {
        return this.props.onPress != null || this.props.onPressIn != null || this.props.onPressOut != null || this.props.onLongPress != null;
      }
    }, {
      key: "render",
      value: function render() {
        var _this$state$extraStyl, _this$state$extraStyl2;

        var child = React.Children.only(this.props.children);

        var _this$state$pressabil = this.state.pressability.getEventHandlers(),
            onBlur = _this$state$pressabil.onBlur,
            onFocus = _this$state$pressabil.onFocus,
            eventHandlersWithoutBlurAndFocus = (0, _objectWithoutProperties2.default)(_this$state$pressabil, _excluded);

        var accessibilityState = this.props.disabled != null ? (0, _extends2.default)({}, this.props.accessibilityState, {
          disabled: this.props.disabled
        }) : this.props.accessibilityState;
        return React.createElement(_View.default, (0, _extends2.default)({
          accessible: this.props.accessible !== false,
          accessibilityLabel: this.props.accessibilityLabel,
          accessibilityHint: this.props.accessibilityHint,
          accessibilityRole: this.props.accessibilityRole,
          accessibilityState: accessibilityState,
          accessibilityValue: this.props.accessibilityValue,
          accessibilityActions: this.props.accessibilityActions,
          onAccessibilityAction: this.props.onAccessibilityAction,
          importantForAccessibility: this.props.importantForAccessibility,
          accessibilityLiveRegion: this.props.accessibilityLiveRegion,
          accessibilityViewIsModal: this.props.accessibilityViewIsModal,
          accessibilityElementsHidden: this.props.accessibilityElementsHidden,
          style: _StyleSheet.default.compose(this.props.style, (_this$state$extraStyl = this.state.extraStyles) == null ? undefined : _this$state$extraStyl.underlay),
          onLayout: this.props.onLayout,
          hitSlop: this.props.hitSlop,
          hasTVPreferredFocus: this.props.hasTVPreferredFocus,
          nextFocusDown: this.props.nextFocusDown,
          nextFocusForward: this.props.nextFocusForward,
          nextFocusLeft: this.props.nextFocusLeft,
          nextFocusRight: this.props.nextFocusRight,
          nextFocusUp: this.props.nextFocusUp,
          focusable: this.props.focusable !== false && this.props.onPress !== undefined,
          nativeID: this.props.nativeID,
          testID: this.props.testID,
          ref: this.props.hostRef
        }, eventHandlersWithoutBlurAndFocus), React.cloneElement(child, {
          style: _StyleSheet.default.compose(child.props.style, (_this$state$extraStyl2 = this.state.extraStyles) == null ? undefined : _this$state$extraStyl2.child)
        }), null);
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this._isMounted = true;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps, prevState) {
        this.state.pressability.configure(this._createPressabilityConfig());
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this._isMounted = false;

        if (this._hideTimeout != null) {
          clearTimeout(this._hideTimeout);
        }

        this.state.pressability.reset();
      }
    }]);
    return TouchableHighlight;
  }(React.Component);

  var Touchable = React.forwardRef(function (props, hostRef) {
    return React.createElement(TouchableHighlight, (0, _extends2.default)({}, props, {
      hostRef: hostRef
    }));
  });
  Touchable.displayName = 'TouchableHighlight';
  module.exports = Touchable;
},"node_modules/react-native/Libraries/Components/Touchable/TouchableHighlight.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Pressability/Pressability.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _Pressability = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _View = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[10]));

  var _excluded = ["onBlur", "onFocus"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var PASSTHROUGH_PROPS = ['accessibilityActions', 'accessibilityElementsHidden', 'accessibilityHint', 'accessibilityIgnoresInvertColors', 'accessibilityLabel', 'accessibilityLiveRegion', 'accessibilityRole', 'accessibilityValue', 'accessibilityViewIsModal', 'hitSlop', 'importantForAccessibility', 'nativeID', 'onAccessibilityAction', 'onBlur', 'onFocus', 'onLayout', 'testID'];

  var TouchableWithoutFeedback = function (_React$Component) {
    (0, _inherits2.default)(TouchableWithoutFeedback, _React$Component);

    var _super = _createSuper(TouchableWithoutFeedback);

    function TouchableWithoutFeedback() {
      var _this;

      (0, _classCallCheck2.default)(this, TouchableWithoutFeedback);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        pressability: new _Pressability.default(createPressabilityConfig(_this.props))
      };
      return _this;
    }

    (0, _createClass2.default)(TouchableWithoutFeedback, [{
      key: "render",
      value: function render() {
        var element = React.Children.only(this.props.children);
        var children = [element.props.children];

        var _this$state$pressabil = this.state.pressability.getEventHandlers(),
            onBlur = _this$state$pressabil.onBlur,
            onFocus = _this$state$pressabil.onFocus,
            eventHandlersWithoutBlurAndFocus = (0, _objectWithoutProperties2.default)(_this$state$pressabil, _excluded);

        var elementProps = (0, _extends2.default)({}, eventHandlersWithoutBlurAndFocus, {
          accessible: this.props.accessible !== false,
          accessibilityState: this.props.disabled != null ? (0, _extends2.default)({}, this.props.accessibilityState, {
            disabled: this.props.disabled
          }) : this.props.accessibilityState,
          focusable: this.props.focusable !== false && this.props.onPress !== undefined
        });

        for (var _iterator = _createForOfIteratorHelperLoose(PASSTHROUGH_PROPS), _step; !(_step = _iterator()).done;) {
          var prop = _step.value;

          if (this.props[prop] !== undefined) {
            elementProps[prop] = this.props[prop];
          }
        }

        return React.cloneElement.apply(React, [element, elementProps].concat(children));
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this.state.pressability.configure(createPressabilityConfig(this.props));
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.state.pressability.reset();
      }
    }]);
    return TouchableWithoutFeedback;
  }(React.Component);

  function createPressabilityConfig(props) {
    var _props$accessibilityS;

    return {
      cancelable: !props.rejectResponderTermination,
      disabled: props.disabled !== null ? props.disabled : (_props$accessibilityS = props.accessibilityState) == null ? undefined : _props$accessibilityS.disabled,
      hitSlop: props.hitSlop,
      delayLongPress: props.delayLongPress,
      delayPressIn: props.delayPressIn,
      delayPressOut: props.delayPressOut,
      minPressDuration: 0,
      pressRectOffset: props.pressRetentionOffset,
      android_disableSound: props.touchSoundDisabled,
      onBlur: props.onBlur,
      onFocus: props.onFocus,
      onLongPress: props.onLongPress,
      onPress: props.onPress,
      onPressIn: props.onPressIn,
      onPressOut: props.onPressOut
    };
  }

  TouchableWithoutFeedback.displayName = 'TouchableWithoutFeedback';
  module.exports = TouchableWithoutFeedback;
},"node_modules/react-native/Libraries/Components/Touchable/TouchableWithoutFeedback.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Pressability/Pressability.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _NativeActionSheetManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _excluded = ["tintColor", "cancelButtonTintColor", "destructiveButtonIndex"];
  var ActionSheetIOS = {
    showActionSheetWithOptions: function showActionSheetWithOptions(options, callback) {
      _$$_REQUIRE(_dependencyMap[4])(typeof options === 'object' && options !== null, 'Options must be a valid object');

      _$$_REQUIRE(_dependencyMap[4])(typeof callback === 'function', 'Must provide a valid callback');

      _$$_REQUIRE(_dependencyMap[4])(_NativeActionSheetManager.default, "ActionSheetManager doesn't exist");

      var tintColor = options.tintColor,
          cancelButtonTintColor = options.cancelButtonTintColor,
          destructiveButtonIndex = options.destructiveButtonIndex,
          remainingOptions = (0, _objectWithoutProperties2.default)(options, _excluded);
      var destructiveButtonIndices = null;

      if (Array.isArray(destructiveButtonIndex)) {
        destructiveButtonIndices = destructiveButtonIndex;
      } else if (typeof destructiveButtonIndex === 'number') {
        destructiveButtonIndices = [destructiveButtonIndex];
      }

      var processedTintColor = _$$_REQUIRE(_dependencyMap[5])(tintColor);

      var processedCancelButtonTintColor = _$$_REQUIRE(_dependencyMap[5])(cancelButtonTintColor);

      _$$_REQUIRE(_dependencyMap[4])(processedTintColor == null || typeof processedTintColor === 'number', 'Unexpected color given for ActionSheetIOS.showActionSheetWithOptions tintColor');

      _$$_REQUIRE(_dependencyMap[4])(processedCancelButtonTintColor == null || typeof processedCancelButtonTintColor === 'number', 'Unexpected color given for ActionSheetIOS.showActionSheetWithOptions cancelButtonTintColor');

      _NativeActionSheetManager.default.showActionSheetWithOptions((0, _extends2.default)({}, remainingOptions, {
        tintColor: processedTintColor,
        cancelButtonTintColor: processedCancelButtonTintColor,
        destructiveButtonIndices: destructiveButtonIndices
      }), callback);
    },
    showShareActionSheetWithOptions: function showShareActionSheetWithOptions(options, failureCallback, successCallback) {
      _$$_REQUIRE(_dependencyMap[4])(typeof options === 'object' && options !== null, 'Options must be a valid object');

      _$$_REQUIRE(_dependencyMap[4])(typeof failureCallback === 'function', 'Must provide a valid failureCallback');

      _$$_REQUIRE(_dependencyMap[4])(typeof successCallback === 'function', 'Must provide a valid successCallback');

      _$$_REQUIRE(_dependencyMap[4])(_NativeActionSheetManager.default, "ActionSheetManager doesn't exist");

      _NativeActionSheetManager.default.showShareActionSheetWithOptions((0, _extends2.default)({}, options, {
        tintColor: _$$_REQUIRE(_dependencyMap[5])(options.tintColor)
      }), failureCallback, successCallback);
    }
  };
  module.exports = ActionSheetIOS;
},"node_modules/react-native/Libraries/ActionSheetIOS/ActionSheetIOS.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react-native/Libraries/ActionSheetIOS/NativeActionSheetManager.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/StyleSheet/processColor.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('ActionSheetManager');

  exports.default = _default;
},"node_modules/react-native/Libraries/ActionSheetIOS/NativeActionSheetManager.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _EventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _NativeEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _NativeAppearance = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var eventEmitter = new _EventEmitter.default();

  if (_NativeAppearance.default) {
    var nativeEventEmitter = new _NativeEventEmitter.default(_Platform.default.OS !== 'ios' ? null : _NativeAppearance.default);
    nativeEventEmitter.addListener('appearanceChanged', function (newAppearance) {
      var colorScheme = newAppearance.colorScheme;
      (0, _invariant.default)(colorScheme === 'dark' || colorScheme === 'light' || colorScheme == null, "Unrecognized color scheme. Did you mean 'dark' or 'light'?");
      eventEmitter.emit('change', {
        colorScheme: colorScheme
      });
    });
  }

  module.exports = {
    getColorScheme: function getColorScheme() {
      var nativeColorScheme = _NativeAppearance.default == null ? null : _NativeAppearance.default.getColorScheme() || null;
      (0, _invariant.default)(nativeColorScheme === 'dark' || nativeColorScheme === 'light' || nativeColorScheme == null, "Unrecognized color scheme. Did you mean 'dark' or 'light'?");
      return nativeColorScheme;
    },
    addChangeListener: function addChangeListener(listener) {
      return eventEmitter.addListener('change', listener);
    },
    removeChangeListener: function removeChangeListener(listener) {
      eventEmitter.removeListener('change', listener);
    }
  };
},"node_modules/react-native/Libraries/Utilities/Appearance.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/vendor/emitter/EventEmitter.js","node_modules/react-native/Libraries/EventEmitter/NativeEventEmitter.js","node_modules/react-native/Libraries/Utilities/NativeAppearance.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('Appearance');

  exports.default = _default;
},"node_modules/react-native/Libraries/Utilities/NativeAppearance.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createPerformanceLogger = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _NativeHeadlessJsTaskSupport = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _HeadlessJsTaskError = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var runnables = {};
  var runCount = 1;
  var sections = {};
  var taskProviders = new Map();
  var taskCancelProviders = new Map();

  var componentProviderInstrumentationHook = function componentProviderInstrumentationHook(component) {
    return component();
  };

  var wrapperComponentProvider;
  var showArchitectureIndicator = false;
  var AppRegistry = {
    setWrapperComponentProvider: function setWrapperComponentProvider(provider) {
      wrapperComponentProvider = provider;
    },
    enableArchitectureIndicator: function enableArchitectureIndicator(enabled) {
      showArchitectureIndicator = enabled;
    },
    registerConfig: function registerConfig(config) {
      config.forEach(function (appConfig) {
        if (appConfig.run) {
          AppRegistry.registerRunnable(appConfig.appKey, appConfig.run);
        } else {
          _$$_REQUIRE(_dependencyMap[5])(appConfig.component != null, "AppRegistry.registerConfig(...): Every config is expected to set either `run` or `component`, but `%s` has neither.", appConfig.appKey);

          AppRegistry.registerComponent(appConfig.appKey, appConfig.component, appConfig.section);
        }
      });
    },
    registerComponent: function registerComponent(appKey, componentProvider, section) {
      var scopedPerformanceLogger = (0, _createPerformanceLogger.default)();
      runnables[appKey] = {
        componentProvider: componentProvider,
        run: function run(appParameters, displayMode) {
          var _appParameters$initia;

          var concurrentRootEnabled = ((_appParameters$initia = appParameters.initialProps) == null ? undefined : _appParameters$initia.concurrentRoot) || appParameters.concurrentRoot;

          _$$_REQUIRE(_dependencyMap[6])(componentProviderInstrumentationHook(componentProvider, scopedPerformanceLogger), appParameters.initialProps, appParameters.rootTag, wrapperComponentProvider && wrapperComponentProvider(appParameters), appParameters.fabric, showArchitectureIndicator, scopedPerformanceLogger, appKey === 'LogBox', appKey, (0, _$$_REQUIRE(_dependencyMap[7]).coerceDisplayMode)(displayMode), concurrentRootEnabled);
        }
      };

      if (section) {
        sections[appKey] = runnables[appKey];
      }

      return appKey;
    },
    registerRunnable: function registerRunnable(appKey, run) {
      runnables[appKey] = {
        run: run
      };
      return appKey;
    },
    registerSection: function registerSection(appKey, component) {
      AppRegistry.registerComponent(appKey, component, true);
    },
    getAppKeys: function getAppKeys() {
      return Object.keys(runnables);
    },
    getSectionKeys: function getSectionKeys() {
      return Object.keys(sections);
    },
    getSections: function getSections() {
      return (0, _extends2.default)({}, sections);
    },
    getRunnable: function getRunnable(appKey) {
      return runnables[appKey];
    },
    getRegistry: function getRegistry() {
      return {
        sections: AppRegistry.getSectionKeys(),
        runnables: (0, _extends2.default)({}, runnables)
      };
    },
    setComponentProviderInstrumentationHook: function setComponentProviderInstrumentationHook(hook) {
      componentProviderInstrumentationHook = hook;
    },
    runApplication: function runApplication(appKey, appParameters, displayMode) {
      if (appKey !== 'LogBox') {
        var logParams = '';
        var msg = 'Running "' + appKey + logParams;

        _$$_REQUIRE(_dependencyMap[8])(msg);

        _$$_REQUIRE(_dependencyMap[9]).addSource('AppRegistry.runApplication' + runCount++, function () {
          return msg;
        });
      }

      _$$_REQUIRE(_dependencyMap[5])(runnables[appKey] && runnables[appKey].run, "\"" + appKey + "\" has not been registered. This can happen if:\n" + '* Metro (the local dev server) is run from the wrong folder. ' + 'Check if Metro is running, stop it and restart it in the current project.\n' + "* A module failed to load due to an error and `AppRegistry.registerComponent` wasn't called.");

      _$$_REQUIRE(_dependencyMap[10]).setActiveScene({
        name: appKey
      });

      runnables[appKey].run(appParameters, displayMode);
    },
    setSurfaceProps: function setSurfaceProps(appKey, appParameters, displayMode) {
      if (appKey !== 'LogBox') {
        var msg = 'Updating props for Surface "' + appKey + '" with ' + JSON.stringify(appParameters);

        _$$_REQUIRE(_dependencyMap[8])(msg);

        _$$_REQUIRE(_dependencyMap[9]).addSource('AppRegistry.setSurfaceProps' + runCount++, function () {
          return msg;
        });
      }

      _$$_REQUIRE(_dependencyMap[5])(runnables[appKey] && runnables[appKey].run, "\"" + appKey + "\" has not been registered. This can happen if:\n" + '* Metro (the local dev server) is run from the wrong folder. ' + 'Check if Metro is running, stop it and restart it in the current project.\n' + "* A module failed to load due to an error and `AppRegistry.registerComponent` wasn't called.");

      runnables[appKey].run(appParameters, displayMode);
    },
    unmountApplicationComponentAtRootTag: function unmountApplicationComponentAtRootTag(rootTag) {
      _$$_REQUIRE(_dependencyMap[11]).unmountComponentAtNodeAndRemoveContainer(rootTag);
    },
    registerHeadlessTask: function registerHeadlessTask(taskKey, taskProvider) {
      this.registerCancellableHeadlessTask(taskKey, taskProvider, function () {
        return function () {};
      });
    },
    registerCancellableHeadlessTask: function registerCancellableHeadlessTask(taskKey, taskProvider, taskCancelProvider) {
      if (taskProviders.has(taskKey)) {
        console.warn("registerHeadlessTask or registerCancellableHeadlessTask called multiple times for same key '" + taskKey + "'");
      }

      taskProviders.set(taskKey, taskProvider);
      taskCancelProviders.set(taskKey, taskCancelProvider);
    },
    startHeadlessTask: function startHeadlessTask(taskId, taskKey, data) {
      var taskProvider = taskProviders.get(taskKey);

      if (!taskProvider) {
        console.warn("No task registered for key " + taskKey);

        if (_NativeHeadlessJsTaskSupport.default) {
          _NativeHeadlessJsTaskSupport.default.notifyTaskFinished(taskId);
        }

        return;
      }

      taskProvider()(data).then(function () {
        if (_NativeHeadlessJsTaskSupport.default) {
          _NativeHeadlessJsTaskSupport.default.notifyTaskFinished(taskId);
        }
      }).catch(function (reason) {
        console.error(reason);

        if (_NativeHeadlessJsTaskSupport.default && reason instanceof _HeadlessJsTaskError.default) {
          _NativeHeadlessJsTaskSupport.default.notifyTaskRetry(taskId).then(function (retryPosted) {
            if (!retryPosted) {
              _NativeHeadlessJsTaskSupport.default.notifyTaskFinished(taskId);
            }
          });
        }
      });
    },
    cancelHeadlessTask: function cancelHeadlessTask(taskId, taskKey) {
      var taskCancelProvider = taskCancelProviders.get(taskKey);

      if (!taskCancelProvider) {
        throw new Error("No task canceller registered for key '" + taskKey + "'");
      }

      taskCancelProvider()();
    }
  };

  _$$_REQUIRE(_dependencyMap[12]).registerCallableModule('AppRegistry', AppRegistry);

  {
    AppRegistry.registerComponent('LogBox', function () {
      return function NoOp() {
        return null;
      };
    });
  }
  module.exports = AppRegistry;
},"node_modules/react-native/Libraries/ReactNative/AppRegistry.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Utilities/createPerformanceLogger.js","node_modules/react-native/Libraries/ReactNative/NativeHeadlessJsTaskSupport.js","node_modules/react-native/Libraries/ReactNative/HeadlessJsTaskError.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/ReactNative/renderApplication.js","node_modules/react-native/Libraries/ReactNative/DisplayMode.js","node_modules/react-native/Libraries/Utilities/infoLog.js","node_modules/react-native/Libraries/BugReporting/BugReporting.js","node_modules/react-native/Libraries/Utilities/SceneTracker.js","node_modules/react-native/Libraries/Renderer/shims/ReactNative.js","node_modules/react-native/Libraries/BatchedBridge/BatchedBridge.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('HeadlessJsTaskSupport');

  exports.default = _default;
},"node_modules/react-native/Libraries/ReactNative/NativeHeadlessJsTaskSupport.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _wrapNativeSuper2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var HeadlessJsTaskError = function (_Error) {
    (0, _inherits2.default)(HeadlessJsTaskError, _Error);

    var _super = _createSuper(HeadlessJsTaskError);

    function HeadlessJsTaskError() {
      (0, _classCallCheck2.default)(this, HeadlessJsTaskError);
      return _super.apply(this, arguments);
    }

    return (0, _createClass2.default)(HeadlessJsTaskError);
  }((0, _wrapNativeSuper2.default)(Error));

  exports.default = HeadlessJsTaskError;
},"node_modules/react-native/Libraries/ReactNative/HeadlessJsTaskError.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/wrapNativeSuper.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _GlobalPerformanceLogger = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _PerformanceLoggerContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _getCachedComponentWithDebugName = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var React = _$$_REQUIRE(_dependencyMap[5]);

  _$$_REQUIRE(_dependencyMap[6]);

  function renderApplication(RootComponent, initialProps, rootTag, WrapperComponent, fabric, showArchitectureIndicator, scopedPerformanceLogger, isLogBox, debugName, displayMode, useConcurrentRoot) {
    _$$_REQUIRE(_dependencyMap[7])(rootTag, 'Expect to have a valid rootTag, instead got ', rootTag);

    var performanceLogger = scopedPerformanceLogger != null ? scopedPerformanceLogger : _GlobalPerformanceLogger.default;
    var renderable = React.createElement(_PerformanceLoggerContext.default.Provider, {
      value: performanceLogger
    }, React.createElement(_$$_REQUIRE(_dependencyMap[8]), {
      rootTag: rootTag,
      fabric: fabric,
      showArchitectureIndicator: showArchitectureIndicator,
      WrapperComponent: WrapperComponent,
      initialProps: initialProps != null ? initialProps : Object.freeze({}),
      internal_excludeLogBox: isLogBox
    }, React.createElement(RootComponent, (0, _extends2.default)({}, initialProps, {
      rootTag: rootTag
    }))));
    performanceLogger.startTimespan('renderApplication_React_render');
    performanceLogger.setExtra('usedReactFabric', fabric ? '1' : '0');

    if (fabric) {
      _$$_REQUIRE(_dependencyMap[9]).render(renderable, rootTag, null, useConcurrentRoot);
    } else {
      _$$_REQUIRE(_dependencyMap[10]).render(renderable, rootTag);
    }

    performanceLogger.stopTimespan('renderApplication_React_render');
  }

  module.exports = renderApplication;
},"node_modules/react-native/Libraries/ReactNative/renderApplication.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/Utilities/GlobalPerformanceLogger.js","node_modules/react-native/Libraries/Utilities/PerformanceLoggerContext.js","node_modules/react-native/Libraries/ReactNative/getCachedComponentWithDebugName.js","node_modules/react/index.js","node_modules/react-native/Libraries/Utilities/BackHandler.ios.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/ReactNative/AppContainer.js","node_modules/react-native/Libraries/Renderer/shims/ReactFabric.js","node_modules/react-native/Libraries/Renderer/shims/ReactNative.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.usePerformanceLogger = usePerformanceLogger;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _GlobalPerformanceLogger = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var PerformanceLoggerContext = React.createContext(_GlobalPerformanceLogger.default);

  function usePerformanceLogger() {
    return (0, React.useContext)(PerformanceLoggerContext);
  }

  var _default = PerformanceLoggerContext;
  exports.default = _default;
},"node_modules/react-native/Libraries/Utilities/PerformanceLoggerContext.js",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/GlobalPerformanceLogger.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getCachedComponentWithDisplayName;
  var cache = new Map();

  function getCachedComponentWithDisplayName(displayName) {
    var ComponentWithDisplayName = cache.get(displayName);

    if (!ComponentWithDisplayName) {
      ComponentWithDisplayName = function ComponentWithDisplayName(_ref) {
        var children = _ref.children;
        return children;
      };

      ComponentWithDisplayName.displayName = displayName;
      cache.set(displayName, ComponentWithDisplayName);
    }

    return ComponentWithDisplayName;
  }
},"node_modules/react-native/Libraries/ReactNative/getCachedComponentWithDebugName.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = _$$_REQUIRE(_dependencyMap[0]);

  function emptyFunction() {}

  var BackHandler = {
    exitApp: emptyFunction,
    addEventListener: function addEventListener(_eventName, _handler) {
      return {
        remove: emptyFunction
      };
    },
    removeEventListener: function removeEventListener(_eventName, _handler) {}
  };
  module.exports = BackHandler;
},"node_modules/react-native/Libraries/Utilities/BackHandler.ios.js",["node_modules/react-native/Libraries/Components/UnimplementedViews/UnimplementedView.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _View = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _RCTDeviceEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _StyleSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[9]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AppContainer = function (_React$Component) {
    (0, _inherits2.default)(AppContainer, _React$Component);

    var _super = _createSuper(AppContainer);

    function AppContainer() {
      var _this;

      (0, _classCallCheck2.default)(this, AppContainer);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        inspector: null,
        mainKey: 1,
        hasError: false
      };
      _this._subscription = null;
      return _this;
    }

    (0, _createClass2.default)(AppContainer, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this._subscription != null) {
          this._subscription.remove();
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        var logBox = null;
        var innerView = React.createElement(_View.default, {
          collapsable: !this.state.inspector,
          key: this.state.mainKey,
          pointerEvents: "box-none",
          style: styles.appContainer,
          ref: function ref(_ref) {
            _this3._mainRef = _ref;
          }
        }, this.props.children);
        var Wrapper = this.props.WrapperComponent;

        if (Wrapper != null) {
          innerView = React.createElement(Wrapper, {
            initialProps: this.props.initialProps,
            fabric: this.props.fabric === true,
            showArchitectureIndicator: this.props.showArchitectureIndicator === true
          }, innerView);
        }

        return React.createElement(_$$_REQUIRE(_dependencyMap[10]).RootTagContext.Provider, {
          value: (0, _$$_REQUIRE(_dependencyMap[10]).createRootTag)(this.props.rootTag)
        }, React.createElement(_View.default, {
          style: styles.appContainer,
          pointerEvents: "box-none"
        }, !this.state.hasError && innerView, this.state.inspector, logBox));
      }
    }]);
    return AppContainer;
  }(React.Component);

  AppContainer.getDerivedStateFromError = undefined;

  var styles = _StyleSheet.default.create({
    appContainer: {
      flex: 1
    }
  });

  module.exports = AppContainer;
},"node_modules/react-native/Libraries/ReactNative/AppContainer.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/Components/View/View.js","node_modules/react-native/Libraries/EventEmitter/RCTDeviceEventEmitter.js","node_modules/react-native/Libraries/StyleSheet/StyleSheet.js","node_modules/react/index.js","node_modules/react-native/Libraries/ReactNative/RootTag.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ReactFabric;
  {
    ReactFabric = _$$_REQUIRE(_dependencyMap[0]);
  }

  if (global.RN$Bridgeless) {
    global.RN$stopSurface = ReactFabric.stopSurface;
  } else {
    _$$_REQUIRE(_dependencyMap[1]).BatchedBridge.registerCallableModule('ReactFabric', ReactFabric);
  }

  module.exports = ReactFabric;
},"node_modules/react-native/Libraries/Renderer/shims/ReactFabric.js",["node_modules/react-native/Libraries/Renderer/implementations/ReactFabric-prod.js","node_modules/react-native/Libraries/ReactPrivate/ReactNativePrivateInterface.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  _$$_REQUIRE(_dependencyMap[0]);

  var React = _$$_REQUIRE(_dependencyMap[1]);

  function invokeGuardedCallbackImpl(name, func, context, a, b, c, d, e, f) {
    var funcArgs = Array.prototype.slice.call(arguments, 3);

    try {
      func.apply(context, funcArgs);
    } catch (error) {
      this.onError(error);
    }
  }

  var hasError = false,
      caughtError = null,
      hasRethrowError = false,
      rethrowError = null,
      reporter = {
    onError: function onError(error) {
      hasError = true;
      caughtError = error;
    }
  };

  function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
    hasError = false;
    caughtError = null;
    invokeGuardedCallbackImpl.apply(reporter, arguments);
  }

  function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
    invokeGuardedCallback.apply(this, arguments);

    if (hasError) {
      if (hasError) {
        var error = caughtError;
        hasError = false;
        caughtError = null;
      } else throw Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");

      hasRethrowError || (hasRethrowError = true, rethrowError = error);
    }
  }

  var isArrayImpl = Array.isArray,
      getFiberCurrentPropsFromNode = null,
      getInstanceFromNode = null,
      getNodeFromInstance = null;

  function executeDispatch(event, listener, inst) {
    var type = event.type || "unknown-event";
    event.currentTarget = getNodeFromInstance(inst);
    invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
    event.currentTarget = null;
  }

  function executeDirectDispatch(event) {
    var dispatchListener = event._dispatchListeners,
        dispatchInstance = event._dispatchInstances;
    if (isArrayImpl(dispatchListener)) throw Error("executeDirectDispatch(...): Invalid `event`.");
    event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;
    dispatchListener = dispatchListener ? dispatchListener(event) : null;
    event.currentTarget = null;
    event._dispatchListeners = null;
    event._dispatchInstances = null;
    return dispatchListener;
  }

  function functionThatReturnsTrue() {
    return true;
  }

  function functionThatReturnsFalse() {
    return false;
  }

  function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
    this.dispatchConfig = dispatchConfig;
    this._targetInst = targetInst;
    this.nativeEvent = nativeEvent;
    this._dispatchInstances = this._dispatchListeners = null;
    dispatchConfig = this.constructor.Interface;

    for (var propName in dispatchConfig) {
      dispatchConfig.hasOwnProperty(propName) && ((targetInst = dispatchConfig[propName]) ? this[propName] = targetInst(nativeEvent) : "target" === propName ? this.target = nativeEventTarget : this[propName] = nativeEvent[propName]);
    }

    this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }

  _$$_REQUIRE(_dependencyMap[2])(SyntheticEvent.prototype, {
    preventDefault: function preventDefault() {
      this.defaultPrevented = true;
      var event = this.nativeEvent;
      event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
    },
    stopPropagation: function stopPropagation() {
      var event = this.nativeEvent;
      event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
    },
    persist: function persist() {
      this.isPersistent = functionThatReturnsTrue;
    },
    isPersistent: functionThatReturnsFalse,
    destructor: function destructor() {
      var Interface = this.constructor.Interface,
          propName;

      for (propName in Interface) {
        this[propName] = null;
      }

      this.nativeEvent = this._targetInst = this.dispatchConfig = null;
      this.isPropagationStopped = this.isDefaultPrevented = functionThatReturnsFalse;
      this._dispatchInstances = this._dispatchListeners = null;
    }
  });

  SyntheticEvent.Interface = {
    type: null,
    target: null,
    currentTarget: function currentTarget() {
      return null;
    },
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function timeStamp(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: null,
    isTrusted: null
  };

  SyntheticEvent.extend = function (Interface) {
    function E() {}

    function Class() {
      return Super.apply(this, arguments);
    }

    var Super = this;
    E.prototype = Super.prototype;
    var prototype = new E();

    _$$_REQUIRE(_dependencyMap[2])(prototype, Class.prototype);

    Class.prototype = prototype;
    Class.prototype.constructor = Class;
    Class.Interface = _$$_REQUIRE(_dependencyMap[2])({}, Super.Interface, Interface);
    Class.extend = Super.extend;
    addEventPoolingTo(Class);
    return Class;
  };

  addEventPoolingTo(SyntheticEvent);

  function createOrGetPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
    if (this.eventPool.length) {
      var instance = this.eventPool.pop();
      this.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
      return instance;
    }

    return new this(dispatchConfig, targetInst, nativeEvent, nativeInst);
  }

  function releasePooledEvent(event) {
    if (!(event instanceof this)) throw Error("Trying to release an event instance into a pool of a different type.");
    event.destructor();
    10 > this.eventPool.length && this.eventPool.push(event);
  }

  function addEventPoolingTo(EventConstructor) {
    EventConstructor.getPooled = createOrGetPooledEvent;
    EventConstructor.eventPool = [];
    EventConstructor.release = releasePooledEvent;
  }

  var ResponderSyntheticEvent = SyntheticEvent.extend({
    touchHistory: function touchHistory() {
      return null;
    }
  });

  function isStartish(topLevelType) {
    return "topTouchStart" === topLevelType;
  }

  function isMoveish(topLevelType) {
    return "topTouchMove" === topLevelType;
  }

  var startDependencies = ["topTouchStart"],
      moveDependencies = ["topTouchMove"],
      endDependencies = ["topTouchCancel", "topTouchEnd"],
      touchBank = [],
      touchHistory = {
    touchBank: touchBank,
    numberActiveTouches: 0,
    indexOfSingleActiveTouch: -1,
    mostRecentTimeStamp: 0
  };

  function timestampForTouch(touch) {
    return touch.timeStamp || touch.timestamp;
  }

  function getTouchIdentifier(_ref) {
    _ref = _ref.identifier;
    if (null == _ref) throw Error("Touch object is missing identifier.");
    return _ref;
  }

  function recordTouchStart(touch) {
    var identifier = getTouchIdentifier(touch),
        touchRecord = touchBank[identifier];
    touchRecord ? (touchRecord.touchActive = true, touchRecord.startPageX = touch.pageX, touchRecord.startPageY = touch.pageY, touchRecord.startTimeStamp = timestampForTouch(touch), touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchRecord.previousPageX = touch.pageX, touchRecord.previousPageY = touch.pageY, touchRecord.previousTimeStamp = timestampForTouch(touch)) : (touchRecord = {
      touchActive: true,
      startPageX: touch.pageX,
      startPageY: touch.pageY,
      startTimeStamp: timestampForTouch(touch),
      currentPageX: touch.pageX,
      currentPageY: touch.pageY,
      currentTimeStamp: timestampForTouch(touch),
      previousPageX: touch.pageX,
      previousPageY: touch.pageY,
      previousTimeStamp: timestampForTouch(touch)
    }, touchBank[identifier] = touchRecord);
    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
  }

  function recordTouchMove(touch) {
    var touchRecord = touchBank[getTouchIdentifier(touch)];
    touchRecord && (touchRecord.touchActive = true, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch));
  }

  function recordTouchEnd(touch) {
    var touchRecord = touchBank[getTouchIdentifier(touch)];
    touchRecord && (touchRecord.touchActive = false, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch));
  }

  var instrumentationCallback,
      ResponderTouchHistoryStore = {
    instrument: function instrument(callback) {
      instrumentationCallback = callback;
    },
    recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {
      null != instrumentationCallback && instrumentationCallback(topLevelType, nativeEvent);
      if (isMoveish(topLevelType)) nativeEvent.changedTouches.forEach(recordTouchMove);else if (isStartish(topLevelType)) nativeEvent.changedTouches.forEach(recordTouchStart), touchHistory.numberActiveTouches = nativeEvent.touches.length, 1 === touchHistory.numberActiveTouches && (touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier);else if ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType) if (nativeEvent.changedTouches.forEach(recordTouchEnd), touchHistory.numberActiveTouches = nativeEvent.touches.length, 1 === touchHistory.numberActiveTouches) for (topLevelType = 0; topLevelType < touchBank.length; topLevelType++) {
        if (nativeEvent = touchBank[topLevelType], null != nativeEvent && nativeEvent.touchActive) {
          touchHistory.indexOfSingleActiveTouch = topLevelType;
          break;
        }
      }
    },
    touchHistory: touchHistory
  };

  function accumulate(current, next) {
    if (null == next) throw Error("accumulate(...): Accumulated items must not be null or undefined.");
    return null == current ? next : isArrayImpl(current) ? current.concat(next) : isArrayImpl(next) ? [current].concat(next) : [current, next];
  }

  function accumulateInto(current, next) {
    if (null == next) throw Error("accumulateInto(...): Accumulated items must not be null or undefined.");
    if (null == current) return next;

    if (isArrayImpl(current)) {
      if (isArrayImpl(next)) return current.push.apply(current, next), current;
      current.push(next);
      return current;
    }

    return isArrayImpl(next) ? [current].concat(next) : [current, next];
  }

  function forEachAccumulated(arr, cb, scope) {
    Array.isArray(arr) ? arr.forEach(cb, scope) : arr && cb.call(scope, arr);
  }

  var responderInst = null,
      trackedTouchCount = 0;

  function changeResponder(nextResponderInst, blockHostResponder) {
    var oldResponderInst = responderInst;
    responderInst = nextResponderInst;
    if (null !== ResponderEventPlugin.GlobalResponderHandler) ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);
  }

  var eventTypes = {
    startShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onStartShouldSetResponder",
        captured: "onStartShouldSetResponderCapture"
      },
      dependencies: startDependencies
    },
    scrollShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onScrollShouldSetResponder",
        captured: "onScrollShouldSetResponderCapture"
      },
      dependencies: ["topScroll"]
    },
    selectionChangeShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onSelectionChangeShouldSetResponder",
        captured: "onSelectionChangeShouldSetResponderCapture"
      },
      dependencies: ["topSelectionChange"]
    },
    moveShouldSetResponder: {
      phasedRegistrationNames: {
        bubbled: "onMoveShouldSetResponder",
        captured: "onMoveShouldSetResponderCapture"
      },
      dependencies: moveDependencies
    },
    responderStart: {
      registrationName: "onResponderStart",
      dependencies: startDependencies
    },
    responderMove: {
      registrationName: "onResponderMove",
      dependencies: moveDependencies
    },
    responderEnd: {
      registrationName: "onResponderEnd",
      dependencies: endDependencies
    },
    responderRelease: {
      registrationName: "onResponderRelease",
      dependencies: endDependencies
    },
    responderTerminationRequest: {
      registrationName: "onResponderTerminationRequest",
      dependencies: []
    },
    responderGrant: {
      registrationName: "onResponderGrant",
      dependencies: []
    },
    responderReject: {
      registrationName: "onResponderReject",
      dependencies: []
    },
    responderTerminate: {
      registrationName: "onResponderTerminate",
      dependencies: []
    }
  };

  function getParent(inst) {
    do {
      inst = inst.return;
    } while (inst && 5 !== inst.tag);

    return inst ? inst : null;
  }

  function traverseTwoPhase(inst, fn, arg) {
    for (var path = []; inst;) {
      path.push(inst), inst = getParent(inst);
    }

    for (inst = path.length; 0 < inst--;) {
      fn(path[inst], "captured", arg);
    }

    for (inst = 0; inst < path.length; inst++) {
      fn(path[inst], "bubbled", arg);
    }
  }

  function getListener(inst, registrationName) {
    inst = inst.stateNode;
    if (null === inst) return null;
    inst = getFiberCurrentPropsFromNode(inst);
    if (null === inst) return null;
    if ((inst = inst[registrationName]) && "function" !== typeof inst) throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof inst + "` type.");
    return inst;
  }

  function accumulateDirectionalDispatches(inst, phase, event) {
    if (phase = getListener(inst, event.dispatchConfig.phasedRegistrationNames[phase])) event._dispatchListeners = accumulateInto(event._dispatchListeners, phase), event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }

  function accumulateDirectDispatchesSingle(event) {
    if (event && event.dispatchConfig.registrationName) {
      var inst = event._targetInst;

      if (inst && event && event.dispatchConfig.registrationName) {
        var listener = getListener(inst, event.dispatchConfig.registrationName);
        listener && (event._dispatchListeners = accumulateInto(event._dispatchListeners, listener), event._dispatchInstances = accumulateInto(event._dispatchInstances, inst));
      }
    }
  }

  function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
    if (event && event.dispatchConfig.phasedRegistrationNames) {
      var targetInst = event._targetInst;
      targetInst = targetInst ? getParent(targetInst) : null;
      traverseTwoPhase(targetInst, accumulateDirectionalDispatches, event);
    }
  }

  function accumulateTwoPhaseDispatchesSingle(event) {
    event && event.dispatchConfig.phasedRegistrationNames && traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }

  var ResponderEventPlugin = {
    _getResponder: function _getResponder() {
      return responderInst;
    },
    eventTypes: eventTypes,
    extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      if (isStartish(topLevelType)) trackedTouchCount += 1;else if ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType) if (0 <= trackedTouchCount) --trackedTouchCount;else return null;
      ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);

      if (targetInst && ("topScroll" === topLevelType && !nativeEvent.responderIgnoreScroll || 0 < trackedTouchCount && "topSelectionChange" === topLevelType || isStartish(topLevelType) || isMoveish(topLevelType))) {
        var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : "topSelectionChange" === topLevelType ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder;
        if (responderInst) b: {
          var JSCompiler_temp = responderInst;

          for (var depthA = 0, tempA = JSCompiler_temp; tempA; tempA = getParent(tempA)) {
            depthA++;
          }

          tempA = 0;

          for (var tempB = targetInst; tempB; tempB = getParent(tempB)) {
            tempA++;
          }

          for (; 0 < depthA - tempA;) {
            JSCompiler_temp = getParent(JSCompiler_temp), depthA--;
          }

          for (; 0 < tempA - depthA;) {
            targetInst = getParent(targetInst), tempA--;
          }

          for (; depthA--;) {
            if (JSCompiler_temp === targetInst || JSCompiler_temp === targetInst.alternate) break b;
            JSCompiler_temp = getParent(JSCompiler_temp);
            targetInst = getParent(targetInst);
          }

          JSCompiler_temp = null;
        } else JSCompiler_temp = targetInst;
        targetInst = JSCompiler_temp;
        JSCompiler_temp = targetInst === responderInst;
        shouldSetEventType = ResponderSyntheticEvent.getPooled(shouldSetEventType, targetInst, nativeEvent, nativeEventTarget);
        shouldSetEventType.touchHistory = ResponderTouchHistoryStore.touchHistory;
        JSCompiler_temp ? forEachAccumulated(shouldSetEventType, accumulateTwoPhaseDispatchesSingleSkipTarget) : forEachAccumulated(shouldSetEventType, accumulateTwoPhaseDispatchesSingle);

        b: {
          JSCompiler_temp = shouldSetEventType._dispatchListeners;
          targetInst = shouldSetEventType._dispatchInstances;
          if (isArrayImpl(JSCompiler_temp)) for (depthA = 0; depthA < JSCompiler_temp.length && !shouldSetEventType.isPropagationStopped(); depthA++) {
            if (JSCompiler_temp[depthA](shouldSetEventType, targetInst[depthA])) {
              JSCompiler_temp = targetInst[depthA];
              break b;
            }
          } else if (JSCompiler_temp && JSCompiler_temp(shouldSetEventType, targetInst)) {
            JSCompiler_temp = targetInst;
            break b;
          }
          JSCompiler_temp = null;
        }

        shouldSetEventType._dispatchInstances = null;
        shouldSetEventType._dispatchListeners = null;
        shouldSetEventType.isPersistent() || shouldSetEventType.constructor.release(shouldSetEventType);
        if (JSCompiler_temp && JSCompiler_temp !== responderInst) {
          if (shouldSetEventType = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, JSCompiler_temp, nativeEvent, nativeEventTarget), shouldSetEventType.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(shouldSetEventType, accumulateDirectDispatchesSingle), targetInst = true === executeDirectDispatch(shouldSetEventType), responderInst) {
            if (depthA = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget), depthA.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(depthA, accumulateDirectDispatchesSingle), tempA = !depthA._dispatchListeners || executeDirectDispatch(depthA), depthA.isPersistent() || depthA.constructor.release(depthA), tempA) {
              depthA = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminate, responderInst, nativeEvent, nativeEventTarget);
              depthA.touchHistory = ResponderTouchHistoryStore.touchHistory;
              forEachAccumulated(depthA, accumulateDirectDispatchesSingle);
              var JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, [shouldSetEventType, depthA]);
              changeResponder(JSCompiler_temp, targetInst);
            } else shouldSetEventType = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, JSCompiler_temp, nativeEvent, nativeEventTarget), shouldSetEventType.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(shouldSetEventType, accumulateDirectDispatchesSingle), JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, shouldSetEventType);
          } else JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, shouldSetEventType), changeResponder(JSCompiler_temp, targetInst);
        } else JSCompiler_temp$jscomp$0 = null;
      } else JSCompiler_temp$jscomp$0 = null;

      shouldSetEventType = responderInst && isStartish(topLevelType);
      JSCompiler_temp = responderInst && isMoveish(topLevelType);
      targetInst = responderInst && ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType);
      if (shouldSetEventType = shouldSetEventType ? eventTypes.responderStart : JSCompiler_temp ? eventTypes.responderMove : targetInst ? eventTypes.responderEnd : null) shouldSetEventType = ResponderSyntheticEvent.getPooled(shouldSetEventType, responderInst, nativeEvent, nativeEventTarget), shouldSetEventType.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(shouldSetEventType, accumulateDirectDispatchesSingle), JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, shouldSetEventType);
      shouldSetEventType = responderInst && "topTouchCancel" === topLevelType;
      if (topLevelType = responderInst && !shouldSetEventType && ("topTouchEnd" === topLevelType || "topTouchCancel" === topLevelType)) a: {
        if ((topLevelType = nativeEvent.touches) && 0 !== topLevelType.length) for (JSCompiler_temp = 0; JSCompiler_temp < topLevelType.length; JSCompiler_temp++) {
          if (targetInst = topLevelType[JSCompiler_temp].target, null !== targetInst && undefined !== targetInst && 0 !== targetInst) {
            depthA = getInstanceFromNode(targetInst);

            b: {
              for (targetInst = responderInst; depthA;) {
                if (targetInst === depthA || targetInst === depthA.alternate) {
                  targetInst = true;
                  break b;
                }

                depthA = getParent(depthA);
              }

              targetInst = false;
            }

            if (targetInst) {
              topLevelType = false;
              break a;
            }
          }
        }
        topLevelType = true;
      }
      if (topLevelType = shouldSetEventType ? eventTypes.responderTerminate : topLevelType ? eventTypes.responderRelease : null) nativeEvent = ResponderSyntheticEvent.getPooled(topLevelType, responderInst, nativeEvent, nativeEventTarget), nativeEvent.touchHistory = ResponderTouchHistoryStore.touchHistory, forEachAccumulated(nativeEvent, accumulateDirectDispatchesSingle), JSCompiler_temp$jscomp$0 = accumulate(JSCompiler_temp$jscomp$0, nativeEvent), changeResponder(null);
      return JSCompiler_temp$jscomp$0;
    },
    GlobalResponderHandler: null,
    injection: {
      injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {
        ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
      }
    }
  },
      eventPluginOrder = null,
      namesToPlugins = {};

  function recomputePluginOrdering() {
    if (eventPluginOrder) for (var pluginName in namesToPlugins) {
      var pluginModule = namesToPlugins[pluginName],
          pluginIndex = eventPluginOrder.indexOf(pluginName);
      if (!(-1 < pluginIndex)) throw Error("EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `" + pluginName + "`.");

      if (!plugins[pluginIndex]) {
        if (!pluginModule.extractEvents) throw Error("EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `" + pluginName + "` does not.");
        plugins[pluginIndex] = pluginModule;
        pluginIndex = pluginModule.eventTypes;

        for (var eventName in pluginIndex) {
          var JSCompiler_inline_result = undefined;
          var dispatchConfig = pluginIndex[eventName],
              eventName$jscomp$0 = eventName;
          if (eventNameDispatchConfigs.hasOwnProperty(eventName$jscomp$0)) throw Error("EventPluginRegistry: More than one plugin attempted to publish the same event name, `" + eventName$jscomp$0 + "`.");
          eventNameDispatchConfigs[eventName$jscomp$0] = dispatchConfig;
          var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

          if (phasedRegistrationNames) {
            for (JSCompiler_inline_result in phasedRegistrationNames) {
              phasedRegistrationNames.hasOwnProperty(JSCompiler_inline_result) && publishRegistrationName(phasedRegistrationNames[JSCompiler_inline_result], pluginModule, eventName$jscomp$0);
            }

            JSCompiler_inline_result = true;
          } else dispatchConfig.registrationName ? (publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName$jscomp$0), JSCompiler_inline_result = true) : JSCompiler_inline_result = false;

          if (!JSCompiler_inline_result) throw Error("EventPluginRegistry: Failed to publish event `" + eventName + "` for plugin `" + pluginName + "`.");
        }
      }
    }
  }

  function publishRegistrationName(registrationName, pluginModule) {
    if (registrationNameModules[registrationName]) throw Error("EventPluginRegistry: More than one plugin attempted to publish the same registration name, `" + registrationName + "`.");
    registrationNameModules[registrationName] = pluginModule;
  }

  var plugins = [],
      eventNameDispatchConfigs = {},
      registrationNameModules = {};

  function getListener$1(inst, registrationName) {
    inst = inst.stateNode;
    if (null === inst) return null;
    inst = getFiberCurrentPropsFromNode(inst);
    if (null === inst) return null;
    if ((inst = inst[registrationName]) && "function" !== typeof inst) throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof inst + "` type.");
    return inst;
  }

  var customBubblingEventTypes = _$$_REQUIRE(_dependencyMap[3]).ReactNativeViewConfigRegistry.customBubblingEventTypes,
      customDirectEventTypes = _$$_REQUIRE(_dependencyMap[3]).ReactNativeViewConfigRegistry.customDirectEventTypes;

  function accumulateDirectionalDispatches$1(inst, phase, event) {
    if (phase = getListener$1(inst, event.dispatchConfig.phasedRegistrationNames[phase])) event._dispatchListeners = accumulateInto(event._dispatchListeners, phase), event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }

  function accumulateTwoPhaseDispatchesSingle$1(event) {
    if (event && event.dispatchConfig.phasedRegistrationNames) {
      for (var inst = event._targetInst, path = []; inst;) {
        path.push(inst);

        do {
          inst = inst.return;
        } while (inst && 5 !== inst.tag);

        inst = inst ? inst : null;
      }

      for (inst = path.length; 0 < inst--;) {
        accumulateDirectionalDispatches$1(path[inst], "captured", event);
      }

      for (inst = 0; inst < path.length; inst++) {
        accumulateDirectionalDispatches$1(path[inst], "bubbled", event);
      }
    }
  }

  function accumulateDirectDispatchesSingle$1(event) {
    if (event && event.dispatchConfig.registrationName) {
      var inst = event._targetInst;

      if (inst && event && event.dispatchConfig.registrationName) {
        var listener = getListener$1(inst, event.dispatchConfig.registrationName);
        listener && (event._dispatchListeners = accumulateInto(event._dispatchListeners, listener), event._dispatchInstances = accumulateInto(event._dispatchInstances, inst));
      }
    }
  }

  if (eventPluginOrder) throw Error("EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.");
  eventPluginOrder = Array.prototype.slice.call(["ResponderEventPlugin", "ReactNativeBridgeEventPlugin"]);
  recomputePluginOrdering();
  var injectedNamesToPlugins$jscomp$inline_216 = {
    ResponderEventPlugin: ResponderEventPlugin,
    ReactNativeBridgeEventPlugin: {
      eventTypes: {},
      extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        if (null == targetInst) return null;
        var bubbleDispatchConfig = customBubblingEventTypes[topLevelType],
            directDispatchConfig = customDirectEventTypes[topLevelType];
        if (!bubbleDispatchConfig && !directDispatchConfig) throw Error('Unsupported top level event type "' + topLevelType + '" dispatched');
        topLevelType = SyntheticEvent.getPooled(bubbleDispatchConfig || directDispatchConfig, targetInst, nativeEvent, nativeEventTarget);
        if (bubbleDispatchConfig) forEachAccumulated(topLevelType, accumulateTwoPhaseDispatchesSingle$1);else if (directDispatchConfig) forEachAccumulated(topLevelType, accumulateDirectDispatchesSingle$1);else return null;
        return topLevelType;
      }
    }
  },
      isOrderingDirty$jscomp$inline_217 = false,
      pluginName$jscomp$inline_218;

  for (pluginName$jscomp$inline_218 in injectedNamesToPlugins$jscomp$inline_216) {
    if (injectedNamesToPlugins$jscomp$inline_216.hasOwnProperty(pluginName$jscomp$inline_218)) {
      var pluginModule$jscomp$inline_219 = injectedNamesToPlugins$jscomp$inline_216[pluginName$jscomp$inline_218];

      if (!namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_218) || namesToPlugins[pluginName$jscomp$inline_218] !== pluginModule$jscomp$inline_219) {
        if (namesToPlugins[pluginName$jscomp$inline_218]) throw Error("EventPluginRegistry: Cannot inject two different event plugins using the same name, `" + pluginName$jscomp$inline_218 + "`.");
        namesToPlugins[pluginName$jscomp$inline_218] = pluginModule$jscomp$inline_219;
        isOrderingDirty$jscomp$inline_217 = true;
      }
    }
  }

  isOrderingDirty$jscomp$inline_217 && recomputePluginOrdering();

  function getInstanceFromInstance(instanceHandle) {
    return instanceHandle;
  }

  getFiberCurrentPropsFromNode = function getFiberCurrentPropsFromNode(inst) {
    return inst.canonical.currentProps;
  };

  getInstanceFromNode = getInstanceFromInstance;

  getNodeFromInstance = function getNodeFromInstance(inst) {
    inst = inst.stateNode.canonical;
    if (!inst._nativeTag) throw Error("All native instances should have a tag.");
    return inst;
  };

  ResponderEventPlugin.injection.injectGlobalResponderHandler({
    onChange: function onChange(from, to, blockNativeResponder) {
      var fromOrTo = from || to;
      (fromOrTo = fromOrTo && fromOrTo.stateNode) && fromOrTo.canonical._internalInstanceHandle ? (from && nativeFabricUIManager.setIsJSResponder(from.stateNode.node, false, blockNativeResponder || false), to && nativeFabricUIManager.setIsJSResponder(to.stateNode.node, true, blockNativeResponder || false)) : null !== to ? _$$_REQUIRE(_dependencyMap[3]).UIManager.setJSResponder(to.stateNode.canonical._nativeTag, blockNativeResponder) : _$$_REQUIRE(_dependencyMap[3]).UIManager.clearJSResponder();
    }
  });
  var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
      REACT_ELEMENT_TYPE = 60103,
      REACT_PORTAL_TYPE = 60106,
      REACT_FRAGMENT_TYPE = 60107,
      REACT_STRICT_MODE_TYPE = 60108,
      REACT_PROFILER_TYPE = 60114,
      REACT_PROVIDER_TYPE = 60109,
      REACT_CONTEXT_TYPE = 60110,
      REACT_FORWARD_REF_TYPE = 60112,
      REACT_SUSPENSE_TYPE = 60113,
      REACT_SUSPENSE_LIST_TYPE = 60120,
      REACT_MEMO_TYPE = 60115,
      REACT_LAZY_TYPE = 60116,
      REACT_DEBUG_TRACING_MODE_TYPE = 60129,
      REACT_OFFSCREEN_TYPE = 60130,
      REACT_LEGACY_HIDDEN_TYPE = 60131,
      REACT_CACHE_TYPE = 60132;

  if ("function" === typeof Symbol && Symbol.for) {
    var symbolFor = Symbol.for;
    REACT_ELEMENT_TYPE = symbolFor("react.element");
    REACT_PORTAL_TYPE = symbolFor("react.portal");
    REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
    REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
    REACT_PROFILER_TYPE = symbolFor("react.profiler");
    REACT_PROVIDER_TYPE = symbolFor("react.provider");
    REACT_CONTEXT_TYPE = symbolFor("react.context");
    REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
    REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
    REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
    REACT_MEMO_TYPE = symbolFor("react.memo");
    REACT_LAZY_TYPE = symbolFor("react.lazy");
    symbolFor("react.scope");
    REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
    REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
    REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
    REACT_CACHE_TYPE = symbolFor("react.cache");
  }

  var MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && Symbol.iterator;

  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }

  function getComponentNameFromType(type) {
    if (null == type) return null;
    if ("function" === typeof type) return type.displayName || type.name || null;
    if ("string" === typeof type) return type;

    switch (type) {
      case REACT_FRAGMENT_TYPE:
        return "Fragment";

      case REACT_PORTAL_TYPE:
        return "Portal";

      case REACT_PROFILER_TYPE:
        return "Profiler";

      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";

      case REACT_SUSPENSE_TYPE:
        return "Suspense";

      case REACT_SUSPENSE_LIST_TYPE:
        return "SuspenseList";

      case REACT_CACHE_TYPE:
        return "Cache";
    }

    if ("object" === typeof type) switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return (type.displayName || "Context") + ".Consumer";

      case REACT_PROVIDER_TYPE:
        return (type._context.displayName || "Context") + ".Provider";

      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        type = type.displayName;
        type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
        return type;

      case REACT_MEMO_TYPE:
        return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";

      case REACT_LAZY_TYPE:
        innerType = type._payload;
        type = type._init;

        try {
          return getComponentNameFromType(type(innerType));
        } catch (x) {}

    }
    return null;
  }

  function getComponentNameFromFiber(fiber) {
    var type = fiber.type;

    switch (fiber.tag) {
      case 24:
        return "Cache";

      case 9:
        return (type.displayName || "Context") + ".Consumer";

      case 10:
        return (type._context.displayName || "Context") + ".Provider";

      case 18:
        return "DehydratedFragment";

      case 11:
        return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");

      case 7:
        return "Fragment";

      case 5:
        return type;

      case 4:
        return "Portal";

      case 3:
        return "Root";

      case 6:
        return "Text";

      case 16:
        return getComponentNameFromType(type);

      case 23:
        return "LegacyHidden";

      case 8:
        return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";

      case 22:
        return "Offscreen";

      case 12:
        return "Profiler";

      case 21:
        return "Scope";

      case 13:
        return "Suspense";

      case 19:
        return "SuspenseList";

      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof type) return type.displayName || type.name || null;
        if ("string" === typeof type) return type;
    }

    return null;
  }

  function getNearestMountedFiber(fiber) {
    var node = fiber,
        nearestMounted = fiber;
    if (fiber.alternate) for (; node.return;) {
      node = node.return;
    } else {
      fiber = node;

      do {
        node = fiber, 0 !== (node.flags & 2050) && (nearestMounted = node.return), fiber = node.return;
      } while (fiber);
    }
    return 3 === node.tag ? nearestMounted : null;
  }

  function assertIsMounted(fiber) {
    if (getNearestMountedFiber(fiber) !== fiber) throw Error("Unable to find node on an unmounted component.");
  }

  function findCurrentFiberUsingSlowPath(fiber) {
    var alternate = fiber.alternate;

    if (!alternate) {
      alternate = getNearestMountedFiber(fiber);
      if (null === alternate) throw Error("Unable to find node on an unmounted component.");
      return alternate !== fiber ? null : fiber;
    }

    for (var a = fiber, b = alternate;;) {
      var parentA = a.return;
      if (null === parentA) break;
      var parentB = parentA.alternate;

      if (null === parentB) {
        b = parentA.return;

        if (null !== b) {
          a = b;
          continue;
        }

        break;
      }

      if (parentA.child === parentB.child) {
        for (parentB = parentA.child; parentB;) {
          if (parentB === a) return assertIsMounted(parentA), fiber;
          if (parentB === b) return assertIsMounted(parentA), alternate;
          parentB = parentB.sibling;
        }

        throw Error("Unable to find node on an unmounted component.");
      }

      if (a.return !== b.return) a = parentA, b = parentB;else {
        for (var didFindChild = false, child$0 = parentA.child; child$0;) {
          if (child$0 === a) {
            didFindChild = true;
            a = parentA;
            b = parentB;
            break;
          }

          if (child$0 === b) {
            didFindChild = true;
            b = parentA;
            a = parentB;
            break;
          }

          child$0 = child$0.sibling;
        }

        if (!didFindChild) {
          for (child$0 = parentB.child; child$0;) {
            if (child$0 === a) {
              didFindChild = true;
              a = parentB;
              b = parentA;
              break;
            }

            if (child$0 === b) {
              didFindChild = true;
              b = parentB;
              a = parentA;
              break;
            }

            child$0 = child$0.sibling;
          }

          if (!didFindChild) throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
        }
      }
      if (a.alternate !== b) throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
    }

    if (3 !== a.tag) throw Error("Unable to find node on an unmounted component.");
    return a.stateNode.current === a ? fiber : alternate;
  }

  function findCurrentHostFiber(parent) {
    parent = findCurrentFiberUsingSlowPath(parent);
    return null !== parent ? findCurrentHostFiberImpl(parent) : null;
  }

  function findCurrentHostFiberImpl(node) {
    if (5 === node.tag || 6 === node.tag) return node;

    for (node = node.child; null !== node;) {
      var match = findCurrentHostFiberImpl(node);
      if (null !== match) return match;
      node = node.sibling;
    }

    return null;
  }

  function mountSafeCallback_NOT_REALLY_SAFE(context, callback) {
    return function () {
      if (callback && ("boolean" !== typeof context.__isMounted || context.__isMounted)) return callback.apply(context, arguments);
    };
  }

  var emptyObject = {},
      removedKeys = null,
      removedKeyCount = 0,
      deepDifferOptions = {
    unsafelyIgnoreFunctions: true
  };

  function defaultDiffer(prevProp, nextProp) {
    return "object" !== typeof nextProp || null === nextProp ? true : _$$_REQUIRE(_dependencyMap[3]).deepDiffer(prevProp, nextProp, deepDifferOptions);
  }

  function restoreDeletedValuesInNestedArray(updatePayload, node, validAttributes) {
    if (isArrayImpl(node)) for (var i = node.length; i-- && 0 < removedKeyCount;) {
      restoreDeletedValuesInNestedArray(updatePayload, node[i], validAttributes);
    } else if (node && 0 < removedKeyCount) for (i in removedKeys) {
      if (removedKeys[i]) {
        var nextProp = node[i];

        if (undefined !== nextProp) {
          var attributeConfig = validAttributes[i];

          if (attributeConfig) {
            "function" === typeof nextProp && (nextProp = true);
            "undefined" === typeof nextProp && (nextProp = null);
            if ("object" !== typeof attributeConfig) updatePayload[i] = nextProp;else if ("function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process) nextProp = "function" === typeof attributeConfig.process ? attributeConfig.process(nextProp) : nextProp, updatePayload[i] = nextProp;
            removedKeys[i] = false;
            removedKeyCount--;
          }
        }
      }
    }
  }

  function diffNestedProperty(updatePayload, prevProp, nextProp, validAttributes) {
    if (!updatePayload && prevProp === nextProp) return updatePayload;
    if (!prevProp || !nextProp) return nextProp ? addNestedProperty(updatePayload, nextProp, validAttributes) : prevProp ? clearNestedProperty(updatePayload, prevProp, validAttributes) : updatePayload;
    if (!isArrayImpl(prevProp) && !isArrayImpl(nextProp)) return diffProperties(updatePayload, prevProp, nextProp, validAttributes);

    if (isArrayImpl(prevProp) && isArrayImpl(nextProp)) {
      var minLength = prevProp.length < nextProp.length ? prevProp.length : nextProp.length,
          i;

      for (i = 0; i < minLength; i++) {
        updatePayload = diffNestedProperty(updatePayload, prevProp[i], nextProp[i], validAttributes);
      }

      for (; i < prevProp.length; i++) {
        updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
      }

      for (; i < nextProp.length; i++) {
        updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
      }

      return updatePayload;
    }

    return isArrayImpl(prevProp) ? diffProperties(updatePayload, _$$_REQUIRE(_dependencyMap[3]).flattenStyle(prevProp), nextProp, validAttributes) : diffProperties(updatePayload, prevProp, _$$_REQUIRE(_dependencyMap[3]).flattenStyle(nextProp), validAttributes);
  }

  function addNestedProperty(updatePayload, nextProp, validAttributes) {
    if (!nextProp) return updatePayload;
    if (!isArrayImpl(nextProp)) return diffProperties(updatePayload, emptyObject, nextProp, validAttributes);

    for (var i = 0; i < nextProp.length; i++) {
      updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
    }

    return updatePayload;
  }

  function clearNestedProperty(updatePayload, prevProp, validAttributes) {
    if (!prevProp) return updatePayload;
    if (!isArrayImpl(prevProp)) return diffProperties(updatePayload, prevProp, emptyObject, validAttributes);

    for (var i = 0; i < prevProp.length; i++) {
      updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
    }

    return updatePayload;
  }

  function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {
    var attributeConfig, propKey;

    for (propKey in nextProps) {
      if (attributeConfig = validAttributes[propKey]) {
        var prevProp = prevProps[propKey];
        var nextProp = nextProps[propKey];
        "function" === typeof nextProp && (nextProp = true, "function" === typeof prevProp && (prevProp = true));
        "undefined" === typeof nextProp && (nextProp = null, "undefined" === typeof prevProp && (prevProp = null));
        removedKeys && (removedKeys[propKey] = false);
        if (updatePayload && undefined !== updatePayload[propKey]) {
          if ("object" !== typeof attributeConfig) updatePayload[propKey] = nextProp;else {
            if ("function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process) attributeConfig = "function" === typeof attributeConfig.process ? attributeConfig.process(nextProp) : nextProp, updatePayload[propKey] = attributeConfig;
          }
        } else if (prevProp !== nextProp) if ("object" !== typeof attributeConfig) defaultDiffer(prevProp, nextProp) && ((updatePayload || (updatePayload = {}))[propKey] = nextProp);else if ("function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process) {
          if (undefined === prevProp || ("function" === typeof attributeConfig.diff ? attributeConfig.diff(prevProp, nextProp) : defaultDiffer(prevProp, nextProp))) attributeConfig = "function" === typeof attributeConfig.process ? attributeConfig.process(nextProp) : nextProp, (updatePayload || (updatePayload = {}))[propKey] = attributeConfig;
        } else removedKeys = null, removedKeyCount = 0, updatePayload = diffNestedProperty(updatePayload, prevProp, nextProp, attributeConfig), 0 < removedKeyCount && updatePayload && (restoreDeletedValuesInNestedArray(updatePayload, nextProp, attributeConfig), removedKeys = null);
      }
    }

    for (var propKey$2 in prevProps) {
      undefined === nextProps[propKey$2] && (!(attributeConfig = validAttributes[propKey$2]) || updatePayload && undefined !== updatePayload[propKey$2] || (prevProp = prevProps[propKey$2], undefined !== prevProp && ("object" !== typeof attributeConfig || "function" === typeof attributeConfig.diff || "function" === typeof attributeConfig.process ? ((updatePayload || (updatePayload = {}))[propKey$2] = null, removedKeys || (removedKeys = {}), removedKeys[propKey$2] || (removedKeys[propKey$2] = true, removedKeyCount++)) : updatePayload = clearNestedProperty(updatePayload, prevProp, attributeConfig))));
    }

    return updatePayload;
  }

  function batchedUpdatesImpl(fn, bookkeeping) {
    return fn(bookkeeping);
  }

  var isInsideEventHandler = false;

  function batchedUpdates(fn, bookkeeping) {
    if (isInsideEventHandler) return fn(bookkeeping);
    isInsideEventHandler = true;

    try {
      return batchedUpdatesImpl(fn, bookkeeping);
    } finally {
      isInsideEventHandler = false;
    }
  }

  var eventQueue = null;

  function executeDispatchesAndReleaseTopLevel(e) {
    if (e) {
      var dispatchListeners = e._dispatchListeners,
          dispatchInstances = e._dispatchInstances;
      if (isArrayImpl(dispatchListeners)) for (var i = 0; i < dispatchListeners.length && !e.isPropagationStopped(); i++) {
        executeDispatch(e, dispatchListeners[i], dispatchInstances[i]);
      } else dispatchListeners && executeDispatch(e, dispatchListeners, dispatchInstances);
      e._dispatchListeners = null;
      e._dispatchInstances = null;
      e.isPersistent() || e.constructor.release(e);
    }
  }

  function dispatchEvent(target, topLevelType, nativeEvent) {
    var eventTarget = null;

    if (null != target) {
      var stateNode = target.stateNode;
      null != stateNode && (eventTarget = stateNode.canonical);
    }

    batchedUpdates(function () {
      var JSCompiler_inline_result = eventTarget;

      for (var events = null, legacyPlugins = plugins, i = 0; i < legacyPlugins.length; i++) {
        var possiblePlugin = legacyPlugins[i];
        possiblePlugin && (possiblePlugin = possiblePlugin.extractEvents(topLevelType, target, nativeEvent, JSCompiler_inline_result)) && (events = accumulateInto(events, possiblePlugin));
      }

      JSCompiler_inline_result = events;
      null !== JSCompiler_inline_result && (eventQueue = accumulateInto(eventQueue, JSCompiler_inline_result));
      JSCompiler_inline_result = eventQueue;
      eventQueue = null;

      if (JSCompiler_inline_result) {
        forEachAccumulated(JSCompiler_inline_result, executeDispatchesAndReleaseTopLevel);
        if (eventQueue) throw Error("processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.");
        if (hasRethrowError) throw JSCompiler_inline_result = rethrowError, hasRethrowError = false, rethrowError = null, JSCompiler_inline_result;
      }
    });
  }

  var rendererID = null,
      injectedHook = null;

  function onCommitRoot(root) {
    if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot) try {
      injectedHook.onCommitFiberRoot(rendererID, root, undefined, 128 === (root.current.flags & 128));
    } catch (err) {}
  }

  var nextTransitionLane = 64,
      nextRetryLane = 4194304;

  function getHighestPriorityLanes(lanes) {
    switch (lanes & -lanes) {
      case 1:
        return 1;

      case 2:
        return 2;

      case 4:
        return 4;

      case 8:
        return 8;

      case 16:
        return 16;

      case 32:
        return 32;

      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return lanes & 4194240;

      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return lanes & 130023424;

      case 134217728:
        return 134217728;

      case 268435456:
        return 268435456;

      case 536870912:
        return 536870912;

      case 1073741824:
        return 1073741824;

      default:
        return lanes;
    }
  }

  function getNextLanes(root, wipLanes) {
    var pendingLanes = root.pendingLanes;
    if (0 === pendingLanes) return 0;
    var nextLanes = 0,
        suspendedLanes = root.suspendedLanes,
        pingedLanes = root.pingedLanes,
        nonIdlePendingLanes = pendingLanes & 268435455;

    if (0 !== nonIdlePendingLanes) {
      var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
      0 !== nonIdleUnblockedLanes ? nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes && (nextLanes = getHighestPriorityLanes(pingedLanes)));
    } else nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes && (nextLanes = getHighestPriorityLanes(pingedLanes));

    if (0 === nextLanes) return 0;
    if (0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, pingedLanes = wipLanes & -wipLanes, suspendedLanes >= pingedLanes || 16 === suspendedLanes && 0 !== (pingedLanes & 4194240))) return wipLanes;
    0 !== (nextLanes & 4) && (nextLanes |= pendingLanes & 16);
    wipLanes = root.entangledLanes;
    if (0 !== wipLanes) for (root = root.entanglements, wipLanes &= nextLanes; 0 < wipLanes;) {
      pendingLanes = 31 - clz32(wipLanes), suspendedLanes = 1 << pendingLanes, nextLanes |= root[pendingLanes], wipLanes &= ~suspendedLanes;
    }
    return nextLanes;
  }

  function computeExpirationTime(lane, currentTime) {
    switch (lane) {
      case 1:
      case 2:
      case 4:
        return currentTime + 250;

      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return currentTime + 5e3;

      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;

      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;

      default:
        return -1;
    }
  }

  function getLanesToRetrySynchronouslyOnError(root) {
    root = root.pendingLanes & -1073741825;
    return 0 !== root ? root : root & 1073741824 ? 1073741824 : 0;
  }

  function createLaneMap(initial) {
    for (var laneMap = [], i = 0; 31 > i; i++) {
      laneMap.push(initial);
    }

    return laneMap;
  }

  function markRootUpdated(root, updateLane, eventTime) {
    root.pendingLanes |= updateLane;
    536870912 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0);
    root = root.eventTimes;
    updateLane = 31 - clz32(updateLane);
    root[updateLane] = eventTime;
  }

  function markRootFinished(root, remainingLanes) {
    var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
    root.pendingLanes = remainingLanes;
    root.suspendedLanes = 0;
    root.pingedLanes = 0;
    root.expiredLanes &= remainingLanes;
    root.mutableReadLanes &= remainingLanes;
    root.entangledLanes &= remainingLanes;
    remainingLanes = root.entanglements;
    var eventTimes = root.eventTimes;

    for (root = root.expirationTimes; 0 < noLongerPendingLanes;) {
      var index$7 = 31 - clz32(noLongerPendingLanes),
          lane = 1 << index$7;
      remainingLanes[index$7] = 0;
      eventTimes[index$7] = -1;
      root[index$7] = -1;
      noLongerPendingLanes &= ~lane;
    }
  }

  function markRootEntangled(root, entangledLanes) {
    var rootEntangledLanes = root.entangledLanes |= entangledLanes;

    for (root = root.entanglements; rootEntangledLanes;) {
      var index$8 = 31 - clz32(rootEntangledLanes),
          lane = 1 << index$8;
      lane & entangledLanes | root[index$8] & entangledLanes && (root[index$8] |= entangledLanes);
      rootEntangledLanes &= ~lane;
    }
  }

  var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
      log = Math.log,
      LN2 = Math.LN2;

  function clz32Fallback(lanes) {
    return 0 === lanes ? 32 : 31 - (log(lanes) / LN2 | 0) | 0;
  }

  var currentUpdatePriority = 0;

  function lanesToEventPriority(lanes) {
    lanes &= -lanes;
    return 1 < lanes ? 4 < lanes ? 0 !== (lanes & 268435455) ? 16 : 536870912 : 4 : 1;
  }

  function shim() {
    throw Error("The current renderer does not support mutation. This error is likely caused by a bug in React. Please file an issue.");
  }

  function shim$1() {
    throw Error("The current renderer does not support hydration. This error is likely caused by a bug in React. Please file an issue.");
  }

  var _nativeFabricUIManage = nativeFabricUIManager,
      createNode = _nativeFabricUIManage.createNode,
      cloneNode = _nativeFabricUIManage.cloneNode,
      cloneNodeWithNewChildren = _nativeFabricUIManage.cloneNodeWithNewChildren,
      cloneNodeWithNewChildrenAndProps = _nativeFabricUIManage.cloneNodeWithNewChildrenAndProps,
      cloneNodeWithNewProps = _nativeFabricUIManage.cloneNodeWithNewProps,
      createChildNodeSet = _nativeFabricUIManage.createChildSet,
      appendChildNode = _nativeFabricUIManage.appendChild,
      appendChildNodeToSet = _nativeFabricUIManage.appendChildToSet,
      completeRoot = _nativeFabricUIManage.completeRoot,
      registerEventHandler = _nativeFabricUIManage.registerEventHandler,
      fabricMeasure = _nativeFabricUIManage.measure,
      fabricMeasureInWindow = _nativeFabricUIManage.measureInWindow,
      fabricMeasureLayout = _nativeFabricUIManage.measureLayout,
      FabricDiscretePriority = _nativeFabricUIManage.unstable_DiscreteEventPriority,
      fabricGetCurrentEventPriority = _nativeFabricUIManage.unstable_getCurrentEventPriority,
      getViewConfigForType = _$$_REQUIRE(_dependencyMap[3]).ReactNativeViewConfigRegistry.get,
      nextReactTag = 2;

  registerEventHandler && registerEventHandler(dispatchEvent);

  var ReactFabricHostComponent = function () {
    function ReactFabricHostComponent(tag, viewConfig, props, internalInstanceHandle) {
      this._nativeTag = tag;
      this.viewConfig = viewConfig;
      this.currentProps = props;
      this._internalInstanceHandle = internalInstanceHandle;
    }

    var _proto = ReactFabricHostComponent.prototype;

    _proto.blur = function () {
      _$$_REQUIRE(_dependencyMap[3]).TextInputState.blurTextInput(this);
    };

    _proto.focus = function () {
      _$$_REQUIRE(_dependencyMap[3]).TextInputState.focusTextInput(this);
    };

    _proto.measure = function (callback) {
      fabricMeasure(this._internalInstanceHandle.stateNode.node, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
    };

    _proto.measureInWindow = function (callback) {
      fabricMeasureInWindow(this._internalInstanceHandle.stateNode.node, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
    };

    _proto.measureLayout = function (relativeToNativeNode, onSuccess, onFail) {
      "number" !== typeof relativeToNativeNode && relativeToNativeNode instanceof ReactFabricHostComponent && fabricMeasureLayout(this._internalInstanceHandle.stateNode.node, relativeToNativeNode._internalInstanceHandle.stateNode.node, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
    };

    _proto.setNativeProps = function () {};

    return ReactFabricHostComponent;
  }();

  function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
    if (!hostContext.isInAParentText) throw Error("Text strings must be rendered within a <Text> component.");
    hostContext = nextReactTag;
    nextReactTag += 2;
    return {
      node: createNode(hostContext, "RCTRawText", rootContainerInstance, {
        text: text
      }, internalInstanceHandle)
    };
  }

  var scheduleTimeout = setTimeout,
      cancelTimeout = clearTimeout;

  function cloneHiddenInstance(instance) {
    var node = instance.node;
    var JSCompiler_inline_result = diffProperties(null, emptyObject, {
      style: {
        display: "none"
      }
    }, instance.canonical.viewConfig.validAttributes);
    return {
      node: cloneNodeWithNewProps(node, JSCompiler_inline_result),
      canonical: instance.canonical
    };
  }

  function describeComponentFrame(name, source, ownerName) {
    source = "";
    ownerName && (source = " (created by " + ownerName + ")");
    return "\n    in " + (name || "Unknown") + source;
  }

  function describeFunctionComponentFrame(fn, source) {
    return fn ? describeComponentFrame(fn.displayName || fn.name || null, source, null) : "";
  }

  var hasOwnProperty = Object.prototype.hasOwnProperty,
      valueStack = [],
      index = -1;

  function createCursor(defaultValue) {
    return {
      current: defaultValue
    };
  }

  function pop(cursor) {
    0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
  }

  function push(cursor, value) {
    index++;
    valueStack[index] = cursor.current;
    cursor.current = value;
  }

  var emptyContextObject = {},
      contextStackCursor = createCursor(emptyContextObject),
      didPerformWorkStackCursor = createCursor(false),
      previousContext = emptyContextObject;

  function getMaskedContext(workInProgress, unmaskedContext) {
    var contextTypes = workInProgress.type.contextTypes;
    if (!contextTypes) return emptyContextObject;
    var instance = workInProgress.stateNode;
    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) return instance.__reactInternalMemoizedMaskedChildContext;
    var context = {},
        key;

    for (key in contextTypes) {
      context[key] = unmaskedContext[key];
    }

    instance && (workInProgress = workInProgress.stateNode, workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext, workInProgress.__reactInternalMemoizedMaskedChildContext = context);
    return context;
  }

  function isContextProvider(type) {
    type = type.childContextTypes;
    return null !== type && undefined !== type;
  }

  function popContext() {
    pop(didPerformWorkStackCursor);
    pop(contextStackCursor);
  }

  function pushTopLevelContextObject(fiber, context, didChange) {
    if (contextStackCursor.current !== emptyContextObject) throw Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
    push(contextStackCursor, context);
    push(didPerformWorkStackCursor, didChange);
  }

  function processChildContext(fiber, type, parentContext) {
    var instance = fiber.stateNode;
    type = type.childContextTypes;
    if ("function" !== typeof instance.getChildContext) return parentContext;
    instance = instance.getChildContext();

    for (var contextKey in instance) {
      if (!(contextKey in type)) throw Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
    }

    return _$$_REQUIRE(_dependencyMap[2])({}, parentContext, instance);
  }

  function pushContextProvider(workInProgress) {
    workInProgress = (workInProgress = workInProgress.stateNode) && workInProgress.__reactInternalMemoizedMergedChildContext || emptyContextObject;
    previousContext = contextStackCursor.current;
    push(contextStackCursor, workInProgress);
    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current);
    return true;
  }

  function invalidateContextProvider(workInProgress, type, didChange) {
    var instance = workInProgress.stateNode;
    if (!instance) throw Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
    didChange ? (workInProgress = processChildContext(workInProgress, type, previousContext), instance.__reactInternalMemoizedMergedChildContext = workInProgress, pop(didPerformWorkStackCursor), pop(contextStackCursor), push(contextStackCursor, workInProgress)) : pop(didPerformWorkStackCursor);
    push(didPerformWorkStackCursor, didChange);
  }

  var syncQueue = null,
      includesLegacySyncCallbacks = false,
      isFlushingSyncQueue = false;

  function flushSyncCallbacks() {
    if (!isFlushingSyncQueue && null !== syncQueue) {
      isFlushingSyncQueue = true;
      var i = 0,
          previousUpdatePriority = currentUpdatePriority;

      try {
        var queue = syncQueue;

        for (currentUpdatePriority = 1; i < queue.length; i++) {
          var callback = queue[i];

          do {
            callback = callback(true);
          } while (null !== callback);
        }

        syncQueue = null;
        includesLegacySyncCallbacks = false;
      } catch (error) {
        throw null !== syncQueue && (syncQueue = syncQueue.slice(i + 1)), _$$_REQUIRE(_dependencyMap[4]).unstable_scheduleCallback(_$$_REQUIRE(_dependencyMap[4]).unstable_ImmediatePriority, flushSyncCallbacks), error;
      } finally {
        currentUpdatePriority = previousUpdatePriority, isFlushingSyncQueue = false;
      }
    }

    return null;
  }

  var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;

  function is(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
  }

  var objectIs = "function" === typeof Object.is ? Object.is : is;

  function shallowEqual(objA, objB) {
    if (objectIs(objA, objB)) return true;
    if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB) return false;
    var keysA = Object.keys(objA),
        keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;

    for (keysB = 0; keysB < keysA.length; keysB++) {
      if (!hasOwnProperty.call(objB, keysA[keysB]) || !objectIs(objA[keysA[keysB]], objB[keysA[keysB]])) return false;
    }

    return true;
  }

  function describeFiber(fiber) {
    switch (fiber.tag) {
      case 5:
        return describeComponentFrame(fiber.type, null, null);

      case 16:
        return describeComponentFrame("Lazy", null, null);

      case 13:
        return describeComponentFrame("Suspense", null, null);

      case 19:
        return describeComponentFrame("SuspenseList", null, null);

      case 0:
      case 2:
      case 15:
        return describeFunctionComponentFrame(fiber.type, null);

      case 11:
        return describeFunctionComponentFrame(fiber.type.render, null);

      case 1:
        return fiber = describeFunctionComponentFrame(fiber.type, null), fiber;

      default:
        return "";
    }
  }

  function resolveDefaultProps(Component, baseProps) {
    if (Component && Component.defaultProps) {
      baseProps = _$$_REQUIRE(_dependencyMap[2])({}, baseProps);
      Component = Component.defaultProps;

      for (var propName in Component) {
        undefined === baseProps[propName] && (baseProps[propName] = Component[propName]);
      }

      return baseProps;
    }

    return baseProps;
  }

  var valueCursor = createCursor(null),
      currentlyRenderingFiber = null,
      lastContextDependency = null,
      lastFullyObservedContext = null;

  function resetContextDependencies() {
    lastFullyObservedContext = lastContextDependency = currentlyRenderingFiber = null;
  }

  function popProvider(context) {
    var currentValue = valueCursor.current;
    pop(valueCursor);
    context._currentValue2 = currentValue;
  }

  function scheduleWorkOnParentPath(parent, renderLanes) {
    for (; null !== parent;) {
      var alternate = parent.alternate;
      if ((parent.childLanes & renderLanes) === renderLanes) {
        if (null === alternate || (alternate.childLanes & renderLanes) === renderLanes) break;else alternate.childLanes |= renderLanes;
      } else parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes);
      parent = parent.return;
    }
  }

  function prepareToReadContext(workInProgress, renderLanes) {
    currentlyRenderingFiber = workInProgress;
    lastFullyObservedContext = lastContextDependency = null;
    workInProgress = workInProgress.dependencies;
    null !== workInProgress && null !== workInProgress.firstContext && (0 !== (workInProgress.lanes & renderLanes) && (didReceiveUpdate = true), workInProgress.firstContext = null);
  }

  function readContext(context) {
    var value = context._currentValue2;
    if (lastFullyObservedContext !== context) if (context = {
      context: context,
      memoizedValue: value,
      next: null
    }, null === lastContextDependency) {
      if (null === currentlyRenderingFiber) throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      lastContextDependency = context;
      currentlyRenderingFiber.dependencies = {
        lanes: 0,
        firstContext: context
      };
    } else lastContextDependency = lastContextDependency.next = context;
    return value;
  }

  var interleavedQueues = null,
      hasForceUpdate = false;

  function initializeUpdateQueue(fiber) {
    fiber.updateQueue = {
      baseState: fiber.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
        pending: null,
        interleaved: null,
        lanes: 0
      },
      effects: null
    };
  }

  function cloneUpdateQueue(current, workInProgress) {
    current = current.updateQueue;
    workInProgress.updateQueue === current && (workInProgress.updateQueue = {
      baseState: current.baseState,
      firstBaseUpdate: current.firstBaseUpdate,
      lastBaseUpdate: current.lastBaseUpdate,
      shared: current.shared,
      effects: current.effects
    });
  }

  function createUpdate(eventTime, lane) {
    return {
      eventTime: eventTime,
      lane: lane,
      tag: 0,
      payload: null,
      callback: null,
      next: null
    };
  }

  function enqueueUpdate(fiber, update) {
    var updateQueue = fiber.updateQueue;
    null !== updateQueue && (updateQueue = updateQueue.shared, null !== workInProgressRoot && 0 !== (fiber.mode & 1) && 0 === (executionContext & 8) ? (fiber = updateQueue.interleaved, null === fiber ? (update.next = update, null === interleavedQueues ? interleavedQueues = [updateQueue] : interleavedQueues.push(updateQueue)) : (update.next = fiber.next, fiber.next = update), updateQueue.interleaved = update) : (fiber = updateQueue.pending, null === fiber ? update.next = update : (update.next = fiber.next, fiber.next = update), updateQueue.pending = update));
  }

  function entangleTransitions(root, fiber, lane) {
    fiber = fiber.updateQueue;

    if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194240))) {
      var queueLanes = fiber.lanes;
      queueLanes &= root.pendingLanes;
      lane |= queueLanes;
      fiber.lanes = lane;
      markRootEntangled(root, lane);
    }
  }

  function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
    var queue = workInProgress.updateQueue,
        current = workInProgress.alternate;

    if (null !== current && (current = current.updateQueue, queue === current)) {
      var newFirst = null,
          newLast = null;
      queue = queue.firstBaseUpdate;

      if (null !== queue) {
        do {
          var clone = {
            eventTime: queue.eventTime,
            lane: queue.lane,
            tag: queue.tag,
            payload: queue.payload,
            callback: queue.callback,
            next: null
          };
          null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
          queue = queue.next;
        } while (null !== queue);

        null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
      } else newFirst = newLast = capturedUpdate;

      queue = {
        baseState: current.baseState,
        firstBaseUpdate: newFirst,
        lastBaseUpdate: newLast,
        shared: current.shared,
        effects: current.effects
      };
      workInProgress.updateQueue = queue;
      return;
    }

    workInProgress = queue.lastBaseUpdate;
    null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;
    queue.lastBaseUpdate = capturedUpdate;
  }

  function processUpdateQueue(workInProgress$jscomp$0, props, instance, renderLanes) {
    var queue = workInProgress$jscomp$0.updateQueue;
    hasForceUpdate = false;
    var firstBaseUpdate = queue.firstBaseUpdate,
        lastBaseUpdate = queue.lastBaseUpdate,
        pendingQueue = queue.shared.pending;

    if (null !== pendingQueue) {
      queue.shared.pending = null;
      var lastPendingUpdate = pendingQueue,
          firstPendingUpdate = lastPendingUpdate.next;
      lastPendingUpdate.next = null;
      null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
      lastBaseUpdate = lastPendingUpdate;
      var current = workInProgress$jscomp$0.alternate;
      null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
    }

    if (null !== firstBaseUpdate) {
      var newState = queue.baseState;
      lastBaseUpdate = 0;
      current = firstPendingUpdate = lastPendingUpdate = null;
      pendingQueue = firstBaseUpdate;

      do {
        var updateLane = pendingQueue.lane,
            updateEventTime = pendingQueue.eventTime;

        if ((renderLanes & updateLane) === updateLane) {
          null !== current && (current = current.next = {
            eventTime: updateEventTime,
            lane: 0,
            tag: pendingQueue.tag,
            payload: pendingQueue.payload,
            callback: pendingQueue.callback,
            next: null
          });

          a: {
            var workInProgress = workInProgress$jscomp$0,
                update = pendingQueue;
            updateLane = props;
            updateEventTime = instance;

            switch (update.tag) {
              case 1:
                workInProgress = update.payload;

                if ("function" === typeof workInProgress) {
                  newState = workInProgress.call(updateEventTime, newState, updateLane);
                  break a;
                }

                newState = workInProgress;
                break a;

              case 3:
                workInProgress.flags = workInProgress.flags & -16385 | 128;

              case 0:
                workInProgress = update.payload;
                updateLane = "function" === typeof workInProgress ? workInProgress.call(updateEventTime, newState, updateLane) : workInProgress;
                if (null === updateLane || undefined === updateLane) break a;
                newState = _$$_REQUIRE(_dependencyMap[2])({}, newState, updateLane);
                break a;

              case 2:
                hasForceUpdate = true;
            }
          }

          null !== pendingQueue.callback && 0 !== pendingQueue.lane && (workInProgress$jscomp$0.flags |= 64, updateLane = queue.effects, null === updateLane ? queue.effects = [pendingQueue] : updateLane.push(pendingQueue));
        } else updateEventTime = {
          eventTime: updateEventTime,
          lane: updateLane,
          tag: pendingQueue.tag,
          payload: pendingQueue.payload,
          callback: pendingQueue.callback,
          next: null
        }, null === current ? (firstPendingUpdate = current = updateEventTime, lastPendingUpdate = newState) : current = current.next = updateEventTime, lastBaseUpdate |= updateLane;

        pendingQueue = pendingQueue.next;
        if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;else updateLane = pendingQueue, pendingQueue = updateLane.next, updateLane.next = null, queue.lastBaseUpdate = updateLane, queue.shared.pending = null;
      } while (1);

      null === current && (lastPendingUpdate = newState);
      queue.baseState = lastPendingUpdate;
      queue.firstBaseUpdate = firstPendingUpdate;
      queue.lastBaseUpdate = current;
      props = queue.shared.interleaved;

      if (null !== props) {
        queue = props;

        do {
          lastBaseUpdate |= queue.lane, queue = queue.next;
        } while (queue !== props);
      } else null === firstBaseUpdate && (queue.shared.lanes = 0);

      workInProgressRootSkippedLanes |= lastBaseUpdate;
      workInProgress$jscomp$0.lanes = lastBaseUpdate;
      workInProgress$jscomp$0.memoizedState = newState;
    }
  }

  function commitUpdateQueue(finishedWork, finishedQueue, instance) {
    finishedWork = finishedQueue.effects;
    finishedQueue.effects = null;
    if (null !== finishedWork) for (finishedQueue = 0; finishedQueue < finishedWork.length; finishedQueue++) {
      var effect = finishedWork[finishedQueue],
          callback = effect.callback;

      if (null !== callback) {
        effect.callback = null;
        if ("function" !== typeof callback) throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
        callback.call(instance);
      }
    }
  }

  var emptyRefsObject = new React.Component().refs;

  function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
    ctor = workInProgress.memoizedState;
    getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
    getDerivedStateFromProps = null === getDerivedStateFromProps || undefined === getDerivedStateFromProps ? ctor : _$$_REQUIRE(_dependencyMap[2])({}, ctor, getDerivedStateFromProps);
    workInProgress.memoizedState = getDerivedStateFromProps;
    0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
  }

  var classComponentUpdater = {
    isMounted: function isMounted(component) {
      return (component = component._reactInternals) ? getNearestMountedFiber(component) === component : false;
    },
    enqueueSetState: function enqueueSetState(inst, payload, callback) {
      inst = inst._reactInternals;
      var eventTime = requestEventTime(),
          lane = requestUpdateLane(inst),
          update = createUpdate(eventTime, lane);
      update.payload = payload;
      undefined !== callback && null !== callback && (update.callback = callback);
      enqueueUpdate(inst, update);
      payload = scheduleUpdateOnFiber(inst, lane, eventTime);
      null !== payload && entangleTransitions(payload, inst, lane);
    },
    enqueueReplaceState: function enqueueReplaceState(inst, payload, callback) {
      inst = inst._reactInternals;
      var eventTime = requestEventTime(),
          lane = requestUpdateLane(inst),
          update = createUpdate(eventTime, lane);
      update.tag = 1;
      update.payload = payload;
      undefined !== callback && null !== callback && (update.callback = callback);
      enqueueUpdate(inst, update);
      payload = scheduleUpdateOnFiber(inst, lane, eventTime);
      null !== payload && entangleTransitions(payload, inst, lane);
    },
    enqueueForceUpdate: function enqueueForceUpdate(inst, callback) {
      inst = inst._reactInternals;
      var eventTime = requestEventTime(),
          lane = requestUpdateLane(inst),
          update = createUpdate(eventTime, lane);
      update.tag = 2;
      undefined !== callback && null !== callback && (update.callback = callback);
      enqueueUpdate(inst, update);
      callback = scheduleUpdateOnFiber(inst, lane, eventTime);
      null !== callback && entangleTransitions(callback, inst, lane);
    }
  };

  function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
    workInProgress = workInProgress.stateNode;
    return "function" === typeof workInProgress.shouldComponentUpdate ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
  }

  function constructClassInstance(workInProgress, ctor, props) {
    var isLegacyContextConsumer = false,
        unmaskedContext = emptyContextObject;
    var context = ctor.contextType;
    "object" === typeof context && null !== context ? context = readContext(context) : (unmaskedContext = isContextProvider(ctor) ? previousContext : contextStackCursor.current, isLegacyContextConsumer = ctor.contextTypes, context = (isLegacyContextConsumer = null !== isLegacyContextConsumer && undefined !== isLegacyContextConsumer) ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject);
    ctor = new ctor(props, context);
    workInProgress.memoizedState = null !== ctor.state && undefined !== ctor.state ? ctor.state : null;
    ctor.updater = classComponentUpdater;
    workInProgress.stateNode = ctor;
    ctor._reactInternals = workInProgress;
    isLegacyContextConsumer && (workInProgress = workInProgress.stateNode, workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext, workInProgress.__reactInternalMemoizedMaskedChildContext = context);
    return ctor;
  }

  function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
    workInProgress = instance.state;
    "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
    "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
    instance.state !== workInProgress && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }

  function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
    var instance = workInProgress.stateNode;
    instance.props = newProps;
    instance.state = workInProgress.memoizedState;
    instance.refs = emptyRefsObject;
    initializeUpdateQueue(workInProgress);
    var contextType = ctor.contextType;
    "object" === typeof contextType && null !== contextType ? instance.context = readContext(contextType) : (contextType = isContextProvider(ctor) ? previousContext : contextStackCursor.current, instance.context = getMaskedContext(workInProgress, contextType));
    instance.state = workInProgress.memoizedState;
    contextType = ctor.getDerivedStateFromProps;
    "function" === typeof contextType && (applyDerivedStateFromProps(workInProgress, ctor, contextType, newProps), instance.state = workInProgress.memoizedState);
    "function" === typeof ctor.getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate || "function" !== typeof instance.UNSAFE_componentWillMount && "function" !== typeof instance.componentWillMount || (ctor = instance.state, "function" === typeof instance.componentWillMount && instance.componentWillMount(), "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount(), ctor !== instance.state && classComponentUpdater.enqueueReplaceState(instance, instance.state, null), processUpdateQueue(workInProgress, newProps, instance, renderLanes), instance.state = workInProgress.memoizedState);
    "function" === typeof instance.componentDidMount && (workInProgress.flags |= 4);
  }

  function coerceRef(returnFiber, current, element) {
    returnFiber = element.ref;

    if (null !== returnFiber && "function" !== typeof returnFiber && "object" !== typeof returnFiber) {
      if (element._owner) {
        element = element._owner;

        if (element) {
          if (1 !== element.tag) throw Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
          var inst = element.stateNode;
        }

        if (!inst) throw Error("Missing owner for string ref " + returnFiber + ". This error is likely caused by a bug in React. Please file an issue.");
        var stringRef = "" + returnFiber;
        if (null !== current && null !== current.ref && "function" === typeof current.ref && current.ref._stringRef === stringRef) return current.ref;

        current = function current(value) {
          var refs = inst.refs;
          refs === emptyRefsObject && (refs = inst.refs = {});
          null === value ? delete refs[stringRef] : refs[stringRef] = value;
        };

        current._stringRef = stringRef;
        return current;
      }

      if ("string" !== typeof returnFiber) throw Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
      if (!element._owner) throw Error("Element ref was specified as a string (" + returnFiber + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
    }

    return returnFiber;
  }

  function throwOnInvalidObjectType(returnFiber, newChild) {
    returnFiber = Object.prototype.toString.call(newChild);
    throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead.");
  }

  function ChildReconciler(shouldTrackSideEffects) {
    function deleteChild(returnFiber, childToDelete) {
      if (shouldTrackSideEffects) {
        var deletions = returnFiber.deletions;
        null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
      }
    }

    function deleteRemainingChildren(returnFiber, currentFirstChild) {
      if (!shouldTrackSideEffects) return null;

      for (; null !== currentFirstChild;) {
        deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      }

      return null;
    }

    function mapRemainingChildren(returnFiber, currentFirstChild) {
      for (returnFiber = new Map(); null !== currentFirstChild;) {
        null !== currentFirstChild.key ? returnFiber.set(currentFirstChild.key, currentFirstChild) : returnFiber.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      }

      return returnFiber;
    }

    function useFiber(fiber, pendingProps) {
      fiber = createWorkInProgress(fiber, pendingProps);
      fiber.index = 0;
      fiber.sibling = null;
      return fiber;
    }

    function placeChild(newFiber, lastPlacedIndex, newIndex) {
      newFiber.index = newIndex;
      if (!shouldTrackSideEffects) return lastPlacedIndex;
      newIndex = newFiber.alternate;
      if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 2, lastPlacedIndex) : newIndex;
      newFiber.flags |= 2;
      return lastPlacedIndex;
    }

    function placeSingleChild(newFiber) {
      shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 2);
      return newFiber;
    }

    function updateTextNode(returnFiber, current, textContent, lanes) {
      if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
      current = useFiber(current, textContent);
      current.return = returnFiber;
      return current;
    }

    function updateElement(returnFiber, current, element, lanes) {
      var elementType = element.type;
      if (elementType === REACT_FRAGMENT_TYPE) return updateFragment(returnFiber, current, element.props.children, lanes, element.key);
      if (null !== current && current.elementType === elementType) return lanes = useFiber(current, element.props), lanes.ref = coerceRef(returnFiber, current, element), lanes.return = returnFiber, lanes;
      lanes = createFiberFromTypeAndProps(element.type, element.key, element.props, null, returnFiber.mode, lanes);
      lanes.ref = coerceRef(returnFiber, current, element);
      lanes.return = returnFiber;
      return lanes;
    }

    function updatePortal(returnFiber, current, portal, lanes) {
      if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
      current = useFiber(current, portal.children || []);
      current.return = returnFiber;
      return current;
    }

    function updateFragment(returnFiber, current, fragment, lanes, key) {
      if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current;
      current = useFiber(current, fragment);
      current.return = returnFiber;
      return current;
    }

    function createChild(returnFiber, newChild, lanes) {
      if ("string" === typeof newChild || "number" === typeof newChild) return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes), lanes.ref = coerceRef(returnFiber, null, newChild), lanes.return = returnFiber, lanes;

          case REACT_PORTAL_TYPE:
            return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;
        }

        if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newChild = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), newChild.return = returnFiber, newChild;
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      return null;
    }

    function updateSlot(returnFiber, oldFiber, newChild, lanes) {
      var key = null !== oldFiber ? oldFiber.key : null;
      if ("string" === typeof newChild || "number" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;

          case REACT_PORTAL_TYPE:
            return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
        }

        if (isArrayImpl(newChild) || getIteratorFn(newChild)) return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      return null;
    }

    function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
      if ("string" === typeof newChild || "number" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updateElement(returnFiber, existingChildren, newChild, lanes);

          case REACT_PORTAL_TYPE:
            return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
        }

        if (isArrayImpl(newChild) || getIteratorFn(newChild)) return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      return null;
    }

    function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
      for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);

        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }

        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }

      if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), resultingFirstChild;

      if (null === oldFiber) {
        for (; newIdx < newChildren.length; newIdx++) {
          oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
        }

        return resultingFirstChild;
      }

      for (oldFiber = mapRemainingChildren(returnFiber, oldFiber); newIdx < newChildren.length; newIdx++) {
        nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
      }

      shouldTrackSideEffects && oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
      return resultingFirstChild;
    }

    function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
      var iteratorFn = getIteratorFn(newChildrenIterable);
      if ("function" !== typeof iteratorFn) throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
      newChildrenIterable = iteratorFn.call(newChildrenIterable);
      if (null == newChildrenIterable) throw Error("An iterable object provided no iterator.");

      for (var previousNewFiber = iteratorFn = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildrenIterable.next(); null !== oldFiber && !step.done; newIdx++, step = newChildrenIterable.next()) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);

        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }

        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? iteratorFn = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }

      if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), iteratorFn;

      if (null === oldFiber) {
        for (; !step.done; newIdx++, step = newChildrenIterable.next()) {
          step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? iteratorFn = step : previousNewFiber.sibling = step, previousNewFiber = step);
        }

        return iteratorFn;
      }

      for (oldFiber = mapRemainingChildren(returnFiber, oldFiber); !step.done; newIdx++, step = newChildrenIterable.next()) {
        step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? iteratorFn = step : previousNewFiber.sibling = step, previousNewFiber = step);
      }

      shouldTrackSideEffects && oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
      return iteratorFn;
    }

    return function (returnFiber, currentFirstChild, newChild, lanes) {
      var isUnkeyedTopLevelFragment = "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key;
      isUnkeyedTopLevelFragment && (newChild = newChild.props.children);

      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            a: {
              var key = newChild.key;

              for (isUnkeyedTopLevelFragment = currentFirstChild; null !== isUnkeyedTopLevelFragment;) {
                if (isUnkeyedTopLevelFragment.key === key) {
                  key = newChild.type;

                  if (key === REACT_FRAGMENT_TYPE) {
                    if (7 === isUnkeyedTopLevelFragment.tag) {
                      deleteRemainingChildren(returnFiber, isUnkeyedTopLevelFragment.sibling);
                      currentFirstChild = useFiber(isUnkeyedTopLevelFragment, newChild.props.children);
                      currentFirstChild.return = returnFiber;
                      returnFiber = currentFirstChild;
                      break a;
                    }
                  } else if (isUnkeyedTopLevelFragment.elementType === key) {
                    deleteRemainingChildren(returnFiber, isUnkeyedTopLevelFragment.sibling);
                    currentFirstChild = useFiber(isUnkeyedTopLevelFragment, newChild.props);
                    currentFirstChild.ref = coerceRef(returnFiber, isUnkeyedTopLevelFragment, newChild);
                    currentFirstChild.return = returnFiber;
                    returnFiber = currentFirstChild;
                    break a;
                  }

                  deleteRemainingChildren(returnFiber, isUnkeyedTopLevelFragment);
                  break;
                } else deleteChild(returnFiber, isUnkeyedTopLevelFragment);

                isUnkeyedTopLevelFragment = isUnkeyedTopLevelFragment.sibling;
              }

              newChild.type === REACT_FRAGMENT_TYPE ? (currentFirstChild = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), currentFirstChild.return = returnFiber, returnFiber = currentFirstChild) : (lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes), lanes.ref = coerceRef(returnFiber, currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes);
            }

            return placeSingleChild(returnFiber);

          case REACT_PORTAL_TYPE:
            a: {
              for (isUnkeyedTopLevelFragment = newChild.key; null !== currentFirstChild;) {
                if (currentFirstChild.key === isUnkeyedTopLevelFragment) {
                  if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                    currentFirstChild = useFiber(currentFirstChild, newChild.children || []);
                    currentFirstChild.return = returnFiber;
                    returnFiber = currentFirstChild;
                    break a;
                  } else {
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  }
                } else deleteChild(returnFiber, currentFirstChild);
                currentFirstChild = currentFirstChild.sibling;
              }

              currentFirstChild = createFiberFromPortal(newChild, returnFiber.mode, lanes);
              currentFirstChild.return = returnFiber;
              returnFiber = currentFirstChild;
            }

            return placeSingleChild(returnFiber);
        }

        if (isArrayImpl(newChild)) return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
        if (getIteratorFn(newChild)) return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
        throwOnInvalidObjectType(returnFiber, newChild);
      }

      if ("string" === typeof newChild || "number" === typeof newChild) return newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), currentFirstChild = useFiber(currentFirstChild, newChild), currentFirstChild.return = returnFiber, returnFiber = currentFirstChild) : (deleteRemainingChildren(returnFiber, currentFirstChild), currentFirstChild = createFiberFromText(newChild, returnFiber.mode, lanes), currentFirstChild.return = returnFiber, returnFiber = currentFirstChild), placeSingleChild(returnFiber);
      if ("undefined" === typeof newChild && !isUnkeyedTopLevelFragment) switch (returnFiber.tag) {
        case 1:
        case 0:
        case 11:
        case 15:
          throw Error((getComponentNameFromFiber(returnFiber) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
      }
      return deleteRemainingChildren(returnFiber, currentFirstChild);
    };
  }

  var reconcileChildFibers = ChildReconciler(true),
      mountChildFibers = ChildReconciler(false),
      NO_CONTEXT = {},
      contextStackCursor$1 = createCursor(NO_CONTEXT),
      contextFiberStackCursor = createCursor(NO_CONTEXT),
      rootInstanceStackCursor = createCursor(NO_CONTEXT);

  function requiredContext(c) {
    if (c === NO_CONTEXT) throw Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
    return c;
  }

  function pushHostContainer(fiber, nextRootInstance) {
    push(rootInstanceStackCursor, nextRootInstance);
    push(contextFiberStackCursor, fiber);
    push(contextStackCursor$1, NO_CONTEXT);
    pop(contextStackCursor$1);
    push(contextStackCursor$1, {
      isInAParentText: false
    });
  }

  function popHostContainer() {
    pop(contextStackCursor$1);
    pop(contextFiberStackCursor);
    pop(rootInstanceStackCursor);
  }

  function pushHostContext(fiber) {
    requiredContext(rootInstanceStackCursor.current);
    var context = requiredContext(contextStackCursor$1.current);
    var JSCompiler_inline_result = fiber.type;
    JSCompiler_inline_result = "AndroidTextInput" === JSCompiler_inline_result || "RCTMultilineTextInputView" === JSCompiler_inline_result || "RCTSinglelineTextInputView" === JSCompiler_inline_result || "RCTText" === JSCompiler_inline_result || "RCTVirtualText" === JSCompiler_inline_result;
    JSCompiler_inline_result = context.isInAParentText !== JSCompiler_inline_result ? {
      isInAParentText: JSCompiler_inline_result
    } : context;
    context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor$1, JSCompiler_inline_result));
  }

  function popHostContext(fiber) {
    contextFiberStackCursor.current === fiber && (pop(contextStackCursor$1), pop(contextFiberStackCursor));
  }

  var suspenseStackCursor = createCursor(0);

  function findFirstSuspended(row) {
    for (var node = row; null !== node;) {
      if (13 === node.tag) {
        var state = node.memoizedState;
        if (null !== state && (null === state.dehydrated || shim$1() || shim$1())) return node;
      } else if (19 === node.tag && undefined !== node.memoizedProps.revealOrder) {
        if (0 !== (node.flags & 128)) return node;
      } else if (null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === row) break;

      for (; null === node.sibling;) {
        if (null === node.return || node.return === row) return null;
        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }

    return null;
  }

  var workInProgressSources = [];

  function resetWorkInProgressVersions() {
    for (var i = 0; i < workInProgressSources.length; i++) {
      workInProgressSources[i]._workInProgressVersionSecondary = null;
    }

    workInProgressSources.length = 0;
  }

  var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
      ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig,
      renderLanes = 0,
      currentlyRenderingFiber$1 = null,
      currentHook = null,
      workInProgressHook = null,
      didScheduleRenderPhaseUpdate = false,
      didScheduleRenderPhaseUpdateDuringThisPass = false;

  function throwInvalidHookError() {
    throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
  }

  function areHookInputsEqual(nextDeps, prevDeps) {
    if (null === prevDeps) return false;

    for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
      if (!objectIs(nextDeps[i], prevDeps[i])) return false;
    }

    return true;
  }

  function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
    renderLanes = nextRenderLanes;
    currentlyRenderingFiber$1 = workInProgress;
    workInProgress.memoizedState = null;
    workInProgress.updateQueue = null;
    workInProgress.lanes = 0;
    ReactCurrentDispatcher$1.current = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
    current = Component(props, secondArg);

    if (didScheduleRenderPhaseUpdateDuringThisPass) {
      nextRenderLanes = 0;

      do {
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        if (!(25 > nextRenderLanes)) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        nextRenderLanes += 1;
        workInProgressHook = currentHook = null;
        workInProgress.updateQueue = null;
        ReactCurrentDispatcher$1.current = HooksDispatcherOnRerender;
        current = Component(props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
    }

    ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
    workInProgress = null !== currentHook && null !== currentHook.next;
    renderLanes = 0;
    workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
    didScheduleRenderPhaseUpdate = false;
    if (workInProgress) throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
    return current;
  }

  function mountWorkInProgressHook() {
    var hook = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
    return workInProgressHook;
  }

  function updateWorkInProgressHook() {
    if (null === currentHook) {
      var nextCurrentHook = currentlyRenderingFiber$1.alternate;
      nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
    } else nextCurrentHook = currentHook.next;

    var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next;
    if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;else {
      if (null === nextCurrentHook) throw Error("Rendered more hooks than during the previous render.");
      currentHook = nextCurrentHook;
      nextCurrentHook = {
        memoizedState: currentHook.memoizedState,
        baseState: currentHook.baseState,
        baseQueue: currentHook.baseQueue,
        queue: currentHook.queue,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
    }
    return workInProgressHook;
  }

  function basicStateReducer(state, action) {
    return "function" === typeof action ? action(state) : action;
  }

  function updateReducer(reducer) {
    var hook = updateWorkInProgressHook(),
        queue = hook.queue;
    if (null === queue) throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
    queue.lastRenderedReducer = reducer;
    var current = currentHook,
        baseQueue = current.baseQueue,
        pendingQueue = queue.pending;

    if (null !== pendingQueue) {
      if (null !== baseQueue) {
        var baseFirst = baseQueue.next;
        baseQueue.next = pendingQueue.next;
        pendingQueue.next = baseFirst;
      }

      current.baseQueue = baseQueue = pendingQueue;
      queue.pending = null;
    }

    if (null !== baseQueue) {
      pendingQueue = baseQueue.next;
      current = current.baseState;
      var newBaseQueueFirst = baseFirst = null,
          newBaseQueueLast = null,
          update = pendingQueue;

      do {
        var updateLane = update.lane;
        if ((renderLanes & updateLane) === updateLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
          lane: 0,
          action: update.action,
          eagerReducer: update.eagerReducer,
          eagerState: update.eagerState,
          next: null
        }), current = update.eagerReducer === reducer ? update.eagerState : reducer(current, update.action);else {
          var clone = {
            lane: updateLane,
            action: update.action,
            eagerReducer: update.eagerReducer,
            eagerState: update.eagerState,
            next: null
          };
          null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = clone, baseFirst = current) : newBaseQueueLast = newBaseQueueLast.next = clone;
          currentlyRenderingFiber$1.lanes |= updateLane;
          workInProgressRootSkippedLanes |= updateLane;
        }
        update = update.next;
      } while (null !== update && update !== pendingQueue);

      null === newBaseQueueLast ? baseFirst = current : newBaseQueueLast.next = newBaseQueueFirst;
      objectIs(current, hook.memoizedState) || (didReceiveUpdate = true);
      hook.memoizedState = current;
      hook.baseState = baseFirst;
      hook.baseQueue = newBaseQueueLast;
      queue.lastRenderedState = current;
    }

    reducer = queue.interleaved;

    if (null !== reducer) {
      baseQueue = reducer;

      do {
        pendingQueue = baseQueue.lane, currentlyRenderingFiber$1.lanes |= pendingQueue, workInProgressRootSkippedLanes |= pendingQueue, baseQueue = baseQueue.next;
      } while (baseQueue !== reducer);
    } else null === baseQueue && (queue.lanes = 0);

    return [hook.memoizedState, queue.dispatch];
  }

  function rerenderReducer(reducer) {
    var hook = updateWorkInProgressHook(),
        queue = hook.queue;
    if (null === queue) throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
    queue.lastRenderedReducer = reducer;
    var dispatch = queue.dispatch,
        lastRenderPhaseUpdate = queue.pending,
        newState = hook.memoizedState;

    if (null !== lastRenderPhaseUpdate) {
      queue.pending = null;
      var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;

      do {
        newState = reducer(newState, update.action), update = update.next;
      } while (update !== lastRenderPhaseUpdate);

      objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
      hook.memoizedState = newState;
      null === hook.baseQueue && (hook.baseState = newState);
      queue.lastRenderedState = newState;
    }

    return [newState, dispatch];
  }

  function readFromUnsubcribedMutableSource(root, source, getSnapshot) {
    var getVersion = source._getVersion;
    getVersion = getVersion(source._source);
    var JSCompiler_inline_result = source._workInProgressVersionSecondary;
    if (null !== JSCompiler_inline_result) root = JSCompiler_inline_result === getVersion;else if (root = root.mutableReadLanes, root = (renderLanes & root) === root) source._workInProgressVersionSecondary = getVersion, workInProgressSources.push(source);
    if (root) return getSnapshot(source._source);
    workInProgressSources.push(source);
    throw Error("Cannot read from mutable source during the current render without tearing. This may be a bug in React. Please file an issue.");
  }

  function _useMutableSource(hook, source, getSnapshot, subscribe) {
    var root = workInProgressRoot;
    if (null === root) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");

    var getVersion = source._getVersion,
        version = getVersion(source._source),
        dispatcher = ReactCurrentDispatcher$1.current,
        _dispatcher$useState = dispatcher.useState(function () {
      return readFromUnsubcribedMutableSource(root, source, getSnapshot);
    }),
        setSnapshot = _dispatcher$useState[1],
        snapshot = _dispatcher$useState[0];

    _dispatcher$useState = workInProgressHook;
    var memoizedState = hook.memoizedState,
        refs = memoizedState.refs,
        prevGetSnapshot = refs.getSnapshot,
        prevSource = memoizedState.source;
    memoizedState = memoizedState.subscribe;
    var fiber = currentlyRenderingFiber$1;
    hook.memoizedState = {
      refs: refs,
      source: source,
      subscribe: subscribe
    };
    dispatcher.useEffect(function () {
      refs.getSnapshot = getSnapshot;
      refs.setSnapshot = setSnapshot;
      var maybeNewVersion = getVersion(source._source);
      objectIs(version, maybeNewVersion) || (maybeNewVersion = getSnapshot(source._source), objectIs(snapshot, maybeNewVersion) || (setSnapshot(maybeNewVersion), maybeNewVersion = requestUpdateLane(fiber), root.mutableReadLanes |= maybeNewVersion & root.pendingLanes), markRootEntangled(root, root.mutableReadLanes));
    }, [getSnapshot, source, subscribe]);
    dispatcher.useEffect(function () {
      return subscribe(source._source, function () {
        var latestGetSnapshot = refs.getSnapshot,
            latestSetSnapshot = refs.setSnapshot;

        try {
          latestSetSnapshot(latestGetSnapshot(source._source));
          var lane = requestUpdateLane(fiber);
          root.mutableReadLanes |= lane & root.pendingLanes;
        } catch (error) {
          latestSetSnapshot(function () {
            throw error;
          });
        }
      });
    }, [source, subscribe]);
    objectIs(prevGetSnapshot, getSnapshot) && objectIs(prevSource, source) && objectIs(memoizedState, subscribe) || (hook = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: snapshot
    }, hook.dispatch = setSnapshot = dispatchAction.bind(null, currentlyRenderingFiber$1, hook), _dispatcher$useState.queue = hook, _dispatcher$useState.baseQueue = null, snapshot = readFromUnsubcribedMutableSource(root, source, getSnapshot), _dispatcher$useState.memoizedState = _dispatcher$useState.baseState = snapshot);
    return snapshot;
  }

  function updateMutableSource(source, getSnapshot, subscribe) {
    var hook = updateWorkInProgressHook();
    return _useMutableSource(hook, source, getSnapshot, subscribe);
  }

  function mountState(initialState) {
    var hook = mountWorkInProgressHook();
    "function" === typeof initialState && (initialState = initialState());
    hook.memoizedState = hook.baseState = initialState;
    initialState = hook.queue = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: initialState
    };
    initialState = initialState.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, initialState);
    return [hook.memoizedState, initialState];
  }

  function pushEffect(tag, create, destroy, deps) {
    tag = {
      tag: tag,
      create: create,
      destroy: destroy,
      deps: deps,
      next: null
    };
    create = currentlyRenderingFiber$1.updateQueue;
    null === create ? (create = {
      lastEffect: null
    }, currentlyRenderingFiber$1.updateQueue = create, create.lastEffect = tag.next = tag) : (destroy = create.lastEffect, null === destroy ? create.lastEffect = tag.next = tag : (deps = destroy.next, destroy.next = tag, tag.next = deps, create.lastEffect = tag));
    return tag;
  }

  function updateRef() {
    return updateWorkInProgressHook().memoizedState;
  }

  function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
    var hook = mountWorkInProgressHook();
    currentlyRenderingFiber$1.flags |= fiberFlags;
    hook.memoizedState = pushEffect(1 | hookFlags, create, undefined, undefined === deps ? null : deps);
  }

  function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
    var hook = updateWorkInProgressHook();
    deps = undefined === deps ? null : deps;
    var destroy = undefined;

    if (null !== currentHook) {
      var prevEffect = currentHook.memoizedState;
      destroy = prevEffect.destroy;

      if (null !== deps && areHookInputsEqual(deps, prevEffect.deps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, deps);
        return;
      }
    }

    currentlyRenderingFiber$1.flags |= fiberFlags;
    hook.memoizedState = pushEffect(1 | hookFlags, create, destroy, deps);
  }

  function mountEffect(create, deps) {
    return mountEffectImpl(1049600, 4, create, deps);
  }

  function updateEffect(create, deps) {
    return updateEffectImpl(1024, 4, create, deps);
  }

  function updateLayoutEffect(create, deps) {
    return updateEffectImpl(4, 2, create, deps);
  }

  function imperativeHandleEffect(create, ref) {
    if ("function" === typeof ref) return create = create(), ref(create), function () {
      ref(null);
    };
    if (null !== ref && undefined !== ref) return create = create(), ref.current = create, function () {
      ref.current = null;
    };
  }

  function updateImperativeHandle(ref, create, deps) {
    deps = null !== deps && undefined !== deps ? deps.concat([ref]) : null;
    return updateEffectImpl(4, 2, imperativeHandleEffect.bind(null, create, ref), deps);
  }

  function mountDebugValue() {}

  function updateCallback(callback, deps) {
    var hook = updateWorkInProgressHook();
    deps = undefined === deps ? null : deps;
    var prevState = hook.memoizedState;
    if (null !== prevState && null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
    hook.memoizedState = [callback, deps];
    return callback;
  }

  function updateMemo(nextCreate, deps) {
    var hook = updateWorkInProgressHook();
    deps = undefined === deps ? null : deps;
    var prevState = hook.memoizedState;
    if (null !== prevState && null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
    nextCreate = nextCreate();
    hook.memoizedState = [nextCreate, deps];
    return nextCreate;
  }

  function startTransition(setPending, callback) {
    var previousPriority = currentUpdatePriority;
    currentUpdatePriority = 0 !== previousPriority && 4 > previousPriority ? previousPriority : 4;
    setPending(true);
    var prevTransition = ReactCurrentBatchConfig$1.transition;
    ReactCurrentBatchConfig$1.transition = 1;

    try {
      setPending(false), callback();
    } finally {
      currentUpdatePriority = previousPriority, ReactCurrentBatchConfig$1.transition = prevTransition;
    }
  }

  function dispatchAction(fiber, queue, action) {
    var eventTime = requestEventTime(),
        lane = requestUpdateLane(fiber),
        update = {
      lane: lane,
      action: action,
      eagerReducer: null,
      eagerState: null,
      next: null
    },
        alternate = fiber.alternate;
    if (fiber === currentlyRenderingFiber$1 || null !== alternate && alternate === currentlyRenderingFiber$1) didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true, lane = queue.pending, null === lane ? update.next = update : (update.next = lane.next, lane.next = update), queue.pending = update;else {
      if (null !== workInProgressRoot && 0 !== (fiber.mode & 1) && 0 === (executionContext & 8)) {
        var interleaved = queue.interleaved;
        null === interleaved ? (update.next = update, null === interleavedQueues ? interleavedQueues = [queue] : interleavedQueues.push(queue)) : (update.next = interleaved.next, interleaved.next = update);
        queue.interleaved = update;
      } else interleaved = queue.pending, null === interleaved ? update.next = update : (update.next = interleaved.next, interleaved.next = update), queue.pending = update;

      if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) try {
        var currentState = queue.lastRenderedState,
            eagerState = alternate(currentState, action);
        update.eagerReducer = alternate;
        update.eagerState = eagerState;
        if (objectIs(eagerState, currentState)) return;
      } catch (error) {} finally {}
      update = scheduleUpdateOnFiber(fiber, lane, eventTime);
      0 !== (lane & 4194240) && null !== update && (fiber = queue.lanes, fiber &= update.pendingLanes, lane |= fiber, queue.lanes = lane, markRootEntangled(update, lane));
    }
  }

  var ContextOnlyDispatcher = {
    readContext: readContext,
    useCallback: throwInvalidHookError,
    useContext: throwInvalidHookError,
    useEffect: throwInvalidHookError,
    useImperativeHandle: throwInvalidHookError,
    useLayoutEffect: throwInvalidHookError,
    useMemo: throwInvalidHookError,
    useReducer: throwInvalidHookError,
    useRef: throwInvalidHookError,
    useState: throwInvalidHookError,
    useDebugValue: throwInvalidHookError,
    useDeferredValue: throwInvalidHookError,
    useTransition: throwInvalidHookError,
    useMutableSource: throwInvalidHookError,
    useOpaqueIdentifier: throwInvalidHookError,
    unstable_isNewReconciler: false
  },
      HooksDispatcherOnMount = {
    readContext: readContext,
    useCallback: function useCallback(callback, deps) {
      mountWorkInProgressHook().memoizedState = [callback, undefined === deps ? null : deps];
      return callback;
    },
    useContext: readContext,
    useEffect: mountEffect,
    useImperativeHandle: function useImperativeHandle(ref, create, deps) {
      deps = null !== deps && undefined !== deps ? deps.concat([ref]) : null;
      return mountEffectImpl(4, 2, imperativeHandleEffect.bind(null, create, ref), deps);
    },
    useLayoutEffect: function useLayoutEffect(create, deps) {
      return mountEffectImpl(4, 2, create, deps);
    },
    useMemo: function useMemo(nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = undefined === deps ? null : deps;
      nextCreate = nextCreate();
      hook.memoizedState = [nextCreate, deps];
      return nextCreate;
    },
    useReducer: function useReducer(reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      initialArg = undefined !== init ? init(initialArg) : initialArg;
      hook.memoizedState = hook.baseState = initialArg;
      reducer = hook.queue = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialArg
      };
      reducer = reducer.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, reducer);
      return [hook.memoizedState, reducer];
    },
    useRef: function useRef(initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = {
        current: initialValue
      };
      return hook.memoizedState = initialValue;
    },
    useState: mountState,
    useDebugValue: mountDebugValue,
    useDeferredValue: function useDeferredValue(value) {
      var _mountState = mountState(value),
          prevValue = _mountState[0],
          setValue = _mountState[1];

      mountEffect(function () {
        var prevTransition = ReactCurrentBatchConfig$1.transition;
        ReactCurrentBatchConfig$1.transition = 1;

        try {
          setValue(value);
        } finally {
          ReactCurrentBatchConfig$1.transition = prevTransition;
        }
      }, [value]);
      return prevValue;
    },
    useTransition: function useTransition() {
      var _mountState2 = mountState(false),
          isPending = _mountState2[0];

      _mountState2 = startTransition.bind(null, _mountState2[1]);
      mountWorkInProgressHook().memoizedState = _mountState2;
      return [isPending, _mountState2];
    },
    useMutableSource: function useMutableSource(source, getSnapshot, subscribe) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = {
        refs: {
          getSnapshot: getSnapshot,
          setSnapshot: null
        },
        source: source,
        subscribe: subscribe
      };
      return _useMutableSource(hook, source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function useOpaqueIdentifier() {
      throw Error("Not yet implemented");
    },
    unstable_isNewReconciler: false
  },
      HooksDispatcherOnUpdate = {
    readContext: readContext,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: updateReducer,
    useRef: updateRef,
    useState: function useState() {
      return updateReducer(basicStateReducer);
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function useDeferredValue(value) {
      var _updateState = updateReducer(basicStateReducer),
          prevValue = _updateState[0],
          setValue = _updateState[1];

      updateEffect(function () {
        var prevTransition = ReactCurrentBatchConfig$1.transition;
        ReactCurrentBatchConfig$1.transition = 1;

        try {
          setValue(value);
        } finally {
          ReactCurrentBatchConfig$1.transition = prevTransition;
        }
      }, [value]);
      return prevValue;
    },
    useTransition: function useTransition() {
      var isPending = updateReducer(basicStateReducer)[0],
          start = updateWorkInProgressHook().memoizedState;
      return [isPending, start];
    },
    useMutableSource: updateMutableSource,
    useOpaqueIdentifier: function useOpaqueIdentifier() {
      return updateReducer(basicStateReducer)[0];
    },
    unstable_isNewReconciler: false
  },
      HooksDispatcherOnRerender = {
    readContext: readContext,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: rerenderReducer,
    useRef: updateRef,
    useState: function useState() {
      return rerenderReducer(basicStateReducer);
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function useDeferredValue(value) {
      var _rerenderState = rerenderReducer(basicStateReducer),
          prevValue = _rerenderState[0],
          setValue = _rerenderState[1];

      updateEffect(function () {
        var prevTransition = ReactCurrentBatchConfig$1.transition;
        ReactCurrentBatchConfig$1.transition = 1;

        try {
          setValue(value);
        } finally {
          ReactCurrentBatchConfig$1.transition = prevTransition;
        }
      }, [value]);
      return prevValue;
    },
    useTransition: function useTransition() {
      var isPending = rerenderReducer(basicStateReducer)[0],
          start = updateWorkInProgressHook().memoizedState;
      return [isPending, start];
    },
    useMutableSource: updateMutableSource,
    useOpaqueIdentifier: function useOpaqueIdentifier() {
      return rerenderReducer(basicStateReducer)[0];
    },
    unstable_isNewReconciler: false
  };

  function createCapturedValue(value, source) {
    try {
      var info = "",
          node = source;

      do {
        info += describeFiber(node), node = node.return;
      } while (node);

      var JSCompiler_inline_result = info;
    } catch (x) {
      JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
    }

    return {
      value: value,
      source: source,
      stack: JSCompiler_inline_result
    };
  }

  if ("function" !== typeof _$$_REQUIRE(_dependencyMap[3]).ReactFiberErrorDialog.showErrorDialog) throw Error("Expected ReactFiberErrorDialog.showErrorDialog to be a function.");

  function logCapturedError(boundary, errorInfo) {
    try {
      false !== _$$_REQUIRE(_dependencyMap[3]).ReactFiberErrorDialog.showErrorDialog({
        componentStack: null !== errorInfo.stack ? errorInfo.stack : "",
        error: errorInfo.value,
        errorBoundary: null !== boundary && 1 === boundary.tag ? boundary.stateNode : null
      }) && console.error(errorInfo.value);
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }

  var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;

  function createRootErrorUpdate(fiber, errorInfo, lane) {
    lane = createUpdate(-1, lane);
    lane.tag = 3;
    lane.payload = {
      element: null
    };
    var error = errorInfo.value;

    lane.callback = function () {
      hasUncaughtError || (hasUncaughtError = true, firstUncaughtError = error);
      logCapturedError(fiber, errorInfo);
    };

    return lane;
  }

  function createClassErrorUpdate(fiber, errorInfo, lane) {
    lane = createUpdate(-1, lane);
    lane.tag = 3;
    var getDerivedStateFromError = fiber.type.getDerivedStateFromError;

    if ("function" === typeof getDerivedStateFromError) {
      var error = errorInfo.value;

      lane.payload = function () {
        logCapturedError(fiber, errorInfo);
        return getDerivedStateFromError(error);
      };
    }

    var inst = fiber.stateNode;
    null !== inst && "function" === typeof inst.componentDidCatch && (lane.callback = function () {
      "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this), logCapturedError(fiber, errorInfo));
      var stack = errorInfo.stack;
      this.componentDidCatch(errorInfo.value, {
        componentStack: null !== stack ? stack : ""
      });
    });
    return lane;
  }

  var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner,
      didReceiveUpdate = false;

  function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
    workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
  }

  function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
    Component = Component.render;
    var ref = workInProgress.ref;
    prepareToReadContext(workInProgress, renderLanes);
    nextProps = renderWithHooks(current, workInProgress, Component, nextProps, ref, renderLanes);
    if (null !== current && !didReceiveUpdate) return workInProgress.updateQueue = current.updateQueue, workInProgress.flags &= -1029, current.lanes &= ~renderLanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    workInProgress.flags |= 1;
    reconcileChildren(current, workInProgress, nextProps, renderLanes);
    return workInProgress.child;
  }

  function updateMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {
    if (null === current) {
      var type = Component.type;
      if ("function" === typeof type && !shouldConstruct(type) && undefined === type.defaultProps && null === Component.compare && undefined === Component.defaultProps) return workInProgress.tag = 15, workInProgress.type = type, updateSimpleMemoComponent(current, workInProgress, type, nextProps, updateLanes, renderLanes);
      current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
      current.ref = workInProgress.ref;
      current.return = workInProgress;
      return workInProgress.child = current;
    }

    type = current.child;
    if (0 === (updateLanes & renderLanes) && (updateLanes = type.memoizedProps, Component = Component.compare, Component = null !== Component ? Component : shallowEqual, Component(updateLanes, nextProps) && current.ref === workInProgress.ref)) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    workInProgress.flags |= 1;
    current = createWorkInProgress(type, nextProps);
    current.ref = workInProgress.ref;
    current.return = workInProgress;
    return workInProgress.child = current;
  }

  function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {
    if (null !== current && shallowEqual(current.memoizedProps, nextProps) && current.ref === workInProgress.ref) {
      didReceiveUpdate = false;
      if (0 === (renderLanes & updateLanes)) return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      0 !== (current.flags & 32768) && (didReceiveUpdate = true);
    }

    return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
  }

  function updateOffscreenComponent(current, workInProgress, renderLanes) {
    var nextProps = workInProgress.pendingProps,
        nextChildren = nextProps.children,
        prevState = null !== current ? current.memoizedState : null;
    if ("hidden" === nextProps.mode || "unstable-defer-without-hiding" === nextProps.mode) {
      if (0 === (workInProgress.mode & 1)) workInProgress.memoizedState = {
        baseLanes: 0,
        cachePool: null
      }, push(subtreeRenderLanesCursor, subtreeRenderLanes), subtreeRenderLanes |= renderLanes;else {
        if (0 === (renderLanes & 1073741824)) return current = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, workInProgress.lanes = workInProgress.childLanes = 1073741824, workInProgress.memoizedState = {
          baseLanes: current,
          cachePool: null
        }, workInProgress.updateQueue = null, push(subtreeRenderLanesCursor, subtreeRenderLanes), subtreeRenderLanes |= current, null;
        workInProgress.memoizedState = {
          baseLanes: 0,
          cachePool: null
        };
        nextProps = null !== prevState ? prevState.baseLanes : renderLanes;
        push(subtreeRenderLanesCursor, subtreeRenderLanes);
        subtreeRenderLanes |= nextProps;
      }
    } else null !== prevState ? (nextProps = prevState.baseLanes | renderLanes, workInProgress.memoizedState = null) : nextProps = renderLanes, push(subtreeRenderLanesCursor, subtreeRenderLanes), subtreeRenderLanes |= nextProps;
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    return workInProgress.child;
  }

  function markRef(current, workInProgress) {
    var ref = workInProgress.ref;
    if (null === current && null !== ref || null !== current && current.ref !== ref) workInProgress.flags |= 256;
  }

  function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
    var context = isContextProvider(Component) ? previousContext : contextStackCursor.current;
    context = getMaskedContext(workInProgress, context);
    prepareToReadContext(workInProgress, renderLanes);
    Component = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);
    if (null !== current && !didReceiveUpdate) return workInProgress.updateQueue = current.updateQueue, workInProgress.flags &= -1029, current.lanes &= ~renderLanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    workInProgress.flags |= 1;
    reconcileChildren(current, workInProgress, Component, renderLanes);
    return workInProgress.child;
  }

  function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
    if (isContextProvider(Component)) {
      var hasContext = true;
      pushContextProvider(workInProgress);
    } else hasContext = false;

    prepareToReadContext(workInProgress, renderLanes);
    if (null === workInProgress.stateNode) null !== current && (current.alternate = null, workInProgress.alternate = null, workInProgress.flags |= 2), constructClassInstance(workInProgress, Component, nextProps), mountClassInstance(workInProgress, Component, nextProps, renderLanes), nextProps = true;else if (null === current) {
      var instance = workInProgress.stateNode,
          oldProps = workInProgress.memoizedProps;
      instance.props = oldProps;
      var oldContext = instance.context,
          contextType = Component.contextType;
      "object" === typeof contextType && null !== contextType ? contextType = readContext(contextType) : (contextType = isContextProvider(Component) ? previousContext : contextStackCursor.current, contextType = getMaskedContext(workInProgress, contextType));
      var getDerivedStateFromProps = Component.getDerivedStateFromProps,
          hasNewLifecycles = "function" === typeof getDerivedStateFromProps || "function" === typeof instance.getSnapshotBeforeUpdate;
      hasNewLifecycles || "function" !== typeof instance.UNSAFE_componentWillReceiveProps && "function" !== typeof instance.componentWillReceiveProps || (oldProps !== nextProps || oldContext !== contextType) && callComponentWillReceiveProps(workInProgress, instance, nextProps, contextType);
      hasForceUpdate = false;
      var oldState = workInProgress.memoizedState;
      instance.state = oldState;
      processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
      oldContext = workInProgress.memoizedState;
      oldProps !== nextProps || oldState !== oldContext || didPerformWorkStackCursor.current || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, nextProps), oldContext = workInProgress.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, oldProps, nextProps, oldState, oldContext, contextType)) ? (hasNewLifecycles || "function" !== typeof instance.UNSAFE_componentWillMount && "function" !== typeof instance.componentWillMount || ("function" === typeof instance.componentWillMount && instance.componentWillMount(), "function" === typeof instance.UNSAFE_componentWillMount && instance.UNSAFE_componentWillMount()), "function" === typeof instance.componentDidMount && (workInProgress.flags |= 4)) : ("function" === typeof instance.componentDidMount && (workInProgress.flags |= 4), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), instance.props = nextProps, instance.state = oldContext, instance.context = contextType, nextProps = oldProps) : ("function" === typeof instance.componentDidMount && (workInProgress.flags |= 4), nextProps = false);
    } else {
      instance = workInProgress.stateNode;
      cloneUpdateQueue(current, workInProgress);
      oldProps = workInProgress.memoizedProps;
      contextType = workInProgress.type === workInProgress.elementType ? oldProps : resolveDefaultProps(workInProgress.type, oldProps);
      instance.props = contextType;
      hasNewLifecycles = workInProgress.pendingProps;
      oldState = instance.context;
      oldContext = Component.contextType;
      "object" === typeof oldContext && null !== oldContext ? oldContext = readContext(oldContext) : (oldContext = isContextProvider(Component) ? previousContext : contextStackCursor.current, oldContext = getMaskedContext(workInProgress, oldContext));
      var getDerivedStateFromProps$jscomp$0 = Component.getDerivedStateFromProps;
      (getDerivedStateFromProps = "function" === typeof getDerivedStateFromProps$jscomp$0 || "function" === typeof instance.getSnapshotBeforeUpdate) || "function" !== typeof instance.UNSAFE_componentWillReceiveProps && "function" !== typeof instance.componentWillReceiveProps || (oldProps !== hasNewLifecycles || oldState !== oldContext) && callComponentWillReceiveProps(workInProgress, instance, nextProps, oldContext);
      hasForceUpdate = false;
      oldState = workInProgress.memoizedState;
      instance.state = oldState;
      processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
      var newState = workInProgress.memoizedState;
      oldProps !== hasNewLifecycles || oldState !== newState || didPerformWorkStackCursor.current || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps$jscomp$0 && (applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps$jscomp$0, nextProps), newState = workInProgress.memoizedState), (contextType = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, contextType, nextProps, oldState, newState, oldContext) || false) ? (getDerivedStateFromProps || "function" !== typeof instance.UNSAFE_componentWillUpdate && "function" !== typeof instance.componentWillUpdate || ("function" === typeof instance.componentWillUpdate && instance.componentWillUpdate(nextProps, newState, oldContext), "function" === typeof instance.UNSAFE_componentWillUpdate && instance.UNSAFE_componentWillUpdate(nextProps, newState, oldContext)), "function" === typeof instance.componentDidUpdate && (workInProgress.flags |= 4), "function" === typeof instance.getSnapshotBeforeUpdate && (workInProgress.flags |= 512)) : ("function" !== typeof instance.componentDidUpdate || oldProps === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), "function" !== typeof instance.getSnapshotBeforeUpdate || oldProps === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 512), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), instance.props = nextProps, instance.state = newState, instance.context = oldContext, nextProps = contextType) : ("function" !== typeof instance.componentDidUpdate || oldProps === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), "function" !== typeof instance.getSnapshotBeforeUpdate || oldProps === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 512), nextProps = false);
    }
    return finishClassComponent(current, workInProgress, Component, nextProps, hasContext, renderLanes);
  }

  function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {
    markRef(current, workInProgress);
    var didCaptureError = 0 !== (workInProgress.flags & 128);
    if (!shouldUpdate && !didCaptureError) return hasContext && invalidateContextProvider(workInProgress, Component, false), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    shouldUpdate = workInProgress.stateNode;
    ReactCurrentOwner$1.current = workInProgress;
    var nextChildren = didCaptureError && "function" !== typeof Component.getDerivedStateFromError ? null : shouldUpdate.render();
    workInProgress.flags |= 1;
    null !== current && didCaptureError ? (workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes)) : reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    workInProgress.memoizedState = shouldUpdate.state;
    hasContext && invalidateContextProvider(workInProgress, Component, true);
    return workInProgress.child;
  }

  function pushHostRootContext(workInProgress) {
    var root = workInProgress.stateNode;
    root.pendingContext ? pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context) : root.context && pushTopLevelContextObject(workInProgress, root.context, false);
    pushHostContainer(workInProgress, root.containerInfo);
  }

  var SUSPENDED_MARKER = {
    dehydrated: null,
    retryLane: 0
  };

  function mountSuspenseOffscreenState(renderLanes) {
    return {
      baseLanes: renderLanes,
      cachePool: null
    };
  }

  function updateSuspenseComponent(current, workInProgress, renderLanes) {
    var nextProps = workInProgress.pendingProps,
        suspenseContext = suspenseStackCursor.current,
        showFallback = false,
        JSCompiler_temp;
    (JSCompiler_temp = 0 !== (workInProgress.flags & 128)) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseContext & 2));
    JSCompiler_temp ? (showFallback = true, workInProgress.flags &= -129) : null !== current && null === current.memoizedState || undefined === nextProps.fallback || true === nextProps.unstable_avoidThisFallback || (suspenseContext |= 1);
    push(suspenseStackCursor, suspenseContext & 1);

    if (null === current) {
      current = nextProps.children;
      suspenseContext = nextProps.fallback;
      if (showFallback) return current = mountSuspenseFallbackChildren(workInProgress, current, suspenseContext, renderLanes), workInProgress.child.memoizedState = mountSuspenseOffscreenState(renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, current;
      if ("number" === typeof nextProps.unstable_expectedLoadTime) return current = mountSuspenseFallbackChildren(workInProgress, current, suspenseContext, renderLanes), workInProgress.child.memoizedState = mountSuspenseOffscreenState(renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress.lanes = 4194304, current;
      renderLanes = createFiberFromOffscreen({
        mode: "visible",
        children: current
      }, workInProgress.mode, renderLanes, null);
      renderLanes.return = workInProgress;
      return workInProgress.child = renderLanes;
    }

    if (null !== current.memoizedState) {
      if (showFallback) return nextProps = updateSuspenseFallbackChildren(current, workInProgress, nextProps.children, nextProps.fallback, renderLanes), showFallback = workInProgress.child, suspenseContext = current.child.memoizedState, showFallback.memoizedState = null === suspenseContext ? mountSuspenseOffscreenState(renderLanes) : {
        baseLanes: suspenseContext.baseLanes | renderLanes,
        cachePool: null
      }, showFallback.childLanes = current.childLanes & ~renderLanes, workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;
      renderLanes = updateSuspensePrimaryChildren(current, workInProgress, nextProps.children, renderLanes);
      workInProgress.memoizedState = null;
      return renderLanes;
    }

    if (showFallback) return nextProps = updateSuspenseFallbackChildren(current, workInProgress, nextProps.children, nextProps.fallback, renderLanes), showFallback = workInProgress.child, suspenseContext = current.child.memoizedState, showFallback.memoizedState = null === suspenseContext ? mountSuspenseOffscreenState(renderLanes) : {
      baseLanes: suspenseContext.baseLanes | renderLanes,
      cachePool: null
    }, showFallback.childLanes = current.childLanes & ~renderLanes, workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;
    renderLanes = updateSuspensePrimaryChildren(current, workInProgress, nextProps.children, renderLanes);
    workInProgress.memoizedState = null;
    return renderLanes;
  }

  function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {
    var mode = workInProgress.mode,
        progressedPrimaryFragment = workInProgress.child;
    primaryChildren = {
      mode: "hidden",
      children: primaryChildren
    };
    0 === (mode & 1) && null !== progressedPrimaryFragment ? (progressedPrimaryFragment.childLanes = 0, progressedPrimaryFragment.pendingProps = primaryChildren) : progressedPrimaryFragment = createFiberFromOffscreen(primaryChildren, mode, 0, null);
    fallbackChildren = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
    progressedPrimaryFragment.return = workInProgress;
    fallbackChildren.return = workInProgress;
    progressedPrimaryFragment.sibling = fallbackChildren;
    workInProgress.child = progressedPrimaryFragment;
    return fallbackChildren;
  }

  function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {
    var currentPrimaryChildFragment = current.child;
    current = currentPrimaryChildFragment.sibling;
    primaryChildren = createWorkInProgress(currentPrimaryChildFragment, {
      mode: "visible",
      children: primaryChildren
    });
    0 === (workInProgress.mode & 1) && (primaryChildren.lanes = renderLanes);
    primaryChildren.return = workInProgress;
    primaryChildren.sibling = null;
    null !== current && (renderLanes = workInProgress.deletions, null === renderLanes ? (workInProgress.deletions = [current], workInProgress.flags |= 16) : renderLanes.push(current));
    return workInProgress.child = primaryChildren;
  }

  function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {
    var mode = workInProgress.mode;
    current = current.child;
    var currentFallbackChildFragment = current.sibling,
        primaryChildProps = {
      mode: "hidden",
      children: primaryChildren
    };
    0 === (mode & 1) && workInProgress.child !== current ? (primaryChildren = workInProgress.child, primaryChildren.childLanes = 0, primaryChildren.pendingProps = primaryChildProps, workInProgress.deletions = null) : (primaryChildren = createWorkInProgress(current, primaryChildProps), primaryChildren.subtreeFlags = current.subtreeFlags & 1835008);
    null !== currentFallbackChildFragment ? fallbackChildren = createWorkInProgress(currentFallbackChildFragment, fallbackChildren) : (fallbackChildren = createFiberFromFragment(fallbackChildren, mode, renderLanes, null), fallbackChildren.flags |= 2);
    fallbackChildren.return = workInProgress;
    primaryChildren.return = workInProgress;
    primaryChildren.sibling = fallbackChildren;
    workInProgress.child = primaryChildren;
    return fallbackChildren;
  }

  function scheduleWorkOnFiber(fiber, renderLanes) {
    fiber.lanes |= renderLanes;
    var alternate = fiber.alternate;
    null !== alternate && (alternate.lanes |= renderLanes);
    scheduleWorkOnParentPath(fiber.return, renderLanes);
  }

  function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {
    var renderState = workInProgress.memoizedState;
    null === renderState ? workInProgress.memoizedState = {
      isBackwards: isBackwards,
      rendering: null,
      renderingStartTime: 0,
      last: lastContentRow,
      tail: tail,
      tailMode: tailMode
    } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
  }

  function updateSuspenseListComponent(current, workInProgress, renderLanes) {
    var nextProps = workInProgress.pendingProps,
        revealOrder = nextProps.revealOrder,
        tailMode = nextProps.tail;
    reconcileChildren(current, workInProgress, nextProps.children, renderLanes);
    nextProps = suspenseStackCursor.current;
    if (0 !== (nextProps & 2)) nextProps = nextProps & 1 | 2, workInProgress.flags |= 128;else {
      if (null !== current && 0 !== (current.flags & 128)) a: for (current = workInProgress.child; null !== current;) {
        if (13 === current.tag) null !== current.memoizedState && scheduleWorkOnFiber(current, renderLanes);else if (19 === current.tag) scheduleWorkOnFiber(current, renderLanes);else if (null !== current.child) {
          current.child.return = current;
          current = current.child;
          continue;
        }
        if (current === workInProgress) break a;

        for (; null === current.sibling;) {
          if (null === current.return || current.return === workInProgress) break a;
          current = current.return;
        }

        current.sibling.return = current.return;
        current = current.sibling;
      }
      nextProps &= 1;
    }
    push(suspenseStackCursor, nextProps);
    if (0 === (workInProgress.mode & 1)) workInProgress.memoizedState = null;else switch (revealOrder) {
      case "forwards":
        renderLanes = workInProgress.child;

        for (revealOrder = null; null !== renderLanes;) {
          current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;
        }

        renderLanes = revealOrder;
        null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);
        initSuspenseListRenderState(workInProgress, false, revealOrder, renderLanes, tailMode);
        break;

      case "backwards":
        renderLanes = null;
        revealOrder = workInProgress.child;

        for (workInProgress.child = null; null !== revealOrder;) {
          current = revealOrder.alternate;

          if (null !== current && null === findFirstSuspended(current)) {
            workInProgress.child = revealOrder;
            break;
          }

          current = revealOrder.sibling;
          revealOrder.sibling = renderLanes;
          renderLanes = revealOrder;
          revealOrder = current;
        }

        initSuspenseListRenderState(workInProgress, true, renderLanes, null, tailMode);
        break;

      case "together":
        initSuspenseListRenderState(workInProgress, false, null, null, undefined);
        break;

      default:
        workInProgress.memoizedState = null;
    }
    return workInProgress.child;
  }

  function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
    null !== current && (workInProgress.dependencies = current.dependencies);
    workInProgressRootSkippedLanes |= workInProgress.lanes;
    if (0 === (renderLanes & workInProgress.childLanes)) return null;
    if (null !== current && workInProgress.child !== current.child) throw Error("Resuming work not yet implemented.");

    if (null !== workInProgress.child) {
      current = workInProgress.child;
      renderLanes = createWorkInProgress(current, current.pendingProps);
      workInProgress.child = renderLanes;

      for (renderLanes.return = workInProgress; null !== current.sibling;) {
        current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;
      }

      renderLanes.sibling = null;
    }

    return workInProgress.child;
  }

  function hadNoMutationsEffects(current, completedWork) {
    if (null !== current && current.child === completedWork.child) return true;
    if (0 !== (completedWork.flags & 16)) return false;

    for (current = completedWork.child; null !== current;) {
      if (0 !== (current.flags & 6454) || 0 !== (current.subtreeFlags & 6454)) return false;
      current = current.sibling;
    }

    return true;
  }

  var _appendAllChildren, updateHostContainer, updateHostComponent$1, updateHostText$1;

  _appendAllChildren = function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {
    for (var node = workInProgress.child; null !== node;) {
      if (5 === node.tag) {
        var instance = node.stateNode;
        needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance));
        appendChildNode(parent.node, instance.node);
      } else if (6 === node.tag) {
        instance = node.stateNode;
        if (needsVisibilityToggle && isHidden) throw Error("Not yet implemented.");
        appendChildNode(parent.node, instance.node);
      } else if (4 !== node.tag) {
        if (13 === node.tag && 0 !== (node.flags & 4) && (instance = null !== node.memoizedState)) {
          var primaryChildParent = node.child;

          if (null !== primaryChildParent && (null !== primaryChildParent.child && (primaryChildParent.child.return = primaryChildParent, _appendAllChildren(parent, primaryChildParent, true, instance)), instance = primaryChildParent.sibling, null !== instance)) {
            instance.return = node;
            node = instance;
            continue;
          }
        }

        if (null !== node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
      }

      if (node === workInProgress) break;

      for (; null === node.sibling;) {
        if (null === node.return || node.return === workInProgress) return;
        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  };

  function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {
    for (var node = workInProgress.child; null !== node;) {
      if (5 === node.tag) {
        var instance = node.stateNode;
        needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance));
        appendChildNodeToSet(containerChildSet, instance.node);
      } else if (6 === node.tag) {
        instance = node.stateNode;
        if (needsVisibilityToggle && isHidden) throw Error("Not yet implemented.");
        appendChildNodeToSet(containerChildSet, instance.node);
      } else if (4 !== node.tag) {
        if (13 === node.tag && 0 !== (node.flags & 4) && (instance = null !== node.memoizedState)) {
          var primaryChildParent = node.child;

          if (null !== primaryChildParent && (null !== primaryChildParent.child && (primaryChildParent.child.return = primaryChildParent, appendAllChildrenToContainer(containerChildSet, primaryChildParent, true, instance)), instance = primaryChildParent.sibling, null !== instance)) {
            instance.return = node;
            node = instance;
            continue;
          }
        }

        if (null !== node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
      }

      if (node === workInProgress) break;

      for (; null === node.sibling;) {
        if (null === node.return || node.return === workInProgress) return;
        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  }

  updateHostContainer = function updateHostContainer(current, workInProgress) {
    var portalOrRoot = workInProgress.stateNode;

    if (!hadNoMutationsEffects(current, workInProgress)) {
      current = portalOrRoot.containerInfo;
      var newChildSet = createChildNodeSet(current);
      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);
      portalOrRoot.pendingChildren = newChildSet;
      workInProgress.flags |= 4;
      completeRoot(current, newChildSet);
    }
  };

  updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps) {
    type = current.stateNode;
    var oldProps = current.memoizedProps;
    if ((current = hadNoMutationsEffects(current, workInProgress)) && oldProps === newProps) workInProgress.stateNode = type;else {
      var recyclableInstance = workInProgress.stateNode;
      requiredContext(contextStackCursor$1.current);
      var updatePayload = null;
      oldProps !== newProps && (oldProps = diffProperties(null, oldProps, newProps, recyclableInstance.canonical.viewConfig.validAttributes), recyclableInstance.canonical.currentProps = newProps, updatePayload = oldProps);
      current && null === updatePayload ? workInProgress.stateNode = type : (newProps = updatePayload, oldProps = type.node, type = {
        node: current ? null !== newProps ? cloneNodeWithNewProps(oldProps, newProps) : cloneNode(oldProps) : null !== newProps ? cloneNodeWithNewChildrenAndProps(oldProps, newProps) : cloneNodeWithNewChildren(oldProps),
        canonical: type.canonical
      }, workInProgress.stateNode = type, current ? workInProgress.flags |= 4 : _appendAllChildren(type, workInProgress, false, false));
    }
  };

  updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
    oldText !== newText ? (current = requiredContext(rootInstanceStackCursor.current), oldText = requiredContext(contextStackCursor$1.current), workInProgress.stateNode = createTextInstance(newText, current, oldText, workInProgress), workInProgress.flags |= 4) : workInProgress.stateNode = current.stateNode;
  };

  function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
    switch (renderState.tailMode) {
      case "hidden":
        hasRenderedATailFallback = renderState.tail;

        for (var lastTailNode = null; null !== hasRenderedATailFallback;) {
          null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
        }

        null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
        break;

      case "collapsed":
        lastTailNode = renderState.tail;

        for (var lastTailNode$69 = null; null !== lastTailNode;) {
          null !== lastTailNode.alternate && (lastTailNode$69 = lastTailNode), lastTailNode = lastTailNode.sibling;
        }

        null === lastTailNode$69 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$69.sibling = null;
    }
  }

  function bubbleProperties(completedWork) {
    var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child,
        newChildLanes = 0,
        subtreeFlags = 0;
    if (didBailout) for (var child$70 = completedWork.child; null !== child$70;) {
      newChildLanes |= child$70.lanes | child$70.childLanes, subtreeFlags |= child$70.subtreeFlags & 1835008, subtreeFlags |= child$70.flags & 1835008, child$70.return = completedWork, child$70 = child$70.sibling;
    } else for (child$70 = completedWork.child; null !== child$70;) {
      newChildLanes |= child$70.lanes | child$70.childLanes, subtreeFlags |= child$70.subtreeFlags, subtreeFlags |= child$70.flags, child$70.return = completedWork, child$70 = child$70.sibling;
    }
    completedWork.subtreeFlags |= subtreeFlags;
    completedWork.childLanes = newChildLanes;
    return didBailout;
  }

  function completeWork(current, workInProgress, renderLanes) {
    var newProps = workInProgress.pendingProps;

    switch (workInProgress.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return bubbleProperties(workInProgress), null;

      case 1:
        return isContextProvider(workInProgress.type) && popContext(), bubbleProperties(workInProgress), null;

      case 3:
        return newProps = workInProgress.stateNode, popHostContainer(), pop(didPerformWorkStackCursor), pop(contextStackCursor), resetWorkInProgressVersions(), newProps.pendingContext && (newProps.context = newProps.pendingContext, newProps.pendingContext = null), null !== current && null !== current.child || newProps.hydrate || (workInProgress.flags |= 512), updateHostContainer(current, workInProgress), bubbleProperties(workInProgress), null;

      case 5:
        popHostContext(workInProgress);
        renderLanes = requiredContext(rootInstanceStackCursor.current);
        var type = workInProgress.type;
        if (null !== current && null != workInProgress.stateNode) updateHostComponent$1(current, workInProgress, type, newProps, renderLanes), current.ref !== workInProgress.ref && (workInProgress.flags |= 256);else {
          if (!newProps) {
            if (null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            bubbleProperties(workInProgress);
            return null;
          }

          requiredContext(contextStackCursor$1.current);
          current = nextReactTag;
          nextReactTag += 2;
          type = getViewConfigForType(type);
          var updatePayload = diffProperties(null, emptyObject, newProps, type.validAttributes);
          renderLanes = createNode(current, type.uiViewClassName, renderLanes, updatePayload, workInProgress);
          current = new ReactFabricHostComponent(current, type, newProps, workInProgress);
          current = {
            node: renderLanes,
            canonical: current
          };

          _appendAllChildren(current, workInProgress, false, false);

          workInProgress.stateNode = current;
          null !== workInProgress.ref && (workInProgress.flags |= 256);
        }
        bubbleProperties(workInProgress);
        return null;

      case 6:
        if (current && null != workInProgress.stateNode) updateHostText$1(current, workInProgress, current.memoizedProps, newProps);else {
          if ("string" !== typeof newProps && null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
          current = requiredContext(rootInstanceStackCursor.current);
          renderLanes = requiredContext(contextStackCursor$1.current);
          workInProgress.stateNode = createTextInstance(newProps, current, renderLanes, workInProgress);
        }
        bubbleProperties(workInProgress);
        return null;

      case 13:
        pop(suspenseStackCursor);
        newProps = workInProgress.memoizedState;
        if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, workInProgress;
        newProps = null !== newProps;
        renderLanes = false;
        null !== current && (renderLanes = null !== current.memoizedState);
        if (newProps && !renderLanes && 0 !== (workInProgress.mode & 1)) if (null === current && true !== workInProgress.memoizedProps.unstable_avoidThisFallback || 0 !== (suspenseStackCursor.current & 1)) 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3);else {
          if (0 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus) workInProgressRootExitStatus = 4;
          null === workInProgressRoot || 0 === (workInProgressRootSkippedLanes & 268435455) && 0 === (workInProgressRootUpdatedLanes & 268435455) || markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
        }
        newProps && (workInProgress.flags |= 4);
        bubbleProperties(workInProgress);
        return null;

      case 4:
        return popHostContainer(), updateHostContainer(current, workInProgress), bubbleProperties(workInProgress), null;

      case 10:
        return popProvider(workInProgress.type._context), bubbleProperties(workInProgress), null;

      case 17:
        return isContextProvider(workInProgress.type) && popContext(), bubbleProperties(workInProgress), null;

      case 19:
        pop(suspenseStackCursor);
        type = workInProgress.memoizedState;
        if (null === type) return bubbleProperties(workInProgress), null;
        newProps = 0 !== (workInProgress.flags & 128);
        updatePayload = type.rendering;
        if (null === updatePayload) {
          if (newProps) cutOffTailIfNeeded(type, false);else {
            if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128)) for (current = workInProgress.child; null !== current;) {
              updatePayload = findFirstSuspended(current);

              if (null !== updatePayload) {
                workInProgress.flags |= 128;
                cutOffTailIfNeeded(type, false);
                current = updatePayload.updateQueue;
                null !== current && (workInProgress.updateQueue = current, workInProgress.flags |= 4);
                workInProgress.subtreeFlags = 0;
                current = renderLanes;

                for (newProps = workInProgress.child; null !== newProps;) {
                  renderLanes = newProps, type = current, renderLanes.flags &= 1835010, updatePayload = renderLanes.alternate, null === updatePayload ? (renderLanes.childLanes = 0, renderLanes.lanes = type, renderLanes.child = null, renderLanes.subtreeFlags = 0, renderLanes.memoizedProps = null, renderLanes.memoizedState = null, renderLanes.updateQueue = null, renderLanes.dependencies = null, renderLanes.stateNode = null) : (renderLanes.childLanes = updatePayload.childLanes, renderLanes.lanes = updatePayload.lanes, renderLanes.child = updatePayload.child, renderLanes.subtreeFlags = 0, renderLanes.deletions = null, renderLanes.memoizedProps = updatePayload.memoizedProps, renderLanes.memoizedState = updatePayload.memoizedState, renderLanes.updateQueue = updatePayload.updateQueue, renderLanes.type = updatePayload.type, type = updatePayload.dependencies, renderLanes.dependencies = null === type ? null : {
                    lanes: type.lanes,
                    firstContext: type.firstContext
                  }), newProps = newProps.sibling;
                }

                push(suspenseStackCursor, suspenseStackCursor.current & 1 | 2);
                return workInProgress.child;
              }

              current = current.sibling;
            }
            null !== type.tail && _$$_REQUIRE(_dependencyMap[4]).unstable_now() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress.lanes = 4194304);
          }
        } else {
          if (!newProps) if (current = findFirstSuspended(updatePayload), null !== current) {
            if (workInProgress.flags |= 128, newProps = true, current = current.updateQueue, null !== current && (workInProgress.updateQueue = current, workInProgress.flags |= 4), cutOffTailIfNeeded(type, true), null === type.tail && "hidden" === type.tailMode && !updatePayload.alternate) return bubbleProperties(workInProgress), null;
          } else 2 * _$$_REQUIRE(_dependencyMap[4]).unstable_now() - type.renderingStartTime > workInProgressRootRenderTargetTime && 1073741824 !== renderLanes && (workInProgress.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress.lanes = 4194304);
          type.isBackwards ? (updatePayload.sibling = workInProgress.child, workInProgress.child = updatePayload) : (current = type.last, null !== current ? current.sibling = updatePayload : workInProgress.child = updatePayload, type.last = updatePayload);
        }
        if (null !== type.tail) return workInProgress = type.tail, type.rendering = workInProgress, type.tail = workInProgress.sibling, type.renderingStartTime = _$$_REQUIRE(_dependencyMap[4]).unstable_now(), workInProgress.sibling = null, current = suspenseStackCursor.current, push(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress;
        bubbleProperties(workInProgress);
        return null;

      case 22:
      case 23:
        return popRenderLanes(), renderLanes = null !== workInProgress.memoizedState, null !== current && null !== current.memoizedState !== renderLanes && "unstable-defer-without-hiding" !== newProps.mode && (workInProgress.flags |= 4), renderLanes && 0 === (subtreeRenderLanes & 1073741824) && 0 !== (workInProgress.mode & 1) || bubbleProperties(workInProgress), null;
    }

    throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
  }

  function unwindWork(workInProgress) {
    switch (workInProgress.tag) {
      case 1:
        isContextProvider(workInProgress.type) && popContext();
        var flags = workInProgress.flags;
        return flags & 16384 ? (workInProgress.flags = flags & -16385 | 128, workInProgress) : null;

      case 3:
        popHostContainer();
        pop(didPerformWorkStackCursor);
        pop(contextStackCursor);
        resetWorkInProgressVersions();
        flags = workInProgress.flags;
        if (0 !== (flags & 128)) throw Error("The root failed to unmount after an error. This is likely a bug in React. Please file an issue.");
        workInProgress.flags = flags & -16385 | 128;
        return workInProgress;

      case 5:
        return popHostContext(workInProgress), null;

      case 13:
        return pop(suspenseStackCursor), flags = workInProgress.flags, flags & 16384 ? (workInProgress.flags = flags & -16385 | 128, workInProgress) : null;

      case 19:
        return pop(suspenseStackCursor), null;

      case 4:
        return popHostContainer(), null;

      case 10:
        return popProvider(workInProgress.type._context), null;

      case 22:
      case 23:
        return popRenderLanes(), null;

      case 24:
        return null;

      default:
        return null;
    }
  }

  var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
      nextEffect = null;

  function safelyDetachRef(current, nearestMountedAncestor) {
    var ref = current.ref;
    if (null !== ref) if ("function" === typeof ref) try {
      ref(null);
    } catch (error) {
      captureCommitPhaseError(current, nearestMountedAncestor, error);
    } else ref.current = null;
  }

  var shouldFireAfterActiveInstanceBlur = false;

  function commitBeforeMutationEffects(root, firstChild) {
    for (nextEffect = firstChild; null !== nextEffect;) {
      if (root = nextEffect, firstChild = root.child, 0 !== (root.subtreeFlags & 516) && null !== firstChild) firstChild.return = root, nextEffect = firstChild;else for (; null !== nextEffect;) {
        root = nextEffect;

        try {
          var current = root.alternate;
          if (0 !== (root.flags & 512)) switch (root.tag) {
            case 0:
            case 11:
            case 15:
              break;

            case 1:
              if (null !== current) {
                var prevProps = current.memoizedProps,
                    prevState = current.memoizedState,
                    instance = root.stateNode,
                    snapshot = instance.getSnapshotBeforeUpdate(root.elementType === root.type ? prevProps : resolveDefaultProps(root.type, prevProps), prevState);
                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
              }

              break;

            case 3:
              break;

            case 5:
            case 6:
            case 4:
            case 17:
              break;

            default:
              throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
          }
        } catch (error) {
          captureCommitPhaseError(root, root.return, error);
        }

        firstChild = root.sibling;

        if (null !== firstChild) {
          firstChild.return = root.return;
          nextEffect = firstChild;
          break;
        }

        nextEffect = root.return;
      }
    }

    current = shouldFireAfterActiveInstanceBlur;
    shouldFireAfterActiveInstanceBlur = false;
    return current;
  }

  function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
    var updateQueue = finishedWork.updateQueue;
    updateQueue = null !== updateQueue ? updateQueue.lastEffect : null;

    if (null !== updateQueue) {
      var effect = updateQueue = updateQueue.next;

      do {
        if ((effect.tag & flags) === flags) {
          var destroy = effect.destroy;
          effect.destroy = undefined;

          if (undefined !== destroy) {
            var current = finishedWork,
                nearestMountedAncestor = nearestMountedAncestor$jscomp$0;

            try {
              destroy();
            } catch (error) {
              captureCommitPhaseError(current, nearestMountedAncestor, error);
            }
          }
        }

        effect = effect.next;
      } while (effect !== updateQueue);
    }
  }

  function commitHookEffectListMount(tag, finishedWork) {
    finishedWork = finishedWork.updateQueue;
    finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;

    if (null !== finishedWork) {
      var effect = finishedWork = finishedWork.next;

      do {
        if ((effect.tag & tag) === tag) {
          var create$82 = effect.create;
          effect.destroy = create$82();
        }

        effect = effect.next;
      } while (effect !== finishedWork);
    }
  }

  function detachFiberAfterEffects(fiber) {
    var alternate = fiber.alternate;
    null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
    fiber.child = null;
    fiber.deletions = null;
    fiber.sibling = null;
    fiber.stateNode = null;
    fiber.return = null;
    fiber.dependencies = null;
    fiber.memoizedProps = null;
    fiber.memoizedState = null;
    fiber.pendingProps = null;
    fiber.stateNode = null;
    fiber.updateQueue = null;
  }

  function commitWork(current, finishedWork) {
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        commitHookEffectListUnmount(3, finishedWork, finishedWork.return);
        return;

      case 12:
        return;

      case 13:
        null !== finishedWork.memoizedState && (globalMostRecentFallbackTime = _$$_REQUIRE(_dependencyMap[4]).unstable_now());
        attachSuspenseRetryListeners(finishedWork);
        return;

      case 19:
        attachSuspenseRetryListeners(finishedWork);
        return;

      case 22:
      case 23:
        return;
    }

    a: {
      switch (finishedWork.tag) {
        case 1:
        case 5:
        case 6:
          break a;

        case 3:
        case 4:
          break a;
      }

      throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
  }

  function attachSuspenseRetryListeners(finishedWork) {
    var wakeables = finishedWork.updateQueue;

    if (null !== wakeables) {
      finishedWork.updateQueue = null;
      var retryCache = finishedWork.stateNode;
      null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
      wakeables.forEach(function (wakeable) {
        var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
        retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
      });
    }
  }

  function commitMutationEffects(root, firstChild) {
    for (nextEffect = firstChild; null !== nextEffect;) {
      root = nextEffect;
      firstChild = root.deletions;
      if (null !== firstChild) for (var i = 0; i < firstChild.length; i++) {
        var childToDelete = firstChild[i];

        try {
          a: for (var node = childToDelete;;) {
            var current = node;
            if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount) try {
              injectedHook.onCommitFiberUnmount(rendererID, current);
            } catch (err) {}

            switch (current.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                var updateQueue = current.updateQueue;

                if (null !== updateQueue) {
                  var lastEffect = updateQueue.lastEffect;

                  if (null !== lastEffect) {
                    var firstEffect = lastEffect.next,
                        effect = firstEffect;

                    do {
                      var _effect = effect,
                          destroy = _effect.destroy,
                          tag = _effect.tag;

                      if (undefined !== destroy && 0 !== (tag & 2)) {
                        _effect = current;
                        var nearestMountedAncestor = root;

                        try {
                          destroy();
                        } catch (error) {
                          captureCommitPhaseError(_effect, nearestMountedAncestor, error);
                        }
                      }

                      effect = effect.next;
                    } while (effect !== firstEffect);
                  }
                }

                break;

              case 1:
                safelyDetachRef(current, root);
                var instance = current.stateNode;
                if ("function" === typeof instance.componentWillUnmount) try {
                  effect = current, _effect = instance, _effect.props = effect.memoizedProps, _effect.state = effect.memoizedState, _effect.componentWillUnmount();
                } catch (unmountError) {
                  captureCommitPhaseError(current, root, unmountError);
                }
                break;

              case 5:
                safelyDetachRef(current, root);
                break;

              case 4:
                createChildNodeSet(current.stateNode.containerInfo);
            }

            if (null !== node.child) node.child.return = node, node = node.child;else {
              if (node === childToDelete) break;

              for (; null === node.sibling;) {
                if (null === node.return || node.return === childToDelete) break a;
                node = node.return;
              }

              node.sibling.return = node.return;
              node = node.sibling;
            }
          }

          var alternate = childToDelete.alternate;
          null !== alternate && (alternate.return = null);
          childToDelete.return = null;
        } catch (error) {
          captureCommitPhaseError(childToDelete, root, error);
        }
      }
      firstChild = root.child;
      if (0 !== (root.subtreeFlags & 6454) && null !== firstChild) firstChild.return = root, nextEffect = firstChild;else for (; null !== nextEffect;) {
        root = nextEffect;

        try {
          var flags = root.flags;

          if (flags & 256) {
            var current$jscomp$0 = root.alternate;

            if (null !== current$jscomp$0) {
              var currentRef = current$jscomp$0.ref;
              null !== currentRef && ("function" === typeof currentRef ? currentRef(null) : currentRef.current = null);
            }
          }

          switch (flags & 2054) {
            case 2:
              root.flags &= -3;
              break;

            case 6:
              root.flags &= -3;
              commitWork(root.alternate, root);
              break;

            case 2048:
              root.flags &= -2049;
              break;

            case 2052:
              root.flags &= -2049;
              commitWork(root.alternate, root);
              break;

            case 4:
              commitWork(root.alternate, root);
          }
        } catch (error) {
          captureCommitPhaseError(root, root.return, error);
        }

        firstChild = root.sibling;

        if (null !== firstChild) {
          firstChild.return = root.return;
          nextEffect = firstChild;
          break;
        }

        nextEffect = root.return;
      }
    }
  }

  function commitLayoutEffects(finishedWork) {
    for (nextEffect = finishedWork; null !== nextEffect;) {
      var fiber = nextEffect,
          firstChild = fiber.child;
      if (0 !== (fiber.subtreeFlags & 324) && null !== firstChild) firstChild.return = fiber, nextEffect = firstChild;else for (fiber = finishedWork; null !== nextEffect;) {
        firstChild = nextEffect;

        if (0 !== (firstChild.flags & 324)) {
          var current = firstChild.alternate;

          try {
            if (0 !== (firstChild.flags & 68)) switch (firstChild.tag) {
              case 0:
              case 11:
              case 15:
                commitHookEffectListMount(3, firstChild);
                break;

              case 1:
                var instance = firstChild.stateNode;
                if (firstChild.flags & 4) if (null === current) instance.componentDidMount();else {
                  var prevProps = firstChild.elementType === firstChild.type ? current.memoizedProps : resolveDefaultProps(firstChild.type, current.memoizedProps);
                  instance.componentDidUpdate(prevProps, current.memoizedState, instance.__reactInternalSnapshotBeforeUpdate);
                }
                var updateQueue = firstChild.updateQueue;
                null !== updateQueue && commitUpdateQueue(firstChild, updateQueue, instance);
                break;

              case 3:
                var updateQueue$83 = firstChild.updateQueue;

                if (null !== updateQueue$83) {
                  current = null;
                  if (null !== firstChild.child) switch (firstChild.child.tag) {
                    case 5:
                      current = firstChild.child.stateNode.canonical;
                      break;

                    case 1:
                      current = firstChild.child.stateNode;
                  }
                  commitUpdateQueue(firstChild, updateQueue$83, current);
                }

                break;

              case 5:
                null === current && firstChild.flags & 4 && shim();
                break;

              case 6:
                break;

              case 4:
                break;

              case 12:
                break;

              case 13:
                break;

              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;

              default:
                throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }

            if (firstChild.flags & 256) {
              current = undefined;
              var ref = firstChild.ref;

              if (null !== ref) {
                var instance$jscomp$0 = firstChild.stateNode;

                switch (firstChild.tag) {
                  case 5:
                    current = instance$jscomp$0.canonical;
                    break;

                  default:
                    current = instance$jscomp$0;
                }

                "function" === typeof ref ? ref(current) : ref.current = current;
              }
            }
          } catch (error) {
            captureCommitPhaseError(firstChild, firstChild.return, error);
          }
        }

        if (firstChild === fiber) {
          nextEffect = null;
          break;
        }

        current = firstChild.sibling;

        if (null !== current) {
          current.return = firstChild.return;
          nextEffect = current;
          break;
        }

        nextEffect = firstChild.return;
      }
    }
  }

  var ceil = Math.ceil,
      ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,
      ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
      ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig,
      executionContext = 0,
      workInProgressRoot = null,
      workInProgress = null,
      workInProgressRootRenderLanes = 0,
      subtreeRenderLanes = 0,
      subtreeRenderLanesCursor = createCursor(0),
      workInProgressRootExitStatus = 0,
      workInProgressRootFatalError = null,
      workInProgressRootSkippedLanes = 0,
      workInProgressRootUpdatedLanes = 0,
      workInProgressRootPingedLanes = 0,
      globalMostRecentFallbackTime = 0,
      workInProgressRootRenderTargetTime = Infinity,
      hasUncaughtError = false,
      firstUncaughtError = null,
      legacyErrorBoundariesThatAlreadyFailed = null,
      rootDoesHavePassiveEffects = false,
      rootWithPendingPassiveEffects = null,
      pendingPassiveEffectsLanes = 0,
      nestedUpdateCount = 0,
      rootWithNestedUpdates = null,
      currentEventTime = -1,
      currentEventTransitionLane = 0;

  function requestEventTime() {
    return 0 !== (executionContext & 24) ? _$$_REQUIRE(_dependencyMap[4]).unstable_now() : -1 !== currentEventTime ? currentEventTime : currentEventTime = _$$_REQUIRE(_dependencyMap[4]).unstable_now();
  }

  function requestUpdateLane(fiber) {
    if (0 === (fiber.mode & 1)) return 1;
    if (0 !== (executionContext & 8) && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
    if (0 !== ReactCurrentBatchConfig.transition) return 0 === currentEventTransitionLane && (fiber = nextTransitionLane, nextTransitionLane <<= 1, 0 === (nextTransitionLane & 4194240) && (nextTransitionLane = 64), currentEventTransitionLane = fiber), currentEventTransitionLane;
    fiber = currentUpdatePriority;
    if (0 === fiber) a: {
      fiber = fabricGetCurrentEventPriority ? fabricGetCurrentEventPriority() : null;
      if (null != fiber) switch (fiber) {
        case FabricDiscretePriority:
          fiber = 1;
          break a;
      }
      fiber = 16;
    }
    return fiber;
  }

  function scheduleUpdateOnFiber(fiber, lane, eventTime) {
    if (50 < nestedUpdateCount) throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
    var root = markUpdateLaneFromFiberToRoot(fiber, lane);
    if (null === root) return null;
    markRootUpdated(root, lane, eventTime);
    root === workInProgressRoot && (0 === (executionContext & 8) && (workInProgressRootUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended$1(root, workInProgressRootRenderLanes));
    1 === lane ? 0 !== (executionContext & 4) && 0 === (executionContext & 24) ? performSyncWorkOnRoot(root) : (ensureRootIsScheduled(root, eventTime), 0 === executionContext && 0 === (fiber.mode & 1) && (workInProgressRootRenderTargetTime = _$$_REQUIRE(_dependencyMap[4]).unstable_now() + 500, includesLegacySyncCallbacks && flushSyncCallbacks())) : ensureRootIsScheduled(root, eventTime);
    return root;
  }

  function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
    sourceFiber.lanes |= lane;
    var alternate = sourceFiber.alternate;
    null !== alternate && (alternate.lanes |= lane);
    alternate = sourceFiber;

    for (sourceFiber = sourceFiber.return; null !== sourceFiber;) {
      sourceFiber.childLanes |= lane, alternate = sourceFiber.alternate, null !== alternate && (alternate.childLanes |= lane), alternate = sourceFiber, sourceFiber = sourceFiber.return;
    }

    return 3 === alternate.tag ? alternate.stateNode : null;
  }

  function ensureRootIsScheduled(root, currentTime) {
    for (var existingCallbackNode = root.callbackNode, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes; 0 < lanes;) {
      var index$5 = 31 - clz32(lanes),
          lane = 1 << index$5,
          expirationTime = expirationTimes[index$5];

      if (-1 === expirationTime) {
        if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
      } else expirationTime <= currentTime && (root.expiredLanes |= lane);

      lanes &= ~lane;
    }

    suspendedLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : 0);
    if (0 === suspendedLanes) null !== existingCallbackNode && _$$_REQUIRE(_dependencyMap[4]).unstable_cancelCallback(existingCallbackNode), root.callbackNode = null, root.callbackPriority = 0;else if (currentTime = suspendedLanes & -suspendedLanes, root.callbackPriority !== currentTime) {
      null != existingCallbackNode && _$$_REQUIRE(_dependencyMap[4]).unstable_cancelCallback(existingCallbackNode);
      if (1 === currentTime) 0 === root.tag ? (existingCallbackNode = performSyncWorkOnRoot.bind(null, root), includesLegacySyncCallbacks = true, null === syncQueue ? syncQueue = [existingCallbackNode] : syncQueue.push(existingCallbackNode)) : (existingCallbackNode = performSyncWorkOnRoot.bind(null, root), null === syncQueue ? syncQueue = [existingCallbackNode] : syncQueue.push(existingCallbackNode)), _$$_REQUIRE(_dependencyMap[4]).unstable_scheduleCallback(_$$_REQUIRE(_dependencyMap[4]).unstable_ImmediatePriority, flushSyncCallbacks), existingCallbackNode = null;else {
        switch (lanesToEventPriority(suspendedLanes)) {
          case 1:
            existingCallbackNode = _$$_REQUIRE(_dependencyMap[4]).unstable_ImmediatePriority;
            break;

          case 4:
            existingCallbackNode = _$$_REQUIRE(_dependencyMap[4]).unstable_UserBlockingPriority;
            break;

          case 16:
            existingCallbackNode = _$$_REQUIRE(_dependencyMap[4]).unstable_NormalPriority;
            break;

          case 536870912:
            existingCallbackNode = _$$_REQUIRE(_dependencyMap[4]).unstable_IdlePriority;
            break;

          default:
            existingCallbackNode = _$$_REQUIRE(_dependencyMap[4]).unstable_NormalPriority;
        }

        existingCallbackNode = _$$_REQUIRE(_dependencyMap[4]).unstable_scheduleCallback(existingCallbackNode, performConcurrentWorkOnRoot.bind(null, root));
      }
      root.callbackPriority = currentTime;
      root.callbackNode = existingCallbackNode;
    }
  }

  function performConcurrentWorkOnRoot(root, didTimeout) {
    currentEventTime = -1;
    currentEventTransitionLane = 0;
    if (0 !== (executionContext & 24)) throw Error("Should not already be working.");
    var originalCallbackNode = root.callbackNode;
    if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode) return null;
    var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : 0);
    if (0 === lanes) return null;
    var JSCompiler_inline_result = 0 !== (lanes & root.expiredLanes) ? false : 0 === (lanes & 30);

    if (JSCompiler_inline_result && !didTimeout) {
      didTimeout = lanes;
      JSCompiler_inline_result = executionContext;
      executionContext |= 8;
      var prevDispatcher = pushDispatcher();
      if (workInProgressRoot !== root || workInProgressRootRenderLanes !== didTimeout) workInProgressRootRenderTargetTime = _$$_REQUIRE(_dependencyMap[4]).unstable_now() + 500, prepareFreshStack(root, didTimeout);

      do {
        try {
          workLoopConcurrent();
          break;
        } catch (thrownValue) {
          handleError(root, thrownValue);
        }
      } while (1);

      resetContextDependencies();
      ReactCurrentDispatcher$2.current = prevDispatcher;
      executionContext = JSCompiler_inline_result;
      null !== workInProgress ? didTimeout = 0 : (workInProgressRoot = null, workInProgressRootRenderLanes = 0, didTimeout = workInProgressRootExitStatus);
    } else didTimeout = renderRootSync(root, lanes);

    if (0 !== didTimeout) {
      2 === didTimeout && (executionContext |= 32, root.hydrate && (root.hydrate = false, shim(root.containerInfo)), JSCompiler_inline_result = getLanesToRetrySynchronouslyOnError(root), 0 !== JSCompiler_inline_result && (lanes = JSCompiler_inline_result, didTimeout = renderRootSync(root, JSCompiler_inline_result)));
      if (1 === didTimeout) throw originalCallbackNode = workInProgressRootFatalError, prepareFreshStack(root, 0), markRootSuspended$1(root, lanes), ensureRootIsScheduled(root, _$$_REQUIRE(_dependencyMap[4]).unstable_now()), originalCallbackNode;
      root.finishedWork = root.current.alternate;
      root.finishedLanes = lanes;

      switch (didTimeout) {
        case 0:
        case 1:
          throw Error("Root did not complete. This is a bug in React.");

        case 2:
          commitRoot(root);
          break;

        case 3:
          markRootSuspended$1(root, lanes);

          if ((lanes & 130023424) === lanes && (didTimeout = globalMostRecentFallbackTime + 500 - _$$_REQUIRE(_dependencyMap[4]).unstable_now(), 10 < didTimeout)) {
            if (0 !== getNextLanes(root, 0)) break;
            JSCompiler_inline_result = root.suspendedLanes;

            if ((JSCompiler_inline_result & lanes) !== lanes) {
              requestEventTime();
              root.pingedLanes |= root.suspendedLanes & JSCompiler_inline_result;
              break;
            }

            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), didTimeout);
            break;
          }

          commitRoot(root);
          break;

        case 4:
          markRootSuspended$1(root, lanes);
          if ((lanes & 4194240) === lanes) break;
          didTimeout = root.eventTimes;

          for (JSCompiler_inline_result = -1; 0 < lanes;) {
            var index$4 = 31 - clz32(lanes);
            prevDispatcher = 1 << index$4;
            index$4 = didTimeout[index$4];
            index$4 > JSCompiler_inline_result && (JSCompiler_inline_result = index$4);
            lanes &= ~prevDispatcher;
          }

          lanes = JSCompiler_inline_result;
          lanes = _$$_REQUIRE(_dependencyMap[4]).unstable_now() - lanes;
          lanes = (120 > lanes ? 120 : 480 > lanes ? 480 : 1080 > lanes ? 1080 : 1920 > lanes ? 1920 : 3e3 > lanes ? 3e3 : 4320 > lanes ? 4320 : 1960 * ceil(lanes / 1960)) - lanes;

          if (10 < lanes) {
            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), lanes);
            break;
          }

          commitRoot(root);
          break;

        case 5:
          commitRoot(root);
          break;

        default:
          throw Error("Unknown root exit status.");
      }
    }

    ensureRootIsScheduled(root, _$$_REQUIRE(_dependencyMap[4]).unstable_now());
    return root.callbackNode === originalCallbackNode ? performConcurrentWorkOnRoot.bind(null, root) : null;
  }

  function markRootSuspended$1(root, suspendedLanes) {
    suspendedLanes &= ~workInProgressRootPingedLanes;
    suspendedLanes &= ~workInProgressRootUpdatedLanes;
    root.suspendedLanes |= suspendedLanes;
    root.pingedLanes &= ~suspendedLanes;

    for (root = root.expirationTimes; 0 < suspendedLanes;) {
      var index$6 = 31 - clz32(suspendedLanes),
          lane = 1 << index$6;
      root[index$6] = -1;
      suspendedLanes &= ~lane;
    }
  }

  function performSyncWorkOnRoot(root) {
    if (0 !== (executionContext & 24)) throw Error("Should not already be working.");
    flushPassiveEffects();
    var lanes = getNextLanes(root, 0);
    if (0 === (lanes & 1)) return ensureRootIsScheduled(root, _$$_REQUIRE(_dependencyMap[4]).unstable_now()), null;
    var exitStatus = renderRootSync(root, lanes);

    if (0 !== root.tag && 2 === exitStatus) {
      executionContext |= 32;
      root.hydrate && (root.hydrate = false, shim(root.containerInfo));
      var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
      0 !== errorRetryLanes && (lanes = errorRetryLanes, exitStatus = renderRootSync(root, lanes));
    }

    if (1 === exitStatus) throw exitStatus = workInProgressRootFatalError, prepareFreshStack(root, 0), markRootSuspended$1(root, lanes), ensureRootIsScheduled(root, _$$_REQUIRE(_dependencyMap[4]).unstable_now()), exitStatus;
    root.finishedWork = root.current.alternate;
    root.finishedLanes = lanes;
    commitRoot(root);
    ensureRootIsScheduled(root, _$$_REQUIRE(_dependencyMap[4]).unstable_now());
    return null;
  }

  function popRenderLanes() {
    subtreeRenderLanes = subtreeRenderLanesCursor.current;
    pop(subtreeRenderLanesCursor);
  }

  function prepareFreshStack(root, lanes) {
    root.finishedWork = null;
    root.finishedLanes = 0;
    var timeoutHandle = root.timeoutHandle;
    -1 !== timeoutHandle && (root.timeoutHandle = -1, cancelTimeout(timeoutHandle));
    if (null !== workInProgress) for (timeoutHandle = workInProgress.return; null !== timeoutHandle;) {
      var interruptedWork = timeoutHandle;

      switch (interruptedWork.tag) {
        case 1:
          interruptedWork = interruptedWork.type.childContextTypes;
          null !== interruptedWork && undefined !== interruptedWork && popContext();
          break;

        case 3:
          popHostContainer();
          pop(didPerformWorkStackCursor);
          pop(contextStackCursor);
          resetWorkInProgressVersions();
          break;

        case 5:
          popHostContext(interruptedWork);
          break;

        case 4:
          popHostContainer();
          break;

        case 13:
          pop(suspenseStackCursor);
          break;

        case 19:
          pop(suspenseStackCursor);
          break;

        case 10:
          popProvider(interruptedWork.type._context);
          break;

        case 22:
        case 23:
          popRenderLanes();
      }

      timeoutHandle = timeoutHandle.return;
    }
    workInProgressRoot = root;
    workInProgress = createWorkInProgress(root.current, null);
    workInProgressRootRenderLanes = subtreeRenderLanes = lanes;
    workInProgressRootExitStatus = 0;
    workInProgressRootFatalError = null;
    workInProgressRootPingedLanes = workInProgressRootUpdatedLanes = workInProgressRootSkippedLanes = 0;

    if (null !== interleavedQueues) {
      for (root = 0; root < interleavedQueues.length; root++) {
        if (lanes = interleavedQueues[root], timeoutHandle = lanes.interleaved, null !== timeoutHandle) {
          lanes.interleaved = null;
          interruptedWork = timeoutHandle.next;
          var lastPendingUpdate = lanes.pending;

          if (null !== lastPendingUpdate) {
            var firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = interruptedWork;
            timeoutHandle.next = firstPendingUpdate;
          }

          lanes.pending = timeoutHandle;
        }
      }

      interleavedQueues = null;
    }
  }

  function handleError(root$jscomp$0, thrownValue) {
    do {
      var erroredWork = workInProgress;

      try {
        resetContextDependencies();
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;

        if (didScheduleRenderPhaseUpdate) {
          for (var hook = currentlyRenderingFiber$1.memoizedState; null !== hook;) {
            var queue = hook.queue;
            null !== queue && (queue.pending = null);
            hook = hook.next;
          }

          didScheduleRenderPhaseUpdate = false;
        }

        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        ReactCurrentOwner$2.current = null;

        if (null === erroredWork || null === erroredWork.return) {
          workInProgressRootExitStatus = 1;
          workInProgressRootFatalError = thrownValue;
          workInProgress = null;
          break;
        }

        a: {
          var root = root$jscomp$0,
              returnFiber = erroredWork.return,
              sourceFiber = erroredWork,
              value = thrownValue;
          thrownValue = workInProgressRootRenderLanes;
          sourceFiber.flags |= 8192;

          if (null !== value && "object" === typeof value && "function" === typeof value.then) {
            var wakeable = value,
                tag = sourceFiber.tag;

            if (0 === (sourceFiber.mode & 1) && (0 === tag || 11 === tag || 15 === tag)) {
              var currentSource = sourceFiber.alternate;
              currentSource ? (sourceFiber.updateQueue = currentSource.updateQueue, sourceFiber.memoizedState = currentSource.memoizedState, sourceFiber.lanes = currentSource.lanes) : (sourceFiber.updateQueue = null, sourceFiber.memoizedState = null);
            }

            var hasInvisibleParentBoundary = 0 !== (suspenseStackCursor.current & 1),
                workInProgress$30 = returnFiber;

            do {
              var JSCompiler_temp;

              if (JSCompiler_temp = 13 === workInProgress$30.tag) {
                var nextState = workInProgress$30.memoizedState;
                if (null !== nextState) JSCompiler_temp = null !== nextState.dehydrated ? true : false;else {
                  var props = workInProgress$30.memoizedProps;
                  JSCompiler_temp = undefined === props.fallback ? false : true !== props.unstable_avoidThisFallback ? true : hasInvisibleParentBoundary ? false : true;
                }
              }

              if (JSCompiler_temp) {
                var wakeables = workInProgress$30.updateQueue;

                if (null === wakeables) {
                  var updateQueue = new Set();
                  updateQueue.add(wakeable);
                  workInProgress$30.updateQueue = updateQueue;
                } else wakeables.add(wakeable);

                if (0 === (workInProgress$30.mode & 1) && workInProgress$30 !== returnFiber) {
                  workInProgress$30.flags |= 128;
                  sourceFiber.flags |= 32768;
                  sourceFiber.flags &= -10053;
                  if (1 === sourceFiber.tag) if (null === sourceFiber.alternate) sourceFiber.tag = 17;else {
                    var update = createUpdate(-1, 1);
                    update.tag = 2;
                    enqueueUpdate(sourceFiber, update);
                  }
                  sourceFiber.lanes |= 1;
                  break a;
                }

                value = undefined;
                sourceFiber = thrownValue;
                var pingCache = root.pingCache;
                null === pingCache ? (pingCache = root.pingCache = new PossiblyWeakMap(), value = new Set(), pingCache.set(wakeable, value)) : (value = pingCache.get(wakeable), undefined === value && (value = new Set(), pingCache.set(wakeable, value)));

                if (!value.has(sourceFiber)) {
                  value.add(sourceFiber);
                  var ping = pingSuspendedRoot.bind(null, root, wakeable, sourceFiber);
                  wakeable.then(ping, ping);
                }

                workInProgress$30.flags |= 16384;
                workInProgress$30.lanes = thrownValue;
                break a;
              }

              workInProgress$30 = workInProgress$30.return;
            } while (null !== workInProgress$30);

            value = Error((getComponentNameFromFiber(sourceFiber) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
          }

          5 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
          value = createCapturedValue(value, sourceFiber);
          workInProgress$30 = returnFiber;

          do {
            switch (workInProgress$30.tag) {
              case 3:
                root = value;
                workInProgress$30.flags |= 16384;
                thrownValue &= -thrownValue;
                workInProgress$30.lanes |= thrownValue;
                var update$31 = createRootErrorUpdate(workInProgress$30, root, thrownValue);
                enqueueCapturedUpdate(workInProgress$30, update$31);
                break a;

              case 1:
                root = value;
                var ctor = workInProgress$30.type,
                    instance = workInProgress$30.stateNode;

                if (0 === (workInProgress$30.flags & 128) && ("function" === typeof ctor.getDerivedStateFromError || null !== instance && "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance)))) {
                  workInProgress$30.flags |= 16384;
                  thrownValue &= -thrownValue;
                  workInProgress$30.lanes |= thrownValue;
                  var update$34 = createClassErrorUpdate(workInProgress$30, root, thrownValue);
                  enqueueCapturedUpdate(workInProgress$30, update$34);
                  break a;
                }

            }

            workInProgress$30 = workInProgress$30.return;
          } while (null !== workInProgress$30);
        }

        completeUnitOfWork(erroredWork);
      } catch (yetAnotherThrownValue) {
        thrownValue = yetAnotherThrownValue;
        workInProgress === erroredWork && null !== erroredWork && (workInProgress = erroredWork = erroredWork.return);
        continue;
      }

      break;
    } while (1);
  }

  function pushDispatcher() {
    var prevDispatcher = ReactCurrentDispatcher$2.current;
    ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
    return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
  }

  function renderRootSync(root, lanes) {
    var prevExecutionContext = executionContext;
    executionContext |= 8;
    var prevDispatcher = pushDispatcher();
    workInProgressRoot === root && workInProgressRootRenderLanes === lanes || prepareFreshStack(root, lanes);

    do {
      try {
        workLoopSync();
        break;
      } catch (thrownValue) {
        handleError(root, thrownValue);
      }
    } while (1);

    resetContextDependencies();
    executionContext = prevExecutionContext;
    ReactCurrentDispatcher$2.current = prevDispatcher;
    if (null !== workInProgress) throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
    workInProgressRoot = null;
    workInProgressRootRenderLanes = 0;
    return workInProgressRootExitStatus;
  }

  function workLoopSync() {
    for (; null !== workInProgress;) {
      performUnitOfWork(workInProgress);
    }
  }

  function workLoopConcurrent() {
    for (; null !== workInProgress && !_$$_REQUIRE(_dependencyMap[4]).unstable_shouldYield();) {
      performUnitOfWork(workInProgress);
    }
  }

  function performUnitOfWork(unitOfWork) {
    var next = beginWork$1(unitOfWork.alternate, unitOfWork, subtreeRenderLanes);
    unitOfWork.memoizedProps = unitOfWork.pendingProps;
    null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    ReactCurrentOwner$2.current = null;
  }

  function completeUnitOfWork(unitOfWork) {
    var completedWork = unitOfWork;

    do {
      var current = completedWork.alternate;
      unitOfWork = completedWork.return;

      if (0 === (completedWork.flags & 8192)) {
        if (current = completeWork(current, completedWork, subtreeRenderLanes), null !== current) {
          workInProgress = current;
          return;
        }
      } else {
        current = unwindWork(completedWork);

        if (null !== current) {
          current.flags &= 8191;
          workInProgress = current;
          return;
        }

        null !== unitOfWork && (unitOfWork.flags |= 8192, unitOfWork.subtreeFlags = 0, unitOfWork.deletions = null);
      }

      completedWork = completedWork.sibling;

      if (null !== completedWork) {
        workInProgress = completedWork;
        return;
      }

      workInProgress = completedWork = unitOfWork;
    } while (null !== completedWork);

    0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
  }

  function commitRoot(root) {
    var previousUpdateLanePriority = currentUpdatePriority,
        prevTransition = ReactCurrentBatchConfig$2.transition;

    try {
      ReactCurrentBatchConfig$2.transition = 0, currentUpdatePriority = 1, commitRootImpl(root, previousUpdateLanePriority);
    } finally {
      ReactCurrentBatchConfig$2.transition = prevTransition, currentUpdatePriority = previousUpdateLanePriority;
    }

    return null;
  }

  function commitRootImpl(root, renderPriorityLevel) {
    do {
      flushPassiveEffects();
    } while (null !== rootWithPendingPassiveEffects);

    if (0 !== (executionContext & 24)) throw Error("Should not already be working.");
    var finishedWork = root.finishedWork,
        lanes = root.finishedLanes;
    if (null === finishedWork) return null;
    root.finishedWork = null;
    root.finishedLanes = 0;
    if (finishedWork === root.current) throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
    root.callbackNode = null;
    root.callbackPriority = 0;
    var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
    markRootFinished(root, remainingLanes);
    root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
    0 === (finishedWork.subtreeFlags & 1040) && 0 === (finishedWork.flags & 1040) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = true, _$$_REQUIRE(_dependencyMap[4]).unstable_scheduleCallback(_$$_REQUIRE(_dependencyMap[4]).unstable_NormalPriority, function () {
      flushPassiveEffects();
      return null;
    }));
    remainingLanes = 0 !== (finishedWork.flags & 8054);

    if (0 !== (finishedWork.subtreeFlags & 8054) || remainingLanes) {
      remainingLanes = ReactCurrentBatchConfig$2.transition;
      ReactCurrentBatchConfig$2.transition = 0;
      var previousPriority = currentUpdatePriority;
      currentUpdatePriority = 1;
      var prevExecutionContext = executionContext;
      executionContext |= 16;
      ReactCurrentOwner$2.current = null;
      commitBeforeMutationEffects(root, finishedWork);
      commitMutationEffects(root, finishedWork);
      root.current = finishedWork;
      commitLayoutEffects(finishedWork, root, lanes);

      _$$_REQUIRE(_dependencyMap[4]).unstable_requestPaint();

      executionContext = prevExecutionContext;
      currentUpdatePriority = previousPriority;
      ReactCurrentBatchConfig$2.transition = remainingLanes;
    } else root.current = finishedWork;

    rootDoesHavePassiveEffects && (rootDoesHavePassiveEffects = false, rootWithPendingPassiveEffects = root, pendingPassiveEffectsLanes = lanes);
    remainingLanes = root.pendingLanes;
    0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
    0 !== (remainingLanes & 1) ? root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root) : nestedUpdateCount = 0;
    onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
    ensureRootIsScheduled(root, _$$_REQUIRE(_dependencyMap[4]).unstable_now());
    if (hasUncaughtError) throw hasUncaughtError = false, root = firstUncaughtError, firstUncaughtError = null, root;
    if (0 !== (executionContext & 4)) return null;
    0 !== (pendingPassiveEffectsLanes & 1) && 0 !== root.tag && flushPassiveEffects();
    flushSyncCallbacks();
    return null;
  }

  function flushPassiveEffects() {
    if (null !== rootWithPendingPassiveEffects) {
      var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
          prevTransition = ReactCurrentBatchConfig$2.transition,
          previousPriority = currentUpdatePriority;

      try {
        ReactCurrentBatchConfig$2.transition = 0;
        currentUpdatePriority = 16 > renderPriority ? 16 : renderPriority;
        if (null === rootWithPendingPassiveEffects) var JSCompiler_inline_result = false;else {
          renderPriority = rootWithPendingPassiveEffects;
          rootWithPendingPassiveEffects = null;
          pendingPassiveEffectsLanes = 0;
          if (0 !== (executionContext & 24)) throw Error("Cannot flush passive effects while already rendering.");
          var prevExecutionContext = executionContext;
          executionContext |= 16;

          for (nextEffect = renderPriority.current; null !== nextEffect;) {
            var fiber = nextEffect,
                child = fiber.child;

            if (0 !== (nextEffect.flags & 16)) {
              var deletions = fiber.deletions;

              if (null !== deletions) {
                for (var i = 0; i < deletions.length; i++) {
                  var fiberToDelete = deletions[i];

                  for (nextEffect = fiberToDelete; null !== nextEffect;) {
                    var fiber$jscomp$0 = nextEffect;

                    switch (fiber$jscomp$0.tag) {
                      case 0:
                      case 11:
                      case 15:
                        commitHookEffectListUnmount(4, fiber$jscomp$0, fiber);
                    }

                    var child$jscomp$0 = fiber$jscomp$0.child;
                    if (null !== child$jscomp$0) child$jscomp$0.return = fiber$jscomp$0, nextEffect = child$jscomp$0;else for (; null !== nextEffect;) {
                      fiber$jscomp$0 = nextEffect;
                      var sibling = fiber$jscomp$0.sibling,
                          returnFiber = fiber$jscomp$0.return;
                      detachFiberAfterEffects(fiber$jscomp$0);

                      if (fiber$jscomp$0 === fiberToDelete) {
                        nextEffect = null;
                        break;
                      }

                      if (null !== sibling) {
                        sibling.return = returnFiber;
                        nextEffect = sibling;
                        break;
                      }

                      nextEffect = returnFiber;
                    }
                  }
                }

                var previousFiber = fiber.alternate;

                if (null !== previousFiber) {
                  var detachedChild = previousFiber.child;

                  if (null !== detachedChild) {
                    previousFiber.child = null;

                    do {
                      var detachedSibling = detachedChild.sibling;
                      detachedChild.sibling = null;
                      detachedChild = detachedSibling;
                    } while (null !== detachedChild);
                  }
                }

                nextEffect = fiber;
              }
            }

            if (0 !== (fiber.subtreeFlags & 1040) && null !== child) child.return = fiber, nextEffect = child;else b: for (; null !== nextEffect;) {
              fiber = nextEffect;
              if (0 !== (fiber.flags & 1024)) switch (fiber.tag) {
                case 0:
                case 11:
                case 15:
                  commitHookEffectListUnmount(5, fiber, fiber.return);
              }
              var sibling$jscomp$0 = fiber.sibling;

              if (null !== sibling$jscomp$0) {
                sibling$jscomp$0.return = fiber.return;
                nextEffect = sibling$jscomp$0;
                break b;
              }

              nextEffect = fiber.return;
            }
          }

          var finishedWork = renderPriority.current;

          for (nextEffect = finishedWork; null !== nextEffect;) {
            child = nextEffect;
            var firstChild = child.child;
            if (0 !== (child.subtreeFlags & 1040) && null !== firstChild) firstChild.return = child, nextEffect = firstChild;else b: for (child = finishedWork; null !== nextEffect;) {
              deletions = nextEffect;
              if (0 !== (deletions.flags & 1024)) try {
                switch (deletions.tag) {
                  case 0:
                  case 11:
                  case 15:
                    commitHookEffectListMount(5, deletions);
                }
              } catch (error) {
                captureCommitPhaseError(deletions, deletions.return, error);
              }

              if (deletions === child) {
                nextEffect = null;
                break b;
              }

              var sibling$jscomp$1 = deletions.sibling;

              if (null !== sibling$jscomp$1) {
                sibling$jscomp$1.return = deletions.return;
                nextEffect = sibling$jscomp$1;
                break b;
              }

              nextEffect = deletions.return;
            }
          }

          executionContext = prevExecutionContext;
          flushSyncCallbacks();
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot) try {
            injectedHook.onPostCommitFiberRoot(rendererID, renderPriority);
          } catch (err) {}
          JSCompiler_inline_result = true;
        }
        return JSCompiler_inline_result;
      } finally {
        currentUpdatePriority = previousPriority, ReactCurrentBatchConfig$2.transition = prevTransition;
      }
    }

    return false;
  }

  function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
    sourceFiber = createCapturedValue(error, sourceFiber);
    sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, 1);
    enqueueUpdate(rootFiber, sourceFiber);
    sourceFiber = requestEventTime();
    rootFiber = markUpdateLaneFromFiberToRoot(rootFiber, 1);
    null !== rootFiber && (markRootUpdated(rootFiber, 1, sourceFiber), ensureRootIsScheduled(rootFiber, sourceFiber));
  }

  function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
    if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);else for (nearestMountedAncestor = sourceFiber.return; null !== nearestMountedAncestor;) {
      if (3 === nearestMountedAncestor.tag) {
        captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
        break;
      } else if (1 === nearestMountedAncestor.tag) {
        var instance = nearestMountedAncestor.stateNode;

        if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
          sourceFiber = createCapturedValue(error, sourceFiber);
          sourceFiber = createClassErrorUpdate(nearestMountedAncestor, sourceFiber, 1);
          enqueueUpdate(nearestMountedAncestor, sourceFiber);
          sourceFiber = requestEventTime();
          nearestMountedAncestor = markUpdateLaneFromFiberToRoot(nearestMountedAncestor, 1);
          null !== nearestMountedAncestor && (markRootUpdated(nearestMountedAncestor, 1, sourceFiber), ensureRootIsScheduled(nearestMountedAncestor, sourceFiber));
          break;
        }
      }

      nearestMountedAncestor = nearestMountedAncestor.return;
    }
  }

  function pingSuspendedRoot(root, wakeable, pingedLanes) {
    var pingCache = root.pingCache;
    null !== pingCache && pingCache.delete(wakeable);
    wakeable = requestEventTime();
    root.pingedLanes |= root.suspendedLanes & pingedLanes;
    workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 130023424) === workInProgressRootRenderLanes && 500 > _$$_REQUIRE(_dependencyMap[4]).unstable_now() - globalMostRecentFallbackTime ? prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes);
    ensureRootIsScheduled(root, wakeable);
  }

  function resolveRetryWakeable(boundaryFiber, wakeable) {
    var retryCache = boundaryFiber.stateNode;
    null !== retryCache && retryCache.delete(wakeable);
    wakeable = 0;
    0 === wakeable && (0 === (boundaryFiber.mode & 1) ? wakeable = 1 : (wakeable = nextRetryLane, nextRetryLane <<= 1, 0 === (nextRetryLane & 130023424) && (nextRetryLane = 4194304)));
    retryCache = requestEventTime();
    boundaryFiber = markUpdateLaneFromFiberToRoot(boundaryFiber, wakeable);
    null !== boundaryFiber && (markRootUpdated(boundaryFiber, wakeable, retryCache), ensureRootIsScheduled(boundaryFiber, retryCache));
  }

  var beginWork$1;

  beginWork$1 = function beginWork$1(current, workInProgress, renderLanes) {
    var updateLanes = workInProgress.lanes;
    if (null !== current) {
      if (current.memoizedProps !== workInProgress.pendingProps || didPerformWorkStackCursor.current) didReceiveUpdate = true;else {
        if (0 === (renderLanes & updateLanes)) {
          didReceiveUpdate = false;

          switch (workInProgress.tag) {
            case 3:
              pushHostRootContext(workInProgress);
              break;

            case 5:
              pushHostContext(workInProgress);
              break;

            case 1:
              isContextProvider(workInProgress.type) && pushContextProvider(workInProgress);
              break;

            case 4:
              pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
              break;

            case 10:
              updateLanes = workInProgress.type._context;
              var nextValue = workInProgress.memoizedProps.value;
              push(valueCursor, updateLanes._currentValue2);
              updateLanes._currentValue2 = nextValue;
              break;

            case 13:
              if (null !== workInProgress.memoizedState) {
                if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);
                push(suspenseStackCursor, suspenseStackCursor.current & 1);
                workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                return null !== workInProgress ? workInProgress.sibling : null;
              }

              push(suspenseStackCursor, suspenseStackCursor.current & 1);
              break;

            case 19:
              updateLanes = 0 !== (renderLanes & workInProgress.childLanes);

              if (0 !== (current.flags & 128)) {
                if (updateLanes) return updateSuspenseListComponent(current, workInProgress, renderLanes);
                workInProgress.flags |= 128;
              }

              nextValue = workInProgress.memoizedState;
              null !== nextValue && (nextValue.rendering = null, nextValue.tail = null, nextValue.lastEffect = null);
              push(suspenseStackCursor, suspenseStackCursor.current);
              if (updateLanes) break;else return null;

            case 22:
            case 23:
              return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes);
          }

          return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
        }

        didReceiveUpdate = 0 !== (current.flags & 32768) ? true : false;
      }
    } else didReceiveUpdate = false;
    workInProgress.lanes = 0;

    switch (workInProgress.tag) {
      case 2:
        updateLanes = workInProgress.type;
        null !== current && (current.alternate = null, workInProgress.alternate = null, workInProgress.flags |= 2);
        current = workInProgress.pendingProps;
        nextValue = getMaskedContext(workInProgress, contextStackCursor.current);
        prepareToReadContext(workInProgress, renderLanes);
        nextValue = renderWithHooks(null, workInProgress, updateLanes, current, nextValue, renderLanes);
        workInProgress.flags |= 1;

        if ("object" === typeof nextValue && null !== nextValue && "function" === typeof nextValue.render && undefined === nextValue.$$typeof) {
          workInProgress.tag = 1;
          workInProgress.memoizedState = null;
          workInProgress.updateQueue = null;

          if (isContextProvider(updateLanes)) {
            var hasContext = true;
            pushContextProvider(workInProgress);
          } else hasContext = false;

          workInProgress.memoizedState = null !== nextValue.state && undefined !== nextValue.state ? nextValue.state : null;
          initializeUpdateQueue(workInProgress);
          nextValue.updater = classComponentUpdater;
          workInProgress.stateNode = nextValue;
          nextValue._reactInternals = workInProgress;
          mountClassInstance(workInProgress, updateLanes, current, renderLanes);
          workInProgress = finishClassComponent(null, workInProgress, updateLanes, true, hasContext, renderLanes);
        } else workInProgress.tag = 0, reconcileChildren(null, workInProgress, nextValue, renderLanes), workInProgress = workInProgress.child;

        return workInProgress;

      case 16:
        nextValue = workInProgress.elementType;

        a: {
          null !== current && (current.alternate = null, workInProgress.alternate = null, workInProgress.flags |= 2);
          current = workInProgress.pendingProps;
          hasContext = nextValue._init;
          nextValue = hasContext(nextValue._payload);
          workInProgress.type = nextValue;
          hasContext = workInProgress.tag = resolveLazyComponentTag(nextValue);
          current = resolveDefaultProps(nextValue, current);

          switch (hasContext) {
            case 0:
              workInProgress = updateFunctionComponent(null, workInProgress, nextValue, current, renderLanes);
              break a;

            case 1:
              workInProgress = updateClassComponent(null, workInProgress, nextValue, current, renderLanes);
              break a;

            case 11:
              workInProgress = updateForwardRef(null, workInProgress, nextValue, current, renderLanes);
              break a;

            case 14:
              workInProgress = updateMemoComponent(null, workInProgress, nextValue, resolveDefaultProps(nextValue.type, current), updateLanes, renderLanes);
              break a;
          }

          throw Error("Element type is invalid. Received a promise that resolves to: " + nextValue + ". Lazy element type must resolve to a class or function.");
        }

        return workInProgress;

      case 0:
        return updateLanes = workInProgress.type, nextValue = workInProgress.pendingProps, nextValue = workInProgress.elementType === updateLanes ? nextValue : resolveDefaultProps(updateLanes, nextValue), updateFunctionComponent(current, workInProgress, updateLanes, nextValue, renderLanes);

      case 1:
        return updateLanes = workInProgress.type, nextValue = workInProgress.pendingProps, nextValue = workInProgress.elementType === updateLanes ? nextValue : resolveDefaultProps(updateLanes, nextValue), updateClassComponent(current, workInProgress, updateLanes, nextValue, renderLanes);

      case 3:
        pushHostRootContext(workInProgress);
        updateLanes = workInProgress.updateQueue;
        if (null === current || null === updateLanes) throw Error("If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.");
        nextValue = workInProgress.pendingProps;
        updateLanes = workInProgress.memoizedState.element;
        cloneUpdateQueue(current, workInProgress);
        processUpdateQueue(workInProgress, nextValue, null, renderLanes);
        nextValue = workInProgress.memoizedState.element;
        nextValue === updateLanes ? workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) : (reconcileChildren(current, workInProgress, nextValue, renderLanes), workInProgress = workInProgress.child);
        return workInProgress;

      case 5:
        return pushHostContext(workInProgress), updateLanes = workInProgress.pendingProps.children, markRef(current, workInProgress), reconcileChildren(current, workInProgress, updateLanes, renderLanes), workInProgress.child;

      case 6:
        return null;

      case 13:
        return updateSuspenseComponent(current, workInProgress, renderLanes);

      case 4:
        return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), updateLanes = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, updateLanes, renderLanes) : reconcileChildren(current, workInProgress, updateLanes, renderLanes), workInProgress.child;

      case 11:
        return updateLanes = workInProgress.type, nextValue = workInProgress.pendingProps, nextValue = workInProgress.elementType === updateLanes ? nextValue : resolveDefaultProps(updateLanes, nextValue), updateForwardRef(current, workInProgress, updateLanes, nextValue, renderLanes);

      case 7:
        return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;

      case 8:
        return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;

      case 12:
        return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;

      case 10:
        a: {
          updateLanes = workInProgress.type._context;
          nextValue = workInProgress.pendingProps;
          hasContext = workInProgress.memoizedProps;
          var newValue = nextValue.value;
          push(valueCursor, updateLanes._currentValue2);
          updateLanes._currentValue2 = newValue;
          if (null !== hasContext) if (objectIs(hasContext.value, newValue)) {
            if (hasContext.children === nextValue.children && !didPerformWorkStackCursor.current) {
              workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
              break a;
            }
          } else for (newValue = workInProgress.child, null !== newValue && (newValue.return = workInProgress); null !== newValue;) {
            var list = newValue.dependencies;

            if (null !== list) {
              hasContext = newValue.child;

              for (var dependency = list.firstContext; null !== dependency;) {
                if (dependency.context === updateLanes) {
                  if (1 === newValue.tag) {
                    dependency = createUpdate(-1, renderLanes & -renderLanes);
                    dependency.tag = 2;
                    var updateQueue = newValue.updateQueue;

                    if (null !== updateQueue) {
                      updateQueue = updateQueue.shared;
                      var pending = updateQueue.pending;
                      null === pending ? dependency.next = dependency : (dependency.next = pending.next, pending.next = dependency);
                      updateQueue.pending = dependency;
                    }
                  }

                  newValue.lanes |= renderLanes;
                  dependency = newValue.alternate;
                  null !== dependency && (dependency.lanes |= renderLanes);
                  scheduleWorkOnParentPath(newValue.return, renderLanes);
                  list.lanes |= renderLanes;
                  break;
                }

                dependency = dependency.next;
              }
            } else hasContext = 10 === newValue.tag ? newValue.type === workInProgress.type ? null : newValue.child : newValue.child;

            if (null !== hasContext) hasContext.return = newValue;else for (hasContext = newValue; null !== hasContext;) {
              if (hasContext === workInProgress) {
                hasContext = null;
                break;
              }

              newValue = hasContext.sibling;

              if (null !== newValue) {
                newValue.return = hasContext.return;
                hasContext = newValue;
                break;
              }

              hasContext = hasContext.return;
            }
            newValue = hasContext;
          }
          reconcileChildren(current, workInProgress, nextValue.children, renderLanes);
          workInProgress = workInProgress.child;
        }

        return workInProgress;

      case 9:
        return nextValue = workInProgress.type, updateLanes = workInProgress.pendingProps.children, prepareToReadContext(workInProgress, renderLanes), nextValue = readContext(nextValue), updateLanes = updateLanes(nextValue), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, updateLanes, renderLanes), workInProgress.child;

      case 14:
        return nextValue = workInProgress.type, hasContext = resolveDefaultProps(nextValue, workInProgress.pendingProps), hasContext = resolveDefaultProps(nextValue.type, hasContext), updateMemoComponent(current, workInProgress, nextValue, hasContext, updateLanes, renderLanes);

      case 15:
        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, updateLanes, renderLanes);

      case 17:
        return updateLanes = workInProgress.type, nextValue = workInProgress.pendingProps, nextValue = workInProgress.elementType === updateLanes ? nextValue : resolveDefaultProps(updateLanes, nextValue), null !== current && (current.alternate = null, workInProgress.alternate = null, workInProgress.flags |= 2), workInProgress.tag = 1, isContextProvider(updateLanes) ? (current = true, pushContextProvider(workInProgress)) : current = false, prepareToReadContext(workInProgress, renderLanes), constructClassInstance(workInProgress, updateLanes, nextValue), mountClassInstance(workInProgress, updateLanes, nextValue, renderLanes), finishClassComponent(null, workInProgress, updateLanes, true, current, renderLanes);

      case 19:
        return updateSuspenseListComponent(current, workInProgress, renderLanes);

      case 22:
        return updateOffscreenComponent(current, workInProgress, renderLanes);

      case 23:
        return updateOffscreenComponent(current, workInProgress, renderLanes);
    }

    throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
  };

  function FiberNode(tag, pendingProps, key, mode) {
    this.tag = tag;
    this.key = key;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = pendingProps;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = mode;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }

  function createFiber(tag, pendingProps, key, mode) {
    return new FiberNode(tag, pendingProps, key, mode);
  }

  function shouldConstruct(Component) {
    Component = Component.prototype;
    return !(!Component || !Component.isReactComponent);
  }

  function resolveLazyComponentTag(Component) {
    if ("function" === typeof Component) return shouldConstruct(Component) ? 1 : 0;

    if (undefined !== Component && null !== Component) {
      Component = Component.$$typeof;
      if (Component === REACT_FORWARD_REF_TYPE) return 11;
      if (Component === REACT_MEMO_TYPE) return 14;
    }

    return 2;
  }

  function createWorkInProgress(current, pendingProps) {
    var workInProgress = current.alternate;
    null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null);
    workInProgress.flags = current.flags & 1835008;
    workInProgress.childLanes = current.childLanes;
    workInProgress.lanes = current.lanes;
    workInProgress.child = current.child;
    workInProgress.memoizedProps = current.memoizedProps;
    workInProgress.memoizedState = current.memoizedState;
    workInProgress.updateQueue = current.updateQueue;
    pendingProps = current.dependencies;
    workInProgress.dependencies = null === pendingProps ? null : {
      lanes: pendingProps.lanes,
      firstContext: pendingProps.firstContext
    };
    workInProgress.sibling = current.sibling;
    workInProgress.index = current.index;
    workInProgress.ref = current.ref;
    return workInProgress;
  }

  function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
    var fiberTag = 2;
    owner = type;
    if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);else if ("string" === typeof type) fiberTag = 5;else a: switch (type) {
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);

      case REACT_DEBUG_TRACING_MODE_TYPE:
        fiberTag = 8;
        mode |= 4;
        break;

      case REACT_STRICT_MODE_TYPE:
        fiberTag = 8;
        mode |= 8;
        break;

      case REACT_PROFILER_TYPE:
        return type = createFiber(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;

      case REACT_SUSPENSE_TYPE:
        return type = createFiber(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;

      case REACT_SUSPENSE_LIST_TYPE:
        return type = createFiber(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;

      case REACT_OFFSCREEN_TYPE:
        return createFiberFromOffscreen(pendingProps, mode, lanes, key);

      case REACT_LEGACY_HIDDEN_TYPE:
        return type = createFiber(23, pendingProps, key, mode), type.elementType = REACT_LEGACY_HIDDEN_TYPE, type.lanes = lanes, type;

      default:
        if ("object" === typeof type && null !== type) switch (type.$$typeof) {
          case REACT_PROVIDER_TYPE:
            fiberTag = 10;
            break a;

          case REACT_CONTEXT_TYPE:
            fiberTag = 9;
            break a;

          case REACT_FORWARD_REF_TYPE:
            fiberTag = 11;
            break a;

          case REACT_MEMO_TYPE:
            fiberTag = 14;
            break a;

          case REACT_LAZY_TYPE:
            fiberTag = 16;
            owner = null;
            break a;
        }
        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (null == type ? type : typeof type) + ".");
    }
    key = createFiber(fiberTag, pendingProps, key, mode);
    key.elementType = type;
    key.type = owner;
    key.lanes = lanes;
    return key;
  }

  function createFiberFromFragment(elements, mode, lanes, key) {
    elements = createFiber(7, elements, key, mode);
    elements.lanes = lanes;
    return elements;
  }

  function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
    pendingProps = createFiber(22, pendingProps, key, mode);
    pendingProps.elementType = REACT_OFFSCREEN_TYPE;
    pendingProps.lanes = lanes;
    return pendingProps;
  }

  function createFiberFromText(content, mode, lanes) {
    content = createFiber(6, content, null, mode);
    content.lanes = lanes;
    return content;
  }

  function createFiberFromPortal(portal, mode, lanes) {
    mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);
    mode.lanes = lanes;
    mode.stateNode = {
      containerInfo: portal.containerInfo,
      pendingChildren: null,
      implementation: portal.implementation
    };
    return mode;
  }

  function FiberRootNode(containerInfo, tag, hydrate) {
    this.tag = tag;
    this.containerInfo = containerInfo;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.pendingContext = this.context = null;
    this.hydrate = hydrate;
    this.callbackNode = null;
    this.callbackPriority = 0;
    this.eventTimes = createLaneMap(0);
    this.expirationTimes = createLaneMap(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = createLaneMap(0);
  }

  function createPortal(children, containerInfo, implementation) {
    var key = 3 < arguments.length && undefined !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: REACT_PORTAL_TYPE,
      key: null == key ? null : "" + key,
      children: children,
      containerInfo: containerInfo,
      implementation: implementation
    };
  }

  function findHostInstance(component) {
    var fiber = component._reactInternals;

    if (undefined === fiber) {
      if ("function" === typeof component.render) throw Error("Unable to find node on an unmounted component.");
      throw Error("Argument appears to not be a ReactComponent. Keys: " + Object.keys(component));
    }

    component = findCurrentHostFiber(fiber);
    return null === component ? null : component.stateNode;
  }

  function updateContainer(element, container, parentComponent, callback) {
    var current = container.current,
        eventTime = requestEventTime(),
        lane = requestUpdateLane(current);

    a: if (parentComponent) {
      parentComponent = parentComponent._reactInternals;

      b: {
        if (getNearestMountedFiber(parentComponent) !== parentComponent || 1 !== parentComponent.tag) throw Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var JSCompiler_inline_result = parentComponent;

        do {
          switch (JSCompiler_inline_result.tag) {
            case 3:
              JSCompiler_inline_result = JSCompiler_inline_result.stateNode.context;
              break b;

            case 1:
              if (isContextProvider(JSCompiler_inline_result.type)) {
                JSCompiler_inline_result = JSCompiler_inline_result.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }

          }

          JSCompiler_inline_result = JSCompiler_inline_result.return;
        } while (null !== JSCompiler_inline_result);

        throw Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }

      if (1 === parentComponent.tag) {
        var Component = parentComponent.type;

        if (isContextProvider(Component)) {
          parentComponent = processChildContext(parentComponent, Component, JSCompiler_inline_result);
          break a;
        }
      }

      parentComponent = JSCompiler_inline_result;
    } else parentComponent = emptyContextObject;

    null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
    container = createUpdate(eventTime, lane);
    container.payload = {
      element: element
    };
    callback = undefined === callback ? null : callback;
    null !== callback && (container.callback = callback);
    enqueueUpdate(current, container);
    element = scheduleUpdateOnFiber(current, lane, eventTime);
    null !== element && entangleTransitions(element, current, lane);
    return lane;
  }

  function emptyFindFiberByHostInstance() {
    return null;
  }

  function findNodeHandle(componentOrHandle) {
    if (null == componentOrHandle) return null;
    if ("number" === typeof componentOrHandle) return componentOrHandle;
    if (componentOrHandle._nativeTag) return componentOrHandle._nativeTag;
    if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) return componentOrHandle.canonical._nativeTag;
    componentOrHandle = findHostInstance(componentOrHandle);
    return null == componentOrHandle ? componentOrHandle : componentOrHandle.canonical ? componentOrHandle.canonical._nativeTag : componentOrHandle._nativeTag;
  }

  batchedUpdatesImpl = function batchedUpdatesImpl(fn, a) {
    var prevExecutionContext = executionContext;
    executionContext |= 1;

    try {
      return fn(a);
    } finally {
      executionContext = prevExecutionContext, 0 === executionContext && (workInProgressRootRenderTargetTime = _$$_REQUIRE(_dependencyMap[4]).unstable_now() + 500, includesLegacySyncCallbacks && flushSyncCallbacks());
    }
  };

  var roots = new Map(),
      devToolsConfig$jscomp$inline_939 = {
    findFiberByHostInstance: getInstanceFromInstance,
    bundleType: 0,
    version: "18.0.0-experimental-568dc3532",
    rendererPackageName: "react-native-renderer",
    rendererConfig: {
      getInspectorDataForViewTag: function getInspectorDataForViewTag() {
        throw Error("getInspectorDataForViewTag() is not available in production");
      },
      getInspectorDataForViewAtPoint: function () {
        throw Error("getInspectorDataForViewAtPoint() is not available in production.");
      }.bind(null, findNodeHandle)
    }
  };
  var internals$jscomp$inline_1177 = {
    bundleType: devToolsConfig$jscomp$inline_939.bundleType,
    version: devToolsConfig$jscomp$inline_939.version,
    rendererPackageName: devToolsConfig$jscomp$inline_939.rendererPackageName,
    rendererConfig: devToolsConfig$jscomp$inline_939.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ReactSharedInternals.ReactCurrentDispatcher,
    findHostInstanceByFiber: function findHostInstanceByFiber(fiber) {
      fiber = findCurrentHostFiber(fiber);
      return null === fiber ? null : fiber.stateNode;
    },
    findFiberByHostInstance: devToolsConfig$jscomp$inline_939.findFiberByHostInstance || emptyFindFiberByHostInstance,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.0.0-experimental-568dc3532"
  };

  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var hook$jscomp$inline_1178 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!hook$jscomp$inline_1178.isDisabled && hook$jscomp$inline_1178.supportsFiber) try {
      rendererID = hook$jscomp$inline_1178.inject(internals$jscomp$inline_1177), injectedHook = hook$jscomp$inline_1178;
    } catch (err) {}
  }

  exports.createPortal = function (children, containerTag) {
    return createPortal(children, containerTag, null, 2 < arguments.length && undefined !== arguments[2] ? arguments[2] : null);
  };

  exports.dispatchCommand = function (handle, command, args) {
    null != handle._nativeTag && (handle._internalInstanceHandle ? nativeFabricUIManager.dispatchCommand(handle._internalInstanceHandle.stateNode.node, command, args) : _$$_REQUIRE(_dependencyMap[3]).UIManager.dispatchViewManagerCommand(handle._nativeTag, command, args));
  };

  exports.findHostInstance_DEPRECATED = function (componentOrHandle) {
    if (null == componentOrHandle) return null;
    if (componentOrHandle._nativeTag) return componentOrHandle;
    if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) return componentOrHandle.canonical;
    componentOrHandle = findHostInstance(componentOrHandle);
    return null == componentOrHandle ? componentOrHandle : componentOrHandle.canonical ? componentOrHandle.canonical : componentOrHandle;
  };

  exports.findNodeHandle = findNodeHandle;

  exports.render = function (element, containerTag, callback, concurrentRoot) {
    var root = roots.get(containerTag);
    root || (root = concurrentRoot ? 1 : 0, concurrentRoot = new FiberRootNode(containerTag, root, false), root = createFiber(3, null, null, 1 === root ? 1 : 0), concurrentRoot.current = root, root.stateNode = concurrentRoot, root.memoizedState = {
      element: null
    }, initializeUpdateQueue(root), root = concurrentRoot, roots.set(containerTag, root));
    updateContainer(element, root, null, callback);

    a: if (element = root.current, element.child) switch (element.child.tag) {
      case 5:
        element = element.child.stateNode.canonical;
        break a;

      default:
        element = element.child.stateNode;
    } else element = null;

    return element;
  };

  exports.sendAccessibilityEvent = function (handle, eventType) {
    null != handle._nativeTag && (handle._internalInstanceHandle ? nativeFabricUIManager.sendAccessibilityEvent(handle._internalInstanceHandle.stateNode.node, eventType) : _$$_REQUIRE(_dependencyMap[3]).legacySendAccessibilityEvent(handle._nativeTag, eventType));
  };

  exports.stopSurface = function (containerTag) {
    var root = roots.get(containerTag);
    root && updateContainer(null, root, null, function () {
      roots.delete(containerTag);
    });
  };

  exports.unmountComponentAtNode = function (containerTag) {
    this.stopSurface(containerTag);
  };
},"node_modules/react-native/Libraries/Renderer/implementations/ReactFabric-prod.js",["node_modules/react-native/Libraries/ReactPrivate/ReactNativePrivateInitializeCore.js","node_modules/react/index.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/ReactPrivate/ReactNativePrivateInterface.js","node_modules/scheduler/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.coerceDisplayMode = coerceDisplayMode;
  exports.default = undefined;
  var DisplayMode = Object.freeze({
    VISIBLE: 1,
    SUSPENDED: 2,
    HIDDEN: 3
  });

  function coerceDisplayMode(value) {
    switch (value) {
      case DisplayMode.SUSPENDED:
        return DisplayMode.SUSPENDED;

      case DisplayMode.HIDDEN:
        return DisplayMode.HIDDEN;

      default:
        return DisplayMode.VISIBLE;
    }
  }

  var _default = DisplayMode;
  exports.default = _default;
},"node_modules/react-native/Libraries/ReactNative/DisplayMode.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _RCTDeviceEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _NativeRedBox = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _NativeBugReporting = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function defaultExtras() {
    BugReporting.addFileSource('react_hierarchy.txt', function () {
      return _$$_REQUIRE(_dependencyMap[7])();
    });
  }

  var BugReporting = function () {
    function BugReporting() {
      (0, _classCallCheck2.default)(this, BugReporting);
    }

    (0, _createClass2.default)(BugReporting, null, [{
      key: "_maybeInit",
      value: function _maybeInit() {
        if (!BugReporting._subscription) {
          BugReporting._subscription = _RCTDeviceEventEmitter.default.addListener('collectBugExtraData', BugReporting.collectExtraData, null);
          defaultExtras();
        }

        if (!BugReporting._redboxSubscription) {
          BugReporting._redboxSubscription = _RCTDeviceEventEmitter.default.addListener('collectRedBoxExtraData', BugReporting.collectExtraData, null);
        }
      }
    }, {
      key: "addSource",
      value: function addSource(key, callback) {
        return this._addSource(key, callback, BugReporting._extraSources);
      }
    }, {
      key: "addFileSource",
      value: function addFileSource(key, callback) {
        return this._addSource(key, callback, BugReporting._fileSources);
      }
    }, {
      key: "_addSource",
      value: function _addSource(key, callback, source) {
        BugReporting._maybeInit();

        if (source.has(key)) {
          console.warn("BugReporting.add* called multiple times for same key '" + key + "'");
        }

        source.set(key, callback);
        return {
          remove: function remove() {
            source.delete(key);
          }
        };
      }
    }, {
      key: "collectExtraData",
      value: function collectExtraData() {
        var extraData = {};

        for (var _iterator = _createForOfIteratorHelperLoose(BugReporting._extraSources), _step; !(_step = _iterator()).done;) {
          var _ref = _step.value;

          var _ref2 = (0, _slicedToArray2.default)(_ref, 2);

          var _key = _ref2[0];
          var callback = _ref2[1];
          extraData[_key] = callback();
        }

        var fileData = {};

        for (var _iterator2 = _createForOfIteratorHelperLoose(BugReporting._fileSources), _step2; !(_step2 = _iterator2()).done;) {
          var _ref3 = _step2.value;

          var _ref4 = (0, _slicedToArray2.default)(_ref3, 2);

          var _key2 = _ref4[0];
          var _callback = _ref4[1];
          fileData[_key2] = _callback();
        }

        if (_NativeBugReporting.default != null && _NativeBugReporting.default.setExtraData != null) {
          _NativeBugReporting.default.setExtraData(extraData, fileData);
        }

        if (_NativeRedBox.default != null && _NativeRedBox.default.setExtraData != null) {
          _NativeRedBox.default.setExtraData(extraData, 'From BugReporting.js');
        }

        return {
          extras: extraData,
          files: fileData
        };
      }
    }]);
    return BugReporting;
  }();

  BugReporting._extraSources = new Map();
  BugReporting._fileSources = new Map();
  BugReporting._subscription = null;
  BugReporting._redboxSubscription = null;
  module.exports = BugReporting;
},"node_modules/react-native/Libraries/BugReporting/BugReporting.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/EventEmitter/RCTDeviceEventEmitter.js","node_modules/react-native/Libraries/NativeModules/specs/NativeRedBox.js","node_modules/react-native/Libraries/BugReporting/NativeBugReporting.js","node_modules/react-native/Libraries/BugReporting/dumpReactTree.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('RedBox');

  exports.default = _default;
},"node_modules/react-native/Libraries/NativeModules/specs/NativeRedBox.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('BugReporting');

  exports.default = _default;
},"node_modules/react-native/Libraries/BugReporting/NativeBugReporting.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function dumpReactTree() {
    try {
      return getReactTree();
    } catch (e) {
      return 'Failed to dump react tree: ' + e;
    }
  }

  function getReactTree() {
    return "React tree dumps have been temporarily disabled while React is upgraded to Fiber.";
  }

  module.exports = dumpReactTree;
},"node_modules/react-native/Libraries/BugReporting/dumpReactTree.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _listeners = [];
  var _activeScene = {
    name: 'default'
  };
  var SceneTracker = {
    setActiveScene: function setActiveScene(scene) {
      _activeScene = scene;

      _listeners.forEach(function (listener) {
        return listener(_activeScene);
      });
    },
    getActiveScene: function getActiveScene() {
      return _activeScene;
    },
    addActiveSceneChangedListener: function addActiveSceneChangedListener(callback) {
      _listeners.push(callback);

      return {
        remove: function remove() {
          _listeners = _listeners.filter(function (listener) {
            return callback !== listener;
          });
        }
      };
    }
  };
  module.exports = SceneTracker;
},"node_modules/react-native/Libraries/Utilities/SceneTracker.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _NativeEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _logError = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _NativeAppState = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var AppState = function () {
    function AppState() {
      var _this = this;

      (0, _classCallCheck2.default)(this, AppState);
      this.currentState = null;

      if (_NativeAppState.default == null) {
        this.isAvailable = false;
      } else {
        this.isAvailable = true;
        var emitter = new _NativeEventEmitter.default(_Platform.default.OS !== 'ios' ? null : _NativeAppState.default);
        this._emitter = emitter;
        this.currentState = _NativeAppState.default.getConstants().initialAppState;
        var eventUpdated = false;
        emitter.addListener('appStateDidChange', function (appStateData) {
          eventUpdated = true;
          _this.currentState = appStateData.app_state;
        });

        _NativeAppState.default.getCurrentAppState(function (appStateData) {
          if (!eventUpdated && _this.currentState !== appStateData.app_state) {
            _this.currentState = appStateData.app_state;
            emitter.emit('appStateDidChange', appStateData);
          }
        }, _logError.default);
      }
    }

    (0, _createClass2.default)(AppState, [{
      key: "addEventListener",
      value: function addEventListener(type, handler) {
        var emitter = this._emitter;

        if (emitter == null) {
          throw new Error('Cannot use AppState when `isAvailable` is false.');
        }

        switch (type) {
          case 'change':
            var changeHandler = handler;
            return emitter.addListener('appStateDidChange', function (appStateData) {
              changeHandler(appStateData.app_state);
            });

          case 'memoryWarning':
            var memoryWarningHandler = handler;
            return emitter.addListener('memoryWarning', memoryWarningHandler);

          case 'blur':
          case 'focus':
            var focusOrBlurHandler = handler;
            return emitter.addListener('appStateFocusChange', function (hasFocus) {
              if (type === 'blur' && !hasFocus) {
                focusOrBlurHandler();
              }

              if (type === 'focus' && hasFocus) {
                focusOrBlurHandler();
              }
            });
        }

        throw new Error('Trying to subscribe to unknown event: ' + type);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener) {
        var emitter = this._emitter;

        if (emitter == null) {
          throw new Error('Cannot use AppState when `isAvailable` is false.');
        }

        switch (type) {
          case 'change':
            emitter.removeListener('appStateDidChange', listener);
            return;

          case 'memoryWarning':
            emitter.removeListener('memoryWarning', listener);
            return;

          case 'blur':
          case 'focus':
            emitter.addListener('appStateFocusChange', listener);
            return;
        }

        throw new Error('Trying to unsubscribe from unknown event: ' + type);
      }
    }]);
    return AppState;
  }();

  module.exports = new AppState();
},"node_modules/react-native/Libraries/AppState/AppState.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/EventEmitter/NativeEventEmitter.js","node_modules/react-native/Libraries/Utilities/logError.js","node_modules/react-native/Libraries/AppState/NativeAppState.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var logError = function logError() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 1 && args[0] instanceof Error) {
      var err = args[0];
      console.error('Error: "' + err.message + '".  Stack:\n' + err.stack);
    } else {
      console.error.apply(console, args);
    }
  };

  module.exports = logError;
},"node_modules/react-native/Libraries/Utilities/logError.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.getEnforcing('AppState');

  exports.default = _default;
},"node_modules/react-native/Libraries/AppState/NativeAppState.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _NativeAsyncLocalStorage = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _NativeAsyncSQLiteDBStorage = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var RCTAsyncStorage = _NativeAsyncSQLiteDBStorage.default || _NativeAsyncLocalStorage.default;
  var AsyncStorage = {
    _getRequests: [],
    _getKeys: [],
    _immediate: null,
    getItem: function getItem(key, callback) {
      (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiGet([key], function (errors, result) {
          var value = result && result[0] && result[0][1] ? result[0][1] : null;
          var errs = convertErrors(errors);
          callback && callback(errs && errs[0], value);

          if (errs) {
            reject(errs[0]);
          } else {
            resolve(value);
          }
        });
      });
    },
    setItem: function setItem(key, value, callback) {
      (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiSet([[key, value]], function (errors) {
          var errs = convertErrors(errors);
          callback && callback(errs && errs[0]);

          if (errs) {
            reject(errs[0]);
          } else {
            resolve();
          }
        });
      });
    },
    removeItem: function removeItem(key, callback) {
      (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiRemove([key], function (errors) {
          var errs = convertErrors(errors);
          callback && callback(errs && errs[0]);

          if (errs) {
            reject(errs[0]);
          } else {
            resolve();
          }
        });
      });
    },
    mergeItem: function mergeItem(key, value, callback) {
      (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiMerge([[key, value]], function (errors) {
          var errs = convertErrors(errors);
          callback && callback(errs && errs[0]);

          if (errs) {
            reject(errs[0]);
          } else {
            resolve();
          }
        });
      });
    },
    clear: function clear(callback) {
      (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.clear(function (error) {
          callback && callback(convertError(error));

          if (error && convertError(error)) {
            reject(convertError(error));
          } else {
            resolve();
          }
        });
      });
    },
    getAllKeys: function getAllKeys(callback) {
      (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.getAllKeys(function (error, keys) {
          callback && callback(convertError(error), keys);

          if (error) {
            reject(convertError(error));
          } else {
            resolve(keys);
          }
        });
      });
    },
    flushGetRequests: function flushGetRequests() {
      var getRequests = this._getRequests;
      var getKeys = this._getKeys;
      this._getRequests = [];
      this._getKeys = [];
      (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');
      RCTAsyncStorage.multiGet(getKeys, function (errors, result) {
        var map = {};
        result && result.forEach(function (_ref) {
          var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
              key = _ref2[0],
              value = _ref2[1];

          map[key] = value;
          return value;
        });
        var reqLength = getRequests.length;

        for (var i = 0; i < reqLength; i++) {
          var request = getRequests[i];
          var requestKeys = request.keys;
          var requestResult = requestKeys.map(function (key) {
            return [key, map[key]];
          });
          request.callback && request.callback(null, requestResult);
          request.resolve && request.resolve(requestResult);
        }
      });
    },
    multiGet: function multiGet(keys, callback) {
      var _this = this;

      if (!this._immediate) {
        this._immediate = setImmediate(function () {
          _this._immediate = null;

          _this.flushGetRequests();
        });
      }

      return new Promise(function (resolve, reject) {
        _this._getRequests.push({
          keys: keys,
          callback: callback,
          keyIndex: _this._getKeys.length,
          resolve: resolve,
          reject: reject
        });

        keys.forEach(function (key) {
          if (_this._getKeys.indexOf(key) === -1) {
            _this._getKeys.push(key);
          }
        });
      });
    },
    multiSet: function multiSet(keyValuePairs, callback) {
      (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiSet(keyValuePairs, function (errors) {
          var error = convertErrors(errors);
          callback && callback(error);

          if (error) {
            reject(error);
          } else {
            resolve();
          }
        });
      });
    },
    multiRemove: function multiRemove(keys, callback) {
      (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiRemove(keys, function (errors) {
          var error = convertErrors(errors);
          callback && callback(error);

          if (error) {
            reject(error);
          } else {
            resolve();
          }
        });
      });
    },
    multiMerge: function multiMerge(keyValuePairs, callback) {
      (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');
      return new Promise(function (resolve, reject) {
        RCTAsyncStorage.multiMerge(keyValuePairs, function (errors) {
          var error = convertErrors(errors);
          callback && callback(error);

          if (error) {
            reject(error);
          } else {
            resolve();
          }
        });
      });
    }
  };

  if (RCTAsyncStorage && !RCTAsyncStorage.multiMerge) {
    delete AsyncStorage.mergeItem;
    delete AsyncStorage.multiMerge;
  }

  function convertErrors(errs) {
    if (!errs) {
      return null;
    }

    return (Array.isArray(errs) ? errs : [errs]).map(function (e) {
      return convertError(e);
    });
  }

  function convertError(error) {
    if (!error) {
      return null;
    }

    var out = new Error(error.message);
    out.key = error.key;
    return out;
  }

  module.exports = AsyncStorage;
},"node_modules/react-native/Libraries/Storage/AsyncStorage.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react-native/Libraries/Storage/NativeAsyncLocalStorage.js","node_modules/react-native/Libraries/Storage/NativeAsyncSQLiteDBStorage.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('AsyncLocalStorage');

  exports.default = _default;
},"node_modules/react-native/Libraries/Storage/NativeAsyncLocalStorage.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('AsyncSQLiteDBStorage');

  exports.default = _default;
},"node_modules/react-native/Libraries/Storage/NativeAsyncSQLiteDBStorage.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _NativeClipboard = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  module.exports = {
    getString: function getString() {
      return _NativeClipboard.default.getString();
    },
    setString: function setString(content) {
      _NativeClipboard.default.setString(content);
    }
  };
},"node_modules/react-native/Libraries/Components/Clipboard/Clipboard.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Components/Clipboard/NativeClipboard.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.getEnforcing('Clipboard');

  exports.default = _default;
},"node_modules/react-native/Libraries/Components/Clipboard/NativeClipboard.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _NativeDeviceInfo = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  module.exports = _NativeDeviceInfo.default;
},"node_modules/react-native/Libraries/Utilities/DeviceInfo.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/NativeDeviceInfo.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _NativeDevSettings = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _NativeEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var DevSettings = {
    addMenuItem: function addMenuItem(title, handler) {},
    reload: function reload(reason) {},
    onFastRefresh: function onFastRefresh() {}
  };
  module.exports = DevSettings;
},"node_modules/react-native/Libraries/Utilities/DevSettings.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/NativeModules/specs/NativeDevSettings.js","node_modules/react-native/Libraries/EventEmitter/NativeEventEmitter.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.getEnforcing('DevSettings');

  exports.default = _default;
},"node_modules/react-native/Libraries/NativeModules/specs/NativeDevSettings.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _NativeImagePickerIOS = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var ImagePickerIOS = {
    canRecordVideos: function canRecordVideos(callback) {
      (0, _invariant.default)(_NativeImagePickerIOS.default, 'ImagePickerIOS is not available');
      return _NativeImagePickerIOS.default.canRecordVideos(callback);
    },
    canUseCamera: function canUseCamera(callback) {
      (0, _invariant.default)(_NativeImagePickerIOS.default, 'ImagePickerIOS is not available');
      return _NativeImagePickerIOS.default.canUseCamera(callback);
    },
    openCameraDialog: function openCameraDialog(config, successCallback, cancelCallback) {
      (0, _invariant.default)(_NativeImagePickerIOS.default, 'ImagePickerIOS is not available');
      var newConfig = {
        videoMode: true,
        unmirrorFrontFacingCamera: false
      };

      if (config.videoMode != null) {
        newConfig.videoMode = config.videoMode;
      }

      if (config.unmirrorFrontFacingCamera != null) {
        newConfig.unmirrorFrontFacingCamera = config.unmirrorFrontFacingCamera;
      }

      return _NativeImagePickerIOS.default.openCameraDialog(newConfig, successCallback, cancelCallback);
    },
    openSelectDialog: function openSelectDialog(config, successCallback, cancelCallback) {
      (0, _invariant.default)(_NativeImagePickerIOS.default, 'ImagePickerIOS is not available');
      var newConfig = {
        showImages: true,
        showVideos: false
      };

      if (config.showImages != null) {
        newConfig.showImages = config.showImages;
      }

      if (config.showVideos != null) {
        newConfig.showVideos = config.showVideos;
      }

      return _NativeImagePickerIOS.default.openSelectDialog(newConfig, successCallback, cancelCallback);
    },
    removePendingVideo: function removePendingVideo(url) {
      (0, _invariant.default)(_NativeImagePickerIOS.default, 'ImagePickerIOS is not available');

      _NativeImagePickerIOS.default.removePendingVideo(url);
    },
    clearAllPendingVideos: function clearAllPendingVideos() {
      (0, _invariant.default)(_NativeImagePickerIOS.default, 'ImagePickerIOS is not available');

      _NativeImagePickerIOS.default.clearAllPendingVideos();
    }
  };
  module.exports = ImagePickerIOS;
},"node_modules/react-native/Libraries/Image/ImagePickerIOS.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Image/NativeImagePickerIOS.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('ImagePickerIOS');

  exports.default = _default;
},"node_modules/react-native/Libraries/Image/NativeImagePickerIOS.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _NativeEventEmitter2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _InteractionManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _NativeLinkingManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _NativeIntentAndroid = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _nullthrows = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var Linking = function (_NativeEventEmitter) {
    (0, _inherits2.default)(Linking, _NativeEventEmitter);

    var _super = _createSuper(Linking);

    function Linking() {
      (0, _classCallCheck2.default)(this, Linking);
      return _super.call(this, _Platform.default.OS === 'ios' ? (0, _nullthrows.default)(_NativeLinkingManager.default) : undefined);
    }

    (0, _createClass2.default)(Linking, [{
      key: "addEventListener",
      value: function addEventListener(eventType, listener, context) {
        return this.addListener(eventType, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(eventType, listener) {
        this.removeListener(eventType, listener);
      }
    }, {
      key: "openURL",
      value: function openURL(url) {
        this._validateURL(url);

        if (_Platform.default.OS === 'android') {
          return (0, _nullthrows.default)(_NativeIntentAndroid.default).openURL(url);
        } else {
          return (0, _nullthrows.default)(_NativeLinkingManager.default).openURL(url);
        }
      }
    }, {
      key: "canOpenURL",
      value: function canOpenURL(url) {
        this._validateURL(url);

        if (_Platform.default.OS === 'android') {
          return (0, _nullthrows.default)(_NativeIntentAndroid.default).canOpenURL(url);
        } else {
          return (0, _nullthrows.default)(_NativeLinkingManager.default).canOpenURL(url);
        }
      }
    }, {
      key: "openSettings",
      value: function openSettings() {
        if (_Platform.default.OS === 'android') {
          return (0, _nullthrows.default)(_NativeIntentAndroid.default).openSettings();
        } else {
          return (0, _nullthrows.default)(_NativeLinkingManager.default).openSettings();
        }
      }
    }, {
      key: "getInitialURL",
      value: function getInitialURL() {
        return _Platform.default.OS === 'android' ? _InteractionManager.default.runAfterInteractions().then(function () {
          return (0, _nullthrows.default)(_NativeIntentAndroid.default).getInitialURL();
        }) : (0, _nullthrows.default)(_NativeLinkingManager.default).getInitialURL();
      }
    }, {
      key: "sendIntent",
      value: function sendIntent(action, extras) {
        if (_Platform.default.OS === 'android') {
          return (0, _nullthrows.default)(_NativeIntentAndroid.default).sendIntent(action, extras);
        } else {
          return new Promise(function (resolve, reject) {
            return reject(new Error('Unsupported'));
          });
        }
      }
    }, {
      key: "_validateURL",
      value: function _validateURL(url) {
        (0, _invariant.default)(typeof url === 'string', 'Invalid URL: should be a string. Was: ' + url);
        (0, _invariant.default)(url, 'Invalid URL: cannot be empty');
      }
    }]);
    return Linking;
  }(_NativeEventEmitter2.default);

  module.exports = new Linking();
},"node_modules/react-native/Libraries/Linking/Linking.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/Libraries/EventEmitter/NativeEventEmitter.js","node_modules/react-native/Libraries/Interaction/InteractionManager.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/Linking/NativeLinkingManager.js","node_modules/react-native/Libraries/Linking/NativeIntentAndroid.js","node_modules/invariant/browser.js","node_modules/nullthrows/nullthrows.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('LinkingManager');

  exports.default = _default;
},"node_modules/react-native/Libraries/Linking/NativeLinkingManager.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('IntentAndroid');

  exports.default = _default;
},"node_modules/react-native/Libraries/Linking/NativeIntentAndroid.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _RCTLog = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var LogBox;
  {
    LogBox = {
      install: function install() {},
      uninstall: function uninstall() {},
      isInstalled: function isInstalled() {
        return false;
      },
      ignoreLogs: function ignoreLogs(patterns) {},
      ignoreAllLogs: function ignoreAllLogs(value) {},
      clearAllLogs: function clearAllLogs() {},
      addLog: function addLog(log) {},
      addException: function addException(error) {}
    };
  }
  module.exports = LogBox;
},"node_modules/react-native/Libraries/LogBox/LogBox.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js","node_modules/react-native/Libraries/Utilities/RCTLog.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var PanResponder = {
    _initializeGestureState: function _initializeGestureState(gestureState) {
      gestureState.moveX = 0;
      gestureState.moveY = 0;
      gestureState.x0 = 0;
      gestureState.y0 = 0;
      gestureState.dx = 0;
      gestureState.dy = 0;
      gestureState.vx = 0;
      gestureState.vy = 0;
      gestureState.numberActiveTouches = 0;
      gestureState._accountsForMovesUpTo = 0;
    },
    _updateGestureStateOnMove: function _updateGestureStateOnMove(gestureState, touchHistory) {
      gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
      gestureState.moveX = _$$_REQUIRE(_dependencyMap[0]).currentCentroidXOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
      gestureState.moveY = _$$_REQUIRE(_dependencyMap[0]).currentCentroidYOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
      var movedAfter = gestureState._accountsForMovesUpTo;

      var prevX = _$$_REQUIRE(_dependencyMap[0]).previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);

      var x = _$$_REQUIRE(_dependencyMap[0]).currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);

      var prevY = _$$_REQUIRE(_dependencyMap[0]).previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);

      var y = _$$_REQUIRE(_dependencyMap[0]).currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);

      var nextDX = gestureState.dx + (x - prevX);
      var nextDY = gestureState.dy + (y - prevY);
      var dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;
      gestureState.vx = (nextDX - gestureState.dx) / dt;
      gestureState.vy = (nextDY - gestureState.dy) / dt;
      gestureState.dx = nextDX;
      gestureState.dy = nextDY;
      gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;
    },
    create: function create(config) {
      var interactionState = {
        handle: null
      };
      var gestureState = {
        stateID: Math.random(),
        moveX: 0,
        moveY: 0,
        x0: 0,
        y0: 0,
        dx: 0,
        dy: 0,
        vx: 0,
        vy: 0,
        numberActiveTouches: 0,
        _accountsForMovesUpTo: 0
      };
      var panHandlers = {
        onStartShouldSetResponder: function onStartShouldSetResponder(event) {
          return config.onStartShouldSetPanResponder == null ? false : config.onStartShouldSetPanResponder(event, gestureState);
        },
        onMoveShouldSetResponder: function onMoveShouldSetResponder(event) {
          return config.onMoveShouldSetPanResponder == null ? false : config.onMoveShouldSetPanResponder(event, gestureState);
        },
        onStartShouldSetResponderCapture: function onStartShouldSetResponderCapture(event) {
          if (event.nativeEvent.touches.length === 1) {
            PanResponder._initializeGestureState(gestureState);
          }

          gestureState.numberActiveTouches = event.touchHistory.numberActiveTouches;
          return config.onStartShouldSetPanResponderCapture != null ? config.onStartShouldSetPanResponderCapture(event, gestureState) : false;
        },
        onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(event) {
          var touchHistory = event.touchHistory;

          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
            return false;
          }

          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);

          return config.onMoveShouldSetPanResponderCapture ? config.onMoveShouldSetPanResponderCapture(event, gestureState) : false;
        },
        onResponderGrant: function onResponderGrant(event) {
          if (!interactionState.handle) {
            interactionState.handle = _$$_REQUIRE(_dependencyMap[1]).createInteractionHandle();
          }

          gestureState.x0 = _$$_REQUIRE(_dependencyMap[0]).currentCentroidX(event.touchHistory);
          gestureState.y0 = _$$_REQUIRE(_dependencyMap[0]).currentCentroidY(event.touchHistory);
          gestureState.dx = 0;
          gestureState.dy = 0;

          if (config.onPanResponderGrant) {
            config.onPanResponderGrant(event, gestureState);
          }

          return config.onShouldBlockNativeResponder == null ? true : config.onShouldBlockNativeResponder(event, gestureState);
        },
        onResponderReject: function onResponderReject(event) {
          clearInteractionHandle(interactionState, config.onPanResponderReject, event, gestureState);
        },
        onResponderRelease: function onResponderRelease(event) {
          clearInteractionHandle(interactionState, config.onPanResponderRelease, event, gestureState);

          PanResponder._initializeGestureState(gestureState);
        },
        onResponderStart: function onResponderStart(event) {
          var touchHistory = event.touchHistory;
          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;

          if (config.onPanResponderStart) {
            config.onPanResponderStart(event, gestureState);
          }
        },
        onResponderMove: function onResponderMove(event) {
          var touchHistory = event.touchHistory;

          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
            return;
          }

          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);

          if (config.onPanResponderMove) {
            config.onPanResponderMove(event, gestureState);
          }
        },
        onResponderEnd: function onResponderEnd(event) {
          var touchHistory = event.touchHistory;
          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
          clearInteractionHandle(interactionState, config.onPanResponderEnd, event, gestureState);
        },
        onResponderTerminate: function onResponderTerminate(event) {
          clearInteractionHandle(interactionState, config.onPanResponderTerminate, event, gestureState);

          PanResponder._initializeGestureState(gestureState);
        },
        onResponderTerminationRequest: function onResponderTerminationRequest(event) {
          return config.onPanResponderTerminationRequest == null ? true : config.onPanResponderTerminationRequest(event, gestureState);
        }
      };
      return {
        panHandlers: panHandlers,
        getInteractionHandle: function getInteractionHandle() {
          return interactionState.handle;
        }
      };
    }
  };

  function clearInteractionHandle(interactionState, callback, event, gestureState) {
    if (interactionState.handle) {
      _$$_REQUIRE(_dependencyMap[1]).clearInteractionHandle(interactionState.handle);

      interactionState.handle = null;
    }

    if (callback) {
      callback(event, gestureState);
    }
  }

  module.exports = PanResponder;
},"node_modules/react-native/Libraries/Interaction/PanResponder.js",["node_modules/react-native/Libraries/Interaction/TouchHistoryMath.js","node_modules/react-native/Libraries/Interaction/InteractionManager.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var TouchHistoryMath = {
    centroidDimension: function centroidDimension(touchHistory, touchesChangedAfter, isXAxis, ofCurrent) {
      var touchBank = touchHistory.touchBank;
      var total = 0;
      var count = 0;
      var oneTouchData = touchHistory.numberActiveTouches === 1 ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch] : null;

      if (oneTouchData !== null) {
        if (oneTouchData.touchActive && oneTouchData.currentTimeStamp > touchesChangedAfter) {
          total += ofCurrent && isXAxis ? oneTouchData.currentPageX : ofCurrent && !isXAxis ? oneTouchData.currentPageY : !ofCurrent && isXAxis ? oneTouchData.previousPageX : oneTouchData.previousPageY;
          count = 1;
        }
      } else {
        for (var i = 0; i < touchBank.length; i++) {
          var touchTrack = touchBank[i];

          if (touchTrack !== null && touchTrack !== undefined && touchTrack.touchActive && touchTrack.currentTimeStamp >= touchesChangedAfter) {
            var toAdd = undefined;

            if (ofCurrent && isXAxis) {
              toAdd = touchTrack.currentPageX;
            } else if (ofCurrent && !isXAxis) {
              toAdd = touchTrack.currentPageY;
            } else if (!ofCurrent && isXAxis) {
              toAdd = touchTrack.previousPageX;
            } else {
              toAdd = touchTrack.previousPageY;
            }

            total += toAdd;
            count++;
          }
        }
      }

      return count > 0 ? total / count : TouchHistoryMath.noCentroid;
    },
    currentCentroidXOfTouchesChangedAfter: function currentCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, true);
    },
    currentCentroidYOfTouchesChangedAfter: function currentCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, true);
    },
    previousCentroidXOfTouchesChangedAfter: function previousCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, false);
    },
    previousCentroidYOfTouchesChangedAfter: function previousCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, false);
    },
    currentCentroidX: function currentCentroidX(touchHistory) {
      return TouchHistoryMath.centroidDimension(touchHistory, 0, true, true);
    },
    currentCentroidY: function currentCentroidY(touchHistory) {
      return TouchHistoryMath.centroidDimension(touchHistory, 0, false, true);
    },
    noCentroid: -1
  };
  module.exports = TouchHistoryMath;
},"node_modules/react-native/Libraries/Interaction/TouchHistoryMath.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _regenerator = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _NativeDialogManagerAndroid = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _NativePermissionsAndroid = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var PERMISSION_REQUEST_RESULT = Object.freeze({
    GRANTED: 'granted',
    DENIED: 'denied',
    NEVER_ASK_AGAIN: 'never_ask_again'
  });
  var PERMISSIONS = Object.freeze({
    READ_CALENDAR: 'android.permission.READ_CALENDAR',
    WRITE_CALENDAR: 'android.permission.WRITE_CALENDAR',
    CAMERA: 'android.permission.CAMERA',
    READ_CONTACTS: 'android.permission.READ_CONTACTS',
    WRITE_CONTACTS: 'android.permission.WRITE_CONTACTS',
    GET_ACCOUNTS: 'android.permission.GET_ACCOUNTS',
    ACCESS_FINE_LOCATION: 'android.permission.ACCESS_FINE_LOCATION',
    ACCESS_COARSE_LOCATION: 'android.permission.ACCESS_COARSE_LOCATION',
    ACCESS_BACKGROUND_LOCATION: 'android.permission.ACCESS_BACKGROUND_LOCATION',
    RECORD_AUDIO: 'android.permission.RECORD_AUDIO',
    READ_PHONE_STATE: 'android.permission.READ_PHONE_STATE',
    CALL_PHONE: 'android.permission.CALL_PHONE',
    READ_CALL_LOG: 'android.permission.READ_CALL_LOG',
    WRITE_CALL_LOG: 'android.permission.WRITE_CALL_LOG',
    ADD_VOICEMAIL: 'com.android.voicemail.permission.ADD_VOICEMAIL',
    USE_SIP: 'android.permission.USE_SIP',
    PROCESS_OUTGOING_CALLS: 'android.permission.PROCESS_OUTGOING_CALLS',
    BODY_SENSORS: 'android.permission.BODY_SENSORS',
    SEND_SMS: 'android.permission.SEND_SMS',
    RECEIVE_SMS: 'android.permission.RECEIVE_SMS',
    READ_SMS: 'android.permission.READ_SMS',
    RECEIVE_WAP_PUSH: 'android.permission.RECEIVE_WAP_PUSH',
    RECEIVE_MMS: 'android.permission.RECEIVE_MMS',
    READ_EXTERNAL_STORAGE: 'android.permission.READ_EXTERNAL_STORAGE',
    WRITE_EXTERNAL_STORAGE: 'android.permission.WRITE_EXTERNAL_STORAGE',
    BLUETOOTH_CONNECT: 'android.permission.BLUETOOTH_CONNECT',
    BLUETOOTH_SCAN: 'android.permission.BLUETOOTH_SCAN',
    BLUETOOTH_ADVERTISE: 'android.permission.BLUETOOTH_ADVERTISE',
    ACCESS_MEDIA_LOCATION: 'android.permission.ACCESS_MEDIA_LOCATION',
    ACCEPT_HANDOVER: 'android.permission.ACCEPT_HANDOVER',
    ACTIVITY_RECOGNITION: 'android.permission.ACTIVITY_RECOGNITION',
    ANSWER_PHONE_CALLS: 'android.permission.ANSWER_PHONE_CALLS',
    READ_PHONE_NUMBERS: 'android.permission.READ_PHONE_NUMBERS',
    UWB_RANGING: 'android.permission.UWB_RANGING'
  });

  var PermissionsAndroid = function () {
    function PermissionsAndroid() {
      (0, _classCallCheck2.default)(this, PermissionsAndroid);
      this.PERMISSIONS = PERMISSIONS;
      this.RESULTS = PERMISSION_REQUEST_RESULT;
    }

    (0, _createClass2.default)(PermissionsAndroid, [{
      key: "checkPermission",
      value: function checkPermission(permission) {
        console.warn('"PermissionsAndroid.checkPermission" is deprecated. Use "PermissionsAndroid.check" instead');
        {
          console.warn('"PermissionsAndroid" module works only for Android platform.');
          return Promise.resolve(false);
        }
        (0, _invariant.default)(_NativePermissionsAndroid.default, 'PermissionsAndroid is not installed correctly.');
        return _NativePermissionsAndroid.default.checkPermission(permission);
      }
    }, {
      key: "check",
      value: function check(permission) {
        {
          console.warn('"PermissionsAndroid" module works only for Android platform.');
          return Promise.resolve(false);
        }
        (0, _invariant.default)(_NativePermissionsAndroid.default, 'PermissionsAndroid is not installed correctly.');
        return _NativePermissionsAndroid.default.checkPermission(permission);
      }
    }, {
      key: "requestPermission",
      value: function requestPermission(permission, rationale) {
        var response;
        return _regenerator.default.async(function requestPermission$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                console.warn('"PermissionsAndroid.requestPermission" is deprecated. Use "PermissionsAndroid.request" instead');
                console.warn('"PermissionsAndroid" module works only for Android platform.');
                return _context.abrupt("return", Promise.resolve(false));

              case 4:
                _context.next = 6;
                return _regenerator.default.awrap(this.request(permission, rationale));

              case 6:
                response = _context.sent;
                return _context.abrupt("return", response === this.RESULTS.GRANTED);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, null, this, null, Promise);
      }
    }, {
      key: "request",
      value: function request(permission, rationale) {
        var shouldShowRationale;
        return _regenerator.default.async(function request$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                console.warn('"PermissionsAndroid" module works only for Android platform.');
                return _context2.abrupt("return", Promise.resolve(this.RESULTS.DENIED));

              case 3:
                (0, _invariant.default)(_NativePermissionsAndroid.default, 'PermissionsAndroid is not installed correctly.');

                if (!rationale) {
                  _context2.next = 10;
                  break;
                }

                _context2.next = 7;
                return _regenerator.default.awrap(_NativePermissionsAndroid.default.shouldShowRequestPermissionRationale(permission));

              case 7:
                shouldShowRationale = _context2.sent;

                if (!(shouldShowRationale && !!_NativeDialogManagerAndroid.default)) {
                  _context2.next = 10;
                  break;
                }

                return _context2.abrupt("return", new Promise(function (resolve, reject) {
                  var options = (0, _extends2.default)({}, rationale);

                  _NativeDialogManagerAndroid.default.showAlert(options, function () {
                    return reject(new Error('Error showing rationale'));
                  }, function () {
                    return resolve(_NativePermissionsAndroid.default.requestPermission(permission));
                  });
                }));

              case 10:
                return _context2.abrupt("return", _NativePermissionsAndroid.default.requestPermission(permission));

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, null, this, null, Promise);
      }
    }, {
      key: "requestMultiple",
      value: function requestMultiple(permissions) {
        {
          console.warn('"PermissionsAndroid" module works only for Android platform.');
          return Promise.resolve({});
        }
        (0, _invariant.default)(_NativePermissionsAndroid.default, 'PermissionsAndroid is not installed correctly.');
        return _NativePermissionsAndroid.default.requestMultiplePermissions(permissions);
      }
    }]);
    return PermissionsAndroid;
  }();

  var PermissionsAndroidInstance = new PermissionsAndroid();
  module.exports = PermissionsAndroidInstance;
},"node_modules/react-native/Libraries/PermissionsAndroid/PermissionsAndroid.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/regenerator/index.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/NativeModules/specs/NativeDialogManagerAndroid.js","node_modules/react-native/Libraries/PermissionsAndroid/NativePermissionsAndroid.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('PermissionsAndroid');

  exports.default = _default;
},"node_modules/react-native/Libraries/PermissionsAndroid/NativePermissionsAndroid.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _NativeEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _NativePushNotificationManagerIOS = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _Platform = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var PushNotificationEmitter = new _NativeEventEmitter.default(_Platform.default.OS !== 'ios' ? null : _NativePushNotificationManagerIOS.default);

  var _notifHandlers = new Map();

  var DEVICE_NOTIF_EVENT = 'remoteNotificationReceived';
  var NOTIF_REGISTER_EVENT = 'remoteNotificationsRegistered';
  var NOTIF_REGISTRATION_ERROR_EVENT = 'remoteNotificationRegistrationError';
  var DEVICE_LOCAL_NOTIF_EVENT = 'localNotificationReceived';

  var PushNotificationIOS = function () {
    function PushNotificationIOS(nativeNotif) {
      var _this = this;

      (0, _classCallCheck2.default)(this, PushNotificationIOS);
      this._data = {};
      this._remoteNotificationCompleteCallbackCalled = false;
      this._isRemote = nativeNotif.remote;

      if (this._isRemote) {
        this._notificationId = nativeNotif.notificationId;
      }

      if (nativeNotif.remote) {
        Object.keys(nativeNotif).forEach(function (notifKey) {
          var notifVal = nativeNotif[notifKey];

          if (notifKey === 'aps') {
            _this._alert = notifVal.alert;
            _this._sound = notifVal.sound;
            _this._badgeCount = notifVal.badge;
            _this._category = notifVal.category;
            _this._contentAvailable = notifVal['content-available'];
            _this._threadID = notifVal['thread-id'];
          } else {
            _this._data[notifKey] = notifVal;
          }
        });
      } else {
        this._badgeCount = nativeNotif.applicationIconBadgeNumber;
        this._sound = nativeNotif.soundName;
        this._alert = nativeNotif.alertBody;
        this._data = nativeNotif.userInfo;
        this._category = nativeNotif.category;
      }
    }

    (0, _createClass2.default)(PushNotificationIOS, [{
      key: "finish",
      value: function finish(fetchResult) {
        if (!this._isRemote || !this._notificationId || this._remoteNotificationCompleteCallbackCalled) {
          return;
        }

        this._remoteNotificationCompleteCallbackCalled = true;
        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');

        _NativePushNotificationManagerIOS.default.onFinishRemoteNotification(this._notificationId, fetchResult);
      }
    }, {
      key: "getMessage",
      value: function getMessage() {
        return this._alert;
      }
    }, {
      key: "getSound",
      value: function getSound() {
        return this._sound;
      }
    }, {
      key: "getCategory",
      value: function getCategory() {
        return this._category;
      }
    }, {
      key: "getAlert",
      value: function getAlert() {
        return this._alert;
      }
    }, {
      key: "getContentAvailable",
      value: function getContentAvailable() {
        return this._contentAvailable;
      }
    }, {
      key: "getBadgeCount",
      value: function getBadgeCount() {
        return this._badgeCount;
      }
    }, {
      key: "getData",
      value: function getData() {
        return this._data;
      }
    }, {
      key: "getThreadID",
      value: function getThreadID() {
        return this._threadID;
      }
    }], [{
      key: "presentLocalNotification",
      value: function presentLocalNotification(details) {
        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');

        _NativePushNotificationManagerIOS.default.presentLocalNotification(details);
      }
    }, {
      key: "scheduleLocalNotification",
      value: function scheduleLocalNotification(details) {
        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');

        _NativePushNotificationManagerIOS.default.scheduleLocalNotification(details);
      }
    }, {
      key: "cancelAllLocalNotifications",
      value: function cancelAllLocalNotifications() {
        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');

        _NativePushNotificationManagerIOS.default.cancelAllLocalNotifications();
      }
    }, {
      key: "removeAllDeliveredNotifications",
      value: function removeAllDeliveredNotifications() {
        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');

        _NativePushNotificationManagerIOS.default.removeAllDeliveredNotifications();
      }
    }, {
      key: "getDeliveredNotifications",
      value: function getDeliveredNotifications(callback) {
        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');

        _NativePushNotificationManagerIOS.default.getDeliveredNotifications(callback);
      }
    }, {
      key: "removeDeliveredNotifications",
      value: function removeDeliveredNotifications(identifiers) {
        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');

        _NativePushNotificationManagerIOS.default.removeDeliveredNotifications(identifiers);
      }
    }, {
      key: "setApplicationIconBadgeNumber",
      value: function setApplicationIconBadgeNumber(number) {
        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');

        _NativePushNotificationManagerIOS.default.setApplicationIconBadgeNumber(number);
      }
    }, {
      key: "getApplicationIconBadgeNumber",
      value: function getApplicationIconBadgeNumber(callback) {
        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');

        _NativePushNotificationManagerIOS.default.getApplicationIconBadgeNumber(callback);
      }
    }, {
      key: "cancelLocalNotifications",
      value: function cancelLocalNotifications(userInfo) {
        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');

        _NativePushNotificationManagerIOS.default.cancelLocalNotifications(userInfo);
      }
    }, {
      key: "getScheduledLocalNotifications",
      value: function getScheduledLocalNotifications(callback) {
        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');

        _NativePushNotificationManagerIOS.default.getScheduledLocalNotifications(callback);
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, handler) {
        (0, _invariant.default)(type === 'notification' || type === 'register' || type === 'registrationError' || type === 'localNotification', 'PushNotificationIOS only supports `notification`, `register`, `registrationError`, and `localNotification` events');
        var listener;

        if (type === 'notification') {
          listener = PushNotificationEmitter.addListener(DEVICE_NOTIF_EVENT, function (notifData) {
            handler(new PushNotificationIOS(notifData));
          });
        } else if (type === 'localNotification') {
          listener = PushNotificationEmitter.addListener(DEVICE_LOCAL_NOTIF_EVENT, function (notifData) {
            handler(new PushNotificationIOS(notifData));
          });
        } else if (type === 'register') {
          listener = PushNotificationEmitter.addListener(NOTIF_REGISTER_EVENT, function (registrationInfo) {
            handler(registrationInfo.deviceToken);
          });
        } else if (type === 'registrationError') {
          listener = PushNotificationEmitter.addListener(NOTIF_REGISTRATION_ERROR_EVENT, function (errorInfo) {
            handler(errorInfo);
          });
        }

        _notifHandlers.set(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, handler) {
        (0, _invariant.default)(type === 'notification' || type === 'register' || type === 'registrationError' || type === 'localNotification', 'PushNotificationIOS only supports `notification`, `register`, `registrationError`, and `localNotification` events');

        var listener = _notifHandlers.get(type);

        if (!listener) {
          return;
        }

        listener.remove();

        _notifHandlers.delete(type);
      }
    }, {
      key: "requestPermissions",
      value: function requestPermissions(permissions) {
        var requestedPermissions = {
          alert: true,
          badge: true,
          sound: true
        };

        if (permissions) {
          requestedPermissions = {
            alert: !!permissions.alert,
            badge: !!permissions.badge,
            sound: !!permissions.sound
          };
        }

        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');
        return _NativePushNotificationManagerIOS.default.requestPermissions(requestedPermissions);
      }
    }, {
      key: "abandonPermissions",
      value: function abandonPermissions() {
        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');

        _NativePushNotificationManagerIOS.default.abandonPermissions();
      }
    }, {
      key: "checkPermissions",
      value: function checkPermissions(callback) {
        (0, _invariant.default)(typeof callback === 'function', 'Must provide a valid callback');
        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');

        _NativePushNotificationManagerIOS.default.checkPermissions(callback);
      }
    }, {
      key: "getInitialNotification",
      value: function getInitialNotification() {
        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');
        return _NativePushNotificationManagerIOS.default.getInitialNotification().then(function (notification) {
          return notification && new PushNotificationIOS(notification);
        });
      }
    }, {
      key: "getAuthorizationStatus",
      value: function getAuthorizationStatus(callback) {
        (0, _invariant.default)(_NativePushNotificationManagerIOS.default, 'PushNotificationManager is not available.');

        _NativePushNotificationManagerIOS.default.getAuthorizationStatus(callback);
      }
    }]);
    return PushNotificationIOS;
  }();

  PushNotificationIOS.FetchResult = {
    NewData: 'UIBackgroundFetchResultNewData',
    NoData: 'UIBackgroundFetchResultNoData',
    ResultFailed: 'UIBackgroundFetchResultFailed'
  };
  module.exports = PushNotificationIOS;
},"node_modules/react-native/Libraries/PushNotificationIOS/PushNotificationIOS.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/EventEmitter/NativeEventEmitter.js","node_modules/react-native/Libraries/PushNotificationIOS/NativePushNotificationManagerIOS.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/Utilities/Platform.ios.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('PushNotificationManager');

  exports.default = _default;
},"node_modules/react-native/Libraries/PushNotificationIOS/NativePushNotificationManagerIOS.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _RCTDeviceEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _NativeSettingsManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var subscriptions = [];
  var Settings = {
    _settings: _NativeSettingsManager.default && _NativeSettingsManager.default.getConstants().settings,
    get: function get(key) {
      return this._settings[key];
    },
    set: function set(settings) {
      this._settings = (0, _extends2.default)(this._settings, settings);

      _NativeSettingsManager.default.setValues(settings);
    },
    watchKeys: function watchKeys(keys, callback) {
      if (typeof keys === 'string') {
        keys = [keys];
      }

      (0, _invariant.default)(Array.isArray(keys), 'keys should be a string or array of strings');
      var sid = subscriptions.length;
      subscriptions.push({
        keys: keys,
        callback: callback
      });
      return sid;
    },
    clearWatch: function clearWatch(watchId) {
      if (watchId < subscriptions.length) {
        subscriptions[watchId] = {
          keys: [],
          callback: null
        };
      }
    },
    _sendObservations: function _sendObservations(body) {
      var _this = this;

      Object.keys(body).forEach(function (key) {
        var newValue = body[key];
        var didChange = _this._settings[key] !== newValue;
        _this._settings[key] = newValue;

        if (didChange) {
          subscriptions.forEach(function (sub) {
            if (sub.keys.indexOf(key) !== -1 && sub.callback) {
              sub.callback();
            }
          });
        }
      });
    }
  };

  _RCTDeviceEventEmitter.default.addListener('settingsUpdated', Settings._sendObservations.bind(Settings));

  module.exports = Settings;
},"node_modules/react-native/Libraries/Settings/Settings.ios.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/Libraries/EventEmitter/RCTDeviceEventEmitter.js","node_modules/react-native/Libraries/Settings/NativeSettingsManager.js","node_modules/invariant/browser.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.getEnforcing('SettingsManager');

  exports.default = _default;
},"node_modules/react-native/Libraries/Settings/NativeSettingsManager.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _NativeActionSheetManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _NativeShareModule = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var Share = function () {
    function Share() {
      (0, _classCallCheck2.default)(this, Share);
    }

    (0, _createClass2.default)(Share, null, [{
      key: "share",
      value: function share(content) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _$$_REQUIRE(_dependencyMap[6])(typeof content === 'object' && content !== null, 'Content to share must be a valid object');

        _$$_REQUIRE(_dependencyMap[6])(typeof content.url === 'string' || typeof content.message === 'string', 'At least one of URL and message is required');

        _$$_REQUIRE(_dependencyMap[6])(typeof options === 'object' && options !== null, 'Options must be a valid object');

        {
          return new Promise(function (resolve, reject) {
            var tintColor = _$$_REQUIRE(_dependencyMap[7])(options.tintColor);

            _$$_REQUIRE(_dependencyMap[6])(tintColor == null || typeof tintColor === 'number', 'Unexpected color given for options.tintColor');

            _$$_REQUIRE(_dependencyMap[6])(_NativeActionSheetManager.default, 'NativeActionSheetManager is not registered on iOS, but it should be.');

            _NativeActionSheetManager.default.showShareActionSheetWithOptions({
              message: typeof content.message === 'string' ? content.message : undefined,
              url: typeof content.url === 'string' ? content.url : undefined,
              subject: options.subject,
              tintColor: typeof tintColor === 'number' ? tintColor : undefined,
              excludedActivityTypes: options.excludedActivityTypes
            }, function (error) {
              return reject(error);
            }, function (success, activityType) {
              if (success) {
                resolve({
                  action: 'sharedAction',
                  activityType: activityType
                });
              } else {
                resolve({
                  action: 'dismissedAction',
                  activityType: null
                });
              }
            });
          });
        }
      }
    }]);
    return Share;
  }();

  Share.sharedAction = 'sharedAction';
  Share.dismissedAction = 'dismissedAction';
  module.exports = Share;
},"node_modules/react-native/Libraries/Share/Share.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/react-native/Libraries/ActionSheetIOS/NativeActionSheetManager.js","node_modules/react-native/Libraries/Share/NativeShareModule.js","node_modules/invariant/browser.js","node_modules/react-native/Libraries/StyleSheet/processColor.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('ShareModule');

  exports.default = _default;
},"node_modules/react-native/Libraries/Share/NativeShareModule.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var ToastAndroid = {
    show: function show(message, duration) {
      console.warn('ToastAndroid is not supported on this platform.');
    },
    showWithGravity: function showWithGravity(message, duration, gravity) {
      console.warn('ToastAndroid is not supported on this platform.');
    },
    showWithGravityAndOffset: function showWithGravityAndOffset(message, duration, gravity, xOffset, yOffset) {
      console.warn('ToastAndroid is not supported on this platform.');
    }
  };
  module.exports = ToastAndroid;
},"node_modules/react-native/Libraries/Components/ToastAndroid/ToastAndroid.ios.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useColorScheme;

  var _react = _$$_REQUIRE(_dependencyMap[0]);

  var _Appearance = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function useColorScheme() {
    var subscription = (0, _react.useMemo)(function () {
      return {
        getCurrentValue: function getCurrentValue() {
          return _Appearance.default.getColorScheme();
        },
        subscribe: function subscribe(callback) {
          var appearanceSubscription = _Appearance.default.addChangeListener(callback);

          return function () {
            appearanceSubscription.remove();
          };
        }
      };
    }, []);
    return (0, _$$_REQUIRE(_dependencyMap[3]).useSubscription)(subscription);
  }
},"node_modules/react-native/Libraries/Utilities/useColorScheme.js",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/Appearance.js","node_modules/use-subscription/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  {
    module.exports = _$$_REQUIRE(_dependencyMap[0]);
  }
},"node_modules/use-subscription/index.js",["node_modules/use-subscription/cjs/use-subscription.production.min.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /** @license React vundefined
   * use-subscription.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  var g = _$$_REQUIRE(_dependencyMap[0]);

  exports.useSubscription = function (a) {
    var c = a.getCurrentValue,
        d = a.subscribe,
        b = g.useState(function () {
      return {
        getCurrentValue: c,
        subscribe: d,
        value: c()
      };
    });
    a = b[0];
    var f = b[1];
    b = a.value;
    if (a.getCurrentValue !== c || a.subscribe !== d) b = c(), f({
      getCurrentValue: c,
      subscribe: d,
      value: b
    });
    g.useDebugValue(b);
    g.useEffect(function () {
      function b() {
        if (!a) {
          var b = c();
          f(function (a) {
            return a.getCurrentValue !== c || a.subscribe !== d || a.value === b ? a : _$$_REQUIRE(_dependencyMap[1])({}, a, {
              value: b
            });
          });
        }
      }

      var a = false,
          h = d(b);
      b();
      return function () {
        a = true;
        h();
      };
    }, [c, d]);
    return b;
  };
},"node_modules/use-subscription/cjs/use-subscription.production.min.js",["node_modules/react/index.js","node_modules/object-assign/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useWindowDimensions;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _Dimensions = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _react = _$$_REQUIRE(_dependencyMap[3]);

  function useWindowDimensions() {
    var _useState = (0, _react.useState)(function () {
      return _Dimensions.default.get('window');
    }),
        _useState2 = (0, _slicedToArray2.default)(_useState, 2),
        dimensions = _useState2[0],
        setDimensions = _useState2[1];

    (0, _react.useEffect)(function () {
      function handleChange(_ref) {
        var window = _ref.window;

        if (dimensions.width !== window.width || dimensions.height !== window.height || dimensions.scale !== window.scale || dimensions.fontScale !== window.fontScale) {
          setDimensions(window);
        }
      }

      var subscription = _Dimensions.default.addEventListener('change', handleChange);

      handleChange({
        window: _Dimensions.default.get('window')
      });
      return function () {
        subscription.remove();
      };
    }, [dimensions]);
    return dimensions;
  }
},"node_modules/react-native/Libraries/Utilities/useWindowDimensions.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react-native/Libraries/Utilities/Dimensions.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var UTFSequence = _$$_REQUIRE(_dependencyMap[0])({
    BOM: "\uFEFF",
    BULLET: "\u2022",
    BULLET_SP: "\xA0\u2022\xA0",
    MIDDOT: "\xB7",
    MIDDOT_SP: "\xA0\xB7\xA0",
    MIDDOT_KATAKANA: "\u30FB",
    MDASH: "\u2014",
    MDASH_SP: "\xA0\u2014\xA0",
    NDASH: "\u2013",
    NDASH_SP: "\xA0\u2013\xA0",
    NBSP: "\xA0",
    PIZZA: "\uD83C\uDF55",
    TRIANGLE_LEFT: "\u25C0",
    TRIANGLE_RIGHT: "\u25B6"
  });

  module.exports = UTFSequence;
},"node_modules/react-native/Libraries/UTFSequence.js",["node_modules/react-native/Libraries/Utilities/deepFreezeAndThrowOnMutationInDev.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _NativeVibration = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _vibrating = false;
  var _id = 0;
  var _default_vibration_length = 400;

  function vibrateByPattern(pattern) {
    var repeat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (_vibrating) {
      return;
    }

    _vibrating = true;

    if (pattern[0] === 0) {
      _NativeVibration.default.vibrate(_default_vibration_length);

      pattern = pattern.slice(1);
    }

    if (pattern.length === 0) {
      _vibrating = false;
      return;
    }

    setTimeout(function () {
      return vibrateScheduler(++_id, pattern, repeat, 1);
    }, pattern[0]);
  }

  function vibrateScheduler(id, pattern, repeat, nextIndex) {
    if (!_vibrating || id !== _id) {
      return;
    }

    _NativeVibration.default.vibrate(_default_vibration_length);

    if (nextIndex >= pattern.length) {
      if (repeat) {
        nextIndex = 0;
      } else {
        _vibrating = false;
        return;
      }
    }

    setTimeout(function () {
      return vibrateScheduler(id, pattern, repeat, nextIndex + 1);
    }, pattern[nextIndex]);
  }

  var Vibration = {
    vibrate: function vibrate() {
      var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _default_vibration_length;
      var repeat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      {
        if (_vibrating) {
          return;
        }

        if (typeof pattern === 'number') {
          _NativeVibration.default.vibrate(pattern);
        } else if (Array.isArray(pattern)) {
          vibrateByPattern(pattern, repeat);
        } else {
          throw new Error('Vibration pattern should be a number or array');
        }
      }
    },
    cancel: function cancel() {
      {
        _vibrating = false;
      }
    }
  };
  module.exports = Vibration;
},"node_modules/react-native/Libraries/Vibration/Vibration.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Vibration/NativeVibration.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.getEnforcing('Vibration');

  exports.default = _default;
},"node_modules/react-native/Libraries/Vibration/NativeVibration.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _$$_REQUIRE(_dependencyMap[0])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _$$_REQUIRE(_dependencyMap[0])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _$$_REQUIRE(_dependencyMap[1])(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var React = _$$_REQUIRE(_dependencyMap[2]);

  var YellowBox;
  {
    YellowBox = function (_React$Component2) {
      _$$_REQUIRE(_dependencyMap[3])(YellowBox, _React$Component2);

      var _super2 = _createSuper(YellowBox);

      function YellowBox() {
        _$$_REQUIRE(_dependencyMap[4])(this, YellowBox);

        return _super2.apply(this, arguments);
      }

      _$$_REQUIRE(_dependencyMap[5])(YellowBox, [{
        key: "render",
        value: function render() {
          return null;
        }
      }], [{
        key: "ignoreWarnings",
        value: function ignoreWarnings(patterns) {}
      }, {
        key: "install",
        value: function install() {}
      }, {
        key: "uninstall",
        value: function uninstall() {}
      }]);

      return YellowBox;
    }(React.Component);
  }
  module.exports = YellowBox;
},"node_modules/react-native/Libraries/YellowBox/YellowBoxDeprecated.js",["node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/react/index.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DynamicColorIOS = undefined;

  var DynamicColorIOS = function DynamicColorIOS(tuple) {
    return (0, _$$_REQUIRE(_dependencyMap[0]).DynamicColorIOSPrivate)({
      light: tuple.light,
      dark: tuple.dark,
      highContrastLight: tuple.highContrastLight,
      highContrastDark: tuple.highContrastDark
    });
  };

  exports.DynamicColorIOS = DynamicColorIOS;
},"node_modules/react-native/Libraries/StyleSheet/PlatformColorValueTypesIOS.ios.js",["node_modules/react-native/Libraries/StyleSheet/PlatformColorValueTypes.ios.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    Link: true,
    NavigationContainer: true,
    ServerContainer: true,
    DarkTheme: true,
    DefaultTheme: true,
    ThemeProvider: true,
    useTheme: true,
    useLinkBuilder: true,
    useLinkProps: true,
    useLinkTo: true,
    useScrollToTop: true
  };
  Object.defineProperty(exports, "DarkTheme", {
    enumerable: true,
    get: function get() {
      return _DarkTheme.default;
    }
  });
  Object.defineProperty(exports, "DefaultTheme", {
    enumerable: true,
    get: function get() {
      return _DefaultTheme.default;
    }
  });
  Object.defineProperty(exports, "Link", {
    enumerable: true,
    get: function get() {
      return _Link.default;
    }
  });
  Object.defineProperty(exports, "NavigationContainer", {
    enumerable: true,
    get: function get() {
      return _NavigationContainer.default;
    }
  });
  Object.defineProperty(exports, "ServerContainer", {
    enumerable: true,
    get: function get() {
      return _ServerContainer.default;
    }
  });
  Object.defineProperty(exports, "ThemeProvider", {
    enumerable: true,
    get: function get() {
      return _ThemeProvider.default;
    }
  });
  Object.defineProperty(exports, "useLinkBuilder", {
    enumerable: true,
    get: function get() {
      return _useLinkBuilder.default;
    }
  });
  Object.defineProperty(exports, "useLinkProps", {
    enumerable: true,
    get: function get() {
      return _useLinkProps.default;
    }
  });
  Object.defineProperty(exports, "useLinkTo", {
    enumerable: true,
    get: function get() {
      return _useLinkTo.default;
    }
  });
  Object.defineProperty(exports, "useScrollToTop", {
    enumerable: true,
    get: function get() {
      return _useScrollToTop.default;
    }
  });
  Object.defineProperty(exports, "useTheme", {
    enumerable: true,
    get: function get() {
      return _useTheme.default;
    }
  });

  var _Link = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _NavigationContainer = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _ServerContainer = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _DarkTheme = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _DefaultTheme = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _ThemeProvider = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _useTheme = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  Object.keys(_$$_REQUIRE(_dependencyMap[8])).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[8])[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[8])[key];
      }
    });
  });

  var _useLinkBuilder = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _useLinkProps = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _useLinkTo = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _useScrollToTop = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  Object.keys(_$$_REQUIRE(_dependencyMap[13])).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[13])[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[13])[key];
      }
    });
  });
},"node_modules/@react-navigation/native/src/index.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/native/src/Link.tsx","node_modules/@react-navigation/native/src/NavigationContainer.tsx","node_modules/@react-navigation/native/src/ServerContainer.tsx","node_modules/@react-navigation/native/src/theming/DarkTheme.tsx","node_modules/@react-navigation/native/src/theming/DefaultTheme.tsx","node_modules/@react-navigation/native/src/theming/ThemeProvider.tsx","node_modules/@react-navigation/native/src/theming/useTheme.tsx","node_modules/@react-navigation/native/src/types.tsx","node_modules/@react-navigation/native/src/useLinkBuilder.tsx","node_modules/@react-navigation/native/src/useLinkProps.tsx","node_modules/@react-navigation/native/src/useLinkTo.tsx","node_modules/@react-navigation/native/src/useScrollToTop.tsx","node_modules/@react-navigation/core/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = Link;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[4]);

  var _useLinkProps = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _excluded = ["to", "action"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function Link(_ref) {
    var to = _ref.to,
        action = _ref.action,
        rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);
    var props = (0, _useLinkProps.default)({
      to: to,
      action: action
    });

    var onPress = function onPress(e) {
      if ('onPress' in rest) {
        rest.onPress == null ? undefined : rest.onPress(e);
      }

      props.onPress(e);
    };

    return React.createElement(_reactNative.Text, (0, _extends2.default)({}, props, rest, _reactNative.Platform.select({
      web: {
        onClick: onPress
      },
      default: {
        onPress: onPress
      }
    })));
  }
},"node_modules/@react-navigation/native/src/Link.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@react-navigation/native/src/useLinkProps.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useLinkProps;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[1]);

  var _LinkingContext = _$$_REQUIRE(_dependencyMap[2])(_$$_REQUIRE(_dependencyMap[3]));

  var _useLinkTo = _$$_REQUIRE(_dependencyMap[2])(_$$_REQUIRE(_dependencyMap[4]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var getStateFromParams = function getStateFromParams(params) {
    if (params != null && params.state) {
      return params.state;
    }

    if (params != null && params.screen) {
      return {
        routes: [{
          name: params.screen,
          params: params.params,
          state: params.screen ? getStateFromParams(params.params) : undefined
        }]
      };
    }

    return undefined;
  };

  function useLinkProps(_ref) {
    var _options$getPathFromS;

    var to = _ref.to,
        action = _ref.action;
    var root = React.useContext(_$$_REQUIRE(_dependencyMap[5]).NavigationContainerRefContext);
    var navigation = React.useContext(_$$_REQUIRE(_dependencyMap[5]).NavigationHelpersContext);

    var _React$useContext = React.useContext(_LinkingContext.default),
        options = _React$useContext.options;

    var linkTo = (0, _useLinkTo.default)();

    var onPress = function onPress(e) {
      var _e$currentTarget;

      var shouldHandle = false;

      if (_reactNative.Platform.OS !== 'web' || !e) {
        shouldHandle = e ? !e.defaultPrevented : true;
      } else if (!e.defaultPrevented && !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && (e.button == null || e.button === 0) && [undefined, null, '', 'self'].includes((_e$currentTarget = e.currentTarget) == null ? undefined : _e$currentTarget.target)) {
        e.preventDefault();
        shouldHandle = true;
      }

      if (shouldHandle) {
        if (action) {
          if (navigation) {
            navigation.dispatch(action);
          } else if (root) {
            root.dispatch(action);
          } else {
            throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
          }
        } else {
          linkTo(to);
        }
      }
    };

    var getPathFromStateHelper = (_options$getPathFromS = options == null ? undefined : options.getPathFromState) != null ? _options$getPathFromS : _$$_REQUIRE(_dependencyMap[5]).getPathFromState;
    var href = typeof to === 'string' ? to : getPathFromStateHelper({
      routes: [{
        name: to.screen,
        params: to.params,
        state: getStateFromParams(to.params)
      }]
    }, options == null ? undefined : options.config);
    return {
      href: href,
      accessibilityRole: 'link',
      onPress: onPress
    };
  }
},"node_modules/@react-navigation/native/src/useLinkProps.tsx",["node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/native/src/LinkingContext.tsx","node_modules/@react-navigation/native/src/useLinkTo.tsx","node_modules/@react-navigation/core/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var LinkingContext = React.createContext({
    options: undefined
  });
  LinkingContext.displayName = 'LinkingContext';
  var _default = LinkingContext;
  exports.default = _default;
},"node_modules/@react-navigation/native/src/LinkingContext.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useLinkTo;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _LinkingContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useLinkTo() {
    var navigation = React.useContext(_$$_REQUIRE(_dependencyMap[3]).NavigationContainerRefContext);
    var linking = React.useContext(_LinkingContext.default);
    var linkTo = React.useCallback(function (to) {
      if (navigation === undefined) {
        throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
      }

      if (typeof to !== 'string') {
        navigation.navigate(to.screen, to.params);
        return;
      }

      if (!to.startsWith('/')) {
        throw new Error("The path must start with '/' (" + to + ").");
      }

      var options = linking.options;
      var state = options != null && options.getStateFromPath ? options.getStateFromPath(to, options.config) : (0, _$$_REQUIRE(_dependencyMap[3]).getStateFromPath)(to, options == null ? undefined : options.config);

      if (state) {
        var action = (0, _$$_REQUIRE(_dependencyMap[3]).getActionFromState)(state, options == null ? undefined : options.config);

        if (action !== undefined) {
          navigation.dispatch(action);
        } else {
          navigation.reset(state);
        }
      } else {
        throw new Error('Failed to parse the path to a navigation state.');
      }
    }, [linking, navigation]);
    return linkTo;
  }
},"node_modules/@react-navigation/native/src/useLinkTo.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/native/src/LinkingContext.tsx","node_modules/@react-navigation/core/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    BaseNavigationContainer: true,
    createNavigationContainerRef: true,
    createNavigatorFactory: true,
    CurrentRenderContext: true,
    findFocusedRoute: true,
    getActionFromState: true,
    getFocusedRouteNameFromRoute: true,
    getPathFromState: true,
    getStateFromPath: true,
    NavigationContainerRefContext: true,
    NavigationContext: true,
    NavigationHelpersContext: true,
    NavigationRouteContext: true,
    useFocusEffect: true,
    useIsFocused: true,
    useNavigation: true,
    useNavigationBuilder: true,
    useNavigationContainerRef: true,
    useNavigationState: true,
    useRoute: true,
    validatePathConfig: true
  };
  Object.defineProperty(exports, "BaseNavigationContainer", {
    enumerable: true,
    get: function get() {
      return _BaseNavigationContainer.default;
    }
  });
  Object.defineProperty(exports, "CurrentRenderContext", {
    enumerable: true,
    get: function get() {
      return _CurrentRenderContext.default;
    }
  });
  Object.defineProperty(exports, "NavigationContainerRefContext", {
    enumerable: true,
    get: function get() {
      return _NavigationContainerRefContext.default;
    }
  });
  Object.defineProperty(exports, "NavigationContext", {
    enumerable: true,
    get: function get() {
      return _NavigationContext.default;
    }
  });
  Object.defineProperty(exports, "NavigationHelpersContext", {
    enumerable: true,
    get: function get() {
      return _NavigationHelpersContext.default;
    }
  });
  Object.defineProperty(exports, "NavigationRouteContext", {
    enumerable: true,
    get: function get() {
      return _NavigationRouteContext.default;
    }
  });
  Object.defineProperty(exports, "createNavigationContainerRef", {
    enumerable: true,
    get: function get() {
      return _createNavigationContainerRef.default;
    }
  });
  Object.defineProperty(exports, "createNavigatorFactory", {
    enumerable: true,
    get: function get() {
      return _createNavigatorFactory.default;
    }
  });
  Object.defineProperty(exports, "findFocusedRoute", {
    enumerable: true,
    get: function get() {
      return _findFocusedRoute.default;
    }
  });
  Object.defineProperty(exports, "getActionFromState", {
    enumerable: true,
    get: function get() {
      return _getActionFromState.default;
    }
  });
  Object.defineProperty(exports, "getFocusedRouteNameFromRoute", {
    enumerable: true,
    get: function get() {
      return _getFocusedRouteNameFromRoute.default;
    }
  });
  Object.defineProperty(exports, "getPathFromState", {
    enumerable: true,
    get: function get() {
      return _getPathFromState.default;
    }
  });
  Object.defineProperty(exports, "getStateFromPath", {
    enumerable: true,
    get: function get() {
      return _getStateFromPath.default;
    }
  });
  Object.defineProperty(exports, "useFocusEffect", {
    enumerable: true,
    get: function get() {
      return _useFocusEffect.default;
    }
  });
  Object.defineProperty(exports, "useIsFocused", {
    enumerable: true,
    get: function get() {
      return _useIsFocused.default;
    }
  });
  Object.defineProperty(exports, "useNavigation", {
    enumerable: true,
    get: function get() {
      return _useNavigation.default;
    }
  });
  Object.defineProperty(exports, "useNavigationBuilder", {
    enumerable: true,
    get: function get() {
      return _useNavigationBuilder.default;
    }
  });
  Object.defineProperty(exports, "useNavigationContainerRef", {
    enumerable: true,
    get: function get() {
      return _useNavigationContainerRef.default;
    }
  });
  Object.defineProperty(exports, "useNavigationState", {
    enumerable: true,
    get: function get() {
      return _useNavigationState.default;
    }
  });
  Object.defineProperty(exports, "useRoute", {
    enumerable: true,
    get: function get() {
      return _useRoute.default;
    }
  });
  Object.defineProperty(exports, "validatePathConfig", {
    enumerable: true,
    get: function get() {
      return _validatePathConfig.default;
    }
  });

  var _BaseNavigationContainer = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createNavigationContainerRef = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createNavigatorFactory = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _CurrentRenderContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _findFocusedRoute = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getActionFromState = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getFocusedRouteNameFromRoute = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _getPathFromState = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _getStateFromPath = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _NavigationContainerRefContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _NavigationContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _NavigationHelpersContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var _NavigationRouteContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[13]));

  Object.keys(_$$_REQUIRE(_dependencyMap[14])).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[14])[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[14])[key];
      }
    });
  });

  var _useFocusEffect = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[15]));

  var _useIsFocused = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[16]));

  var _useNavigation = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[17]));

  var _useNavigationBuilder = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[18]));

  var _useNavigationContainerRef = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[19]));

  var _useNavigationState = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[20]));

  var _useRoute = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[21]));

  var _validatePathConfig = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[22]));

  Object.keys(_$$_REQUIRE(_dependencyMap[23])).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[23])[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[23])[key];
      }
    });
  });
},"node_modules/@react-navigation/core/src/index.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/core/src/BaseNavigationContainer.tsx","node_modules/@react-navigation/core/src/createNavigationContainerRef.tsx","node_modules/@react-navigation/core/src/createNavigatorFactory.tsx","node_modules/@react-navigation/core/src/CurrentRenderContext.tsx","node_modules/@react-navigation/core/src/findFocusedRoute.tsx","node_modules/@react-navigation/core/src/getActionFromState.tsx","node_modules/@react-navigation/core/src/getFocusedRouteNameFromRoute.tsx","node_modules/@react-navigation/core/src/getPathFromState.tsx","node_modules/@react-navigation/core/src/getStateFromPath.tsx","node_modules/@react-navigation/core/src/NavigationContainerRefContext.tsx","node_modules/@react-navigation/core/src/NavigationContext.tsx","node_modules/@react-navigation/core/src/NavigationHelpersContext.tsx","node_modules/@react-navigation/core/src/NavigationRouteContext.tsx","node_modules/@react-navigation/core/src/types.tsx","node_modules/@react-navigation/core/src/useFocusEffect.tsx","node_modules/@react-navigation/core/src/useIsFocused.tsx","node_modules/@react-navigation/core/src/useNavigation.tsx","node_modules/@react-navigation/core/src/useNavigationBuilder.tsx","node_modules/@react-navigation/core/src/useNavigationContainerRef.tsx","node_modules/@react-navigation/core/src/useNavigationState.tsx","node_modules/@react-navigation/core/src/useRoute.tsx","node_modules/@react-navigation/core/src/validatePathConfig.tsx","node_modules/@react-navigation/routers/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  var _checkDuplicateRouteNames = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _checkSerializable = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _EnsureSingleNavigator = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _findFocusedRoute = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _NavigationBuilderContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _NavigationContainerRefContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _NavigationContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _NavigationRouteContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var _NavigationStateContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[13]));

  var _UnhandledActionContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[14]));

  var _useChildListeners2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[15]));

  var _useEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[16]));

  var _useKeyedChildListeners = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[17]));

  var _useOptionsGetters2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[18]));

  var _useSyncState3 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[19]));

  var _excluded = ["key", "routeNames"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var serializableWarnings = [];
  var duplicateNameWarnings = [];

  var getPartialState = function getPartialState(state) {
    if (state === undefined) {
      return;
    }

    var key = state.key,
        routeNames = state.routeNames,
        partialState = (0, _objectWithoutProperties2.default)(state, _excluded);
    return (0, _extends2.default)({}, partialState, {
      stale: true,
      routes: state.routes.map(function (route) {
        if (route.state === undefined) {
          return route;
        }

        return (0, _extends2.default)({}, route, {
          state: getPartialState(route.state)
        });
      })
    });
  };

  var BaseNavigationContainer = React.forwardRef(function BaseNavigationContainer(_ref, ref) {
    var initialState = _ref.initialState,
        onStateChange = _ref.onStateChange,
        onUnhandledAction = _ref.onUnhandledAction,
        independent = _ref.independent,
        children = _ref.children;
    var parent = React.useContext(_NavigationStateContext.default);

    if (!parent.isDefault && !independent) {
      throw new Error("Looks like you have nested a 'NavigationContainer' inside another. Normally you need only one container at the root of the app, so this was probably an error. If this was intentional, pass 'independent={true}' explicitly. Note that this will make the child navigators disconnected from the parent and you won't be able to navigate between them.");
    }

    var _useSyncState = (0, _useSyncState3.default)(function () {
      return getPartialState(initialState == null ? undefined : initialState);
    }),
        _useSyncState2 = (0, _slicedToArray2.default)(_useSyncState, 5),
        state = _useSyncState2[0],
        getState = _useSyncState2[1],
        setState = _useSyncState2[2],
        scheduleUpdate = _useSyncState2[3],
        flushUpdates = _useSyncState2[4];

    var isFirstMountRef = React.useRef(true);
    var navigatorKeyRef = React.useRef();
    var getKey = React.useCallback(function () {
      return navigatorKeyRef.current;
    }, []);
    var setKey = React.useCallback(function (key) {
      navigatorKeyRef.current = key;
    }, []);

    var _useChildListeners = (0, _useChildListeners2.default)(),
        listeners = _useChildListeners.listeners,
        addListener = _useChildListeners.addListener;

    var _useKeyedChildListene = (0, _useKeyedChildListeners.default)(),
        keyedListeners = _useKeyedChildListene.keyedListeners,
        addKeyedListener = _useKeyedChildListene.addKeyedListener;

    var dispatch = React.useCallback(function (action) {
      if (listeners.focus[0] == null) {
        console.error(_$$_REQUIRE(_dependencyMap[20]).NOT_INITIALIZED_ERROR);
      } else {
        listeners.focus[0](function (navigation) {
          return navigation.dispatch(action);
        });
      }
    }, [listeners.focus]);
    var canGoBack = React.useCallback(function () {
      if (listeners.focus[0] == null) {
        return false;
      }

      var _listeners$focus$ = listeners.focus[0](function (navigation) {
        return navigation.canGoBack();
      }),
          result = _listeners$focus$.result,
          handled = _listeners$focus$.handled;

      if (handled) {
        return result;
      } else {
        return false;
      }
    }, [listeners.focus]);
    var resetRoot = React.useCallback(function (state) {
      var _state$key;

      var target = (_state$key = state == null ? undefined : state.key) != null ? _state$key : keyedListeners.getState.root == null ? undefined : keyedListeners.getState.root().key;

      if (target == null) {
        console.error(_$$_REQUIRE(_dependencyMap[20]).NOT_INITIALIZED_ERROR);
      } else {
        listeners.focus[0](function (navigation) {
          return navigation.dispatch((0, _extends2.default)({}, _$$_REQUIRE(_dependencyMap[21]).CommonActions.reset(state), {
            target: target
          }));
        });
      }
    }, [keyedListeners.getState, listeners.focus]);
    var getRootState = React.useCallback(function () {
      return keyedListeners.getState.root == null ? undefined : keyedListeners.getState.root();
    }, [keyedListeners.getState]);
    var getCurrentRoute = React.useCallback(function () {
      var state = getRootState();

      if (state == null) {
        return undefined;
      }

      var route = (0, _findFocusedRoute.default)(state);
      return route;
    }, [getRootState]);
    var emitter = (0, _useEventEmitter.default)();

    var _useOptionsGetters = (0, _useOptionsGetters2.default)({}),
        addOptionsGetter = _useOptionsGetters.addOptionsGetter,
        getCurrentOptions = _useOptionsGetters.getCurrentOptions;

    var navigation = React.useMemo(function () {
      return (0, _extends2.default)({}, Object.keys(_$$_REQUIRE(_dependencyMap[21]).CommonActions).reduce(function (acc, name) {
        acc[name] = function () {
          return dispatch(_$$_REQUIRE(_dependencyMap[21]).CommonActions[name].apply(_$$_REQUIRE(_dependencyMap[21]).CommonActions, arguments));
        };

        return acc;
      }, {}), emitter.create('root'), {
        dispatch: dispatch,
        resetRoot: resetRoot,
        isFocused: function isFocused() {
          return true;
        },
        canGoBack: canGoBack,
        getParent: function getParent() {
          return undefined;
        },
        getState: function getState() {
          return stateRef.current;
        },
        getRootState: getRootState,
        getCurrentRoute: getCurrentRoute,
        getCurrentOptions: getCurrentOptions,
        isReady: function isReady() {
          return listeners.focus[0] != null;
        }
      });
    }, [canGoBack, dispatch, emitter, getCurrentOptions, getCurrentRoute, getRootState, listeners.focus, resetRoot]);
    React.useImperativeHandle(ref, function () {
      return navigation;
    }, [navigation]);
    var onDispatchAction = React.useCallback(function (action, noop) {
      emitter.emit({
        type: '__unsafe_action__',
        data: {
          action: action,
          noop: noop,
          stack: stackRef.current
        }
      });
    }, [emitter]);
    var lastEmittedOptionsRef = React.useRef();
    var onOptionsChange = React.useCallback(function (options) {
      if (lastEmittedOptionsRef.current === options) {
        return;
      }

      lastEmittedOptionsRef.current = options;
      emitter.emit({
        type: 'options',
        data: {
          options: options
        }
      });
    }, [emitter]);
    var stackRef = React.useRef();
    var builderContext = React.useMemo(function () {
      return {
        addListener: addListener,
        addKeyedListener: addKeyedListener,
        onDispatchAction: onDispatchAction,
        onOptionsChange: onOptionsChange,
        stackRef: stackRef
      };
    }, [addListener, addKeyedListener, onDispatchAction, onOptionsChange]);
    var scheduleContext = React.useMemo(function () {
      return {
        scheduleUpdate: scheduleUpdate,
        flushUpdates: flushUpdates
      };
    }, [scheduleUpdate, flushUpdates]);
    var isInitialRef = React.useRef(true);
    var getIsInitial = React.useCallback(function () {
      return isInitialRef.current;
    }, []);
    var context = React.useMemo(function () {
      return {
        state: state,
        getState: getState,
        setState: setState,
        getKey: getKey,
        setKey: setKey,
        getIsInitial: getIsInitial,
        addOptionsGetter: addOptionsGetter
      };
    }, [state, getState, setState, getKey, setKey, getIsInitial, addOptionsGetter]);
    var onStateChangeRef = React.useRef(onStateChange);
    var stateRef = React.useRef(state);
    React.useEffect(function () {
      isInitialRef.current = false;
      onStateChangeRef.current = onStateChange;
      stateRef.current = state;
    });
    React.useEffect(function () {
      var hydratedState = getRootState();
      emitter.emit({
        type: 'state',
        data: {
          state: state
        }
      });

      if (!isFirstMountRef.current && onStateChangeRef.current) {
        onStateChangeRef.current(hydratedState);
      }

      isFirstMountRef.current = false;
    }, [getRootState, emitter, state]);
    var defaultOnUnhandledAction = React.useCallback(function (action) {
      {
        return;
      }
      var payload = action.payload;
      var message = "The action '" + action.type + "'" + (payload ? " with payload " + JSON.stringify(action.payload) : '') + " was not handled by any navigator.";

      switch (action.type) {
        case 'NAVIGATE':
        case 'PUSH':
        case 'REPLACE':
        case 'JUMP_TO':
          if (payload != null && payload.name) {
            message += "\n\nDo you have a screen named '" + payload.name + "'?\n\nIf you're trying to navigate to a screen in a nested navigator, see https://reactnavigation.org/docs/nesting-navigators#navigating-to-a-screen-in-a-nested-navigator.";
          } else {
            message += "\n\nYou need to pass the name of the screen to navigate to.\n\nSee https://reactnavigation.org/docs/navigation-actions for usage.";
          }

          break;

        case 'GO_BACK':
        case 'POP':
        case 'POP_TO_TOP':
          message += "\n\nIs there any screen to go back to?";
          break;

        case 'OPEN_DRAWER':
        case 'CLOSE_DRAWER':
        case 'TOGGLE_DRAWER':
          message += "\n\nIs your screen inside a Drawer navigator?";
          break;
      }

      message += "\n\nThis is a development-only warning and won't be shown in production.";
      console.error(message);
    }, []);
    var element = React.createElement(_NavigationContainerRefContext.default.Provider, {
      value: navigation
    }, React.createElement(_$$_REQUIRE(_dependencyMap[22]).ScheduleUpdateContext.Provider, {
      value: scheduleContext
    }, React.createElement(_NavigationBuilderContext.default.Provider, {
      value: builderContext
    }, React.createElement(_NavigationStateContext.default.Provider, {
      value: context
    }, React.createElement(_UnhandledActionContext.default.Provider, {
      value: onUnhandledAction != null ? onUnhandledAction : defaultOnUnhandledAction
    }, React.createElement(_EnsureSingleNavigator.default, null, children))))));

    if (independent) {
      element = React.createElement(_NavigationRouteContext.default.Provider, {
        value: undefined
      }, React.createElement(_NavigationContext.default.Provider, {
        value: undefined
      }, element));
    }

    return element;
  });
  var _default = BaseNavigationContainer;
  exports.default = _default;
},"node_modules/@react-navigation/core/src/BaseNavigationContainer.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/@react-navigation/core/src/checkDuplicateRouteNames.tsx","node_modules/@react-navigation/core/src/checkSerializable.tsx","node_modules/@react-navigation/core/src/EnsureSingleNavigator.tsx","node_modules/@react-navigation/core/src/findFocusedRoute.tsx","node_modules/@react-navigation/core/src/NavigationBuilderContext.tsx","node_modules/@react-navigation/core/src/NavigationContainerRefContext.tsx","node_modules/@react-navigation/core/src/NavigationContext.tsx","node_modules/@react-navigation/core/src/NavigationRouteContext.tsx","node_modules/@react-navigation/core/src/NavigationStateContext.tsx","node_modules/@react-navigation/core/src/UnhandledActionContext.tsx","node_modules/@react-navigation/core/src/useChildListeners.tsx","node_modules/@react-navigation/core/src/useEventEmitter.tsx","node_modules/@react-navigation/core/src/useKeyedChildListeners.tsx","node_modules/@react-navigation/core/src/useOptionsGetters.tsx","node_modules/@react-navigation/core/src/useSyncState.tsx","node_modules/@react-navigation/core/src/createNavigationContainerRef.tsx","node_modules/@react-navigation/routers/src/index.tsx","node_modules/@react-navigation/core/src/useScheduleUpdate.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = checkDuplicateRouteNames;

  function checkDuplicateRouteNames(state) {
    var duplicates = [];

    var getRouteNames = function getRouteNames(location, state) {
      state.routes.forEach(function (route) {
        var _route$state, _route$state$routeNam;

        var currentLocation = location ? location + " > " + route.name : route.name;
        (_route$state = route.state) == null ? undefined : (_route$state$routeNam = _route$state.routeNames) == null ? undefined : _route$state$routeNam.forEach(function (routeName) {
          if (routeName === route.name) {
            duplicates.push([currentLocation, currentLocation + " > " + route.name]);
          }
        });

        if (route.state) {
          getRouteNames(currentLocation, route.state);
        }
      });
    };

    getRouteNames('', state);
    return duplicates;
  }
},"node_modules/@react-navigation/core/src/checkDuplicateRouteNames.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = checkSerializable;

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var checkSerializableWithoutCircularReference = function checkSerializableWithoutCircularReference(o, seen, location) {
    if (o === undefined || o === null || typeof o === 'boolean' || typeof o === 'number' || typeof o === 'string') {
      return {
        serializable: true
      };
    }

    if (Object.prototype.toString.call(o) !== '[object Object]' && !Array.isArray(o)) {
      return {
        serializable: false,
        location: location,
        reason: typeof o === 'function' ? 'Function' : String(o)
      };
    }

    if (seen.has(o)) {
      return {
        serializable: false,
        reason: 'Circular reference',
        location: location
      };
    }

    seen.add(o);

    if (Array.isArray(o)) {
      for (var i = 0; i < o.length; i++) {
        var childResult = checkSerializableWithoutCircularReference(o[i], new Set(seen), [].concat((0, _toConsumableArray2.default)(location), [i]));

        if (!childResult.serializable) {
          return childResult;
        }
      }
    } else {
      for (var _key in o) {
        var _childResult = checkSerializableWithoutCircularReference(o[_key], new Set(seen), [].concat((0, _toConsumableArray2.default)(location), [_key]));

        if (!_childResult.serializable) {
          return _childResult;
        }
      }
    }

    return {
      serializable: true
    };
  };

  function checkSerializable(o) {
    return checkSerializableWithoutCircularReference(o, new Set(), []);
  }
},"node_modules/@react-navigation/core/src/checkSerializable.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/toConsumableArray.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SingleNavigatorContext = undefined;
  exports.default = EnsureSingleNavigator;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var MULTIPLE_NAVIGATOR_ERROR = "Another navigator is already registered for this container. You likely have multiple navigators under a single \"NavigationContainer\" or \"Screen\". Make sure each navigator is under a separate \"Screen\" container. See https://reactnavigation.org/docs/nesting-navigators for a guide on nesting.";
  var SingleNavigatorContext = React.createContext(undefined);
  exports.SingleNavigatorContext = SingleNavigatorContext;

  function EnsureSingleNavigator(_ref) {
    var children = _ref.children;
    var navigatorKeyRef = React.useRef();
    var value = React.useMemo(function () {
      return {
        register: function register(key) {
          var currentKey = navigatorKeyRef.current;

          if (currentKey !== undefined && key !== currentKey) {
            throw new Error(MULTIPLE_NAVIGATOR_ERROR);
          }

          navigatorKeyRef.current = key;
        },
        unregister: function unregister(key) {
          var currentKey = navigatorKeyRef.current;

          if (key !== currentKey) {
            return;
          }

          navigatorKeyRef.current = undefined;
        }
      };
    }, []);
    return React.createElement(SingleNavigatorContext.Provider, {
      value: value
    }, children);
  }
},"node_modules/@react-navigation/core/src/EnsureSingleNavigator.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = findFocusedRoute;

  function findFocusedRoute(state) {
    var _current2, _current$index3, _current3;

    var current = state;

    while (((_current = current) == null ? undefined : _current.routes[(_current$index = current.index) != null ? _current$index : 0].state) != null) {
      var _current, _current$index, _current$index2;

      current = current.routes[(_current$index2 = current.index) != null ? _current$index2 : 0].state;
    }

    var route = (_current2 = current) == null ? undefined : _current2.routes[(_current$index3 = (_current3 = current) == null ? undefined : _current3.index) != null ? _current$index3 : 0];
    return route;
  }
},"node_modules/@react-navigation/core/src/findFocusedRoute.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var NavigationBuilderContext = React.createContext({
    onDispatchAction: function onDispatchAction() {
      return undefined;
    },
    onOptionsChange: function onOptionsChange() {
      return undefined;
    }
  });
  var _default = NavigationBuilderContext;
  exports.default = _default;
},"node_modules/@react-navigation/core/src/NavigationBuilderContext.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var NavigationContainerRefContext = React.createContext(undefined);
  var _default = NavigationContainerRefContext;
  exports.default = _default;
},"node_modules/@react-navigation/core/src/NavigationContainerRefContext.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var NavigationContext = React.createContext(undefined);
  var _default = NavigationContext;
  exports.default = _default;
},"node_modules/@react-navigation/core/src/NavigationContext.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var NavigationRouteContext = React.createContext(undefined);
  var _default = NavigationRouteContext;
  exports.default = _default;
},"node_modules/@react-navigation/core/src/NavigationRouteContext.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var MISSING_CONTEXT_ERROR = "Couldn't find a navigation context. Have you wrapped your app with 'NavigationContainer'? See https://reactnavigation.org/docs/getting-started for setup instructions.";

  var _default = React.createContext({
    isDefault: true,

    get getKey() {
      throw new Error(MISSING_CONTEXT_ERROR);
    },

    get setKey() {
      throw new Error(MISSING_CONTEXT_ERROR);
    },

    get getState() {
      throw new Error(MISSING_CONTEXT_ERROR);
    },

    get setState() {
      throw new Error(MISSING_CONTEXT_ERROR);
    },

    get getIsInitial() {
      throw new Error(MISSING_CONTEXT_ERROR);
    }

  });

  exports.default = _default;
},"node_modules/@react-navigation/core/src/NavigationStateContext.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var UnhandledActionContext = React.createContext(undefined);
  var _default = UnhandledActionContext;
  exports.default = _default;
},"node_modules/@react-navigation/core/src/UnhandledActionContext.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useChildListeners;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useChildListeners() {
    var _React$useRef = React.useRef({
      action: [],
      focus: []
    }),
        listeners = _React$useRef.current;

    var addListener = React.useCallback(function (type, listener) {
      listeners[type].push(listener);
      return function () {
        var index = listeners[type].indexOf(listener);
        listeners[type].splice(index, 1);
      };
    }, [listeners]);
    return {
      listeners: listeners,
      addListener: addListener
    };
  }
},"node_modules/@react-navigation/core/src/useChildListeners.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useEventEmitter;

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useEventEmitter(listen) {
    var listenRef = React.useRef(listen);
    React.useEffect(function () {
      listenRef.current = listen;
    });
    var listeners = React.useRef({});
    var create = React.useCallback(function (target) {
      var removeListener = function removeListener(type, callback) {
        var callbacks = listeners.current[type] ? listeners.current[type][target] : undefined;

        if (!callbacks) {
          return;
        }

        var index = callbacks.indexOf(callback);
        callbacks.splice(index, 1);
      };

      var addListener = function addListener(type, callback) {
        listeners.current[type] = listeners.current[type] || {};
        listeners.current[type][target] = listeners.current[type][target] || [];
        listeners.current[type][target].push(callback);
        return function () {
          return removeListener(type, callback);
        };
      };

      return {
        addListener: addListener,
        removeListener: removeListener
      };
    }, []);
    var emit = React.useCallback(function (_ref) {
      var _items$target, _ref2;

      var type = _ref.type,
          data = _ref.data,
          target = _ref.target,
          canPreventDefault = _ref.canPreventDefault;
      var items = listeners.current[type] || {};
      var callbacks = target !== undefined ? (_items$target = items[target]) == null ? undefined : _items$target.slice() : (_ref2 = []).concat.apply(_ref2, (0, _toConsumableArray2.default)(Object.keys(items).map(function (t) {
        return items[t];
      }))).filter(function (cb, i, self) {
        return self.lastIndexOf(cb) === i;
      });
      var event = {
        get type() {
          return type;
        }

      };

      if (target !== undefined) {
        Object.defineProperty(event, 'target', {
          enumerable: true,
          get: function get() {
            return target;
          }
        });
      }

      if (data !== undefined) {
        Object.defineProperty(event, 'data', {
          enumerable: true,
          get: function get() {
            return data;
          }
        });
      }

      if (canPreventDefault) {
        var defaultPrevented = false;
        Object.defineProperties(event, {
          defaultPrevented: {
            enumerable: true,
            get: function get() {
              return defaultPrevented;
            }
          },
          preventDefault: {
            enumerable: true,
            value: function value() {
              defaultPrevented = true;
            }
          }
        });
      }

      listenRef.current == null ? undefined : listenRef.current(event);
      callbacks == null ? undefined : callbacks.forEach(function (cb) {
        return cb(event);
      });
      return event;
    }, []);
    return React.useMemo(function () {
      return {
        create: create,
        emit: emit
      };
    }, [create, emit]);
  }
},"node_modules/@react-navigation/core/src/useEventEmitter.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useKeyedChildListeners;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useKeyedChildListeners() {
    var _React$useRef = React.useRef({
      getState: {},
      beforeRemove: {}
    }),
        keyedListeners = _React$useRef.current;

    var addKeyedListener = React.useCallback(function (type, key, listener) {
      keyedListeners[type][key] = listener;
      return function () {
        keyedListeners[type][key] = undefined;
      };
    }, [keyedListeners]);
    return {
      keyedListeners: keyedListeners,
      addKeyedListener: addKeyedListener
    };
  }
},"node_modules/@react-navigation/core/src/useKeyedChildListeners.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useOptionsGetters;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _NavigationBuilderContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  var _NavigationStateContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useOptionsGetters(_ref) {
    var key = _ref.key,
        options = _ref.options,
        navigation = _ref.navigation;
    var optionsRef = React.useRef(options);
    var optionsGettersFromChildRef = React.useRef({});

    var _React$useContext = React.useContext(_NavigationBuilderContext.default),
        onOptionsChange = _React$useContext.onOptionsChange;

    var _React$useContext2 = React.useContext(_NavigationStateContext.default),
        parentAddOptionsGetter = _React$useContext2.addOptionsGetter;

    var optionsChangeListener = React.useCallback(function () {
      var _navigation$isFocused;

      var isFocused = (_navigation$isFocused = navigation == null ? undefined : navigation.isFocused()) != null ? _navigation$isFocused : true;
      var hasChildren = Object.keys(optionsGettersFromChildRef.current).length;

      if (isFocused && !hasChildren) {
        var _optionsRef$current;

        onOptionsChange((_optionsRef$current = optionsRef.current) != null ? _optionsRef$current : {});
      }
    }, [navigation, onOptionsChange]);
    React.useEffect(function () {
      optionsRef.current = options;
      optionsChangeListener();
      return navigation == null ? undefined : navigation.addListener('focus', optionsChangeListener);
    }, [navigation, options, optionsChangeListener]);
    var getOptionsFromListener = React.useCallback(function () {
      for (var _key in optionsGettersFromChildRef.current) {
        if (optionsGettersFromChildRef.current.hasOwnProperty(_key)) {
          var _optionsGettersFromCh, _optionsGettersFromCh2;

          var result = (_optionsGettersFromCh = (_optionsGettersFromCh2 = optionsGettersFromChildRef.current)[_key]) == null ? undefined : _optionsGettersFromCh.call(_optionsGettersFromCh2);

          if (result !== null) {
            return result;
          }
        }
      }

      return null;
    }, []);
    var getCurrentOptions = React.useCallback(function () {
      var _navigation$isFocused2;

      var isFocused = (_navigation$isFocused2 = navigation == null ? undefined : navigation.isFocused()) != null ? _navigation$isFocused2 : true;

      if (!isFocused) {
        return null;
      }

      var optionsFromListener = getOptionsFromListener();

      if (optionsFromListener !== null) {
        return optionsFromListener;
      }

      return optionsRef.current;
    }, [navigation, getOptionsFromListener]);
    React.useEffect(function () {
      return parentAddOptionsGetter == null ? undefined : parentAddOptionsGetter(key, getCurrentOptions);
    }, [getCurrentOptions, parentAddOptionsGetter, key]);
    var addOptionsGetter = React.useCallback(function (key, getter) {
      optionsGettersFromChildRef.current[key] = getter;
      optionsChangeListener();
      return function () {
        delete optionsGettersFromChildRef.current[key];
        optionsChangeListener();
      };
    }, [optionsChangeListener]);
    return {
      addOptionsGetter: addOptionsGetter,
      getCurrentOptions: getCurrentOptions
    };
  }
},"node_modules/@react-navigation/core/src/useOptionsGetters.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/core/src/NavigationBuilderContext.tsx","node_modules/@react-navigation/core/src/NavigationStateContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useSyncState;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var UNINTIALIZED_STATE = {};

  function useSyncState(initialState) {
    var stateRef = React.useRef(UNINTIALIZED_STATE);
    var isSchedulingRef = React.useRef(false);
    var isMountedRef = React.useRef(true);
    React.useEffect(function () {
      isMountedRef.current = true;
      return function () {
        isMountedRef.current = false;
      };
    }, []);

    if (stateRef.current === UNINTIALIZED_STATE) {
      stateRef.current = typeof initialState === 'function' ? initialState() : initialState;
    }

    var _React$useState = React.useState(stateRef.current),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
        trackingState = _React$useState2[0],
        setTrackingState = _React$useState2[1];

    var getState = React.useCallback(function () {
      return stateRef.current;
    }, []);
    var setState = React.useCallback(function (state) {
      if (state === stateRef.current || !isMountedRef.current) {
        return;
      }

      stateRef.current = state;

      if (!isSchedulingRef.current) {
        setTrackingState(state);
      }
    }, []);
    var scheduleUpdate = React.useCallback(function (callback) {
      isSchedulingRef.current = true;

      try {
        callback();
      } finally {
        isSchedulingRef.current = false;
      }
    }, []);
    var flushUpdates = React.useCallback(function () {
      if (!isMountedRef.current) {
        return;
      }

      setTrackingState(stateRef.current);
    }, []);

    if (trackingState !== stateRef.current) {
      setTrackingState(stateRef.current);
    }

    var state = stateRef.current;
    React.useDebugValue(state);
    return [state, getState, setState, scheduleUpdate, flushUpdates];
  }
},"node_modules/@react-navigation/core/src/useSyncState.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NOT_INITIALIZED_ERROR = undefined;
  exports.default = createNavigationContainerRef;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var NOT_INITIALIZED_ERROR = "The 'navigation' object hasn't been initialized yet. This might happen if you don't have a navigator mounted, or if the navigator hasn't finished mounting. See https://reactnavigation.org/docs/navigating-without-navigation-prop#handling-initialization for more details.";
  exports.NOT_INITIALIZED_ERROR = NOT_INITIALIZED_ERROR;

  function createNavigationContainerRef() {
    var methods = [].concat((0, _toConsumableArray2.default)(Object.keys(_$$_REQUIRE(_dependencyMap[4]).CommonActions)), ['addListener', 'removeListener', 'resetRoot', 'dispatch', 'isFocused', 'canGoBack', 'getRootState', 'getState', 'getParent', 'getCurrentRoute', 'getCurrentOptions']);
    var listeners = {};

    var removeListener = function removeListener(event, callback) {
      if (listeners[event]) {
        listeners[event] = listeners[event].filter(function (cb) {
          return cb !== callback;
        });
      }
    };

    var current = null;
    var ref = (0, _extends2.default)({
      get current() {
        return current;
      },

      set current(value) {
        current = value;

        if (value != null) {
          Object.entries(listeners).forEach(function (_ref) {
            var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
                event = _ref2[0],
                callbacks = _ref2[1];

            callbacks.forEach(function (callback) {
              value.addListener(event, callback);
            });
          });
        }
      },

      isReady: function isReady() {
        if (current == null) {
          return false;
        }

        return current.isReady();
      }
    }, methods.reduce(function (acc, name) {
      acc[name] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (current == null) {
          switch (name) {
            case 'addListener':
              {
                var event = args[0],
                    callback = args[1];
                listeners[event] = listeners[event] || [];
                listeners[event].push(callback);
                return function () {
                  return removeListener(event, callback);
                };
              }

            case 'removeListener':
              {
                var _event = args[0],
                    _callback = args[1];
                removeListener(_event, _callback);
                break;
              }

            default:
              console.error(NOT_INITIALIZED_ERROR);
          }
        } else {
          var _current;

          return (_current = current)[name].apply(_current, args);
        }
      };

      return acc;
    }, {}));
    return ref;
  }
},"node_modules/@react-navigation/core/src/createNavigationContainerRef.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/@react-navigation/routers/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    CommonActions: true,
    BaseRouter: true,
    DrawerActions: true,
    DrawerRouter: true,
    StackActions: true,
    StackRouter: true,
    TabActions: true,
    TabRouter: true
  };
  Object.defineProperty(exports, "BaseRouter", {
    enumerable: true,
    get: function get() {
      return _BaseRouter.default;
    }
  });
  exports.CommonActions = undefined;
  Object.defineProperty(exports, "DrawerActions", {
    enumerable: true,
    get: function get() {
      return _DrawerRouter.DrawerActions;
    }
  });
  Object.defineProperty(exports, "DrawerRouter", {
    enumerable: true,
    get: function get() {
      return _DrawerRouter.default;
    }
  });
  Object.defineProperty(exports, "StackActions", {
    enumerable: true,
    get: function get() {
      return _StackRouter.StackActions;
    }
  });
  Object.defineProperty(exports, "StackRouter", {
    enumerable: true,
    get: function get() {
      return _StackRouter.default;
    }
  });
  Object.defineProperty(exports, "TabActions", {
    enumerable: true,
    get: function get() {
      return _TabRouter.TabActions;
    }
  });
  Object.defineProperty(exports, "TabRouter", {
    enumerable: true,
    get: function get() {
      return _TabRouter.default;
    }
  });

  var CommonActions = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  exports.CommonActions = CommonActions;

  var _BaseRouter = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  var _DrawerRouter = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _StackRouter = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  var _TabRouter = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[5]));

  Object.keys(_$$_REQUIRE(_dependencyMap[6])).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[6])[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[6])[key];
      }
    });
  });

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},"node_modules/@react-navigation/routers/src/index.tsx",["node_modules/@react-navigation/routers/src/CommonActions.tsx","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/routers/src/BaseRouter.tsx","node_modules/@react-navigation/routers/src/DrawerRouter.tsx","node_modules/@react-navigation/routers/src/StackRouter.tsx","node_modules/@react-navigation/routers/src/TabRouter.tsx","node_modules/@react-navigation/routers/src/types.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.goBack = goBack;
  exports.navigate = navigate;
  exports.reset = reset;
  exports.setParams = setParams;

  function goBack() {
    return {
      type: 'GO_BACK'
    };
  }

  function navigate() {
    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
      return {
        type: 'NAVIGATE',
        payload: {
          name: arguments.length <= 0 ? undefined : arguments[0],
          params: arguments.length <= 1 ? undefined : arguments[1]
        }
      };
    } else {
      var payload = (arguments.length <= 0 ? undefined : arguments[0]) || {};

      if (!payload.hasOwnProperty('key') && !payload.hasOwnProperty('name')) {
        throw new Error('You need to specify name or key when calling navigate with an object as the argument. See https://reactnavigation.org/docs/navigation-actions#navigate for usage.');
      }

      return {
        type: 'NAVIGATE',
        payload: payload
      };
    }
  }

  function reset(state) {
    return {
      type: 'RESET',
      payload: state
    };
  }

  function setParams(params) {
    return {
      type: 'SET_PARAMS',
      payload: {
        params: params
      }
    };
  }
},"node_modules/@react-navigation/routers/src/CommonActions.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var BaseRouter = {
    getStateForAction: function getStateForAction(state, action) {
      switch (action.type) {
        case 'SET_PARAMS':
          {
            var index = action.source ? state.routes.findIndex(function (r) {
              return r.key === action.source;
            }) : state.index;

            if (index === -1) {
              return null;
            }

            return (0, _extends2.default)({}, state, {
              routes: state.routes.map(function (r, i) {
                return i === index ? (0, _extends2.default)({}, r, {
                  params: (0, _extends2.default)({}, r.params, action.payload.params)
                }) : r;
              })
            });
          }

        case 'RESET':
          {
            var nextState = action.payload;

            if (nextState.routes.length === 0 || nextState.routes.some(function (route) {
              return !state.routeNames.includes(route.name);
            })) {
              return null;
            }

            if (nextState.stale === false) {
              if (state.routeNames.length !== nextState.routeNames.length || nextState.routeNames.some(function (name) {
                return !state.routeNames.includes(name);
              })) {
                return null;
              }

              return (0, _extends2.default)({}, nextState, {
                routes: nextState.routes.map(function (route) {
                  return route.key ? route : (0, _extends2.default)({}, route, {
                    key: route.name + "-" + (0, _$$_REQUIRE(_dependencyMap[2]).nanoid)()
                  });
                })
              });
            }

            return nextState;
          }

        default:
          return null;
      }
    },
    shouldActionChangeFocus: function shouldActionChangeFocus(action) {
      return action.type === 'NAVIGATE';
    }
  };
  var _default = BaseRouter;
  exports.default = _default;
},"node_modules/@react-navigation/routers/src/BaseRouter.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/nanoid/non-secure/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.nanoid = exports.customAlphabet = undefined;
  var urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';

  var customAlphabet = function customAlphabet(alphabet) {
    var defaultSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 21;
    return function () {
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSize;
      var id = '';
      var i = size;

      while (i--) {
        id += alphabet[Math.random() * alphabet.length | 0];
      }

      return id;
    };
  };

  exports.customAlphabet = customAlphabet;

  var nanoid = function nanoid() {
    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 21;
    var id = '';
    var i = size;

    while (i--) {
      id += urlAlphabet[Math.random() * 64 | 0];
    }

    return id;
  };

  exports.nanoid = nanoid;
},"node_modules/nanoid/non-secure/index.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DrawerActions = undefined;
  exports.default = DrawerRouter;

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _TabRouter = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  var _excluded = ["defaultStatus"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var DrawerActions = (0, _extends2.default)({}, _TabRouter.TabActions, {
    openDrawer: function openDrawer() {
      return {
        type: 'OPEN_DRAWER'
      };
    },
    closeDrawer: function closeDrawer() {
      return {
        type: 'CLOSE_DRAWER'
      };
    },
    toggleDrawer: function toggleDrawer() {
      return {
        type: 'TOGGLE_DRAWER'
      };
    }
  });
  exports.DrawerActions = DrawerActions;

  function DrawerRouter(_ref) {
    var _ref$defaultStatus = _ref.defaultStatus,
        defaultStatus = _ref$defaultStatus === undefined ? 'closed' : _ref$defaultStatus,
        rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);
    var router = (0, _TabRouter.default)(rest);

    var isDrawerInHistory = function isDrawerInHistory(state) {
      var _state$history;

      return Boolean((_state$history = state.history) == null ? undefined : _state$history.some(function (it) {
        return it.type === 'drawer';
      }));
    };

    var addDrawerToHistory = function addDrawerToHistory(state) {
      if (isDrawerInHistory(state)) {
        return state;
      }

      return (0, _extends2.default)({}, state, {
        history: [].concat((0, _toConsumableArray2.default)(state.history), [{
          type: 'drawer',
          status: defaultStatus === 'open' ? 'closed' : 'open'
        }])
      });
    };

    var removeDrawerFromHistory = function removeDrawerFromHistory(state) {
      if (!isDrawerInHistory(state)) {
        return state;
      }

      return (0, _extends2.default)({}, state, {
        history: state.history.filter(function (it) {
          return it.type !== 'drawer';
        })
      });
    };

    var openDrawer = function openDrawer(state) {
      if (defaultStatus === 'open') {
        return removeDrawerFromHistory(state);
      }

      return addDrawerToHistory(state);
    };

    var closeDrawer = function closeDrawer(state) {
      if (defaultStatus === 'open') {
        return addDrawerToHistory(state);
      }

      return removeDrawerFromHistory(state);
    };

    return (0, _extends2.default)({}, router, {
      type: 'drawer',
      getInitialState: function getInitialState(_ref2) {
        var routeNames = _ref2.routeNames,
            routeParamList = _ref2.routeParamList,
            routeGetIdList = _ref2.routeGetIdList;
        var state = router.getInitialState({
          routeNames: routeNames,
          routeParamList: routeParamList,
          routeGetIdList: routeGetIdList
        });
        return (0, _extends2.default)({}, state, {
          default: defaultStatus,
          stale: false,
          type: 'drawer',
          key: "drawer-" + (0, _$$_REQUIRE(_dependencyMap[5]).nanoid)()
        });
      },
      getRehydratedState: function getRehydratedState(partialState, _ref3) {
        var routeNames = _ref3.routeNames,
            routeParamList = _ref3.routeParamList,
            routeGetIdList = _ref3.routeGetIdList;

        if (partialState.stale === false) {
          return partialState;
        }

        var state = router.getRehydratedState(partialState, {
          routeNames: routeNames,
          routeParamList: routeParamList,
          routeGetIdList: routeGetIdList
        });

        if (isDrawerInHistory(partialState)) {
          state = removeDrawerFromHistory(state);
          state = addDrawerToHistory(state);
        }

        return (0, _extends2.default)({}, state, {
          default: defaultStatus,
          type: 'drawer',
          key: "drawer-" + (0, _$$_REQUIRE(_dependencyMap[5]).nanoid)()
        });
      },
      getStateForRouteFocus: function getStateForRouteFocus(state, key) {
        var result = router.getStateForRouteFocus(state, key);
        return closeDrawer(result);
      },
      getStateForAction: function getStateForAction(state, action, options) {
        switch (action.type) {
          case 'OPEN_DRAWER':
            return openDrawer(state);

          case 'CLOSE_DRAWER':
            return closeDrawer(state);

          case 'TOGGLE_DRAWER':
            if (isDrawerInHistory(state)) {
              return removeDrawerFromHistory(state);
            }

            return addDrawerToHistory(state);

          case 'JUMP_TO':
          case 'NAVIGATE':
            {
              var result = router.getStateForAction(state, action, options);

              if (result != null && result.index !== state.index) {
                return closeDrawer(result);
              }

              return result;
            }

          case 'GO_BACK':
            if (isDrawerInHistory(state)) {
              return removeDrawerFromHistory(state);
            }

            return router.getStateForAction(state, action, options);

          default:
            return router.getStateForAction(state, action, options);
        }
      },
      actionCreators: DrawerActions
    });
  }
},"node_modules/@react-navigation/routers/src/DrawerRouter.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@react-navigation/routers/src/TabRouter.tsx","node_modules/nanoid/non-secure/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TabActions = undefined;
  exports.default = TabRouter;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _BaseRouter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var TYPE_ROUTE = 'route';
  var TabActions = {
    jumpTo: function jumpTo(name, params) {
      return {
        type: 'JUMP_TO',
        payload: {
          name: name,
          params: params
        }
      };
    }
  };
  exports.TabActions = TabActions;

  var getRouteHistory = function getRouteHistory(routes, index, backBehavior, initialRouteName) {
    var history = [{
      type: TYPE_ROUTE,
      key: routes[index].key
    }];
    var initialRouteIndex;

    switch (backBehavior) {
      case 'order':
        for (var i = index; i > 0; i--) {
          history.unshift({
            type: TYPE_ROUTE,
            key: routes[i - 1].key
          });
        }

        break;

      case 'firstRoute':
        if (index !== 0) {
          history.unshift({
            type: TYPE_ROUTE,
            key: routes[0].key
          });
        }

        break;

      case 'initialRoute':
        initialRouteIndex = routes.findIndex(function (route) {
          return route.name === initialRouteName;
        });
        initialRouteIndex = initialRouteIndex === -1 ? 0 : initialRouteIndex;

        if (index !== initialRouteIndex) {
          history.unshift({
            type: TYPE_ROUTE,
            key: routes[initialRouteIndex].key
          });
        }

        break;

      case 'history':
        break;
    }

    return history;
  };

  var changeIndex = function changeIndex(state, index, backBehavior, initialRouteName) {
    var history;

    if (backBehavior === 'history') {
      var currentKey = state.routes[index].key;
      history = state.history.filter(function (it) {
        return it.type === 'route' ? it.key !== currentKey : false;
      }).concat({
        type: TYPE_ROUTE,
        key: currentKey
      });
    } else {
      history = getRouteHistory(state.routes, index, backBehavior, initialRouteName);
    }

    return (0, _extends2.default)({}, state, {
      index: index,
      history: history
    });
  };

  function TabRouter(_ref) {
    var initialRouteName = _ref.initialRouteName,
        _ref$backBehavior = _ref.backBehavior,
        backBehavior = _ref$backBehavior === undefined ? 'firstRoute' : _ref$backBehavior;
    var router = (0, _extends2.default)({}, _BaseRouter.default, {
      type: 'tab',
      getInitialState: function getInitialState(_ref2) {
        var routeNames = _ref2.routeNames,
            routeParamList = _ref2.routeParamList;
        var index = initialRouteName !== undefined && routeNames.includes(initialRouteName) ? routeNames.indexOf(initialRouteName) : 0;
        var routes = routeNames.map(function (name) {
          return {
            name: name,
            key: name + "-" + (0, _$$_REQUIRE(_dependencyMap[3]).nanoid)(),
            params: routeParamList[name]
          };
        });
        var history = getRouteHistory(routes, index, backBehavior, initialRouteName);
        return {
          stale: false,
          type: 'tab',
          key: "tab-" + (0, _$$_REQUIRE(_dependencyMap[3]).nanoid)(),
          index: index,
          routeNames: routeNames,
          history: history,
          routes: routes
        };
      },
      getRehydratedState: function getRehydratedState(partialState, _ref3) {
        var _state$routes, _state$index, _state$history$filter, _state$history;

        var routeNames = _ref3.routeNames,
            routeParamList = _ref3.routeParamList;
        var state = partialState;

        if (state.stale === false) {
          return state;
        }

        var routes = routeNames.map(function (name) {
          var route = state.routes.find(function (r) {
            return r.name === name;
          });
          return (0, _extends2.default)({}, route, {
            name: name,
            key: route && route.name === name && route.key ? route.key : name + "-" + (0, _$$_REQUIRE(_dependencyMap[3]).nanoid)(),
            params: routeParamList[name] !== undefined ? (0, _extends2.default)({}, routeParamList[name], route ? route.params : undefined) : route ? route.params : undefined
          });
        });
        var index = Math.min(Math.max(routeNames.indexOf((_state$routes = state.routes[(_state$index = state == null ? undefined : state.index) != null ? _state$index : 0]) == null ? undefined : _state$routes.name), 0), routes.length - 1);
        var history = (_state$history$filter = (_state$history = state.history) == null ? undefined : _state$history.filter(function (it) {
          return routes.find(function (r) {
            return r.key === it.key;
          });
        })) != null ? _state$history$filter : [];
        return changeIndex({
          stale: false,
          type: 'tab',
          key: "tab-" + (0, _$$_REQUIRE(_dependencyMap[3]).nanoid)(),
          index: index,
          routeNames: routeNames,
          history: history,
          routes: routes
        }, index, backBehavior, initialRouteName);
      },
      getStateForRouteNamesChange: function getStateForRouteNamesChange(state, _ref4) {
        var routeNames = _ref4.routeNames,
            routeParamList = _ref4.routeParamList,
            routeKeyChanges = _ref4.routeKeyChanges;
        var routes = routeNames.map(function (name) {
          return state.routes.find(function (r) {
            return r.name === name && !routeKeyChanges.includes(r.name);
          }) || {
            name: name,
            key: name + "-" + (0, _$$_REQUIRE(_dependencyMap[3]).nanoid)(),
            params: routeParamList[name]
          };
        });
        var index = Math.max(0, routeNames.indexOf(state.routes[state.index].name));
        var history = state.history.filter(function (it) {
          return it.type !== 'route' || routes.find(function (r) {
            return r.key === it.key;
          });
        });

        if (!history.length) {
          history = getRouteHistory(routes, index, backBehavior, initialRouteName);
        }

        return (0, _extends2.default)({}, state, {
          history: history,
          routeNames: routeNames,
          routes: routes,
          index: index
        });
      },
      getStateForRouteFocus: function getStateForRouteFocus(state, key) {
        var index = state.routes.findIndex(function (r) {
          return r.key === key;
        });

        if (index === -1 || index === state.index) {
          return state;
        }

        return changeIndex(state, index, backBehavior, initialRouteName);
      },
      getStateForAction: function getStateForAction(state, action, _ref5) {
        var routeParamList = _ref5.routeParamList;

        switch (action.type) {
          case 'JUMP_TO':
          case 'NAVIGATE':
            {
              var index = -1;

              if (action.type === 'NAVIGATE' && action.payload.key) {
                index = state.routes.findIndex(function (route) {
                  return route.key === action.payload.key;
                });
              } else {
                index = state.routes.findIndex(function (route) {
                  return route.name === action.payload.name;
                });
              }

              if (index === -1) {
                return null;
              }

              return changeIndex((0, _extends2.default)({}, state, {
                routes: state.routes.map(function (route, i) {
                  if (i !== index) {
                    return route;
                  }

                  var params;

                  if (action.type === 'NAVIGATE' && action.payload.merge) {
                    params = action.payload.params !== undefined || routeParamList[route.name] !== undefined ? (0, _extends2.default)({}, routeParamList[route.name], route.params, action.payload.params) : route.params;
                  } else {
                    params = routeParamList[route.name] !== undefined ? (0, _extends2.default)({}, routeParamList[route.name], action.payload.params) : action.payload.params;
                  }

                  var path = action.type === 'NAVIGATE' && action.payload.path != null ? action.payload.path : route.path;
                  return params !== route.params || path !== route.path ? (0, _extends2.default)({}, route, {
                    path: path,
                    params: params
                  }) : route;
                })
              }), index, backBehavior, initialRouteName);
            }

          case 'GO_BACK':
            {
              if (state.history.length === 1) {
                return null;
              }

              var previousKey = state.history[state.history.length - 2].key;

              var _index = state.routes.findIndex(function (route) {
                return route.key === previousKey;
              });

              if (_index === -1) {
                return null;
              }

              return (0, _extends2.default)({}, state, {
                history: state.history.slice(0, -1),
                index: _index
              });
            }

          default:
            return _BaseRouter.default.getStateForAction(state, action);
        }
      },
      shouldActionChangeFocus: function shouldActionChangeFocus(action) {
        return action.type === 'NAVIGATE';
      },
      actionCreators: TabActions
    });
    return router;
  }
},"node_modules/@react-navigation/routers/src/TabRouter.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@react-navigation/routers/src/BaseRouter.tsx","node_modules/nanoid/non-secure/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StackActions = undefined;
  exports.default = StackRouter;

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _BaseRouter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var StackActions = {
    replace: function replace(name, params) {
      return {
        type: 'REPLACE',
        payload: {
          name: name,
          params: params
        }
      };
    },
    push: function push(name, params) {
      return {
        type: 'PUSH',
        payload: {
          name: name,
          params: params
        }
      };
    },
    pop: function pop() {
      var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return {
        type: 'POP',
        payload: {
          count: count
        }
      };
    },
    popToTop: function popToTop() {
      return {
        type: 'POP_TO_TOP'
      };
    }
  };
  exports.StackActions = StackActions;

  function StackRouter(options) {
    var router = (0, _extends2.default)({}, _BaseRouter.default, {
      type: 'stack',
      getInitialState: function getInitialState(_ref) {
        var routeNames = _ref.routeNames,
            routeParamList = _ref.routeParamList;
        var initialRouteName = options.initialRouteName !== undefined && routeNames.includes(options.initialRouteName) ? options.initialRouteName : routeNames[0];
        return {
          stale: false,
          type: 'stack',
          key: "stack-" + (0, _$$_REQUIRE(_dependencyMap[4]).nanoid)(),
          index: 0,
          routeNames: routeNames,
          routes: [{
            key: initialRouteName + "-" + (0, _$$_REQUIRE(_dependencyMap[4]).nanoid)(),
            name: initialRouteName,
            params: routeParamList[initialRouteName]
          }]
        };
      },
      getRehydratedState: function getRehydratedState(partialState, _ref2) {
        var routeNames = _ref2.routeNames,
            routeParamList = _ref2.routeParamList;
        var state = partialState;

        if (state.stale === false) {
          return state;
        }

        var routes = state.routes.filter(function (route) {
          return routeNames.includes(route.name);
        }).map(function (route) {
          return (0, _extends2.default)({}, route, {
            key: route.key || route.name + "-" + (0, _$$_REQUIRE(_dependencyMap[4]).nanoid)(),
            params: routeParamList[route.name] !== undefined ? (0, _extends2.default)({}, routeParamList[route.name], route.params) : route.params
          });
        });

        if (routes.length === 0) {
          var initialRouteName = options.initialRouteName !== undefined ? options.initialRouteName : routeNames[0];
          routes.push({
            key: initialRouteName + "-" + (0, _$$_REQUIRE(_dependencyMap[4]).nanoid)(),
            name: initialRouteName,
            params: routeParamList[initialRouteName]
          });
        }

        return {
          stale: false,
          type: 'stack',
          key: "stack-" + (0, _$$_REQUIRE(_dependencyMap[4]).nanoid)(),
          index: routes.length - 1,
          routeNames: routeNames,
          routes: routes
        };
      },
      getStateForRouteNamesChange: function getStateForRouteNamesChange(state, _ref3) {
        var routeNames = _ref3.routeNames,
            routeParamList = _ref3.routeParamList,
            routeKeyChanges = _ref3.routeKeyChanges;
        var routes = state.routes.filter(function (route) {
          return routeNames.includes(route.name) && !routeKeyChanges.includes(route.name);
        });

        if (routes.length === 0) {
          var initialRouteName = options.initialRouteName !== undefined && routeNames.includes(options.initialRouteName) ? options.initialRouteName : routeNames[0];
          routes.push({
            key: initialRouteName + "-" + (0, _$$_REQUIRE(_dependencyMap[4]).nanoid)(),
            name: initialRouteName,
            params: routeParamList[initialRouteName]
          });
        }

        return (0, _extends2.default)({}, state, {
          routeNames: routeNames,
          routes: routes,
          index: Math.min(state.index, routes.length - 1)
        });
      },
      getStateForRouteFocus: function getStateForRouteFocus(state, key) {
        var index = state.routes.findIndex(function (r) {
          return r.key === key;
        });

        if (index === -1 || index === state.index) {
          return state;
        }

        return (0, _extends2.default)({}, state, {
          index: index,
          routes: state.routes.slice(0, index + 1)
        });
      },
      getStateForAction: function getStateForAction(state, action, options) {
        var routeParamList = options.routeParamList;

        switch (action.type) {
          case 'REPLACE':
            {
              var index = action.target === state.key && action.source ? state.routes.findIndex(function (r) {
                return r.key === action.source;
              }) : state.index;

              if (index === -1) {
                return null;
              }

              var _action$payload = action.payload,
                  name = _action$payload.name,
                  key = _action$payload.key,
                  _params = _action$payload.params;

              if (!state.routeNames.includes(name)) {
                return null;
              }

              return (0, _extends2.default)({}, state, {
                routes: state.routes.map(function (route, i) {
                  return i === index ? {
                    key: key !== undefined ? key : name + "-" + (0, _$$_REQUIRE(_dependencyMap[4]).nanoid)(),
                    name: name,
                    params: routeParamList[name] !== undefined ? (0, _extends2.default)({}, routeParamList[name], _params) : _params
                  } : route;
                })
              });
            }

          case 'PUSH':
            if (state.routeNames.includes(action.payload.name)) {
              var getId = options.routeGetIdList[action.payload.name];
              var id = getId == null ? undefined : getId({
                params: action.payload.params
              });
              var route = id ? state.routes.find(function (route) {
                return route.name === action.payload.name && id === (getId == null ? undefined : getId({
                  params: route.params
                }));
              }) : undefined;
              var routes;

              if (route) {
                routes = state.routes.filter(function (r) {
                  return r.key !== route.key;
                });
                routes.push((0, _extends2.default)({}, route, {
                  params: routeParamList[action.payload.name] !== undefined ? (0, _extends2.default)({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                }));
              } else {
                routes = [].concat((0, _toConsumableArray2.default)(state.routes), [{
                  key: action.payload.name + "-" + (0, _$$_REQUIRE(_dependencyMap[4]).nanoid)(),
                  name: action.payload.name,
                  params: routeParamList[action.payload.name] !== undefined ? (0, _extends2.default)({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                }]);
              }

              return (0, _extends2.default)({}, state, {
                index: routes.length - 1,
                routes: routes
              });
            }

            return null;

          case 'POP':
            {
              var _index = action.target === state.key && action.source ? state.routes.findIndex(function (r) {
                return r.key === action.source;
              }) : state.index;

              if (_index > 0) {
                var _count = Math.max(_index - action.payload.count + 1, 1);

                var _routes = state.routes.slice(0, _count).concat(state.routes.slice(_index + 1));

                return (0, _extends2.default)({}, state, {
                  index: _routes.length - 1,
                  routes: _routes
                });
              }

              return null;
            }

          case 'POP_TO_TOP':
            return router.getStateForAction(state, {
              type: 'POP',
              payload: {
                count: state.routes.length - 1
              }
            }, options);

          case 'NAVIGATE':
            if (action.payload.name !== undefined && !state.routeNames.includes(action.payload.name)) {
              return null;
            }

            if (action.payload.key || action.payload.name) {
              var _action$payload$path;

              var _index2 = -1;

              var _getId = action.payload.key === undefined && action.payload.name !== undefined ? options.routeGetIdList[action.payload.name] : undefined;

              var _id = _getId == null ? undefined : _getId({
                params: action.payload.params
              });

              if (_id) {
                _index2 = state.routes.findIndex(function (route) {
                  return route.name === action.payload.name && _id === (_getId == null ? undefined : _getId({
                    params: route.params
                  }));
                });
              } else if (state.routes[state.index].name === action.payload.name && action.payload.key === undefined || state.routes[state.index].key === action.payload.key) {
                _index2 = state.index;
              } else {
                for (var i = state.routes.length - 1; i >= 0; i--) {
                  if (state.routes[i].name === action.payload.name && action.payload.key === undefined || state.routes[i].key === action.payload.key) {
                    _index2 = i;
                    break;
                  }
                }
              }

              if (_index2 === -1 && action.payload.key && action.payload.name === undefined) {
                return null;
              }

              if (_index2 === -1 && action.payload.name !== undefined) {
                var _action$payload$key;

                var _routes2 = [].concat((0, _toConsumableArray2.default)(state.routes), [{
                  key: (_action$payload$key = action.payload.key) != null ? _action$payload$key : action.payload.name + "-" + (0, _$$_REQUIRE(_dependencyMap[4]).nanoid)(),
                  name: action.payload.name,
                  path: action.payload.path,
                  params: routeParamList[action.payload.name] !== undefined ? (0, _extends2.default)({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                }]);

                return (0, _extends2.default)({}, state, {
                  routes: _routes2,
                  index: _routes2.length - 1
                });
              }

              var _route = state.routes[_index2];

              var _params2;

              if (action.payload.merge) {
                _params2 = action.payload.params !== undefined || routeParamList[_route.name] !== undefined ? (0, _extends2.default)({}, routeParamList[_route.name], _route.params, action.payload.params) : _route.params;
              } else {
                _params2 = routeParamList[_route.name] !== undefined ? (0, _extends2.default)({}, routeParamList[_route.name], action.payload.params) : action.payload.params;
              }

              return (0, _extends2.default)({}, state, {
                index: _index2,
                routes: [].concat((0, _toConsumableArray2.default)(state.routes.slice(0, _index2)), [_params2 !== _route.params || action.payload.path && action.payload.path !== _route.path ? (0, _extends2.default)({}, _route, {
                  path: (_action$payload$path = action.payload.path) != null ? _action$payload$path : _route.path,
                  params: _params2
                }) : state.routes[_index2]])
              });
            }

            return null;

          case 'GO_BACK':
            if (state.index > 0) {
              return router.getStateForAction(state, {
                type: 'POP',
                payload: {
                  count: 1
                },
                target: action.target,
                source: action.source
              }, options);
            }

            return null;

          default:
            return _BaseRouter.default.getStateForAction(state, action);
        }
      },
      actionCreators: StackActions
    });
    return router;
  }
},"node_modules/@react-navigation/routers/src/StackRouter.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@react-navigation/routers/src/BaseRouter.tsx","node_modules/nanoid/non-secure/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},"node_modules/@react-navigation/routers/src/types.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ScheduleUpdateContext = undefined;
  exports.default = useScheduleUpdate;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var MISSING_CONTEXT_ERROR = "Couldn't find a schedule context.";
  var ScheduleUpdateContext = React.createContext({
    scheduleUpdate: function scheduleUpdate() {
      throw new Error(MISSING_CONTEXT_ERROR);
    },
    flushUpdates: function flushUpdates() {
      throw new Error(MISSING_CONTEXT_ERROR);
    }
  });
  exports.ScheduleUpdateContext = ScheduleUpdateContext;

  function useScheduleUpdate(callback) {
    var _React$useContext = React.useContext(ScheduleUpdateContext),
        scheduleUpdate = _React$useContext.scheduleUpdate,
        flushUpdates = _React$useContext.flushUpdates;

    scheduleUpdate(callback);
    React.useEffect(flushUpdates);
  }
},"node_modules/@react-navigation/core/src/useScheduleUpdate.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createNavigatorFactory;

  var _Group = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _Screen = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  function createNavigatorFactory(Navigator) {
    return function () {
      if (arguments[0] !== undefined) {
        throw new Error("Creating a navigator doesn't take an argument. Maybe you are trying to use React Navigation 4 API? See https://reactnavigation.org/docs/hello-react-navigation for the latest API and guides.");
      }

      return {
        Navigator: Navigator,
        Group: _Group.default,
        Screen: _Screen.default
      };
    };
  }
},"node_modules/@react-navigation/core/src/createNavigatorFactory.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/core/src/Group.tsx","node_modules/@react-navigation/core/src/Screen.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = Group;

  function Group(_) {
    return null;
  }
},"node_modules/@react-navigation/core/src/Group.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = Screen;

  function Screen(_) {
    return null;
  }
},"node_modules/@react-navigation/core/src/Screen.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var CurrentRenderContext = React.createContext(undefined);
  var _default = CurrentRenderContext;
  exports.default = _default;
},"node_modules/@react-navigation/core/src/CurrentRenderContext.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getActionFromState;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  function getActionFromState(state, options) {
    var _state$index, _normalizedConfig$scr;

    var normalizedConfig = options ? createNormalizedConfigItem(options) : {};
    var routes = state.index != null ? state.routes.slice(0, state.index + 1) : state.routes;

    if (routes.length === 0) {
      return undefined;
    }

    if (!(routes.length === 1 && routes[0].key === undefined || routes.length === 2 && routes[0].key === undefined && routes[0].name === (normalizedConfig == null ? undefined : normalizedConfig.initialRouteName) && routes[1].key === undefined)) {
      return {
        type: 'RESET',
        payload: state
      };
    }

    var route = state.routes[(_state$index = state.index) != null ? _state$index : state.routes.length - 1];
    var current = route == null ? undefined : route.state;
    var config = normalizedConfig == null ? undefined : (_normalizedConfig$scr = normalizedConfig.screens) == null ? undefined : _normalizedConfig$scr[route == null ? undefined : route.name];
    var params = (0, _extends2.default)({}, route.params);
    var payload = route ? {
      name: route.name,
      path: route.path,
      params: params
    } : undefined;

    while (current) {
      var _config, _config2, _config2$screens;

      if (current.routes.length === 0) {
        return undefined;
      }

      var _routes = current.index != null ? current.routes.slice(0, current.index + 1) : current.routes;

      var _route = _routes[_routes.length - 1];
      (0, _extends2.default)(params, {
        initial: undefined,
        screen: undefined,
        params: undefined,
        state: undefined
      });

      if (_routes.length === 1 && _routes[0].key === undefined) {
        params.initial = true;
        params.screen = _route.name;
      } else if (_routes.length === 2 && _routes[0].key === undefined && _routes[0].name === ((_config = config) == null ? undefined : _config.initialRouteName) && _routes[1].key === undefined) {
        params.initial = false;
        params.screen = _route.name;
      } else {
        params.state = current;
        break;
      }

      if (_route.state) {
        params.params = (0, _extends2.default)({}, _route.params);
        params = params.params;
      } else {
        params.path = _route.path;
        params.params = _route.params;
      }

      current = _route.state;
      config = (_config2 = config) == null ? undefined : (_config2$screens = _config2.screens) == null ? undefined : _config2$screens[_route.name];
    }

    if (!payload) {
      return;
    }

    return {
      type: 'NAVIGATE',
      payload: payload
    };
  }

  var createNormalizedConfigItem = function createNormalizedConfigItem(config) {
    return typeof config === 'object' && config != null ? {
      initialRouteName: config.initialRouteName,
      screens: config.screens != null ? createNormalizedConfigs(config.screens) : undefined
    } : {};
  };

  var createNormalizedConfigs = function createNormalizedConfigs(options) {
    return Object.entries(options).reduce(function (acc, _ref) {
      var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      acc[k] = createNormalizedConfigItem(v);
      return acc;
    }, {});
  };
},"node_modules/@react-navigation/core/src/getActionFromState.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/extends.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getFocusedRouteNameFromRoute;

  function getFocusedRouteNameFromRoute(route) {
    var _route$CHILD_STATE, _state$index;

    var state = (_route$CHILD_STATE = route[_$$_REQUIRE(_dependencyMap[0]).CHILD_STATE]) != null ? _route$CHILD_STATE : route.state;
    var params = route.params;
    var routeName = state ? state.routes[(_state$index = state.index) != null ? _state$index : typeof state.type === 'string' && state.type !== 'stack' ? 0 : state.routes.length - 1].name : typeof (params == null ? undefined : params.screen) === 'string' ? params.screen : undefined;
    return routeName;
  }
},"node_modules/@react-navigation/core/src/getFocusedRouteNameFromRoute.tsx",["node_modules/@react-navigation/core/src/useRouteCache.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.CHILD_STATE = undefined;
  exports.default = useRouteCache;

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _excluded = ["state"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var CHILD_STATE = Symbol('CHILD_STATE');
  exports.CHILD_STATE = CHILD_STATE;

  function useRouteCache(routes) {
    var cache = React.useMemo(function () {
      return {
        current: new Map()
      };
    }, []);
    {
      return routes;
    }
    cache.current = routes.reduce(function (acc, route) {
      var previous = cache.current.get(route);

      if (previous) {
        acc.set(route, previous);
      } else {
        var state = route.state,
            proxy = (0, _objectWithoutProperties2.default)(route, _excluded);
        Object.defineProperty(proxy, CHILD_STATE, {
          enumerable: false,
          value: state
        });
        acc.set(route, proxy);
      }

      return acc;
    }, new Map());
    return Array.from(cache.current.values());
  }
},"node_modules/@react-navigation/core/src/useRouteCache.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getPathFromState;

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var queryString = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  var _fromEntries = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _validatePathConfig = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var getActiveRoute = function getActiveRoute(state) {
    var route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];

    if (route.state) {
      return getActiveRoute(route.state);
    }

    return route;
  };

  function getPathFromState(state, options) {
    if (state == null) {
      throw Error("Got 'undefined' for the navigation state. You must pass a valid state object.");
    }

    if (options) {
      (0, _validatePathConfig.default)(options);
    }

    var configs = options != null && options.screens ? createNormalizedConfigs(options == null ? undefined : options.screens) : {};
    var path = '/';
    var current = state;
    var allParams = {};

    var _loop = function _loop() {
      var index = typeof current.index === 'number' ? current.index : 0;
      var route = current.routes[index];
      var pattern = undefined;
      var focusedParams = undefined;
      var focusedRoute = getActiveRoute(state);
      var currentOptions = configs;
      var nestedRouteNames = [];
      var hasNext = true;

      while (route.name in currentOptions && hasNext) {
        pattern = currentOptions[route.name].pattern;
        nestedRouteNames.push(route.name);

        if (route.params) {
          (function () {
            var _currentOptions$route;

            var stringify = (_currentOptions$route = currentOptions[route.name]) == null ? undefined : _currentOptions$route.stringify;
            var currentParams = (0, _fromEntries.default)(Object.entries(route.params).map(function (_ref) {
              var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
                  key = _ref2[0],
                  value = _ref2[1];

              return [key, stringify != null && stringify[key] ? stringify[key](value) : String(value)];
            }));

            if (pattern) {
              (0, _extends2.default)(allParams, currentParams);
            }

            if (focusedRoute === route) {
              var _pattern;

              focusedParams = (0, _extends2.default)({}, currentParams);
              (_pattern = pattern) == null ? undefined : _pattern.split('/').filter(function (p) {
                return p.startsWith(':');
              }).forEach(function (p) {
                var name = getParamName(p);

                if (focusedParams) {
                  delete focusedParams[name];
                }
              });
            }
          })();
        }

        if (!currentOptions[route.name].screens || route.state === undefined) {
          hasNext = false;
        } else {
          index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;
          var nextRoute = route.state.routes[index];
          var nestedConfig = currentOptions[route.name].screens;

          if (nestedConfig && nextRoute.name in nestedConfig) {
            route = nextRoute;
            currentOptions = nestedConfig;
          } else {
            hasNext = false;
          }
        }
      }

      if (pattern === undefined) {
        pattern = nestedRouteNames.join('/');
      }

      if (currentOptions[route.name] !== undefined) {
        path += pattern.split('/').map(function (p) {
          var name = getParamName(p);

          if (p === '*') {
            return route.name;
          }

          if (p.startsWith(':')) {
            var _value = allParams[name];

            if (_value === undefined && p.endsWith('?')) {
              return '';
            }

            return encodeURIComponent(_value);
          }

          return encodeURIComponent(p);
        }).join('/');
      } else {
        path += encodeURIComponent(route.name);
      }

      if (!focusedParams) {
        focusedParams = focusedRoute.params;
      }

      if (route.state) {
        path += '/';
      } else if (focusedParams) {
        for (var param in focusedParams) {
          if (focusedParams[param] === 'undefined') {
            delete focusedParams[param];
          }
        }

        var query = queryString.stringify(focusedParams, {
          sort: false
        });

        if (query) {
          path += "?" + query;
        }
      }

      current = route.state;
    };

    while (current) {
      _loop();
    }

    path = path.replace(/\/+/g, '/');
    path = path.length > 1 ? path.replace(/\/$/, '') : path;
    return path;
  }

  var getParamName = function getParamName(pattern) {
    return pattern.replace(/^:/, '').replace(/\?$/, '');
  };

  var joinPaths = function joinPaths() {
    var _ref3;

    for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {
      paths[_key] = arguments[_key];
    }

    return (_ref3 = []).concat.apply(_ref3, (0, _toConsumableArray2.default)(paths.map(function (p) {
      return p.split('/');
    }))).filter(Boolean).join('/');
  };

  var createConfigItem = function createConfigItem(config, parentPattern) {
    var _pattern3;

    if (typeof config === 'string') {
      var _pattern2 = parentPattern ? joinPaths(parentPattern, config) : config;

      return {
        pattern: _pattern2
      };
    }

    var pattern;

    if (config.exact && config.path === undefined) {
      throw new Error("A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.");
    }

    pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';
    var screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;
    return {
      pattern: (_pattern3 = pattern) == null ? undefined : _pattern3.split('/').filter(Boolean).join('/'),
      stringify: config.stringify,
      screens: screens
    };
  };

  var createNormalizedConfigs = function createNormalizedConfigs(options, pattern) {
    return (0, _fromEntries.default)(Object.entries(options).map(function (_ref4) {
      var _ref5 = (0, _slicedToArray2.default)(_ref4, 2),
          name = _ref5[0],
          c = _ref5[1];

      var result = createConfigItem(c, pattern);
      return [name, result];
    }));
  };
},"node_modules/@react-navigation/core/src/getPathFromState.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/query-string/index.js","node_modules/@react-navigation/core/src/fromEntries.tsx","node_modules/@react-navigation/core/src/validatePathConfig.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var isNullOrUndefined = function isNullOrUndefined(value) {
    return value === null || value === undefined;
  };

  var encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');

  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case 'index':
        return function (key) {
          return function (result, value) {
            var index = result.length;

            if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
              return result;
            }

            if (value === null) {
              return [].concat(_$$_REQUIRE(_dependencyMap[0])(result), [[encode(key, options), '[', index, ']'].join('')]);
            }

            return [].concat(_$$_REQUIRE(_dependencyMap[0])(result), [[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')]);
          };
        };

      case 'bracket':
        return function (key) {
          return function (result, value) {
            if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
              return result;
            }

            if (value === null) {
              return [].concat(_$$_REQUIRE(_dependencyMap[0])(result), [[encode(key, options), '[]'].join('')]);
            }

            return [].concat(_$$_REQUIRE(_dependencyMap[0])(result), [[encode(key, options), '[]=', encode(value, options)].join('')]);
          };
        };

      case 'colon-list-separator':
        return function (key) {
          return function (result, value) {
            if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
              return result;
            }

            if (value === null) {
              return [].concat(_$$_REQUIRE(_dependencyMap[0])(result), [[encode(key, options), ':list='].join('')]);
            }

            return [].concat(_$$_REQUIRE(_dependencyMap[0])(result), [[encode(key, options), ':list=', encode(value, options)].join('')]);
          };
        };

      case 'comma':
      case 'separator':
      case 'bracket-separator':
        {
          var keyValueSep = options.arrayFormat === 'bracket-separator' ? '[]=' : '=';
          return function (key) {
            return function (result, value) {
              if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                return result;
              }

              value = value === null ? '' : value;

              if (result.length === 0) {
                return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
              }

              return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
            };
          };
        }

      default:
        return function (key) {
          return function (result, value) {
            if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
              return result;
            }

            if (value === null) {
              return [].concat(_$$_REQUIRE(_dependencyMap[0])(result), [encode(key, options)]);
            }

            return [].concat(_$$_REQUIRE(_dependencyMap[0])(result), [[encode(key, options), '=', encode(value, options)].join('')]);
          };
        };
    }
  }

  function parserForArrayFormat(options) {
    var result;

    switch (options.arrayFormat) {
      case 'index':
        return function (key, value, accumulator) {
          result = /\[(\d*)\]$/.exec(key);
          key = key.replace(/\[\d*\]$/, '');

          if (!result) {
            accumulator[key] = value;
            return;
          }

          if (accumulator[key] === undefined) {
            accumulator[key] = {};
          }

          accumulator[key][result[1]] = value;
        };

      case 'bracket':
        return function (key, value, accumulator) {
          result = /(\[\])$/.exec(key);
          key = key.replace(/\[\]$/, '');

          if (!result) {
            accumulator[key] = value;
            return;
          }

          if (accumulator[key] === undefined) {
            accumulator[key] = [value];
            return;
          }

          accumulator[key] = [].concat(accumulator[key], value);
        };

      case 'colon-list-separator':
        return function (key, value, accumulator) {
          result = /(:list)$/.exec(key);
          key = key.replace(/:list$/, '');

          if (!result) {
            accumulator[key] = value;
            return;
          }

          if (accumulator[key] === undefined) {
            accumulator[key] = [value];
            return;
          }

          accumulator[key] = [].concat(accumulator[key], value);
        };

      case 'comma':
      case 'separator':
        return function (key, value, accumulator) {
          var isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
          var isEncodedArray = typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
          value = isEncodedArray ? decode(value, options) : value;
          var newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(function (item) {
            return decode(item, options);
          }) : value === null ? value : decode(value, options);
          accumulator[key] = newValue;
        };

      case 'bracket-separator':
        return function (key, value, accumulator) {
          var isArray = /(\[\])$/.test(key);
          key = key.replace(/\[\]$/, '');

          if (!isArray) {
            accumulator[key] = value ? decode(value, options) : value;
            return;
          }

          var arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map(function (item) {
            return decode(item, options);
          });

          if (accumulator[key] === undefined) {
            accumulator[key] = arrayValue;
            return;
          }

          accumulator[key] = [].concat(accumulator[key], arrayValue);
        };

      default:
        return function (key, value, accumulator) {
          if (accumulator[key] === undefined) {
            accumulator[key] = value;
            return;
          }

          accumulator[key] = [].concat(accumulator[key], value);
        };
    }
  }

  function validateArrayFormatSeparator(value) {
    if (typeof value !== 'string' || value.length !== 1) {
      throw new TypeError('arrayFormatSeparator must be single character string');
    }
  }

  function encode(value, options) {
    if (options.encode) {
      return options.strict ? _$$_REQUIRE(_dependencyMap[1])(value) : encodeURIComponent(value);
    }

    return value;
  }

  function decode(value, options) {
    if (options.decode) {
      return _$$_REQUIRE(_dependencyMap[2])(value);
    }

    return value;
  }

  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }

    if (typeof input === 'object') {
      return keysSorter(Object.keys(input)).sort(function (a, b) {
        return Number(a) - Number(b);
      }).map(function (key) {
        return input[key];
      });
    }

    return input;
  }

  function removeHash(input) {
    var hashStart = input.indexOf('#');

    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }

    return input;
  }

  function getHash(url) {
    var hash = '';
    var hashStart = url.indexOf('#');

    if (hashStart !== -1) {
      hash = url.slice(hashStart);
    }

    return hash;
  }

  function extract(input) {
    input = removeHash(input);
    var queryStart = input.indexOf('?');

    if (queryStart === -1) {
      return '';
    }

    return input.slice(queryStart + 1);
  }

  function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {
      value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
      value = value.toLowerCase() === 'true';
    }

    return value;
  }

  function parse(query, options) {
    options = _$$_REQUIRE(_dependencyMap[3])({
      decode: true,
      sort: true,
      arrayFormat: 'none',
      arrayFormatSeparator: ',',
      parseNumbers: false,
      parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    var formatter = parserForArrayFormat(options);
    var ret = Object.create(null);

    if (typeof query !== 'string') {
      return ret;
    }

    query = query.trim().replace(/^[?#&]/, '');

    if (!query) {
      return ret;
    }

    for (var _iterator = _createForOfIteratorHelperLoose(query.split('&')), _step; !(_step = _iterator()).done;) {
      var param = _step.value;

      if (param === '') {
        continue;
      }

      var _splitOnFirst = _$$_REQUIRE(_dependencyMap[4])(options.decode ? param.replace(/\+/g, ' ') : param, '='),
          _splitOnFirst2 = _$$_REQUIRE(_dependencyMap[5])(_splitOnFirst, 2),
          key = _splitOnFirst2[0],
          value = _splitOnFirst2[1];

      value = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);
      formatter(decode(key, options), value, ret);
    }

    for (var _i = 0, _Object$keys = Object.keys(ret); _i < _Object$keys.length; _i++) {
      var _key = _Object$keys[_i];
      var _value = ret[_key];

      if (typeof _value === 'object' && _value !== null) {
        for (var _i2 = 0, _Object$keys2 = Object.keys(_value); _i2 < _Object$keys2.length; _i2++) {
          var k = _Object$keys2[_i2];
          _value[k] = parseValue(_value[k], options);
        }
      } else {
        ret[_key] = parseValue(_value, options);
      }
    }

    if (options.sort === false) {
      return ret;
    }

    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce(function (result, key) {
      var value = ret[key];

      if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
        result[key] = keysSorter(value);
      } else {
        result[key] = value;
      }

      return result;
    }, Object.create(null));
  }

  exports.extract = extract;
  exports.parse = parse;

  exports.stringify = function (object, options) {
    if (!object) {
      return '';
    }

    options = _$$_REQUIRE(_dependencyMap[3])({
      encode: true,
      strict: true,
      arrayFormat: 'none',
      arrayFormatSeparator: ','
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);

    var shouldFilter = function shouldFilter(key) {
      return options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';
    };

    var formatter = encoderForArrayFormat(options);
    var objectCopy = {};

    for (var _i3 = 0, _Object$keys3 = Object.keys(object); _i3 < _Object$keys3.length; _i3++) {
      var key = _Object$keys3[_i3];

      if (!shouldFilter(key)) {
        objectCopy[key] = object[key];
      }
    }

    var keys = Object.keys(objectCopy);

    if (options.sort !== false) {
      keys.sort(options.sort);
    }

    return keys.map(function (key) {
      var value = object[key];

      if (value === undefined) {
        return '';
      }

      if (value === null) {
        return encode(key, options);
      }

      if (Array.isArray(value)) {
        if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
          return encode(key, options) + '[]';
        }

        return value.reduce(formatter(key), []).join('&');
      }

      return encode(key, options) + '=' + encode(value, options);
    }).filter(function (x) {
      return x.length > 0;
    }).join('&');
  };

  exports.parseUrl = function (url, options) {
    options = _$$_REQUIRE(_dependencyMap[3])({
      decode: true
    }, options);

    var _splitOnFirst3 = _$$_REQUIRE(_dependencyMap[4])(url, '#'),
        _splitOnFirst4 = _$$_REQUIRE(_dependencyMap[5])(_splitOnFirst3, 2),
        url_ = _splitOnFirst4[0],
        hash = _splitOnFirst4[1];

    return _$$_REQUIRE(_dependencyMap[3])({
      url: url_.split('?')[0] || '',
      query: parse(extract(url), options)
    }, options && options.parseFragmentIdentifier && hash ? {
      fragmentIdentifier: decode(hash, options)
    } : {});
  };

  exports.stringifyUrl = function (object, options) {
    options = _$$_REQUIRE(_dependencyMap[3])(_$$_REQUIRE(_dependencyMap[6])({
      encode: true,
      strict: true
    }, encodeFragmentIdentifier, true), options);
    var url = removeHash(object.url).split('?')[0] || '';
    var queryFromUrl = exports.extract(object.url);
    var parsedQueryFromUrl = exports.parse(queryFromUrl, {
      sort: false
    });

    var query = _$$_REQUIRE(_dependencyMap[3])(parsedQueryFromUrl, object.query);

    var queryString = exports.stringify(query, options);

    if (queryString) {
      queryString = "?" + queryString;
    }

    var hash = getHash(object.url);

    if (object.fragmentIdentifier) {
      hash = "#" + (options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier);
    }

    return "" + url + queryString + hash;
  };

  exports.pick = function (input, filter, options) {
    options = _$$_REQUIRE(_dependencyMap[3])(_$$_REQUIRE(_dependencyMap[6])({
      parseFragmentIdentifier: true
    }, encodeFragmentIdentifier, false), options);

    var _exports$parseUrl = exports.parseUrl(input, options),
        url = _exports$parseUrl.url,
        query = _exports$parseUrl.query,
        fragmentIdentifier = _exports$parseUrl.fragmentIdentifier;

    return exports.stringifyUrl({
      url: url,
      query: _$$_REQUIRE(_dependencyMap[7])(query, filter),
      fragmentIdentifier: fragmentIdentifier
    }, options);
  };

  exports.exclude = function (input, filter, options) {
    var exclusionFilter = Array.isArray(filter) ? function (key) {
      return !filter.includes(key);
    } : function (key, value) {
      return !filter(key, value);
    };
    return exports.pick(input, exclusionFilter, options);
  };
},"node_modules/query-string/index.js",["node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/strict-uri-encode/index.js","node_modules/decode-uri-component/index.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/split-on-first/index.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/defineProperty.js","node_modules/filter-obj/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = function (str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (x) {
      return "%" + x.charCodeAt(0).toString(16).toUpperCase();
    });
  };
},"node_modules/strict-uri-encode/index.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var token = '%[a-f0-9]{2}';
  var singleMatcher = new RegExp(token, 'gi');
  var multiMatcher = new RegExp("(%[a-f0-9]{2})+", 'gi');

  function decodeComponents(components, split) {
    try {
      return decodeURIComponent(components.join(''));
    } catch (err) {}

    if (components.length === 1) {
      return components;
    }

    split = split || 1;
    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
  }

  function decode(input) {
    try {
      return decodeURIComponent(input);
    } catch (err) {
      var tokens = input.match(singleMatcher);

      for (var i = 1; i < tokens.length; i++) {
        input = decodeComponents(tokens, i).join('');
        tokens = input.match(singleMatcher);
      }

      return input;
    }
  }

  function customDecodeURIComponent(input) {
    var replaceMap = {
      '%FE%FF': "\uFFFD\uFFFD",
      '%FF%FE': "\uFFFD\uFFFD"
    };
    var match = multiMatcher.exec(input);

    while (match) {
      try {
        replaceMap[match[0]] = decodeURIComponent(match[0]);
      } catch (err) {
        var result = decode(match[0]);

        if (result !== match[0]) {
          replaceMap[match[0]] = result;
        }
      }

      match = multiMatcher.exec(input);
    }

    replaceMap['%C2'] = "\uFFFD";
    var entries = Object.keys(replaceMap);

    for (var i = 0; i < entries.length; i++) {
      var key = entries[i];
      input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    }

    return input;
  }

  module.exports = function (encodedURI) {
    if (typeof encodedURI !== 'string') {
      throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    }

    try {
      encodedURI = encodedURI.replace(/\+/g, ' ');
      return decodeURIComponent(encodedURI);
    } catch (err) {
      return customDecodeURIComponent(encodedURI);
    }
  };
},"node_modules/decode-uri-component/index.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = function (string, separator) {
    if (!(typeof string === 'string' && typeof separator === 'string')) {
      throw new TypeError('Expected the arguments to be of type `string`');
    }

    if (separator === '') {
      return [string];
    }

    var separatorIndex = string.indexOf(separator);

    if (separatorIndex === -1) {
      return [string];
    }

    return [string.slice(0, separatorIndex), string.slice(separatorIndex + separator.length)];
  };
},"node_modules/split-on-first/index.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = function (obj, predicate) {
    var ret = {};
    var keys = Object.keys(obj);
    var isArr = Array.isArray(predicate);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var val = obj[key];

      if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
        ret[key] = val;
      }
    }

    return ret;
  };
},"node_modules/filter-obj/index.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = fromEntries;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  function fromEntries(entries) {
    return entries.reduce(function (acc, _ref) {
      var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      if (acc.hasOwnProperty(k)) {
        throw new Error("A value for key '" + k + "' already exists in the object.");
      }

      acc[k] = v;
      return acc;
    }, {});
  }
},"node_modules/@react-navigation/core/src/fromEntries.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = validatePathConfig;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var formatToList = function formatToList(items) {
    return items.map(function (key) {
      return "- " + key;
    }).join('\n');
  };

  function validatePathConfig(config) {
    var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var validKeys = ['initialRouteName', 'screens'];

    if (!root) {
      validKeys.push('path', 'exact', 'stringify', 'parse');
    }

    var invalidKeys = Object.keys(config).filter(function (key) {
      return !validKeys.includes(key);
    });

    if (invalidKeys.length) {
      throw new Error("Found invalid properties in the configuration:\n" + formatToList(invalidKeys) + "\n\nDid you forget to specify them under a 'screens' property?\n\nYou can only specify the following properties:\n" + formatToList(validKeys) + "\n\nSee https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.");
    }

    if (config.screens) {
      Object.entries(config.screens).forEach(function (_ref) {
        var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
            _ = _ref2[0],
            value = _ref2[1];

        if (typeof value !== 'string') {
          validatePathConfig(value, false);
        }
      });
    }
  }
},"node_modules/@react-navigation/core/src/validatePathConfig.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getStateFromPath;

  var _defineProperty2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends4 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _escapeStringRegexp = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var queryString = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[5]));

  var _findFocusedRoute = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _validatePathConfig = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function getStateFromPath(path, options) {
    var _ref;

    if (options) {
      (0, _validatePathConfig.default)(options);
    }

    var initialRoutes = [];

    if (options != null && options.initialRouteName) {
      initialRoutes.push({
        initialRouteName: options.initialRouteName,
        parentScreens: []
      });
    }

    var screens = options == null ? undefined : options.screens;
    var remaining = path.replace(/\/+/g, '/').replace(/^\//, '').replace(/\?.*$/, '');
    remaining = remaining.endsWith('/') ? remaining : remaining + "/";

    if (screens === undefined) {
      var _routes = remaining.split('/').filter(Boolean).map(function (segment) {
        var name = decodeURIComponent(segment);
        return {
          name: name
        };
      });

      if (_routes.length) {
        return createNestedStateObject(path, _routes, initialRoutes);
      }

      return undefined;
    }

    var configs = (_ref = []).concat.apply(_ref, (0, _toConsumableArray2.default)(Object.keys(screens).map(function (key) {
      return createNormalizedConfigs(key, screens, [], initialRoutes, []);
    }))).sort(function (a, b) {
      if (a.pattern === b.pattern) {
        return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));
      }

      if (a.pattern.startsWith(b.pattern)) {
        return -1;
      }

      if (b.pattern.startsWith(a.pattern)) {
        return 1;
      }

      var aParts = a.pattern.split('/');
      var bParts = b.pattern.split('/');

      for (var i = 0; i < Math.max(aParts.length, bParts.length); i++) {
        if (aParts[i] == null) {
          return 1;
        }

        if (bParts[i] == null) {
          return -1;
        }

        var aWildCard = aParts[i] === '*' || aParts[i].startsWith(':');
        var bWildCard = bParts[i] === '*' || bParts[i].startsWith(':');

        if (aWildCard && bWildCard) {
          continue;
        }

        if (aWildCard) {
          return 1;
        }

        if (bWildCard) {
          return -1;
        }
      }

      return bParts.length - aParts.length;
    });

    configs.reduce(function (acc, config) {
      if (acc[config.pattern]) {
        var a = acc[config.pattern].routeNames;
        var b = config.routeNames;
        var intersects = a.length > b.length ? b.every(function (it, i) {
          return a[i] === it;
        }) : a.every(function (it, i) {
          return b[i] === it;
        });

        if (!intersects) {
          throw new Error("Found conflicting screens with the same pattern. The pattern '" + config.pattern + "' resolves to both '" + a.join(' > ') + "' and '" + b.join(' > ') + "'. Patterns must be unique and cannot resolve to more than one screen.");
        }
      }

      return (0, _extends4.default)(acc, (0, _defineProperty2.default)({}, config.pattern, config));
    }, {});

    if (remaining === '/') {
      var match = configs.find(function (config) {
        return config.path === '' && config.routeNames.every(function (name) {
          var _configs$find;

          return !((_configs$find = configs.find(function (c) {
            return c.screen === name;
          })) != null && _configs$find.path);
        });
      });

      if (match) {
        return createNestedStateObject(path, match.routeNames.map(function (name) {
          return {
            name: name
          };
        }), initialRoutes, configs);
      }

      return undefined;
    }

    var result;
    var current;

    var _matchAgainstConfigs = matchAgainstConfigs(remaining, configs.map(function (c) {
      return (0, _extends4.default)({}, c, {
        regex: c.regex ? new RegExp(c.regex.source + '$') : undefined
      });
    })),
        routes = _matchAgainstConfigs.routes,
        remainingPath = _matchAgainstConfigs.remainingPath;

    if (routes !== undefined) {
      current = createNestedStateObject(path, routes, initialRoutes, configs);
      remaining = remainingPath;
      result = current;
    }

    if (current == null || result == null) {
      return undefined;
    }

    return result;
  }

  var joinPaths = function joinPaths() {
    var _ref2;

    for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {
      paths[_key] = arguments[_key];
    }

    return (_ref2 = []).concat.apply(_ref2, (0, _toConsumableArray2.default)(paths.map(function (p) {
      return p.split('/');
    }))).filter(Boolean).join('/');
  };

  var matchAgainstConfigs = function matchAgainstConfigs(remaining, configs) {
    var routes;
    var remainingPath = remaining;

    var _loop = function _loop(config) {
      if (!config.regex) {
        return "continue";
      }

      var match = remainingPath.match(config.regex);

      if (match) {
        var _config$pattern;

        var matchedParams = (_config$pattern = config.pattern) == null ? undefined : _config$pattern.split('/').filter(function (p) {
          return p.startsWith(':');
        }).reduce(function (acc, p, i) {
          return (0, _extends4.default)(acc, (0, _defineProperty2.default)({}, p, match[(i + 1) * 2].replace(/\//, '')));
        }, {});
        routes = config.routeNames.map(function (name) {
          var _config$path;

          var config = configs.find(function (c) {
            return c.screen === name;
          });
          var params = config == null ? undefined : (_config$path = config.path) == null ? undefined : _config$path.split('/').filter(function (p) {
            return p.startsWith(':');
          }).reduce(function (acc, p) {
            var value = matchedParams[p];

            if (value) {
              var _config$parse;

              var key = p.replace(/^:/, '').replace(/\?$/, '');
              acc[key] = (_config$parse = config.parse) != null && _config$parse[key] ? config.parse[key](value) : value;
            }

            return acc;
          }, {});

          if (params && Object.keys(params).length) {
            return {
              name: name,
              params: params
            };
          }

          return {
            name: name
          };
        });
        remainingPath = remainingPath.replace(match[1], '');
        return "break";
      }
    };

    for (var _iterator = _createForOfIteratorHelperLoose(configs), _step; !(_step = _iterator()).done;) {
      var config = _step.value;

      var _ret = _loop(config);

      if (_ret === "continue") continue;
      if (_ret === "break") break;
    }

    return {
      routes: routes,
      remainingPath: remainingPath
    };
  };

  var createNormalizedConfigs = function createNormalizedConfigs(screen, routeConfig) {
    var routeNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var initials = arguments.length > 3 ? arguments[3] : undefined;
    var parentScreens = arguments.length > 4 ? arguments[4] : undefined;
    var parentPattern = arguments.length > 5 ? arguments[5] : undefined;
    var configs = [];
    routeNames.push(screen);
    parentScreens.push(screen);
    var config = routeConfig[screen];

    if (typeof config === 'string') {
      var pattern = parentPattern ? joinPaths(parentPattern, config) : config;
      configs.push(createConfigItem(screen, routeNames, pattern, config));
    } else if (typeof config === 'object') {
      var _pattern;

      if (typeof config.path === 'string') {
        if (config.exact && config.path === undefined) {
          throw new Error("A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.");
        }

        _pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';
        configs.push(createConfigItem(screen, routeNames, _pattern, config.path, config.parse));
      }

      if (config.screens) {
        if (config.initialRouteName) {
          initials.push({
            initialRouteName: config.initialRouteName,
            parentScreens: parentScreens
          });
        }

        Object.keys(config.screens).forEach(function (nestedConfig) {
          var _pattern2;

          var result = createNormalizedConfigs(nestedConfig, config.screens, routeNames, initials, (0, _toConsumableArray2.default)(parentScreens), (_pattern2 = _pattern) != null ? _pattern2 : parentPattern);
          configs.push.apply(configs, (0, _toConsumableArray2.default)(result));
        });
      }
    }

    routeNames.pop();
    return configs;
  };

  var createConfigItem = function createConfigItem(screen, routeNames, pattern, path, parse) {
    pattern = pattern.split('/').filter(Boolean).join('/');
    var regex = pattern ? new RegExp("^(" + pattern.split('/').map(function (it) {
      if (it.startsWith(':')) {
        return "(([^/]+\\/)" + (it.endsWith('?') ? '?' : '') + ")";
      }

      return (it === '*' ? '.*' : (0, _escapeStringRegexp.default)(it)) + "\\/";
    }).join('') + ")") : undefined;
    return {
      screen: screen,
      regex: regex,
      pattern: pattern,
      path: path,
      routeNames: (0, _toConsumableArray2.default)(routeNames),
      parse: parse
    };
  };

  var findParseConfigForRoute = function findParseConfigForRoute(routeName, flatConfig) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(flatConfig), _step2; !(_step2 = _iterator2()).done;) {
      var config = _step2.value;

      if (routeName === config.routeNames[config.routeNames.length - 1]) {
        return config.parse;
      }
    }

    return undefined;
  };

  var findInitialRoute = function findInitialRoute(routeName, parentScreens, initialRoutes) {
    for (var _iterator3 = _createForOfIteratorHelperLoose(initialRoutes), _step3; !(_step3 = _iterator3()).done;) {
      var config = _step3.value;

      if (parentScreens.length === config.parentScreens.length) {
        var sameParents = true;

        for (var i = 0; i < parentScreens.length; i++) {
          if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {
            sameParents = false;
            break;
          }
        }

        if (sameParents) {
          return routeName !== config.initialRouteName ? config.initialRouteName : undefined;
        }
      }
    }

    return undefined;
  };

  var createStateObject = function createStateObject(initialRoute, route, isEmpty) {
    if (isEmpty) {
      if (initialRoute) {
        return {
          index: 1,
          routes: [{
            name: initialRoute
          }, route]
        };
      } else {
        return {
          routes: [route]
        };
      }
    } else {
      if (initialRoute) {
        return {
          index: 1,
          routes: [{
            name: initialRoute
          }, (0, _extends4.default)({}, route, {
            state: {
              routes: []
            }
          })]
        };
      } else {
        return {
          routes: [(0, _extends4.default)({}, route, {
            state: {
              routes: []
            }
          })]
        };
      }
    }
  };

  var createNestedStateObject = function createNestedStateObject(path, routes, initialRoutes, flatConfig) {
    var state;
    var route = routes.shift();
    var parentScreens = [];
    var initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
    parentScreens.push(route.name);
    state = createStateObject(initialRoute, route, routes.length === 0);

    if (routes.length > 0) {
      var nestedState = state;

      while (route = routes.shift()) {
        initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
        var nestedStateIndex = nestedState.index || nestedState.routes.length - 1;
        nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);

        if (routes.length > 0) {
          nestedState = nestedState.routes[nestedStateIndex].state;
        }

        parentScreens.push(route.name);
      }
    }

    route = (0, _findFocusedRoute.default)(state);
    route.path = path;
    var params = parseQueryParams(path, flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined);

    if (params) {
      route.params = (0, _extends4.default)({}, route.params, params);
    }

    return state;
  };

  var parseQueryParams = function parseQueryParams(path, parseConfig) {
    var query = path.split('?')[1];
    var params = queryString.parse(query);

    if (parseConfig) {
      Object.keys(params).forEach(function (name) {
        if (parseConfig[name] && typeof params[name] === 'string') {
          params[name] = parseConfig[name](params[name]);
        }
      });
    }

    return Object.keys(params).length ? params : undefined;
  };
},"node_modules/@react-navigation/core/src/getStateFromPath.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/defineProperty.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/@react-navigation/core/node_modules/escape-string-regexp/index.js","node_modules/query-string/index.js","node_modules/@react-navigation/core/src/findFocusedRoute.tsx","node_modules/@react-navigation/core/src/validatePathConfig.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = function (string) {
    if (typeof string !== 'string') {
      throw new TypeError('Expected a string');
    }

    return string.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
  };
},"node_modules/@react-navigation/core/node_modules/escape-string-regexp/index.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var NavigationHelpersContext = React.createContext(undefined);
  var _default = NavigationHelpersContext;
  exports.default = _default;
},"node_modules/@react-navigation/core/src/NavigationHelpersContext.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PrivateValueStore = undefined;

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var PrivateValueStore = (0, _createClass2.default)(function PrivateValueStore() {
    (0, _classCallCheck2.default)(this, PrivateValueStore);
  });
  exports.PrivateValueStore = PrivateValueStore;
},"node_modules/@react-navigation/core/src/types.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/classCallCheck.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useFocusEffect;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _useNavigation = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useFocusEffect(effect) {
    var navigation = (0, _useNavigation.default)();

    if (arguments[1] !== undefined) {
      var message = "You passed a second argument to 'useFocusEffect', but it only accepts one argument. If you want to pass a dependency array, you can use 'React.useCallback':\n\nuseFocusEffect(\n  React.useCallback(() => {\n    // Your code here\n  }, [depA, depB])\n);\n\nSee usage guide: https://reactnavigation.org/docs/use-focus-effect";
      console.error(message);
    }

    React.useEffect(function () {
      var isFocused = false;
      var cleanup;

      var callback = function callback() {
        var destroy = effect();

        if (destroy === undefined || typeof destroy === 'function') {
          return destroy;
        }
      };

      if (navigation.isFocused()) {
        cleanup = callback();
        isFocused = true;
      }

      var unsubscribeFocus = navigation.addListener('focus', function () {
        if (isFocused) {
          return;
        }

        if (cleanup !== undefined) {
          cleanup();
        }

        cleanup = callback();
        isFocused = true;
      });
      var unsubscribeBlur = navigation.addListener('blur', function () {
        if (cleanup !== undefined) {
          cleanup();
        }

        cleanup = undefined;
        isFocused = false;
      });
      return function () {
        if (cleanup !== undefined) {
          cleanup();
        }

        unsubscribeFocus();
        unsubscribeBlur();
      };
    }, [effect, navigation]);
  }
},"node_modules/@react-navigation/core/src/useFocusEffect.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/core/src/useNavigation.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useNavigation;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _NavigationContainerRefContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  var _NavigationContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useNavigation() {
    var root = React.useContext(_NavigationContainerRefContext.default);
    var navigation = React.useContext(_NavigationContext.default);

    if (navigation === undefined && root === undefined) {
      throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
    }

    return navigation != null ? navigation : root;
  }
},"node_modules/@react-navigation/core/src/useNavigation.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/core/src/NavigationContainerRefContext.tsx","node_modules/@react-navigation/core/src/NavigationContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useIsFocused;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _useNavigation = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useIsFocused() {
    var navigation = (0, _useNavigation.default)();

    var _useState = (0, React.useState)(navigation.isFocused),
        _useState2 = (0, _slicedToArray2.default)(_useState, 2),
        isFocused = _useState2[0],
        setIsFocused = _useState2[1];

    var valueToReturn = navigation.isFocused();

    if (isFocused !== valueToReturn) {
      setIsFocused(valueToReturn);
    }

    React.useEffect(function () {
      var unsubscribeFocus = navigation.addListener('focus', function () {
        return setIsFocused(true);
      });
      var unsubscribeBlur = navigation.addListener('blur', function () {
        return setIsFocused(false);
      });
      return function () {
        unsubscribeFocus();
        unsubscribeBlur();
      };
    }, [navigation]);
    React.useDebugValue(valueToReturn);
    return valueToReturn;
  }
},"node_modules/@react-navigation/core/src/useIsFocused.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react/index.js","node_modules/@react-navigation/core/src/useNavigation.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useNavigationBuilder;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _defineProperty2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _extends3 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[6]));

  var _Group = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _isArrayEqual = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _isRecordEqual = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _NavigationHelpersContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _NavigationRouteContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _NavigationStateContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var _Screen = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[13]));

  var _useChildListeners2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[14]));

  var _useComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[15]));

  var _useCurrentRender = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[16]));

  var _useDescriptors = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[17]));

  var _useEventEmitter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[18]));

  var _useFocusedListenersChildrenAdapter = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[19]));

  var _useFocusEvents = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[20]));

  var _useKeyedChildListeners = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[21]));

  var _useNavigationHelpers = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[22]));

  var _useOnAction = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[23]));

  var _useOnGetState = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[24]));

  var _useOnRouteFocus = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[25]));

  var _useRegisterNavigator = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[26]));

  var _useScheduleUpdate = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[27]));

  var _excluded = ["children", "screenListeners"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  _$$_REQUIRE(_dependencyMap[28]).PrivateValueStore;

  var isValidKey = function isValidKey(key) {
    return key === undefined || typeof key === 'string' && key !== '';
  };

  var getRouteConfigsFromChildren = function getRouteConfigsFromChildren(children, groupKey, groupOptions) {
    var configs = React.Children.toArray(children).reduce(function (acc, child) {
      var _child$type, _child$props;

      if (React.isValidElement(child)) {
        if (child.type === _Screen.default) {
          if (!isValidKey(child.props.navigationKey)) {
            throw new Error("Got an invalid 'navigationKey' prop (" + JSON.stringify(child.props.navigationKey) + ") for the screen '" + child.props.name + "'. It must be a non-empty string or 'undefined'.");
          }

          acc.push({
            keys: [groupKey, child.props.navigationKey],
            options: groupOptions,
            props: child.props
          });
          return acc;
        }

        if (child.type === React.Fragment || child.type === _Group.default) {
          if (!isValidKey(child.props.navigationKey)) {
            throw new Error("Got an invalid 'navigationKey' prop (" + JSON.stringify(child.props.navigationKey) + ") for the group. It must be a non-empty string or 'undefined'.");
          }

          acc.push.apply(acc, (0, _toConsumableArray2.default)(getRouteConfigsFromChildren(child.props.children, child.props.navigationKey, child.type !== _Group.default ? groupOptions : groupOptions != null ? [].concat((0, _toConsumableArray2.default)(groupOptions), [child.props.screenOptions]) : [child.props.screenOptions])));
          return acc;
        }
      }

      throw new Error("A navigator can only contain 'Screen', 'Group' or 'React.Fragment' as its direct children (found " + (React.isValidElement(child) ? "'" + (typeof child.type === 'string' ? child.type : (_child$type = child.type) == null ? undefined : _child$type.name) + "'" + ((_child$props = child.props) != null && _child$props.name ? " for the screen '" + child.props.name + "'" : '') : typeof child === 'object' ? JSON.stringify(child) : "'" + String(child) + "'") + "). To render this component in the navigator, pass it in the 'component' prop to 'Screen'.");
    }, []);
    return configs;
  };

  function useNavigationBuilder(createRouter, options) {
    var navigatorKey = (0, _useRegisterNavigator.default)();
    var route = React.useContext(_NavigationRouteContext.default);
    var children = options.children,
        screenListeners = options.screenListeners,
        rest = (0, _objectWithoutProperties2.default)(options, _excluded);

    var _React$useRef = React.useRef(createRouter((0, _extends3.default)({}, rest, route != null && route.params && route.params.state == null && route.params.initial !== false && typeof route.params.screen === 'string' ? {
      initialRouteName: route.params.screen
    } : null))),
        router = _React$useRef.current;

    var routeConfigs = getRouteConfigsFromChildren(children);
    var screens = routeConfigs.reduce(function (acc, config) {
      if (config.props.name in acc) {
        throw new Error("A navigator cannot contain multiple 'Screen' components with the same name (found duplicate screen named '" + config.props.name + "')");
      }

      acc[config.props.name] = config;
      return acc;
    }, {});
    var routeNames = routeConfigs.map(function (config) {
      return config.props.name;
    });
    var routeKeyList = routeNames.reduce(function (acc, curr) {
      acc[curr] = screens[curr].keys.map(function (key) {
        return key != null ? key : '';
      }).join(':');
      return acc;
    }, {});
    var routeParamList = routeNames.reduce(function (acc, curr) {
      var initialParams = screens[curr].props.initialParams;
      acc[curr] = initialParams;
      return acc;
    }, {});
    var routeGetIdList = routeNames.reduce(function (acc, curr) {
      return (0, _extends3.default)(acc, (0, _defineProperty2.default)({}, curr, screens[curr].props.getId));
    }, {});

    if (!routeNames.length) {
      throw new Error("Couldn't find any screens for the navigator. Have you defined any screens as its children?");
    }

    var isStateValid = React.useCallback(function (state) {
      return state.type === undefined || state.type === router.type;
    }, [router.type]);
    var isStateInitialized = React.useCallback(function (state) {
      return state !== undefined && state.stale === false && isStateValid(state);
    }, [isStateValid]);

    var _React$useContext = React.useContext(_NavigationStateContext.default),
        currentState = _React$useContext.state,
        getCurrentState = _React$useContext.getState,
        setCurrentState = _React$useContext.setState,
        setKey = _React$useContext.setKey,
        getKey = _React$useContext.getKey,
        getIsInitial = _React$useContext.getIsInitial;

    var stateCleanedUp = React.useRef(false);
    var cleanUpState = React.useCallback(function () {
      setCurrentState(undefined);
      stateCleanedUp.current = true;
    }, [setCurrentState]);
    var setState = React.useCallback(function (state) {
      if (stateCleanedUp.current) {
        return;
      }

      setCurrentState(state);
    }, [setCurrentState]);

    var _React$useMemo = React.useMemo(function () {
      var _route$params4;

      var initialRouteParamList = routeNames.reduce(function (acc, curr) {
        var _route$params, _route$params2, _route$params3;

        var initialParams = screens[curr].props.initialParams;
        var initialParamsFromParams = (route == null ? undefined : (_route$params = route.params) == null ? undefined : _route$params.state) == null && (route == null ? undefined : (_route$params2 = route.params) == null ? undefined : _route$params2.initial) !== false && (route == null ? undefined : (_route$params3 = route.params) == null ? undefined : _route$params3.screen) === curr ? route.params.params : undefined;
        acc[curr] = initialParams !== undefined || initialParamsFromParams !== undefined ? (0, _extends3.default)({}, initialParams, initialParamsFromParams) : undefined;
        return acc;
      }, {});

      if ((currentState === undefined || !isStateValid(currentState)) && (route == null ? undefined : (_route$params4 = route.params) == null ? undefined : _route$params4.state) == null) {
        return [router.getInitialState({
          routeNames: routeNames,
          routeParamList: initialRouteParamList,
          routeGetIdList: routeGetIdList
        }), true];
      } else {
        var _route$params$state, _route$params5;

        return [router.getRehydratedState((_route$params$state = route == null ? undefined : (_route$params5 = route.params) == null ? undefined : _route$params5.state) != null ? _route$params$state : currentState, {
          routeNames: routeNames,
          routeParamList: initialRouteParamList,
          routeGetIdList: routeGetIdList
        }), false];
      }
    }, [currentState, router, isStateValid]),
        _React$useMemo2 = (0, _slicedToArray2.default)(_React$useMemo, 2),
        initializedState = _React$useMemo2[0],
        isFirstStateInitialization = _React$useMemo2[1];

    var previousRouteKeyListRef = React.useRef(routeKeyList);
    React.useEffect(function () {
      previousRouteKeyListRef.current = routeKeyList;
    });
    var previousRouteKeyList = previousRouteKeyListRef.current;
    var state = isStateInitialized(currentState) ? currentState : initializedState;
    var nextState = state;

    if (!(0, _isArrayEqual.default)(state.routeNames, routeNames) || !(0, _isRecordEqual.default)(routeKeyList, previousRouteKeyList)) {
      nextState = router.getStateForRouteNamesChange(state, {
        routeNames: routeNames,
        routeParamList: routeParamList,
        routeGetIdList: routeGetIdList,
        routeKeyChanges: Object.keys(routeKeyList).filter(function (name) {
          return previousRouteKeyList.hasOwnProperty(name) && routeKeyList[name] !== previousRouteKeyList[name];
        })
      });
    }

    var previousNestedParamsRef = React.useRef(route == null ? undefined : route.params);
    React.useEffect(function () {
      previousNestedParamsRef.current = route == null ? undefined : route.params;
    }, [route == null ? undefined : route.params]);

    if (route != null && route.params) {
      var previousParams = previousNestedParamsRef.current;
      var action;

      if (typeof route.params.state === 'object' && route.params.state != null && route.params !== previousParams) {
        action = _$$_REQUIRE(_dependencyMap[29]).CommonActions.reset(route.params.state);
      } else if (typeof route.params.screen === 'string' && (route.params.initial === false && isFirstStateInitialization || route.params !== previousParams)) {
        action = _$$_REQUIRE(_dependencyMap[29]).CommonActions.navigate({
          name: route.params.screen,
          params: route.params.params,
          path: route.params.path
        });
      }

      var updatedState = action ? router.getStateForAction(nextState, action, {
        routeNames: routeNames,
        routeParamList: routeParamList,
        routeGetIdList: routeGetIdList
      }) : null;
      nextState = updatedState !== null ? router.getRehydratedState(updatedState, {
        routeNames: routeNames,
        routeParamList: routeParamList,
        routeGetIdList: routeGetIdList
      }) : nextState;
    }

    var shouldUpdate = state !== nextState;
    (0, _useScheduleUpdate.default)(function () {
      if (shouldUpdate) {
        setState(nextState);
      }
    });
    state = nextState;
    React.useEffect(function () {
      setKey(navigatorKey);

      if (!getIsInitial()) {
        setState(nextState);
      }

      return function () {
        setTimeout(function () {
          if (getCurrentState() !== undefined && getKey() === navigatorKey) {
            cleanUpState();
          }
        }, 0);
      };
    }, []);
    var initializedStateRef = React.useRef();
    initializedStateRef.current = initializedState;
    var getState = React.useCallback(function () {
      var currentState = getCurrentState();
      return isStateInitialized(currentState) ? currentState : initializedStateRef.current;
    }, [getCurrentState, isStateInitialized]);
    var emitter = (0, _useEventEmitter.default)(function (e) {
      var _ref;

      var routeNames = [];
      var route;

      if (e.target) {
        var _route;

        route = state.routes.find(function (route) {
          return route.key === e.target;
        });

        if ((_route = route) != null && _route.name) {
          routeNames.push(route.name);
        }
      } else {
        route = state.routes[state.index];
        routeNames.push.apply(routeNames, (0, _toConsumableArray2.default)(Object.keys(screens).filter(function (name) {
          var _route2;

          return ((_route2 = route) == null ? undefined : _route2.name) === name;
        })));
      }

      if (route == null) {
        return;
      }

      var navigation = descriptors[route.key].navigation;

      var listeners = (_ref = []).concat.apply(_ref, (0, _toConsumableArray2.default)([screenListeners].concat((0, _toConsumableArray2.default)(routeNames.map(function (name) {
        var listeners = screens[name].props.listeners;
        return listeners;
      }))).map(function (listeners) {
        var map = typeof listeners === 'function' ? listeners({
          route: route,
          navigation: navigation
        }) : listeners;
        return map ? Object.keys(map).filter(function (type) {
          return type === e.type;
        }).map(function (type) {
          return map == null ? undefined : map[type];
        }) : undefined;
      }))).filter(function (cb, i, self) {
        return cb && self.lastIndexOf(cb) === i;
      });

      listeners.forEach(function (listener) {
        return listener == null ? undefined : listener(e);
      });
    });
    (0, _useFocusEvents.default)({
      state: state,
      emitter: emitter
    });
    React.useEffect(function () {
      emitter.emit({
        type: 'state',
        data: {
          state: state
        }
      });
    }, [emitter, state]);

    var _useChildListeners = (0, _useChildListeners2.default)(),
        childListeners = _useChildListeners.listeners,
        addListener = _useChildListeners.addListener;

    var _useKeyedChildListene = (0, _useKeyedChildListeners.default)(),
        keyedListeners = _useKeyedChildListene.keyedListeners,
        addKeyedListener = _useKeyedChildListene.addKeyedListener;

    var onAction = (0, _useOnAction.default)({
      router: router,
      getState: getState,
      setState: setState,
      key: route == null ? undefined : route.key,
      actionListeners: childListeners.action,
      beforeRemoveListeners: keyedListeners.beforeRemove,
      routerConfigOptions: {
        routeNames: routeNames,
        routeParamList: routeParamList,
        routeGetIdList: routeGetIdList
      },
      emitter: emitter
    });
    var onRouteFocus = (0, _useOnRouteFocus.default)({
      router: router,
      key: route == null ? undefined : route.key,
      getState: getState,
      setState: setState
    });
    var navigation = (0, _useNavigationHelpers.default)({
      id: options.id,
      onAction: onAction,
      getState: getState,
      emitter: emitter,
      router: router
    });
    (0, _useFocusedListenersChildrenAdapter.default)({
      navigation: navigation,
      focusedListeners: childListeners.focus
    });
    (0, _useOnGetState.default)({
      getState: getState,
      getStateListeners: keyedListeners.getState
    });
    var descriptors = (0, _useDescriptors.default)({
      state: state,
      screens: screens,
      navigation: navigation,
      screenOptions: options.screenOptions,
      defaultScreenOptions: options.defaultScreenOptions,
      onAction: onAction,
      getState: getState,
      setState: setState,
      onRouteFocus: onRouteFocus,
      addListener: addListener,
      addKeyedListener: addKeyedListener,
      router: router,
      emitter: emitter
    });
    (0, _useCurrentRender.default)({
      state: state,
      navigation: navigation,
      descriptors: descriptors
    });
    var NavigationContent = (0, _useComponent.default)(_NavigationHelpersContext.default.Provider, {
      value: navigation
    });
    return {
      state: state,
      navigation: navigation,
      descriptors: descriptors,
      NavigationContent: NavigationContent
    };
  }
},"node_modules/@react-navigation/core/src/useNavigationBuilder.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/defineProperty.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/react/index.js","node_modules/@react-navigation/core/src/Group.tsx","node_modules/@react-navigation/core/src/isArrayEqual.tsx","node_modules/@react-navigation/core/src/isRecordEqual.tsx","node_modules/@react-navigation/core/src/NavigationHelpersContext.tsx","node_modules/@react-navigation/core/src/NavigationRouteContext.tsx","node_modules/@react-navigation/core/src/NavigationStateContext.tsx","node_modules/@react-navigation/core/src/Screen.tsx","node_modules/@react-navigation/core/src/useChildListeners.tsx","node_modules/@react-navigation/core/src/useComponent.tsx","node_modules/@react-navigation/core/src/useCurrentRender.tsx","node_modules/@react-navigation/core/src/useDescriptors.tsx","node_modules/@react-navigation/core/src/useEventEmitter.tsx","node_modules/@react-navigation/core/src/useFocusedListenersChildrenAdapter.tsx","node_modules/@react-navigation/core/src/useFocusEvents.tsx","node_modules/@react-navigation/core/src/useKeyedChildListeners.tsx","node_modules/@react-navigation/core/src/useNavigationHelpers.tsx","node_modules/@react-navigation/core/src/useOnAction.tsx","node_modules/@react-navigation/core/src/useOnGetState.tsx","node_modules/@react-navigation/core/src/useOnRouteFocus.tsx","node_modules/@react-navigation/core/src/useRegisterNavigator.tsx","node_modules/@react-navigation/core/src/useScheduleUpdate.tsx","node_modules/@react-navigation/core/src/types.tsx","node_modules/@react-navigation/routers/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isArrayEqual;

  function isArrayEqual(a, b) {
    if (a === b) {
      return true;
    }

    if (a.length !== b.length) {
      return false;
    }

    return a.every(function (it, index) {
      return it === b[index];
    });
  }
},"node_modules/@react-navigation/core/src/isArrayEqual.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isRecordEqual;

  function isRecordEqual(a, b) {
    if (a === b) {
      return true;
    }

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) {
      return false;
    }

    return aKeys.every(function (key) {
      return a[key] === b[key];
    });
  }
},"node_modules/@react-navigation/core/src/isRecordEqual.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useComponent;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useComponent(Component, props) {
    var propsRef = React.useRef(props);
    propsRef.current = props;
    React.useEffect(function () {
      propsRef.current = null;
    });
    return React.useRef(function (rest) {
      var props = propsRef.current;

      if (props === null) {
        throw new Error('The returned component must be rendered in the same render phase as the hook.');
      }

      return React.createElement(Component, (0, _extends2.default)({}, props, rest));
    }).current;
  }
},"node_modules/@react-navigation/core/src/useComponent.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useCurrentRender;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _CurrentRenderContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useCurrentRender(_ref) {
    var state = _ref.state,
        navigation = _ref.navigation,
        descriptors = _ref.descriptors;
    var current = React.useContext(_CurrentRenderContext.default);

    if (current && navigation.isFocused()) {
      current.options = descriptors[state.routes[state.index].key].options;
    }
  }
},"node_modules/@react-navigation/core/src/useCurrentRender.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/core/src/CurrentRenderContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useDescriptors;

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[5]));

  var _NavigationBuilderContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _NavigationContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _NavigationRouteContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _SceneView = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _useNavigationCache = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _useRouteCache = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }

  function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

  function useDescriptors(_ref) {
    var state = _ref.state,
        screens = _ref.screens,
        navigation = _ref.navigation,
        screenOptions = _ref.screenOptions,
        defaultScreenOptions = _ref.defaultScreenOptions,
        onAction = _ref.onAction,
        getState = _ref.getState,
        setState = _ref.setState,
        addListener = _ref.addListener,
        addKeyedListener = _ref.addKeyedListener,
        onRouteFocus = _ref.onRouteFocus,
        router = _ref.router,
        emitter = _ref.emitter;

    var _React$useState = React.useState({}),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
        options = _React$useState2[0],
        setOptions = _React$useState2[1];

    var _React$useContext = React.useContext(_NavigationBuilderContext.default),
        onDispatchAction = _React$useContext.onDispatchAction,
        onOptionsChange = _React$useContext.onOptionsChange,
        stackRef = _React$useContext.stackRef;

    var context = React.useMemo(function () {
      return {
        navigation: navigation,
        onAction: onAction,
        addListener: addListener,
        addKeyedListener: addKeyedListener,
        onRouteFocus: onRouteFocus,
        onDispatchAction: onDispatchAction,
        onOptionsChange: onOptionsChange,
        stackRef: stackRef
      };
    }, [navigation, onAction, addListener, addKeyedListener, onRouteFocus, onDispatchAction, onOptionsChange, stackRef]);
    var navigations = (0, _useNavigationCache.default)({
      state: state,
      getState: getState,
      navigation: navigation,
      setOptions: setOptions,
      router: router,
      emitter: emitter
    });
    var routes = (0, _useRouteCache.default)(state.routes);
    return routes.reduce(function (acc, route, i) {
      var config = screens[route.name];
      var screen = config.props;
      var navigation = navigations[route.key];
      var optionsList = [screenOptions].concat((0, _toConsumableArray2.default)(config.options ? config.options.filter(Boolean) : []), [screen.options, options[route.key]]);
      var customOptions = optionsList.reduce(function (acc, curr) {
        return (0, _extends2.default)(acc, typeof curr !== 'function' ? curr : curr({
          route: route,
          navigation: navigation
        }));
      }, {});
      var mergedOptions = (0, _extends2.default)({}, typeof defaultScreenOptions === 'function' ? defaultScreenOptions({
        route: route,
        navigation: navigation,
        options: customOptions
      }) : defaultScreenOptions, customOptions);

      var clearOptions = function clearOptions() {
        return setOptions(function (o) {
          if (route.key in o) {
            var _route$key = route.key,
                _ = o[_route$key],
                rest = (0, _objectWithoutProperties2.default)(o, [_route$key].map(_toPropertyKey));
            return rest;
          }

          return o;
        });
      };

      acc[route.key] = {
        route: route,
        navigation: navigation,
        render: function render() {
          return React.createElement(_NavigationBuilderContext.default.Provider, {
            key: route.key,
            value: context
          }, React.createElement(_NavigationContext.default.Provider, {
            value: navigation
          }, React.createElement(_NavigationRouteContext.default.Provider, {
            value: route
          }, React.createElement(_SceneView.default, {
            navigation: navigation,
            route: route,
            screen: screen,
            routeState: state.routes[i].state,
            getState: getState,
            setState: setState,
            options: mergedOptions,
            clearOptions: clearOptions
          }))));
        },
        options: mergedOptions
      };
      return acc;
    }, {});
  }
},"node_modules/@react-navigation/core/src/useDescriptors.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react/index.js","node_modules/@react-navigation/core/src/NavigationBuilderContext.tsx","node_modules/@react-navigation/core/src/NavigationContext.tsx","node_modules/@react-navigation/core/src/NavigationRouteContext.tsx","node_modules/@react-navigation/core/src/SceneView.tsx","node_modules/@react-navigation/core/src/useNavigationCache.tsx","node_modules/@react-navigation/core/src/useRouteCache.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = SceneView;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _EnsureSingleNavigator = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _NavigationStateContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _StaticContainer = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _useOptionsGetters2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function SceneView(_ref) {
    var screen = _ref.screen,
        route = _ref.route,
        navigation = _ref.navigation,
        routeState = _ref.routeState,
        getState = _ref.getState,
        setState = _ref.setState,
        options = _ref.options,
        clearOptions = _ref.clearOptions;
    var navigatorKeyRef = React.useRef();
    var getKey = React.useCallback(function () {
      return navigatorKeyRef.current;
    }, []);

    var _useOptionsGetters = (0, _useOptionsGetters2.default)({
      key: route.key,
      options: options,
      navigation: navigation
    }),
        addOptionsGetter = _useOptionsGetters.addOptionsGetter;

    var setKey = React.useCallback(function (key) {
      navigatorKeyRef.current = key;
    }, []);
    var getCurrentState = React.useCallback(function () {
      var state = getState();
      var currentRoute = state.routes.find(function (r) {
        return r.key === route.key;
      });
      return currentRoute ? currentRoute.state : undefined;
    }, [getState, route.key]);
    var setCurrentState = React.useCallback(function (child) {
      var state = getState();
      setState((0, _extends2.default)({}, state, {
        routes: state.routes.map(function (r) {
          return r.key === route.key ? (0, _extends2.default)({}, r, {
            state: child
          }) : r;
        })
      }));
    }, [getState, route.key, setState]);
    var isInitialRef = React.useRef(true);
    React.useEffect(function () {
      isInitialRef.current = false;
    });
    React.useEffect(function () {
      return clearOptions;
    }, []);
    var getIsInitial = React.useCallback(function () {
      return isInitialRef.current;
    }, []);
    var context = React.useMemo(function () {
      return {
        state: routeState,
        getState: getCurrentState,
        setState: setCurrentState,
        getKey: getKey,
        setKey: setKey,
        getIsInitial: getIsInitial,
        addOptionsGetter: addOptionsGetter
      };
    }, [routeState, getCurrentState, setCurrentState, getKey, setKey, getIsInitial, addOptionsGetter]);
    var ScreenComponent = screen.getComponent ? screen.getComponent() : screen.component;
    return React.createElement(_NavigationStateContext.default.Provider, {
      value: context
    }, React.createElement(_EnsureSingleNavigator.default, null, React.createElement(_StaticContainer.default, {
      name: screen.name,
      render: ScreenComponent || screen.children,
      navigation: navigation,
      route: route
    }, ScreenComponent !== undefined ? React.createElement(ScreenComponent, {
      navigation: navigation,
      route: route
    }) : screen.children !== undefined ? screen.children({
      navigation: navigation,
      route: route
    }) : null)));
  }
},"node_modules/@react-navigation/core/src/SceneView.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/@react-navigation/core/src/EnsureSingleNavigator.tsx","node_modules/@react-navigation/core/src/NavigationStateContext.tsx","node_modules/@react-navigation/core/src/StaticContainer.tsx","node_modules/@react-navigation/core/src/useOptionsGetters.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function StaticContainer(props) {
    return props.children;
  }

  var _default = React.memo(StaticContainer, function (prevProps, nextProps) {
    var prevPropKeys = Object.keys(prevProps);
    var nextPropKeys = Object.keys(nextProps);

    if (prevPropKeys.length !== nextPropKeys.length) {
      return false;
    }

    for (var _i = 0, _prevPropKeys = prevPropKeys; _i < _prevPropKeys.length; _i++) {
      var key = _prevPropKeys[_i];

      if (key === 'children') {
        continue;
      }

      if (prevProps[key] !== nextProps[key]) {
        return false;
      }
    }

    return true;
  });

  exports.default = _default;
},"node_modules/@react-navigation/core/src/StaticContainer.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useNavigationCache;

  var _defineProperty2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _extends3 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  var _NavigationBuilderContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _excluded = ["emit"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useNavigationCache(_ref) {
    var state = _ref.state,
        getState = _ref.getState,
        navigation = _ref.navigation,
        _setOptions = _ref.setOptions,
        router = _ref.router,
        emitter = _ref.emitter;

    var _React$useContext = React.useContext(_NavigationBuilderContext.default),
        stackRef = _React$useContext.stackRef;

    var cache = React.useMemo(function () {
      return {
        current: {}
      };
    }, [getState, navigation, _setOptions, router, emitter]);
    var actions = (0, _extends3.default)({}, router.actionCreators, _$$_REQUIRE(_dependencyMap[6]).CommonActions);
    cache.current = state.routes.reduce(function (acc, route) {
      var previous = cache.current[route.key];

      if (previous) {
        acc[route.key] = previous;
      } else {
        var emit = navigation.emit,
            rest = (0, _objectWithoutProperties2.default)(navigation, _excluded);

        var _dispatch = function dispatch(thunk) {
          var action = typeof thunk === 'function' ? thunk(getState()) : thunk;

          if (action != null) {
            navigation.dispatch((0, _extends3.default)({
              source: route.key
            }, action));
          }
        };

        var withStack = function withStack(callback) {
          var isStackSet = false;

          try {
            callback();
          } finally {}
        };

        var helpers = Object.keys(actions).reduce(function (acc, name) {
          acc[name] = function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            return withStack(function () {
              return _dispatch(actions[name].apply(actions, args));
            });
          };

          return acc;
        }, {});
        acc[route.key] = (0, _extends3.default)({}, rest, helpers, emitter.create(route.key), {
          dispatch: function dispatch(thunk) {
            return withStack(function () {
              return _dispatch(thunk);
            });
          },
          getParent: function getParent(id) {
            if (id !== undefined && id === rest.getId()) {
              return acc[route.key];
            }

            return rest.getParent(id);
          },
          setOptions: function setOptions(options) {
            return _setOptions(function (o) {
              return (0, _extends3.default)({}, o, (0, _defineProperty2.default)({}, route.key, (0, _extends3.default)({}, o[route.key], options)));
            });
          },
          isFocused: function isFocused() {
            var state = getState();

            if (state.routes[state.index].key !== route.key) {
              return false;
            }

            return navigation ? navigation.isFocused() : true;
          }
        });
      }

      return acc;
    }, {});
    return cache.current;
  }
},"node_modules/@react-navigation/core/src/useNavigationCache.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/defineProperty.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/@react-navigation/core/src/NavigationBuilderContext.tsx","node_modules/@react-navigation/routers/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useFocusedListenersChildrenAdapter;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _NavigationBuilderContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function useFocusedListenersChildrenAdapter(_ref) {
    var navigation = _ref.navigation,
        focusedListeners = _ref.focusedListeners;

    var _React$useContext = React.useContext(_NavigationBuilderContext.default),
        addListener = _React$useContext.addListener;

    var listener = React.useCallback(function (callback) {
      if (navigation.isFocused()) {
        for (var _iterator = _createForOfIteratorHelperLoose(focusedListeners), _step; !(_step = _iterator()).done;) {
          var _listener = _step.value;

          var _listener2 = _listener(callback),
              handled = _listener2.handled,
              result = _listener2.result;

          if (handled) {
            return {
              handled: handled,
              result: result
            };
          }
        }

        return {
          handled: true,
          result: callback(navigation)
        };
      } else {
        return {
          handled: false,
          result: null
        };
      }
    }, [focusedListeners, navigation]);
    React.useEffect(function () {
      return addListener == null ? undefined : addListener('focus', listener);
    }, [addListener, listener]);
  }
},"node_modules/@react-navigation/core/src/useFocusedListenersChildrenAdapter.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/core/src/NavigationBuilderContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useFocusEvents;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _NavigationContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useFocusEvents(_ref) {
    var state = _ref.state,
        emitter = _ref.emitter;
    var navigation = React.useContext(_NavigationContext.default);
    var lastFocusedKeyRef = React.useRef();
    var currentFocusedKey = state.routes[state.index].key;
    React.useEffect(function () {
      return navigation == null ? undefined : navigation.addListener('focus', function () {
        lastFocusedKeyRef.current = currentFocusedKey;
        emitter.emit({
          type: 'focus',
          target: currentFocusedKey
        });
      });
    }, [currentFocusedKey, emitter, navigation]);
    React.useEffect(function () {
      return navigation == null ? undefined : navigation.addListener('blur', function () {
        lastFocusedKeyRef.current = undefined;
        emitter.emit({
          type: 'blur',
          target: currentFocusedKey
        });
      });
    }, [currentFocusedKey, emitter, navigation]);
    React.useEffect(function () {
      var lastFocusedKey = lastFocusedKeyRef.current;
      lastFocusedKeyRef.current = currentFocusedKey;

      if (lastFocusedKey === undefined && !navigation) {
        emitter.emit({
          type: 'focus',
          target: currentFocusedKey
        });
      }

      if (lastFocusedKey === currentFocusedKey || !(navigation ? navigation.isFocused() : true)) {
        return;
      }

      if (lastFocusedKey === undefined) {
        return;
      }

      emitter.emit({
        type: 'blur',
        target: lastFocusedKey
      });
      emitter.emit({
        type: 'focus',
        target: currentFocusedKey
      });
    }, [currentFocusedKey, emitter, navigation]);
  }
},"node_modules/@react-navigation/core/src/useFocusEvents.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/core/src/NavigationContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useNavigationHelpers;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _NavigationContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _UnhandledActionContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  _$$_REQUIRE(_dependencyMap[5]).PrivateValueStore;

  function useNavigationHelpers(_ref) {
    var navigatorId = _ref.id,
        onAction = _ref.onAction,
        getState = _ref.getState,
        emitter = _ref.emitter,
        router = _ref.router;
    var onUnhandledAction = React.useContext(_UnhandledActionContext.default);
    var parentNavigationHelpers = React.useContext(_NavigationContext.default);
    return React.useMemo(function () {
      var dispatch = function dispatch(op) {
        var action = typeof op === 'function' ? op(getState()) : op;
        var handled = onAction(action);

        if (!handled) {
          onUnhandledAction == null ? undefined : onUnhandledAction(action);
        }
      };

      var actions = (0, _extends2.default)({}, router.actionCreators, _$$_REQUIRE(_dependencyMap[6]).CommonActions);
      var helpers = Object.keys(actions).reduce(function (acc, name) {
        acc[name] = function () {
          return dispatch(actions[name].apply(actions, arguments));
        };

        return acc;
      }, {});
      var navigationHelpers = (0, _extends2.default)({}, parentNavigationHelpers, helpers, {
        dispatch: dispatch,
        emit: emitter.emit,
        isFocused: parentNavigationHelpers ? parentNavigationHelpers.isFocused : function () {
          return true;
        },
        canGoBack: function canGoBack() {
          var state = getState();
          return router.getStateForAction(state, _$$_REQUIRE(_dependencyMap[6]).CommonActions.goBack(), {
            routeNames: state.routeNames,
            routeParamList: {},
            routeGetIdList: {}
          }) !== null || (parentNavigationHelpers == null ? undefined : parentNavigationHelpers.canGoBack()) || false;
        },
        getId: function getId() {
          return navigatorId;
        },
        getParent: function getParent(id) {
          if (id !== undefined) {
            var current = navigationHelpers;

            while (current && id !== current.getId()) {
              current = current.getParent();
            }

            return current;
          }

          return parentNavigationHelpers;
        },
        getState: getState
      });
      return navigationHelpers;
    }, [navigatorId, emitter.emit, getState, onAction, onUnhandledAction, parentNavigationHelpers, router]);
  }
},"node_modules/@react-navigation/core/src/useNavigationHelpers.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/@react-navigation/core/src/NavigationContext.tsx","node_modules/@react-navigation/core/src/UnhandledActionContext.tsx","node_modules/@react-navigation/core/src/types.tsx","node_modules/@react-navigation/routers/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useOnAction;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _NavigationBuilderContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  var _useOnPreventRemove = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useOnAction(_ref) {
    var router = _ref.router,
        getState = _ref.getState,
        setState = _ref.setState,
        key = _ref.key,
        actionListeners = _ref.actionListeners,
        beforeRemoveListeners = _ref.beforeRemoveListeners,
        routerConfigOptions = _ref.routerConfigOptions,
        emitter = _ref.emitter;

    var _React$useContext = React.useContext(_NavigationBuilderContext.default),
        onActionParent = _React$useContext.onAction,
        onRouteFocusParent = _React$useContext.onRouteFocus,
        addListenerParent = _React$useContext.addListener,
        onDispatchAction = _React$useContext.onDispatchAction;

    var routerConfigOptionsRef = React.useRef(routerConfigOptions);
    React.useEffect(function () {
      routerConfigOptionsRef.current = routerConfigOptions;
    });
    var onAction = React.useCallback(function (action) {
      var visitedNavigators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
      var state = getState();

      if (visitedNavigators.has(state.key)) {
        return false;
      }

      visitedNavigators.add(state.key);

      if (typeof action.target !== 'string' || action.target === state.key) {
        var result = router.getStateForAction(state, action, routerConfigOptionsRef.current);
        result = result === null && action.target === state.key ? state : result;

        if (result !== null) {
          onDispatchAction(action, state === result);

          if (state !== result) {
            var isPrevented = (0, _useOnPreventRemove.shouldPreventRemove)(emitter, beforeRemoveListeners, state.routes, result.routes, action);

            if (isPrevented) {
              return true;
            }

            setState(result);
          }

          if (onRouteFocusParent !== undefined) {
            var shouldFocus = router.shouldActionChangeFocus(action);

            if (shouldFocus && key !== undefined) {
              onRouteFocusParent(key);
            }
          }

          return true;
        }
      }

      if (onActionParent !== undefined) {
        if (onActionParent(action, visitedNavigators)) {
          return true;
        }
      }

      for (var i = actionListeners.length - 1; i >= 0; i--) {
        var listener = actionListeners[i];

        if (listener(action, visitedNavigators)) {
          return true;
        }
      }

      return false;
    }, [actionListeners, beforeRemoveListeners, emitter, getState, key, onActionParent, onDispatchAction, onRouteFocusParent, router, setState]);
    (0, _useOnPreventRemove.default)({
      getState: getState,
      emitter: emitter,
      beforeRemoveListeners: beforeRemoveListeners
    });
    React.useEffect(function () {
      return addListenerParent == null ? undefined : addListenerParent('action', onAction);
    }, [addListenerParent, onAction]);
    return onAction;
  }
},"node_modules/@react-navigation/core/src/useOnAction.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/core/src/NavigationBuilderContext.tsx","node_modules/@react-navigation/core/src/useOnPreventRemove.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useOnPreventRemove;
  exports.shouldPreventRemove = undefined;

  var _defineProperty2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends3 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _NavigationBuilderContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _NavigationRouteContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var VISITED_ROUTE_KEYS = Symbol('VISITED_ROUTE_KEYS');

  var shouldPreventRemove = function shouldPreventRemove(emitter, beforeRemoveListeners, currentRoutes, nextRoutes, action) {
    var _action$VISITED_ROUTE;

    var nextRouteKeys = nextRoutes.map(function (route) {
      return route.key;
    });
    var removedRoutes = currentRoutes.filter(function (route) {
      return !nextRouteKeys.includes(route.key);
    }).reverse();
    var visitedRouteKeys = (_action$VISITED_ROUTE = action[VISITED_ROUTE_KEYS]) != null ? _action$VISITED_ROUTE : new Set();
    var beforeRemoveAction = (0, _extends3.default)({}, action, (0, _defineProperty2.default)({}, VISITED_ROUTE_KEYS, visitedRouteKeys));

    for (var _iterator = _createForOfIteratorHelperLoose(removedRoutes), _step; !(_step = _iterator()).done;) {
      var _beforeRemoveListener;

      var route = _step.value;

      if (visitedRouteKeys.has(route.key)) {
        continue;
      }

      var isPrevented = (_beforeRemoveListener = beforeRemoveListeners[route.key]) == null ? undefined : _beforeRemoveListener.call(beforeRemoveListeners, beforeRemoveAction);

      if (isPrevented) {
        return true;
      }

      visitedRouteKeys.add(route.key);
      var event = emitter.emit({
        type: 'beforeRemove',
        target: route.key,
        data: {
          action: beforeRemoveAction
        },
        canPreventDefault: true
      });

      if (event.defaultPrevented) {
        return true;
      }
    }

    return false;
  };

  exports.shouldPreventRemove = shouldPreventRemove;

  function useOnPreventRemove(_ref) {
    var getState = _ref.getState,
        emitter = _ref.emitter,
        beforeRemoveListeners = _ref.beforeRemoveListeners;

    var _React$useContext = React.useContext(_NavigationBuilderContext.default),
        addKeyedListener = _React$useContext.addKeyedListener;

    var route = React.useContext(_NavigationRouteContext.default);
    var routeKey = route == null ? undefined : route.key;
    React.useEffect(function () {
      if (routeKey) {
        return addKeyedListener == null ? undefined : addKeyedListener('beforeRemove', routeKey, function (action) {
          var state = getState();
          return shouldPreventRemove(emitter, beforeRemoveListeners, state.routes, [], action);
        });
      }
    }, [addKeyedListener, beforeRemoveListeners, emitter, getState, routeKey]);
  }
},"node_modules/@react-navigation/core/src/useOnPreventRemove.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/defineProperty.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/@react-navigation/core/src/NavigationBuilderContext.tsx","node_modules/@react-navigation/core/src/NavigationRouteContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useOnGetState;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _isArrayEqual = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _NavigationBuilderContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _NavigationRouteContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useOnGetState(_ref) {
    var getState = _ref.getState,
        getStateListeners = _ref.getStateListeners;

    var _React$useContext = React.useContext(_NavigationBuilderContext.default),
        addKeyedListener = _React$useContext.addKeyedListener;

    var route = React.useContext(_NavigationRouteContext.default);
    var key = route ? route.key : 'root';
    var getRehydratedState = React.useCallback(function () {
      var state = getState();
      var routes = state.routes.map(function (route) {
        var _getStateListeners$ro;

        var childState = (_getStateListeners$ro = getStateListeners[route.key]) == null ? undefined : _getStateListeners$ro.call(getStateListeners);

        if (route.state === childState) {
          return route;
        }

        return (0, _extends2.default)({}, route, {
          state: childState
        });
      });

      if ((0, _isArrayEqual.default)(state.routes, routes)) {
        return state;
      }

      return (0, _extends2.default)({}, state, {
        routes: routes
      });
    }, [getState, getStateListeners]);
    React.useEffect(function () {
      return addKeyedListener == null ? undefined : addKeyedListener('getState', key, getRehydratedState);
    }, [addKeyedListener, getRehydratedState, key]);
  }
},"node_modules/@react-navigation/core/src/useOnGetState.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/@react-navigation/core/src/isArrayEqual.tsx","node_modules/@react-navigation/core/src/NavigationBuilderContext.tsx","node_modules/@react-navigation/core/src/NavigationRouteContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useOnRouteFocus;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _NavigationBuilderContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useOnRouteFocus(_ref) {
    var router = _ref.router,
        getState = _ref.getState,
        sourceRouteKey = _ref.key,
        setState = _ref.setState;

    var _React$useContext = React.useContext(_NavigationBuilderContext.default),
        onRouteFocusParent = _React$useContext.onRouteFocus;

    return React.useCallback(function (key) {
      var state = getState();
      var result = router.getStateForRouteFocus(state, key);

      if (result !== state) {
        setState(result);
      }

      if (onRouteFocusParent !== undefined && sourceRouteKey !== undefined) {
        onRouteFocusParent(sourceRouteKey);
      }
    }, [getState, onRouteFocusParent, router, setState, sourceRouteKey]);
  }
},"node_modules/@react-navigation/core/src/useOnRouteFocus.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/core/src/NavigationBuilderContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useRegisterNavigator;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useRegisterNavigator() {
    var _React$useState = React.useState(function () {
      return (0, _$$_REQUIRE(_dependencyMap[3]).nanoid)();
    }),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 1),
        key = _React$useState2[0];

    var container = React.useContext(_$$_REQUIRE(_dependencyMap[4]).SingleNavigatorContext);

    if (container === undefined) {
      throw new Error("Couldn't register the navigator. Have you wrapped your app with 'NavigationContainer'?\n\nThis can also happen if there are multiple copies of '@react-navigation' packages installed.");
    }

    React.useEffect(function () {
      var register = container.register,
          unregister = container.unregister;
      register(key);
      return function () {
        return unregister(key);
      };
    }, [container, key]);
    return key;
  }
},"node_modules/@react-navigation/core/src/useRegisterNavigator.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react/index.js","node_modules/nanoid/non-secure/index.js","node_modules/@react-navigation/core/src/EnsureSingleNavigator.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useNavigationContainerRef;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _createNavigationContainerRef = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useNavigationContainerRef() {
    var navigation = React.useRef(null);

    if (navigation.current == null) {
      navigation.current = (0, _createNavigationContainerRef.default)();
    }

    return navigation.current;
  }
},"node_modules/@react-navigation/core/src/useNavigationContainerRef.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/core/src/createNavigationContainerRef.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useNavigationState;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _useNavigation = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useNavigationState(selector) {
    var navigation = (0, _useNavigation.default)();

    var _React$useState = React.useState(function () {
      return selector(navigation.getState());
    }),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
        setResult = _React$useState2[1];

    var selectorRef = React.useRef(selector);
    React.useEffect(function () {
      selectorRef.current = selector;
    });
    React.useEffect(function () {
      var unsubscribe = navigation.addListener('state', function (e) {
        setResult(selectorRef.current(e.data.state));
      });
      return unsubscribe;
    }, [navigation]);
    return selector(navigation.getState());
  }
},"node_modules/@react-navigation/core/src/useNavigationState.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react/index.js","node_modules/@react-navigation/core/src/useNavigation.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useRoute;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _NavigationRouteContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useRoute() {
    var route = React.useContext(_NavigationRouteContext.default);

    if (route === undefined) {
      throw new Error("Couldn't find a route object. Is your component inside a screen in a navigator?");
    }

    return route;
  }
},"node_modules/@react-navigation/core/src/useRoute.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/core/src/NavigationRouteContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  var _LinkingContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _DefaultTheme = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _ThemeProvider = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _useBackButton = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _useDocumentTitle = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _useLinking2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _useThenable3 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _excluded = ["theme", "linking", "fallback", "documentTitle", "onReady"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  global.REACT_NAVIGATION_DEVTOOLS = new WeakMap();

  function NavigationContainerInner(_ref, ref) {
    var _ref$theme = _ref.theme,
        theme = _ref$theme === undefined ? _DefaultTheme.default : _ref$theme,
        linking = _ref.linking,
        _ref$fallback = _ref.fallback,
        fallback = _ref$fallback === undefined ? null : _ref$fallback,
        documentTitle = _ref.documentTitle,
        onReady = _ref.onReady,
        rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);
    var isLinkingEnabled = linking ? linking.enabled !== false : false;

    if (linking != null && linking.config) {
      (0, _$$_REQUIRE(_dependencyMap[12]).validatePathConfig)(linking.config);
    }

    var refContainer = React.useRef(null);
    (0, _useBackButton.default)(refContainer);
    (0, _useDocumentTitle.default)(refContainer, documentTitle);

    var _useLinking = (0, _useLinking2.default)(refContainer, (0, _extends2.default)({
      independent: rest.independent,
      enabled: isLinkingEnabled,
      prefixes: []
    }, linking)),
        getInitialState = _useLinking.getInitialState;

    React.useEffect(function () {
      if (refContainer.current) {
        REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {
          get linking() {
            var _linking$prefixes, _linking$getStateFrom, _linking$getPathFromS, _linking$getActionFro;

            return (0, _extends2.default)({}, linking, {
              enabled: isLinkingEnabled,
              prefixes: (_linking$prefixes = linking == null ? undefined : linking.prefixes) != null ? _linking$prefixes : [],
              getStateFromPath: (_linking$getStateFrom = linking == null ? undefined : linking.getStateFromPath) != null ? _linking$getStateFrom : _$$_REQUIRE(_dependencyMap[12]).getStateFromPath,
              getPathFromState: (_linking$getPathFromS = linking == null ? undefined : linking.getPathFromState) != null ? _linking$getPathFromS : _$$_REQUIRE(_dependencyMap[12]).getPathFromState,
              getActionFromState: (_linking$getActionFro = linking == null ? undefined : linking.getActionFromState) != null ? _linking$getActionFro : _$$_REQUIRE(_dependencyMap[12]).getActionFromState
            });
          }

        });
      }
    });

    var _useThenable = (0, _useThenable3.default)(getInitialState),
        _useThenable2 = (0, _slicedToArray2.default)(_useThenable, 2),
        isResolved = _useThenable2[0],
        initialState = _useThenable2[1];

    React.useImperativeHandle(ref, function () {
      return refContainer.current;
    });
    var linkingContext = React.useMemo(function () {
      return {
        options: linking
      };
    }, [linking]);
    var isReady = rest.initialState != null || !isLinkingEnabled || isResolved;
    var onReadyRef = React.useRef(onReady);
    React.useEffect(function () {
      onReadyRef.current = onReady;
    });
    React.useEffect(function () {
      if (isReady) {
        onReadyRef.current == null ? undefined : onReadyRef.current();
      }
    }, [isReady]);

    if (!isReady) {
      return fallback;
    }

    return React.createElement(_LinkingContext.default.Provider, {
      value: linkingContext
    }, React.createElement(_ThemeProvider.default, {
      value: theme
    }, React.createElement(_$$_REQUIRE(_dependencyMap[12]).BaseNavigationContainer, (0, _extends2.default)({}, rest, {
      initialState: rest.initialState == null ? initialState : rest.initialState,
      ref: refContainer
    }))));
  }

  var NavigationContainer = React.forwardRef(NavigationContainerInner);
  var _default = NavigationContainer;
  exports.default = _default;
},"node_modules/@react-navigation/native/src/NavigationContainer.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/@react-navigation/native/src/LinkingContext.tsx","node_modules/@react-navigation/native/src/theming/DefaultTheme.tsx","node_modules/@react-navigation/native/src/theming/ThemeProvider.tsx","node_modules/@react-navigation/native/src/useBackButton.tsx","node_modules/@react-navigation/native/src/useDocumentTitle.native.tsx","node_modules/@react-navigation/native/src/useLinking.native.tsx","node_modules/@react-navigation/native/src/useThenable.tsx","node_modules/@react-navigation/core/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var DefaultTheme = {
    dark: false,
    colors: {
      primary: 'rgb(0, 122, 255)',
      background: 'rgb(242, 242, 242)',
      card: 'rgb(255, 255, 255)',
      text: 'rgb(28, 28, 30)',
      border: 'rgb(216, 216, 216)',
      notification: 'rgb(255, 59, 48)'
    }
  };
  var _default = DefaultTheme;
  exports.default = _default;
},"node_modules/@react-navigation/native/src/theming/DefaultTheme.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ThemeProvider;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _ThemeContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function ThemeProvider(_ref) {
    var value = _ref.value,
        children = _ref.children;
    return React.createElement(_ThemeContext.default.Provider, {
      value: value
    }, children);
  }
},"node_modules/@react-navigation/native/src/theming/ThemeProvider.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/native/src/theming/ThemeContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _DefaultTheme = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var ThemeContext = React.createContext(_DefaultTheme.default);
  ThemeContext.displayName = 'ThemeContext';
  var _default = ThemeContext;
  exports.default = _default;
},"node_modules/@react-navigation/native/src/theming/ThemeContext.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/native/src/theming/DefaultTheme.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useBackButton;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[1]);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useBackButton(ref) {
    React.useEffect(function () {
      var subscription = _reactNative.BackHandler.addEventListener('hardwareBackPress', function () {
        var navigation = ref.current;

        if (navigation == null) {
          return false;
        }

        if (navigation.canGoBack()) {
          navigation.goBack();
          return true;
        }

        return false;
      });

      return function () {
        return subscription.remove();
      };
    }, [ref]);
  }
},"node_modules/@react-navigation/native/src/useBackButton.tsx",["node_modules/react/index.js","node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useDocumentTitle;

  function useDocumentTitle() {}
},"node_modules/@react-navigation/native/src/useDocumentTitle.native.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useLinking;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[1]);

  var _extractPathFromURL = _$$_REQUIRE(_dependencyMap[2])(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var linkingHandlers = [];

  function useLinking(ref, _ref) {
    var independent = _ref.independent,
        _ref$enabled = _ref.enabled,
        enabled = _ref$enabled === undefined ? true : _ref$enabled,
        prefixes = _ref.prefixes,
        filter = _ref.filter,
        config = _ref.config,
        _ref$getInitialURL = _ref.getInitialURL,
        getInitialURL = _ref$getInitialURL === undefined ? function () {
      return Promise.race([_reactNative.Linking.getInitialURL(), new Promise(function (resolve) {
        return setTimeout(resolve, 150);
      })]);
    } : _ref$getInitialURL,
        _ref$subscribe = _ref.subscribe,
        subscribe = _ref$subscribe === undefined ? function (listener) {
      var callback = function callback(_ref2) {
        var url = _ref2.url;
        return listener(url);
      };

      var subscription = _reactNative.Linking.addEventListener('url', callback);

      return function () {
        if (subscription != null && subscription.remove) {
          subscription.remove();
        } else {
          _reactNative.Linking.removeEventListener('url', callback);
        }
      };
    } : _ref$subscribe,
        _ref$getStateFromPath = _ref.getStateFromPath,
        getStateFromPath = _ref$getStateFromPath === undefined ? _$$_REQUIRE(_dependencyMap[4]).getStateFromPath : _ref$getStateFromPath,
        _ref$getActionFromSta = _ref.getActionFromState,
        getActionFromState = _ref$getActionFromSta === undefined ? _$$_REQUIRE(_dependencyMap[4]).getActionFromState : _ref$getActionFromSta;
    React.useEffect(function () {
      {
        return undefined;
      }

      if (independent) {
        return undefined;
      }

      if (enabled !== false && linkingHandlers.length) {
        console.error(['Looks like you have configured linking in multiple places. This is likely an error since deep links should only be handled in one place to avoid conflicts. Make sure that:', "- You don't have multiple NavigationContainers in the app each with 'linking' enabled", '- Only a single instance of the root component is rendered', _reactNative.Platform.OS === 'android' ? "- You have set 'android:launchMode=singleTask' in the '<activity />' section of the 'AndroidManifest.xml' file to avoid launching multiple instances" : ''].join('\n').trim());
      }

      var handler = Symbol();

      if (enabled !== false) {
        linkingHandlers.push(handler);
      }

      return function () {
        var index = linkingHandlers.indexOf(handler);

        if (index > -1) {
          linkingHandlers.splice(index, 1);
        }
      };
    }, [enabled, independent]);
    var enabledRef = React.useRef(enabled);
    var prefixesRef = React.useRef(prefixes);
    var filterRef = React.useRef(filter);
    var configRef = React.useRef(config);
    var getInitialURLRef = React.useRef(getInitialURL);
    var getStateFromPathRef = React.useRef(getStateFromPath);
    var getActionFromStateRef = React.useRef(getActionFromState);
    React.useEffect(function () {
      enabledRef.current = enabled;
      prefixesRef.current = prefixes;
      filterRef.current = filter;
      configRef.current = config;
      getInitialURLRef.current = getInitialURL;
      getStateFromPathRef.current = getStateFromPath;
      getActionFromStateRef.current = getActionFromState;
    });
    var getStateFromURL = React.useCallback(function (url) {
      if (!url || filterRef.current && !filterRef.current(url)) {
        return undefined;
      }

      var path = (0, _extractPathFromURL.default)(prefixesRef.current, url);
      return path ? getStateFromPathRef.current(path, configRef.current) : undefined;
    }, []);
    var getInitialState = React.useCallback(function () {
      var state;

      if (enabledRef.current) {
        var url = getInitialURLRef.current();

        if (url != null && typeof url !== 'string') {
          return url.then(function (url) {
            var state = getStateFromURL(url);
            return state;
          });
        }

        state = getStateFromURL(url);
      }

      var thenable = {
        then: function then(onfulfilled) {
          return Promise.resolve(onfulfilled ? onfulfilled(state) : state);
        },
        catch: function _catch() {
          return thenable;
        }
      };
      return thenable;
    }, [getStateFromURL]);
    React.useEffect(function () {
      var listener = function listener(url) {
        if (!enabled) {
          return;
        }

        var navigation = ref.current;
        var state = navigation ? getStateFromURL(url) : undefined;

        if (navigation && state) {
          var rootState = navigation.getRootState();

          if (state.routes.some(function (r) {
            return !(rootState != null && rootState.routeNames.includes(r.name));
          })) {
            console.warn("The navigation state parsed from the URL contains routes not present in the root navigator. This usually means that the linking configuration doesn't match the navigation structure. See https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.");
            return;
          }

          var action = getActionFromStateRef.current(state, configRef.current);

          if (action !== undefined) {
            try {
              navigation.dispatch(action);
            } catch (e) {
              console.warn("An error occurred when trying to handle the link '" + url + "': " + (typeof e === 'object' && e != null && 'message' in e ? e.message : e));
            }
          } else {
            navigation.resetRoot(state);
          }
        }
      };

      return subscribe(listener);
    }, [enabled, getStateFromURL, ref, subscribe]);
    return {
      getInitialState: getInitialState
    };
  }
},"node_modules/@react-navigation/native/src/useLinking.native.tsx",["node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/native/src/extractPathFromURL.tsx","node_modules/@react-navigation/core/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = extractPathFromURL;

  var _escapeStringRegexp = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function extractPathFromURL(prefixes, url) {
    for (var _iterator = _createForOfIteratorHelperLoose(prefixes), _step; !(_step = _iterator()).done;) {
      var _prefix$match$, _prefix$match;

      var prefix = _step.value;
      var protocol = (_prefix$match$ = (_prefix$match = prefix.match(/^[^:]+:/)) == null ? undefined : _prefix$match[0]) != null ? _prefix$match$ : '';
      var host = prefix.replace(new RegExp("^" + (0, _escapeStringRegexp.default)(protocol)), '').replace(/\/+/g, '/').replace(/^\//, '');
      var prefixRegex = new RegExp("^" + (0, _escapeStringRegexp.default)(protocol) + "(/)*" + host.split('.').map(function (it) {
        return it === '*' ? '[^/]+' : (0, _escapeStringRegexp.default)(it);
      }).join('\\.'));
      var normalizedURL = url.replace(/\/+/g, '/');

      if (prefixRegex.test(normalizedURL)) {
        return normalizedURL.replace(prefixRegex, '');
      }
    }

    return undefined;
  }
},"node_modules/@react-navigation/native/src/extractPathFromURL.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/native/node_modules/escape-string-regexp/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = function (string) {
    if (typeof string !== 'string') {
      throw new TypeError('Expected a string');
    }

    return string.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
  };
},"node_modules/@react-navigation/native/node_modules/escape-string-regexp/index.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useThenable;

  var _regenerator = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useThenable(create) {
    var _React$useState = React.useState(create),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 1),
        promise = _React$useState2[0];

    var initialState = [false, undefined];
    promise.then(function (result) {
      initialState = [true, result];
    });

    var _React$useState3 = React.useState(initialState),
        _React$useState4 = (0, _slicedToArray2.default)(_React$useState3, 2),
        state = _React$useState4[0],
        setState = _React$useState4[1];

    var _state = (0, _slicedToArray2.default)(state, 1),
        resolved = _state[0];

    React.useEffect(function () {
      var cancelled = false;

      var resolve = function _callee() {
        var result;
        return _regenerator.default.async(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return _regenerator.default.awrap(promise);

              case 3:
                result = _context.sent;

              case 4:
                _context.prev = 4;

                if (!cancelled) {
                  setState([true, result]);
                }

                return _context.finish(4);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, null, null, [[0,, 4, 7]], Promise);
      };

      if (!resolved) {
        resolve();
      }

      return function () {
        cancelled = true;
      };
    }, [promise, resolved]);
    return state;
  }
},"node_modules/@react-navigation/native/src/useThenable.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/regenerator/index.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _ServerContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = React.forwardRef(function ServerContainer(_ref, ref) {
    var children = _ref.children,
        location = _ref.location;
    React.useEffect(function () {
      console.error("'ServerContainer' should only be used on the server with 'react-dom/server' for SSR.");
    }, []);
    var current = {};

    if (ref) {
      var value = {
        getCurrentOptions: function getCurrentOptions() {
          return current.options;
        }
      };

      if (typeof ref === 'function') {
        ref(value);
      } else {
        ref.current = value;
      }
    }

    return React.createElement(_ServerContext.default.Provider, {
      value: {
        location: location
      }
    }, React.createElement(_$$_REQUIRE(_dependencyMap[3]).CurrentRenderContext.Provider, {
      value: current
    }, children));
  });

  exports.default = _default;
},"node_modules/@react-navigation/native/src/ServerContainer.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/native/src/ServerContext.tsx","node_modules/@react-navigation/core/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var ServerContext = React.createContext(undefined);
  var _default = ServerContext;
  exports.default = _default;
},"node_modules/@react-navigation/native/src/ServerContext.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var DarkTheme = {
    dark: true,
    colors: {
      primary: 'rgb(10, 132, 255)',
      background: 'rgb(1, 1, 1)',
      card: 'rgb(18, 18, 18)',
      text: 'rgb(229, 229, 231)',
      border: 'rgb(39, 39, 41)',
      notification: 'rgb(255, 69, 58)'
    }
  };
  var _default = DarkTheme;
  exports.default = _default;
},"node_modules/@react-navigation/native/src/theming/DarkTheme.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useTheme;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _ThemeContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useTheme() {
    var theme = React.useContext(_ThemeContext.default);
    return theme;
  }
},"node_modules/@react-navigation/native/src/theming/useTheme.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/native/src/theming/ThemeContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},"node_modules/@react-navigation/native/src/types.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useLinkBuilder;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _LinkingContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var getRootStateForNavigate = function getRootStateForNavigate(navigation, state) {
    var parent = navigation.getParent();

    if (parent) {
      var parentState = parent.getState();
      return getRootStateForNavigate(parent, {
        index: 0,
        routes: [(0, _extends2.default)({}, parentState.routes[parentState.index], {
          state: state
        })]
      });
    }

    return state;
  };

  function useLinkBuilder() {
    var navigation = React.useContext(_$$_REQUIRE(_dependencyMap[4]).NavigationHelpersContext);
    var linking = React.useContext(_LinkingContext.default);
    var buildLink = React.useCallback(function (name, params) {
      var options = linking.options;

      if ((options == null ? undefined : options.enabled) === false) {
        return undefined;
      }

      var state = navigation ? getRootStateForNavigate(navigation, {
        index: 0,
        routes: [{
          name: name,
          params: params
        }]
      }) : {
        index: 0,
        routes: [{
          name: name,
          params: params
        }]
      };
      var path = options != null && options.getPathFromState ? options.getPathFromState(state, options == null ? undefined : options.config) : (0, _$$_REQUIRE(_dependencyMap[4]).getPathFromState)(state, options == null ? undefined : options.config);
      return path;
    }, [linking, navigation]);
    return buildLink;
  }
},"node_modules/@react-navigation/native/src/useLinkBuilder.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/@react-navigation/native/src/LinkingContext.tsx","node_modules/@react-navigation/core/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useScrollToTop;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function getScrollableNode(ref) {
    if (ref.current == null) {
      return null;
    }

    if ('scrollToTop' in ref.current || 'scrollTo' in ref.current || 'scrollToOffset' in ref.current || 'scrollResponderScrollTo' in ref.current) {
      return ref.current;
    } else if ('getScrollResponder' in ref.current) {
      return ref.current.getScrollResponder();
    } else if ('getNode' in ref.current) {
      return ref.current.getNode();
    } else {
      return ref.current;
    }
  }

  function useScrollToTop(ref) {
    var navigation = (0, _$$_REQUIRE(_dependencyMap[1]).useNavigation)();
    var route = (0, _$$_REQUIRE(_dependencyMap[1]).useRoute)();
    React.useEffect(function () {
      var current = navigation;

      while (current && current.getState().type !== 'tab') {
        current = current.getParent();
      }

      if (!current) {
        return;
      }

      var unsubscribe = current.addListener('tabPress', function (e) {
        var isFocused = navigation.isFocused();
        var isFirst = navigation === current || navigation.getState().routes[0].key === route.key;
        requestAnimationFrame(function () {
          var scrollable = getScrollableNode(ref);

          if (isFocused && isFirst && scrollable && !e.defaultPrevented) {
            if ('scrollToTop' in scrollable) {
              scrollable.scrollToTop();
            } else if ('scrollTo' in scrollable) {
              scrollable.scrollTo({
                x: 0,
                y: 0,
                animated: true
              });
            } else if ('scrollToOffset' in scrollable) {
              scrollable.scrollToOffset({
                offset: 0,
                animated: true
              });
            } else if ('scrollResponderScrollTo' in scrollable) {
              scrollable.scrollResponderScrollTo({
                y: 0,
                animated: true
              });
            }
          }
        });
      });
      return unsubscribe;
    }, [navigation, ref, route.key]);
  }
},"node_modules/@react-navigation/native/src/useScrollToTop.tsx",["node_modules/react/index.js","node_modules/@react-navigation/core/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "CardAnimationContext", {
    enumerable: true,
    get: function get() {
      return _CardAnimationContext.default;
    }
  });
  exports.CardStyleInterpolators = undefined;
  Object.defineProperty(exports, "GestureHandlerRefContext", {
    enumerable: true,
    get: function get() {
      return _GestureHandlerRefContext.default;
    }
  });
  Object.defineProperty(exports, "Header", {
    enumerable: true,
    get: function get() {
      return _Header.default;
    }
  });
  exports.HeaderStyleInterpolators = undefined;
  Object.defineProperty(exports, "StackView", {
    enumerable: true,
    get: function get() {
      return _StackView.default;
    }
  });
  exports.TransitionSpecs = exports.TransitionPresets = undefined;
  Object.defineProperty(exports, "createStackNavigator", {
    enumerable: true,
    get: function get() {
      return _createStackNavigator.default;
    }
  });
  Object.defineProperty(exports, "useCardAnimation", {
    enumerable: true,
    get: function get() {
      return _useCardAnimation.default;
    }
  });
  Object.defineProperty(exports, "useGestureHandlerRef", {
    enumerable: true,
    get: function get() {
      return _useGestureHandlerRef.default;
    }
  });

  var CardStyleInterpolators = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  exports.CardStyleInterpolators = CardStyleInterpolators;

  var HeaderStyleInterpolators = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[1]));

  exports.HeaderStyleInterpolators = HeaderStyleInterpolators;

  var TransitionPresets = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  exports.TransitionPresets = TransitionPresets;

  var TransitionSpecs = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  exports.TransitionSpecs = TransitionSpecs;

  var _createStackNavigator = _$$_REQUIRE(_dependencyMap[4])(_$$_REQUIRE(_dependencyMap[5]));

  var _Header = _$$_REQUIRE(_dependencyMap[4])(_$$_REQUIRE(_dependencyMap[6]));

  var _StackView = _$$_REQUIRE(_dependencyMap[4])(_$$_REQUIRE(_dependencyMap[7]));

  var _CardAnimationContext = _$$_REQUIRE(_dependencyMap[4])(_$$_REQUIRE(_dependencyMap[8]));

  var _GestureHandlerRefContext = _$$_REQUIRE(_dependencyMap[4])(_$$_REQUIRE(_dependencyMap[9]));

  var _useCardAnimation = _$$_REQUIRE(_dependencyMap[4])(_$$_REQUIRE(_dependencyMap[10]));

  var _useGestureHandlerRef = _$$_REQUIRE(_dependencyMap[4])(_$$_REQUIRE(_dependencyMap[11]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},"node_modules/@react-navigation/stack/src/index.tsx",["node_modules/@react-navigation/stack/src/TransitionConfigs/CardStyleInterpolators.tsx","node_modules/@react-navigation/stack/src/TransitionConfigs/HeaderStyleInterpolators.tsx","node_modules/@react-navigation/stack/src/TransitionConfigs/TransitionPresets.tsx","node_modules/@react-navigation/stack/src/TransitionConfigs/TransitionSpecs.tsx","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/stack/src/navigators/createStackNavigator.tsx","node_modules/@react-navigation/stack/src/views/Header/Header.tsx","node_modules/@react-navigation/stack/src/views/Stack/StackView.tsx","node_modules/@react-navigation/stack/src/utils/CardAnimationContext.tsx","node_modules/@react-navigation/stack/src/utils/GestureHandlerRefContext.tsx","node_modules/@react-navigation/stack/src/utils/useCardAnimation.tsx","node_modules/@react-navigation/stack/src/utils/useGestureHandlerRef.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.forBottomSheetAndroid = forBottomSheetAndroid;
  exports.forFadeFromBottomAndroid = forFadeFromBottomAndroid;
  exports.forFadeFromCenter = forFadeFromCenter;
  exports.forHorizontalIOS = forHorizontalIOS;
  exports.forModalPresentationIOS = forModalPresentationIOS;
  exports.forNoAnimation = forNoAnimation;
  exports.forRevealFromBottomAndroid = forRevealFromBottomAndroid;
  exports.forScaleFromCenterAndroid = forScaleFromCenterAndroid;
  exports.forVerticalIOS = forVerticalIOS;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0]);

  var _conditional = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  var add = _reactNative.Animated.add,
      multiply = _reactNative.Animated.multiply;

  function forHorizontalIOS(_ref) {
    var current = _ref.current,
        next = _ref.next,
        inverted = _ref.inverted,
        screen = _ref.layouts.screen;
    var translateFocused = multiply(current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [screen.width, 0],
      extrapolate: 'clamp'
    }), inverted);
    var translateUnfocused = next ? multiply(next.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, screen.width * -0.3],
      extrapolate: 'clamp'
    }), inverted) : 0;
    var overlayOpacity = current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 0.07],
      extrapolate: 'clamp'
    });
    var shadowOpacity = current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 0.3],
      extrapolate: 'clamp'
    });
    return {
      cardStyle: {
        transform: [{
          translateX: translateFocused
        }, {
          translateX: translateUnfocused
        }]
      },
      overlayStyle: {
        opacity: overlayOpacity
      },
      shadowStyle: {
        shadowOpacity: shadowOpacity
      }
    };
  }

  function forVerticalIOS(_ref2) {
    var current = _ref2.current,
        inverted = _ref2.inverted,
        screen = _ref2.layouts.screen;
    var translateY = multiply(current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [screen.height, 0],
      extrapolate: 'clamp'
    }), inverted);
    return {
      cardStyle: {
        transform: [{
          translateY: translateY
        }]
      }
    };
  }

  function forModalPresentationIOS(_ref3) {
    var index = _ref3.index,
        current = _ref3.current,
        next = _ref3.next,
        inverted = _ref3.inverted,
        screen = _ref3.layouts.screen,
        insets = _ref3.insets;
    var hasNotchIos = _reactNative.Platform.OS === 'ios' && !_reactNative.Platform.isPad && !_reactNative.Platform.isTVOS && insets.top > 20;
    var isLandscape = screen.width > screen.height;
    var topOffset = isLandscape ? 0 : 10;
    var statusBarHeight = insets.top;
    var aspectRatio = screen.height / screen.width;
    var progress = add(current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
      extrapolate: 'clamp'
    }), next ? next.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
      extrapolate: 'clamp'
    }) : 0);
    var isFirst = index === 0;
    var translateY = multiply(progress.interpolate({
      inputRange: [0, 1, 2],
      outputRange: [screen.height, isFirst ? 0 : topOffset, (isFirst ? statusBarHeight : 0) - topOffset * aspectRatio]
    }), inverted);
    var overlayOpacity = progress.interpolate({
      inputRange: [0, 1, 1.0001, 2],
      outputRange: [0, 0.3, 1, 1]
    });
    var scale = isLandscape ? 1 : progress.interpolate({
      inputRange: [0, 1, 2],
      outputRange: [1, 1, screen.width ? 1 - topOffset * 2 / screen.width : 1]
    });
    var borderRadius = isLandscape ? 0 : isFirst ? progress.interpolate({
      inputRange: [0, 1, 1.0001, 2],
      outputRange: [0, 0, hasNotchIos ? 38 : 0, 10]
    }) : 10;
    return {
      cardStyle: {
        overflow: 'hidden',
        borderTopLeftRadius: borderRadius,
        borderTopRightRadius: borderRadius,
        borderBottomLeftRadius: hasNotchIos ? borderRadius : 0,
        borderBottomRightRadius: hasNotchIos ? borderRadius : 0,
        marginTop: isFirst ? 0 : statusBarHeight,
        marginBottom: isFirst ? 0 : topOffset,
        transform: [{
          translateY: translateY
        }, {
          scale: scale
        }]
      },
      overlayStyle: {
        opacity: overlayOpacity
      }
    };
  }

  function forFadeFromBottomAndroid(_ref4) {
    var current = _ref4.current,
        inverted = _ref4.inverted,
        screen = _ref4.layouts.screen,
        closing = _ref4.closing;
    var translateY = multiply(current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [screen.height * 0.08, 0],
      extrapolate: 'clamp'
    }), inverted);
    var opacity = (0, _conditional.default)(closing, current.progress, current.progress.interpolate({
      inputRange: [0, 0.5, 0.9, 1],
      outputRange: [0, 0.25, 0.7, 1],
      extrapolate: 'clamp'
    }));
    return {
      cardStyle: {
        opacity: opacity,
        transform: [{
          translateY: translateY
        }]
      }
    };
  }

  function forRevealFromBottomAndroid(_ref5) {
    var current = _ref5.current,
        next = _ref5.next,
        inverted = _ref5.inverted,
        screen = _ref5.layouts.screen;
    var containerTranslateY = multiply(current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [screen.height, 0],
      extrapolate: 'clamp'
    }), inverted);
    var cardTranslateYFocused = multiply(current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [screen.height * 0.9590000000000001 * -1, 0],
      extrapolate: 'clamp'
    }), inverted);
    var cardTranslateYUnfocused = next ? multiply(next.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, screen.height * 0.02 * -1],
      extrapolate: 'clamp'
    }), inverted) : 0;
    var overlayOpacity = current.progress.interpolate({
      inputRange: [0, 0.36, 1],
      outputRange: [0, 0.1, 0.1],
      extrapolate: 'clamp'
    });
    return {
      containerStyle: {
        overflow: 'hidden',
        transform: [{
          translateY: containerTranslateY
        }]
      },
      cardStyle: {
        transform: [{
          translateY: cardTranslateYFocused
        }, {
          translateY: cardTranslateYUnfocused
        }]
      },
      overlayStyle: {
        opacity: overlayOpacity
      }
    };
  }

  function forScaleFromCenterAndroid(_ref6) {
    var current = _ref6.current,
        next = _ref6.next,
        closing = _ref6.closing;
    var progress = add(current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
      extrapolate: 'clamp'
    }), next ? next.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
      extrapolate: 'clamp'
    }) : 0);
    var opacity = progress.interpolate({
      inputRange: [0, 0.75, 0.875, 1, 1.0825, 1.2075, 2],
      outputRange: [0, 0, 1, 1, 1, 1, 0]
    });
    var scale = (0, _conditional.default)(closing, current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0.925, 1],
      extrapolate: 'clamp'
    }), progress.interpolate({
      inputRange: [0, 1, 2],
      outputRange: [0.85, 1, 1.075]
    }));
    return {
      cardStyle: {
        opacity: opacity,
        transform: [{
          scale: scale
        }]
      }
    };
  }

  function forBottomSheetAndroid(_ref7) {
    var current = _ref7.current,
        inverted = _ref7.inverted,
        screen = _ref7.layouts.screen,
        closing = _ref7.closing;
    var translateY = multiply(current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [screen.height * 0.8, 0],
      extrapolate: 'clamp'
    }), inverted);
    var opacity = (0, _conditional.default)(closing, current.progress, current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
      extrapolate: 'clamp'
    }));
    var overlayOpacity = current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 0.3],
      extrapolate: 'clamp'
    });
    return {
      cardStyle: {
        opacity: opacity,
        transform: [{
          translateY: translateY
        }]
      },
      overlayStyle: {
        opacity: overlayOpacity
      }
    };
  }

  function forFadeFromCenter(_ref8) {
    var progress = _ref8.current.progress;
    return {
      cardStyle: {
        opacity: progress.interpolate({
          inputRange: [0, 0.5, 0.9, 1],
          outputRange: [0, 0.25, 0.7, 1]
        })
      },
      overlayStyle: {
        opacity: progress.interpolate({
          inputRange: [0, 1],
          outputRange: [0, 0.5],
          extrapolate: 'clamp'
        })
      }
    };
  }

  function forNoAnimation() {
    return {};
  }
},"node_modules/@react-navigation/stack/src/TransitionConfigs/CardStyleInterpolators.tsx",["node_modules/react-native/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/stack/src/utils/conditional.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = conditional;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0]);

  var add = _reactNative.Animated.add,
      multiply = _reactNative.Animated.multiply;

  function conditional(condition, main, fallback) {
    return add(multiply(condition, main), multiply(condition.interpolate({
      inputRange: [0, 1],
      outputRange: [1, 0]
    }), fallback));
  }
},"node_modules/@react-navigation/stack/src/utils/conditional.tsx",["node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.forFade = forFade;
  exports.forNoAnimation = forNoAnimation;
  exports.forSlideLeft = forSlideLeft;
  exports.forSlideRight = forSlideRight;
  exports.forSlideUp = forSlideUp;
  exports.forUIKit = forUIKit;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0]);

  var add = _reactNative.Animated.add;

  function forUIKit(_ref) {
    var current = _ref.current,
        next = _ref.next,
        layouts = _ref.layouts;
    var defaultOffset = 100;
    var leftSpacing = 27;
    var leftLabelOffset = layouts.leftLabel ? (layouts.screen.width - layouts.leftLabel.width) / 2 - leftSpacing : defaultOffset;
    var titleLeftOffset = layouts.title ? (layouts.screen.width - layouts.title.width) / 2 - leftSpacing : defaultOffset;
    var rightOffset = layouts.screen.width / 4;
    var progress = add(current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
      extrapolate: 'clamp'
    }), next ? next.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
      extrapolate: 'clamp'
    }) : 0);
    return {
      leftButtonStyle: {
        opacity: progress.interpolate({
          inputRange: [0.3, 1, 1.5],
          outputRange: [0, 1, 0]
        })
      },
      leftLabelStyle: {
        transform: [{
          translateX: progress.interpolate({
            inputRange: [0, 1, 2],
            outputRange: _reactNative.I18nManager.isRTL ? [-rightOffset, 0, leftLabelOffset] : [leftLabelOffset, 0, -rightOffset]
          })
        }]
      },
      rightButtonStyle: {
        opacity: progress.interpolate({
          inputRange: [0.3, 1, 1.5],
          outputRange: [0, 1, 0]
        })
      },
      titleStyle: {
        opacity: progress.interpolate({
          inputRange: [0, 0.4, 1, 1.5],
          outputRange: [0, 0.1, 1, 0]
        }),
        transform: [{
          translateX: progress.interpolate({
            inputRange: [0.5, 1, 2],
            outputRange: _reactNative.I18nManager.isRTL ? [-titleLeftOffset, 0, rightOffset] : [rightOffset, 0, -titleLeftOffset]
          })
        }]
      },
      backgroundStyle: {
        transform: [{
          translateX: progress.interpolate({
            inputRange: [0, 1, 2],
            outputRange: _reactNative.I18nManager.isRTL ? [-layouts.screen.width, 0, layouts.screen.width] : [layouts.screen.width, 0, -layouts.screen.width]
          })
        }]
      }
    };
  }

  function forFade(_ref2) {
    var current = _ref2.current,
        next = _ref2.next;
    var progress = add(current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
      extrapolate: 'clamp'
    }), next ? next.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
      extrapolate: 'clamp'
    }) : 0);
    var opacity = progress.interpolate({
      inputRange: [0, 1, 2],
      outputRange: [0, 1, 0]
    });
    return {
      leftButtonStyle: {
        opacity: opacity
      },
      rightButtonStyle: {
        opacity: opacity
      },
      titleStyle: {
        opacity: opacity
      },
      backgroundStyle: {
        opacity: progress.interpolate({
          inputRange: [0, 1, 1.9, 2],
          outputRange: [0, 1, 1, 0]
        })
      }
    };
  }

  function forSlideLeft(_ref3) {
    var current = _ref3.current,
        next = _ref3.next,
        screen = _ref3.layouts.screen;
    var progress = add(current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
      extrapolate: 'clamp'
    }), next ? next.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
      extrapolate: 'clamp'
    }) : 0);
    var translateX = progress.interpolate({
      inputRange: [0, 1, 2],
      outputRange: _reactNative.I18nManager.isRTL ? [-screen.width, 0, screen.width] : [screen.width, 0, -screen.width]
    });
    var transform = [{
      translateX: translateX
    }];
    return {
      leftButtonStyle: {
        transform: transform
      },
      rightButtonStyle: {
        transform: transform
      },
      titleStyle: {
        transform: transform
      },
      backgroundStyle: {
        transform: transform
      }
    };
  }

  function forSlideRight(_ref4) {
    var current = _ref4.current,
        next = _ref4.next,
        screen = _ref4.layouts.screen;
    var progress = add(current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
      extrapolate: 'clamp'
    }), next ? next.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
      extrapolate: 'clamp'
    }) : 0);
    var translateX = progress.interpolate({
      inputRange: [0, 1, 2],
      outputRange: _reactNative.I18nManager.isRTL ? [screen.width, 0, -screen.width] : [-screen.width, 0, screen.width]
    });
    var transform = [{
      translateX: translateX
    }];
    return {
      leftButtonStyle: {
        transform: transform
      },
      rightButtonStyle: {
        transform: transform
      },
      titleStyle: {
        transform: transform
      },
      backgroundStyle: {
        transform: transform
      }
    };
  }

  function forSlideUp(_ref5) {
    var current = _ref5.current,
        next = _ref5.next,
        header = _ref5.layouts.header;
    var progress = add(current.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
      extrapolate: 'clamp'
    }), next ? next.progress.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 1],
      extrapolate: 'clamp'
    }) : 0);
    var translateY = progress.interpolate({
      inputRange: [0, 1, 2],
      outputRange: [-header.height, 0, -header.height]
    });
    var transform = [{
      translateY: translateY
    }];
    return {
      leftButtonStyle: {
        transform: transform
      },
      rightButtonStyle: {
        transform: transform
      },
      titleStyle: {
        transform: transform
      },
      backgroundStyle: {
        transform: transform
      }
    };
  }

  function forNoAnimation() {
    return {};
  }
},"node_modules/@react-navigation/stack/src/TransitionConfigs/HeaderStyleInterpolators.tsx",["node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SlideFromRightIOS = exports.ScaleFromCenterAndroid = exports.RevealFromBottomAndroid = exports.ModalTransition = exports.ModalSlideFromBottomIOS = exports.ModalPresentationIOS = exports.ModalFadeTransition = exports.FadeFromBottomAndroid = exports.DefaultTransition = exports.BottomSheetAndroid = undefined;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0]);

  var ANDROID_VERSION_PIE = 28;
  var ANDROID_VERSION_10 = 29;
  var SlideFromRightIOS = {
    gestureDirection: 'horizontal',
    transitionSpec: {
      open: _$$_REQUIRE(_dependencyMap[1]).TransitionIOSSpec,
      close: _$$_REQUIRE(_dependencyMap[1]).TransitionIOSSpec
    },
    cardStyleInterpolator: _$$_REQUIRE(_dependencyMap[2]).forHorizontalIOS,
    headerStyleInterpolator: _$$_REQUIRE(_dependencyMap[3]).forFade
  };
  exports.SlideFromRightIOS = SlideFromRightIOS;
  var ModalSlideFromBottomIOS = {
    gestureDirection: 'vertical',
    transitionSpec: {
      open: _$$_REQUIRE(_dependencyMap[1]).TransitionIOSSpec,
      close: _$$_REQUIRE(_dependencyMap[1]).TransitionIOSSpec
    },
    cardStyleInterpolator: _$$_REQUIRE(_dependencyMap[2]).forVerticalIOS,
    headerStyleInterpolator: _$$_REQUIRE(_dependencyMap[3]).forFade
  };
  exports.ModalSlideFromBottomIOS = ModalSlideFromBottomIOS;
  var ModalPresentationIOS = {
    gestureDirection: 'vertical',
    transitionSpec: {
      open: _$$_REQUIRE(_dependencyMap[1]).TransitionIOSSpec,
      close: _$$_REQUIRE(_dependencyMap[1]).TransitionIOSSpec
    },
    cardStyleInterpolator: _$$_REQUIRE(_dependencyMap[2]).forModalPresentationIOS,
    headerStyleInterpolator: _$$_REQUIRE(_dependencyMap[3]).forFade
  };
  exports.ModalPresentationIOS = ModalPresentationIOS;
  var FadeFromBottomAndroid = {
    gestureDirection: 'vertical',
    transitionSpec: {
      open: _$$_REQUIRE(_dependencyMap[1]).FadeInFromBottomAndroidSpec,
      close: _$$_REQUIRE(_dependencyMap[1]).FadeOutToBottomAndroidSpec
    },
    cardStyleInterpolator: _$$_REQUIRE(_dependencyMap[2]).forFadeFromBottomAndroid,
    headerStyleInterpolator: _$$_REQUIRE(_dependencyMap[3]).forFade
  };
  exports.FadeFromBottomAndroid = FadeFromBottomAndroid;
  var RevealFromBottomAndroid = {
    gestureDirection: 'vertical',
    transitionSpec: {
      open: _$$_REQUIRE(_dependencyMap[1]).RevealFromBottomAndroidSpec,
      close: _$$_REQUIRE(_dependencyMap[1]).RevealFromBottomAndroidSpec
    },
    cardStyleInterpolator: _$$_REQUIRE(_dependencyMap[2]).forRevealFromBottomAndroid,
    headerStyleInterpolator: _$$_REQUIRE(_dependencyMap[3]).forFade
  };
  exports.RevealFromBottomAndroid = RevealFromBottomAndroid;
  var ScaleFromCenterAndroid = {
    gestureDirection: 'horizontal',
    transitionSpec: {
      open: _$$_REQUIRE(_dependencyMap[1]).ScaleFromCenterAndroidSpec,
      close: _$$_REQUIRE(_dependencyMap[1]).ScaleFromCenterAndroidSpec
    },
    cardStyleInterpolator: _$$_REQUIRE(_dependencyMap[2]).forScaleFromCenterAndroid,
    headerStyleInterpolator: _$$_REQUIRE(_dependencyMap[3]).forFade
  };
  exports.ScaleFromCenterAndroid = ScaleFromCenterAndroid;
  var BottomSheetAndroid = {
    gestureDirection: 'vertical',
    transitionSpec: {
      open: _$$_REQUIRE(_dependencyMap[1]).BottomSheetSlideInSpec,
      close: _$$_REQUIRE(_dependencyMap[1]).BottomSheetSlideOutSpec
    },
    cardStyleInterpolator: _$$_REQUIRE(_dependencyMap[2]).forBottomSheetAndroid,
    headerStyleInterpolator: _$$_REQUIRE(_dependencyMap[3]).forFade
  };
  exports.BottomSheetAndroid = BottomSheetAndroid;
  var ModalFadeTransition = {
    gestureDirection: 'vertical',
    transitionSpec: {
      open: _$$_REQUIRE(_dependencyMap[1]).BottomSheetSlideInSpec,
      close: _$$_REQUIRE(_dependencyMap[1]).BottomSheetSlideOutSpec
    },
    cardStyleInterpolator: _$$_REQUIRE(_dependencyMap[2]).forFadeFromCenter,
    headerStyleInterpolator: _$$_REQUIRE(_dependencyMap[3]).forFade
  };
  exports.ModalFadeTransition = ModalFadeTransition;

  var DefaultTransition = _reactNative.Platform.select({
    ios: SlideFromRightIOS,
    android: _reactNative.Platform.Version >= ANDROID_VERSION_10 ? ScaleFromCenterAndroid : _reactNative.Platform.Version >= ANDROID_VERSION_PIE ? RevealFromBottomAndroid : FadeFromBottomAndroid,
    default: ScaleFromCenterAndroid
  });

  exports.DefaultTransition = DefaultTransition;

  var ModalTransition = _reactNative.Platform.select({
    ios: ModalPresentationIOS,
    default: BottomSheetAndroid
  });

  exports.ModalTransition = ModalTransition;
},"node_modules/@react-navigation/stack/src/TransitionConfigs/TransitionPresets.tsx",["node_modules/react-native/index.js","node_modules/@react-navigation/stack/src/TransitionConfigs/TransitionSpecs.tsx","node_modules/@react-navigation/stack/src/TransitionConfigs/CardStyleInterpolators.tsx","node_modules/@react-navigation/stack/src/TransitionConfigs/HeaderStyleInterpolators.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TransitionIOSSpec = exports.ScaleFromCenterAndroidSpec = exports.RevealFromBottomAndroidSpec = exports.FadeOutToBottomAndroidSpec = exports.FadeInFromBottomAndroidSpec = exports.BottomSheetSlideOutSpec = exports.BottomSheetSlideInSpec = undefined;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0]);

  var TransitionIOSSpec = {
    animation: 'spring',
    config: {
      stiffness: 1000,
      damping: 500,
      mass: 3,
      overshootClamping: true,
      restDisplacementThreshold: 10,
      restSpeedThreshold: 10
    }
  };
  exports.TransitionIOSSpec = TransitionIOSSpec;
  var FadeInFromBottomAndroidSpec = {
    animation: 'timing',
    config: {
      duration: 350,
      easing: _reactNative.Easing.out(_reactNative.Easing.poly(5))
    }
  };
  exports.FadeInFromBottomAndroidSpec = FadeInFromBottomAndroidSpec;
  var FadeOutToBottomAndroidSpec = {
    animation: 'timing',
    config: {
      duration: 150,
      easing: _reactNative.Easing.in(_reactNative.Easing.linear)
    }
  };
  exports.FadeOutToBottomAndroidSpec = FadeOutToBottomAndroidSpec;
  var RevealFromBottomAndroidSpec = {
    animation: 'timing',
    config: {
      duration: 425,
      easing: _reactNative.Easing.bezier(0.35, 0.45, 0, 1)
    }
  };
  exports.RevealFromBottomAndroidSpec = RevealFromBottomAndroidSpec;
  var ScaleFromCenterAndroidSpec = {
    animation: 'timing',
    config: {
      duration: 400,
      easing: _reactNative.Easing.bezier(0.35, 0.45, 0, 1)
    }
  };
  exports.ScaleFromCenterAndroidSpec = ScaleFromCenterAndroidSpec;
  var BottomSheetSlideInSpec = {
    animation: 'timing',
    config: {
      duration: 250,
      easing: function easing(t) {
        return Math.cos((t + 1) * Math.PI) / 2.0 + 0.5;
      }
    }
  };
  exports.BottomSheetSlideInSpec = BottomSheetSlideInSpec;
  var BottomSheetSlideOutSpec = {
    animation: 'timing',
    config: {
      duration: 200,
      easing: function easing(t) {
        return t === 1.0 ? 1 : Math.pow(t, 2);
      }
    }
  };
  exports.BottomSheetSlideOutSpec = BottomSheetSlideOutSpec;
},"node_modules/@react-navigation/stack/src/TransitionConfigs/TransitionSpecs.tsx",["node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _warnOnce = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _StackView = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _excluded = ["id", "initialRouteName", "children", "screenListeners", "screenOptions"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function StackNavigator(_ref) {
    var id = _ref.id,
        initialRouteName = _ref.initialRouteName,
        children = _ref.children,
        screenListeners = _ref.screenListeners,
        screenOptions = _ref.screenOptions,
        rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);
    var mode = rest.mode;
    (0, _warnOnce.default)(mode != null, "Stack Navigator: 'mode=\"" + mode + "\"' is deprecated. Use 'presentation: \"" + mode + "\"' in 'screenOptions' instead.\n\nSee https://reactnavigation.org/docs/stack-navigator#presentation for more details.");
    var headerMode = rest.headerMode;
    (0, _warnOnce.default)(headerMode === 'none', "Stack Navigator: 'headerMode=\"none\"' is deprecated. Use 'headerShown: false' in 'screenOptions' instead.\n\nSee https://reactnavigation.org/docs/stack-navigator/#headershown for more details.");
    (0, _warnOnce.default)(headerMode != null && headerMode !== 'none', "Stack Navigator: 'headerMode' is moved to 'options'. Moved it to 'screenOptions' to keep current behavior.\n\nSee https://reactnavigation.org/docs/stack-navigator/#headermode for more details.");
    var keyboardHandlingEnabled = rest.keyboardHandlingEnabled;
    (0, _warnOnce.default)(keyboardHandlingEnabled !== undefined, "Stack Navigator: 'keyboardHandlingEnabled' is moved to 'options'. Moved it to 'screenOptions' to keep current behavior.\n\nSee https://reactnavigation.org/docs/stack-navigator/#keyboardhandlingenabled for more details.");
    var defaultScreenOptions = {
      presentation: mode,
      headerShown: headerMode ? headerMode !== 'none' : true,
      headerMode: headerMode && headerMode !== 'none' ? headerMode : undefined,
      keyboardHandlingEnabled: keyboardHandlingEnabled
    };

    var _useNavigationBuilder = (0, _$$_REQUIRE(_dependencyMap[6]).useNavigationBuilder)(_$$_REQUIRE(_dependencyMap[6]).StackRouter, {
      id: id,
      initialRouteName: initialRouteName,
      children: children,
      screenListeners: screenListeners,
      screenOptions: screenOptions,
      defaultScreenOptions: defaultScreenOptions
    }),
        state = _useNavigationBuilder.state,
        descriptors = _useNavigationBuilder.descriptors,
        navigation = _useNavigationBuilder.navigation,
        NavigationContent = _useNavigationBuilder.NavigationContent;

    React.useEffect(function () {
      return navigation.addListener == null ? undefined : navigation.addListener('tabPress', function (e) {
        var isFocused = navigation.isFocused();
        requestAnimationFrame(function () {
          if (state.index > 0 && isFocused && !e.defaultPrevented) {
            navigation.dispatch((0, _extends2.default)({}, _$$_REQUIRE(_dependencyMap[6]).StackActions.popToTop(), {
              target: state.key
            }));
          }
        });
      });
    }, [navigation, state.index, state.key]);
    return React.createElement(NavigationContent, null, React.createElement(_StackView.default, (0, _extends2.default)({}, rest, {
      state: state,
      descriptors: descriptors,
      navigation: navigation
    })));
  }

  var _default = (0, _$$_REQUIRE(_dependencyMap[6]).createNavigatorFactory)(StackNavigator);

  exports.default = _default;
},"node_modules/@react-navigation/stack/src/navigators/createStackNavigator.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/warn-once/index.js","node_modules/@react-navigation/stack/src/views/Stack/StackView.tsx","node_modules/@react-navigation/native/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var DEV = false;
  var warnings = new Set();

  function warnOnce(condition) {}

  module.exports = warnOnce;
},"node_modules/warn-once/index.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[9]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[10]);

  var _ModalPresentationContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _HeaderContainer = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var _CardStack = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[13]));

  var _excluded = ["state", "descriptors"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var GestureHandlerWrapper = _$$_REQUIRE(_dependencyMap[14]).GestureHandlerRootView != null ? _$$_REQUIRE(_dependencyMap[14]).GestureHandlerRootView : _reactNative.View;

  var isArrayEqual = function isArrayEqual(a, b) {
    return a.length === b.length && a.every(function (it, index) {
      return it === b[index];
    });
  };

  var StackView = function (_React$Component) {
    (0, _inherits2.default)(StackView, _React$Component);

    var _super = _createSuper(StackView);

    function StackView() {
      var _this;

      (0, _classCallCheck2.default)(this, StackView);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        routes: [],
        previousRoutes: [],
        previousDescriptors: {},
        openingRouteKeys: [],
        closingRouteKeys: [],
        replacingRouteKeys: [],
        descriptors: {}
      };

      _this.getPreviousRoute = function (_ref) {
        var route = _ref.route;
        var _this$state = _this.state,
            closingRouteKeys = _this$state.closingRouteKeys,
            replacingRouteKeys = _this$state.replacingRouteKeys;

        var routes = _this.state.routes.filter(function (r) {
          return r.key === route.key || !closingRouteKeys.includes(r.key) && !replacingRouteKeys.includes(r.key);
        });

        var index = routes.findIndex(function (r) {
          return r.key === route.key;
        });
        return routes[index - 1];
      };

      _this.renderScene = function (_ref2) {
        var route = _ref2.route;
        var descriptor = _this.state.descriptors[route.key] || _this.props.descriptors[route.key];

        if (!descriptor) {
          return null;
        }

        return descriptor.render();
      };

      _this.renderHeader = function (props) {
        return React.createElement(_HeaderContainer.default, props);
      };

      _this.handleOpenRoute = function (_ref3) {
        var route = _ref3.route;
        var _this$props = _this.props,
            state = _this$props.state,
            navigation = _this$props.navigation;
        var _this$state2 = _this.state,
            closingRouteKeys = _this$state2.closingRouteKeys,
            replacingRouteKeys = _this$state2.replacingRouteKeys;

        if (closingRouteKeys.some(function (key) {
          return key === route.key;
        }) && replacingRouteKeys.every(function (key) {
          return key !== route.key;
        }) && state.routeNames.includes(route.name) && !state.routes.some(function (r) {
          return r.key === route.key;
        })) {
          navigation.navigate(route);
        } else {
          _this.setState(function (state) {
            return {
              routes: state.replacingRouteKeys.length ? state.routes.filter(function (r) {
                return !state.replacingRouteKeys.includes(r.key);
              }) : state.routes,
              openingRouteKeys: state.openingRouteKeys.filter(function (key) {
                return key !== route.key;
              }),
              closingRouteKeys: state.closingRouteKeys.filter(function (key) {
                return key !== route.key;
              }),
              replacingRouteKeys: []
            };
          });
        }
      };

      _this.handleCloseRoute = function (_ref4) {
        var route = _ref4.route;
        var _this$props2 = _this.props,
            state = _this$props2.state,
            navigation = _this$props2.navigation;

        if (state.routes.some(function (r) {
          return r.key === route.key;
        })) {
          navigation.dispatch((0, _extends2.default)({}, _$$_REQUIRE(_dependencyMap[15]).StackActions.pop(), {
            source: route.key,
            target: state.key
          }));
        } else {
          _this.setState(function (state) {
            return {
              routes: state.routes.filter(function (r) {
                return r.key !== route.key;
              }),
              openingRouteKeys: state.openingRouteKeys.filter(function (key) {
                return key !== route.key;
              }),
              closingRouteKeys: state.closingRouteKeys.filter(function (key) {
                return key !== route.key;
              })
            };
          });
        }
      };

      _this.handleTransitionStart = function (_ref5, closing) {
        var route = _ref5.route;
        return _this.props.navigation.emit({
          type: 'transitionStart',
          data: {
            closing: closing
          },
          target: route.key
        });
      };

      _this.handleTransitionEnd = function (_ref6, closing) {
        var route = _ref6.route;
        return _this.props.navigation.emit({
          type: 'transitionEnd',
          data: {
            closing: closing
          },
          target: route.key
        });
      };

      _this.handleGestureStart = function (_ref7) {
        var route = _ref7.route;

        _this.props.navigation.emit({
          type: 'gestureStart',
          target: route.key
        });
      };

      _this.handleGestureEnd = function (_ref8) {
        var route = _ref8.route;

        _this.props.navigation.emit({
          type: 'gestureEnd',
          target: route.key
        });
      };

      _this.handleGestureCancel = function (_ref9) {
        var route = _ref9.route;

        _this.props.navigation.emit({
          type: 'gestureCancel',
          target: route.key
        });
      };

      return _this;
    }

    (0, _createClass2.default)(StackView, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props3 = this.props,
            state = _this$props3.state,
            _ = _this$props3.descriptors,
            rest = (0, _objectWithoutProperties2.default)(_this$props3, _excluded);
        var _this$state3 = this.state,
            routes = _this$state3.routes,
            descriptors = _this$state3.descriptors,
            openingRouteKeys = _this$state3.openingRouteKeys,
            closingRouteKeys = _this$state3.closingRouteKeys;
        return React.createElement(GestureHandlerWrapper, {
          style: styles.container
        }, React.createElement(_$$_REQUIRE(_dependencyMap[16]).SafeAreaProviderCompat, null, React.createElement(_$$_REQUIRE(_dependencyMap[17]).SafeAreaInsetsContext.Consumer, null, function (insets) {
          return React.createElement(_ModalPresentationContext.default.Consumer, null, function (isParentModal) {
            return React.createElement(_$$_REQUIRE(_dependencyMap[16]).HeaderShownContext.Consumer, null, function (isParentHeaderShown) {
              return React.createElement(_CardStack.default, (0, _extends2.default)({
                insets: insets,
                isParentHeaderShown: isParentHeaderShown,
                isParentModal: isParentModal,
                getPreviousRoute: _this2.getPreviousRoute,
                routes: routes,
                openingRouteKeys: openingRouteKeys,
                closingRouteKeys: closingRouteKeys,
                onOpenRoute: _this2.handleOpenRoute,
                onCloseRoute: _this2.handleCloseRoute,
                onTransitionStart: _this2.handleTransitionStart,
                onTransitionEnd: _this2.handleTransitionEnd,
                renderHeader: _this2.renderHeader,
                renderScene: _this2.renderScene,
                state: state,
                descriptors: descriptors,
                onGestureStart: _this2.handleGestureStart,
                onGestureEnd: _this2.handleGestureEnd,
                onGestureCancel: _this2.handleGestureCancel
              }, rest));
            });
          });
        })));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(props, state) {
        if ((props.state.routes === state.previousRoutes || isArrayEqual(props.state.routes.map(function (r) {
          return r.key;
        }), state.previousRoutes.map(function (r) {
          return r.key;
        }))) && state.routes.length) {
          var _routes = state.routes;
          var _previousRoutes = state.previousRoutes;
          var _descriptors = props.descriptors;
          var previousDescriptors = state.previousDescriptors;

          if (props.descriptors !== state.previousDescriptors) {
            _descriptors = state.routes.reduce(function (acc, route) {
              acc[route.key] = props.descriptors[route.key] || state.descriptors[route.key];
              return acc;
            }, {});
            previousDescriptors = props.descriptors;
          }

          if (props.state.routes !== state.previousRoutes) {
            var map = props.state.routes.reduce(function (acc, route) {
              acc[route.key] = route;
              return acc;
            }, {});
            _routes = state.routes.map(function (route) {
              return map[route.key] || route;
            });
            _previousRoutes = props.state.routes;
          }

          return {
            routes: _routes,
            previousRoutes: _previousRoutes,
            descriptors: _descriptors,
            previousDescriptors: previousDescriptors
          };
        }

        var routes = props.state.index < props.state.routes.length - 1 ? props.state.routes.slice(0, props.state.index + 1) : props.state.routes;
        var openingRouteKeys = state.openingRouteKeys,
            closingRouteKeys = state.closingRouteKeys,
            replacingRouteKeys = state.replacingRouteKeys,
            previousRoutes = state.previousRoutes;
        var previousFocusedRoute = previousRoutes[previousRoutes.length - 1];
        var nextFocusedRoute = routes[routes.length - 1];

        var isAnimationEnabled = function isAnimationEnabled(key) {
          var descriptor = props.descriptors[key] || state.descriptors[key];
          return descriptor ? descriptor.options.animationEnabled !== false : true;
        };

        var getAnimationTypeForReplace = function getAnimationTypeForReplace(key) {
          var _descriptor$options$a;

          var descriptor = props.descriptors[key] || state.descriptors[key];
          return (_descriptor$options$a = descriptor.options.animationTypeForReplace) != null ? _descriptor$options$a : 'push';
        };

        if (previousFocusedRoute && previousFocusedRoute.key !== nextFocusedRoute.key) {
          if (!previousRoutes.some(function (r) {
            return r.key === nextFocusedRoute.key;
          })) {
            if (isAnimationEnabled(nextFocusedRoute.key) && !openingRouteKeys.includes(nextFocusedRoute.key)) {
              openingRouteKeys = [].concat((0, _toConsumableArray2.default)(openingRouteKeys), [nextFocusedRoute.key]);
              closingRouteKeys = closingRouteKeys.filter(function (key) {
                return key !== nextFocusedRoute.key;
              });
              replacingRouteKeys = replacingRouteKeys.filter(function (key) {
                return key !== nextFocusedRoute.key;
              });

              if (!routes.some(function (r) {
                return r.key === previousFocusedRoute.key;
              })) {
                openingRouteKeys = openingRouteKeys.filter(function (key) {
                  return key !== previousFocusedRoute.key;
                });

                if (getAnimationTypeForReplace(nextFocusedRoute.key) === 'pop') {
                  closingRouteKeys = [].concat((0, _toConsumableArray2.default)(closingRouteKeys), [previousFocusedRoute.key]);
                  openingRouteKeys = openingRouteKeys.filter(function (key) {
                    return key !== nextFocusedRoute.key;
                  });
                  routes = [].concat((0, _toConsumableArray2.default)(routes), [previousFocusedRoute]);
                } else {
                  replacingRouteKeys = [].concat((0, _toConsumableArray2.default)(replacingRouteKeys), [previousFocusedRoute.key]);
                  closingRouteKeys = closingRouteKeys.filter(function (key) {
                    return key !== previousFocusedRoute.key;
                  });
                  routes = routes.slice();
                  routes.splice(routes.length - 1, 0, previousFocusedRoute);
                }
              }
            }
          } else if (!routes.some(function (r) {
            return r.key === previousFocusedRoute.key;
          })) {
            if (isAnimationEnabled(previousFocusedRoute.key) && !closingRouteKeys.includes(previousFocusedRoute.key)) {
              closingRouteKeys = [].concat((0, _toConsumableArray2.default)(closingRouteKeys), [previousFocusedRoute.key]);
              openingRouteKeys = openingRouteKeys.filter(function (key) {
                return key !== previousFocusedRoute.key;
              });
              replacingRouteKeys = replacingRouteKeys.filter(function (key) {
                return key !== previousFocusedRoute.key;
              });
              routes = [].concat((0, _toConsumableArray2.default)(routes), [previousFocusedRoute]);
            }
          } else {}
        } else if (replacingRouteKeys.length || closingRouteKeys.length) {
          var _routes2;

          routes = routes.slice();

          (_routes2 = routes).splice.apply(_routes2, [routes.length - 1, 0].concat((0, _toConsumableArray2.default)(state.routes.filter(function (_ref10) {
            var key = _ref10.key;
            return isAnimationEnabled(key) ? replacingRouteKeys.includes(key) || closingRouteKeys.includes(key) : false;
          }))));
        }

        if (!routes.length) {
          throw new Error('There should always be at least one route in the navigation state.');
        }

        var descriptors = routes.reduce(function (acc, route) {
          acc[route.key] = props.descriptors[route.key] || state.descriptors[route.key];
          return acc;
        }, {});
        return {
          routes: routes,
          previousRoutes: props.state.routes,
          previousDescriptors: props.descriptors,
          openingRouteKeys: openingRouteKeys,
          closingRouteKeys: closingRouteKeys,
          replacingRouteKeys: replacingRouteKeys,
          descriptors: descriptors
        };
      }
    }]);
    return StackView;
  }(React.Component);

  exports.default = StackView;

  var styles = _reactNative.StyleSheet.create({
    container: {
      flex: 1
    }
  });
},"node_modules/@react-navigation/stack/src/views/Stack/StackView.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@react-navigation/stack/src/utils/ModalPresentationContext.tsx","node_modules/@react-navigation/stack/src/views/Header/HeaderContainer.tsx","node_modules/@react-navigation/stack/src/views/Stack/CardStack.tsx","node_modules/@react-navigation/stack/src/views/GestureHandler.ios.tsx","node_modules/@react-navigation/native/src/index.tsx","node_modules/@react-navigation/elements/src/index.tsx","node_modules/react-native-safe-area-context/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var ModalPresentationContext = React.createContext(false);
  var _default = ModalPresentationContext;
  exports.default = _default;
},"node_modules/@react-navigation/stack/src/utils/ModalPresentationContext.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = HeaderContainer;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[1]);

  var _Header = _$$_REQUIRE(_dependencyMap[2])(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function HeaderContainer(_ref) {
    var mode = _ref.mode,
        scenes = _ref.scenes,
        layout = _ref.layout,
        getPreviousScene = _ref.getPreviousScene,
        getFocusedRoute = _ref.getFocusedRoute,
        onContentHeightChange = _ref.onContentHeightChange,
        style = _ref.style;
    var focusedRoute = getFocusedRoute();
    var parentHeaderBack = React.useContext(_$$_REQUIRE(_dependencyMap[4]).HeaderBackContext);
    return React.createElement(_reactNative.Animated.View, {
      pointerEvents: "box-none",
      style: style
    }, scenes.slice(-3).map(function (scene, i, self) {
      var _self, _self2;

      if (mode === 'screen' && i !== self.length - 1 || !scene) {
        return null;
      }

      var _scene$descriptor$opt = scene.descriptor.options,
          header = _scene$descriptor$opt.header,
          headerMode = _scene$descriptor$opt.headerMode,
          _scene$descriptor$opt2 = _scene$descriptor$opt.headerShown,
          headerShown = _scene$descriptor$opt2 === undefined ? true : _scene$descriptor$opt2,
          headerTransparent = _scene$descriptor$opt.headerTransparent,
          headerStyleInterpolator = _scene$descriptor$opt.headerStyleInterpolator;

      if (headerMode !== mode || !headerShown) {
        return null;
      }

      var isFocused = focusedRoute.key === scene.descriptor.route.key;
      var previousScene = getPreviousScene({
        route: scene.descriptor.route
      });
      var headerBack = parentHeaderBack;

      if (previousScene) {
        var _previousScene$descri = previousScene.descriptor,
            options = _previousScene$descri.options,
            route = _previousScene$descri.route;
        headerBack = previousScene ? {
          title: (0, _$$_REQUIRE(_dependencyMap[4]).getHeaderTitle)(options, route.name)
        } : parentHeaderBack;
      }

      var previousDescriptor = (_self = self[i - 1]) == null ? undefined : _self.descriptor;
      var nextDescriptor = (_self2 = self[i + 1]) == null ? undefined : _self2.descriptor;

      var _ref2 = (previousDescriptor == null ? undefined : previousDescriptor.options) || {},
          _ref2$headerShown = _ref2.headerShown,
          previousHeaderShown = _ref2$headerShown === undefined ? true : _ref2$headerShown,
          previousHeaderMode = _ref2.headerMode;

      var nextHeaderlessScene = self.slice(i + 1).find(function (scene) {
        var _ref3 = (scene == null ? undefined : scene.descriptor.options) || {},
            _ref3$headerShown = _ref3.headerShown,
            currentHeaderShown = _ref3$headerShown === undefined ? true : _ref3$headerShown,
            currentHeaderMode = _ref3.headerMode;

        return currentHeaderShown === false || currentHeaderMode === 'screen';
      });

      var _ref4 = (nextHeaderlessScene == null ? undefined : nextHeaderlessScene.descriptor.options) || {},
          nextHeaderlessGestureDirection = _ref4.gestureDirection;

      var isHeaderStatic = (previousHeaderShown === false || previousHeaderMode === 'screen') && !nextDescriptor || nextHeaderlessScene;
      var props = {
        layout: layout,
        back: headerBack,
        progress: scene.progress,
        options: scene.descriptor.options,
        route: scene.descriptor.route,
        navigation: scene.descriptor.navigation,
        styleInterpolator: mode === 'float' ? isHeaderStatic ? nextHeaderlessGestureDirection === 'vertical' || nextHeaderlessGestureDirection === 'vertical-inverted' ? _$$_REQUIRE(_dependencyMap[5]).forSlideUp : nextHeaderlessGestureDirection === 'horizontal-inverted' ? _$$_REQUIRE(_dependencyMap[5]).forSlideRight : _$$_REQUIRE(_dependencyMap[5]).forSlideLeft : headerStyleInterpolator : _$$_REQUIRE(_dependencyMap[5]).forNoAnimation
      };
      return React.createElement(_$$_REQUIRE(_dependencyMap[6]).NavigationContext.Provider, {
        key: scene.descriptor.route.key,
        value: scene.descriptor.navigation
      }, React.createElement(_$$_REQUIRE(_dependencyMap[6]).NavigationRouteContext.Provider, {
        value: scene.descriptor.route
      }, React.createElement(_reactNative.View, {
        onLayout: onContentHeightChange ? function (e) {
          var height = e.nativeEvent.layout.height;
          onContentHeightChange({
            route: scene.descriptor.route,
            height: height
          });
        } : undefined,
        pointerEvents: isFocused ? 'box-none' : 'none',
        accessibilityElementsHidden: !isFocused,
        importantForAccessibility: isFocused ? 'auto' : 'no-hide-descendants',
        style: mode === 'float' && !isFocused || headerTransparent ? styles.header : null
      }, header !== undefined ? header(props) : React.createElement(_Header.default, props))));
    }));
  }

  var styles = _reactNative.StyleSheet.create({
    header: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0
    }
  });
},"node_modules/@react-navigation/stack/src/views/Header/HeaderContainer.tsx",["node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/stack/src/views/Header/Header.tsx","node_modules/@react-navigation/elements/src/index.tsx","node_modules/@react-navigation/stack/src/TransitionConfigs/HeaderStyleInterpolators.tsx","node_modules/@react-navigation/native/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _debounce = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _ModalPresentationContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _HeaderSegment = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = React.memo(function Header(_ref) {
    var back = _ref.back,
        layout = _ref.layout,
        progress = _ref.progress,
        options = _ref.options,
        route = _ref.route,
        navigation = _ref.navigation,
        styleInterpolator = _ref.styleInterpolator;
    var insets = (0, _$$_REQUIRE(_dependencyMap[6]).useSafeAreaInsets)();
    var previousTitle;

    if (options.headerBackTitle !== undefined) {
      previousTitle = options.headerBackTitle;
    } else if (back) {
      previousTitle = back.title;
    }

    var goBack = React.useCallback((0, _debounce.default)(function () {
      if (navigation.isFocused() && navigation.canGoBack()) {
        navigation.dispatch((0, _extends2.default)({}, _$$_REQUIRE(_dependencyMap[7]).StackActions.pop(), {
          source: route.key
        }));
      }
    }, 50), [navigation, route.key]);
    var isModal = React.useContext(_ModalPresentationContext.default);
    var isParentHeaderShown = React.useContext(_$$_REQUIRE(_dependencyMap[8]).HeaderShownContext);
    var statusBarHeight = options.headerStatusBarHeight !== undefined ? options.headerStatusBarHeight : isModal || isParentHeaderShown ? 0 : insets.top;
    return React.createElement(_HeaderSegment.default, (0, _extends2.default)({}, options, {
      title: (0, _$$_REQUIRE(_dependencyMap[8]).getHeaderTitle)(options, route.name),
      progress: progress,
      layout: layout,
      modal: isModal,
      headerBackTitle: options.headerBackTitle !== undefined ? options.headerBackTitle : previousTitle,
      headerStatusBarHeight: statusBarHeight,
      onGoBack: back ? goBack : undefined,
      styleInterpolator: styleInterpolator
    }));
  });

  exports.default = _default;
},"node_modules/@react-navigation/stack/src/views/Header/Header.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/@react-navigation/stack/src/utils/debounce.tsx","node_modules/@react-navigation/stack/src/utils/ModalPresentationContext.tsx","node_modules/@react-navigation/stack/src/views/Header/HeaderSegment.tsx","node_modules/react-native-safe-area-context/src/index.tsx","node_modules/@react-navigation/native/src/index.tsx","node_modules/@react-navigation/elements/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = debounce;

  function debounce(func, duration) {
    var timeout;
    return function () {
      if (!timeout) {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        func.apply(this, args);
        timeout = setTimeout(function () {
          timeout = undefined;
        }, duration);
      }
    };
  }
},"node_modules/@react-navigation/stack/src/utils/debounce.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = HeaderSegment;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[5]);

  var _memoize = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _excluded = ["progress", "layout", "modal", "onGoBack", "headerTitle", "headerLeft", "headerRight", "headerBackImage", "headerBackTitle", "headerBackTitleVisible", "headerTruncatedBackTitle", "headerBackAccessibilityLabel", "headerBackTestID", "headerBackAllowFontScaling", "headerBackTitleStyle", "headerTitleContainerStyle", "headerLeftContainerStyle", "headerRightContainerStyle", "headerBackgroundContainerStyle", "headerStyle", "headerStatusBarHeight", "styleInterpolator"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function HeaderSegment(props) {
    var _React$useState = React.useState(undefined),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
        leftLabelLayout = _React$useState2[0],
        setLeftLabelLayout = _React$useState2[1];

    var _React$useState3 = React.useState(undefined),
        _React$useState4 = (0, _slicedToArray2.default)(_React$useState3, 2),
        titleLayout = _React$useState4[0],
        setTitleLayout = _React$useState4[1];

    var handleTitleLayout = function handleTitleLayout(e) {
      var _e$nativeEvent$layout = e.nativeEvent.layout,
          height = _e$nativeEvent$layout.height,
          width = _e$nativeEvent$layout.width;
      setTitleLayout(function (titleLayout) {
        if (titleLayout && height === titleLayout.height && width === titleLayout.width) {
          return titleLayout;
        }

        return {
          height: height,
          width: width
        };
      });
    };

    var handleLeftLabelLayout = function handleLeftLabelLayout(e) {
      var _e$nativeEvent$layout2 = e.nativeEvent.layout,
          height = _e$nativeEvent$layout2.height,
          width = _e$nativeEvent$layout2.width;

      if (leftLabelLayout && height === leftLabelLayout.height && width === leftLabelLayout.width) {
        return;
      }

      setLeftLabelLayout({
        height: height,
        width: width
      });
    };

    var getInterpolatedStyle = (0, _memoize.default)(function (styleInterpolator, layout, current, next, titleLayout, leftLabelLayout, headerHeight) {
      return styleInterpolator({
        current: {
          progress: current
        },
        next: next && {
          progress: next
        },
        layouts: {
          header: {
            height: headerHeight,
            width: layout.width
          },
          screen: layout,
          title: titleLayout,
          leftLabel: leftLabelLayout
        }
      });
    });
    var progress = props.progress,
        layout = props.layout,
        modal = props.modal,
        onGoBack = props.onGoBack,
        title = props.headerTitle,
        _props$headerLeft = props.headerLeft,
        left = _props$headerLeft === undefined ? onGoBack ? function (props) {
      return React.createElement(_$$_REQUIRE(_dependencyMap[7]).HeaderBackButton, props);
    } : undefined : _props$headerLeft,
        right = props.headerRight,
        headerBackImage = props.headerBackImage,
        headerBackTitle = props.headerBackTitle,
        _props$headerBackTitl = props.headerBackTitleVisible,
        headerBackTitleVisible = _props$headerBackTitl === undefined ? _reactNative.Platform.OS === 'ios' : _props$headerBackTitl,
        headerTruncatedBackTitle = props.headerTruncatedBackTitle,
        headerBackAccessibilityLabel = props.headerBackAccessibilityLabel,
        headerBackTestID = props.headerBackTestID,
        headerBackAllowFontScaling = props.headerBackAllowFontScaling,
        headerBackTitleStyle = props.headerBackTitleStyle,
        headerTitleContainerStyle = props.headerTitleContainerStyle,
        headerLeftContainerStyle = props.headerLeftContainerStyle,
        headerRightContainerStyle = props.headerRightContainerStyle,
        headerBackgroundContainerStyle = props.headerBackgroundContainerStyle,
        customHeaderStyle = props.headerStyle,
        headerStatusBarHeight = props.headerStatusBarHeight,
        styleInterpolator = props.styleInterpolator,
        rest = (0, _objectWithoutProperties2.default)(props, _excluded);
    var defaultHeight = (0, _$$_REQUIRE(_dependencyMap[7]).getDefaultHeaderHeight)(layout, modal, headerStatusBarHeight);

    var _ref = _reactNative.StyleSheet.flatten(customHeaderStyle || {}),
        _ref$height = _ref.height,
        height = _ref$height === undefined ? defaultHeight : _ref$height;

    var _getInterpolatedStyle = getInterpolatedStyle(styleInterpolator, layout, progress.current, progress.next, titleLayout, headerBackTitle ? leftLabelLayout : undefined, typeof height === 'number' ? height : defaultHeight),
        titleStyle = _getInterpolatedStyle.titleStyle,
        leftButtonStyle = _getInterpolatedStyle.leftButtonStyle,
        leftLabelStyle = _getInterpolatedStyle.leftLabelStyle,
        rightButtonStyle = _getInterpolatedStyle.rightButtonStyle,
        backgroundStyle = _getInterpolatedStyle.backgroundStyle;

    var headerLeft = left ? function (props) {
      return left((0, _extends2.default)({}, props, {
        backImage: headerBackImage,
        accessibilityLabel: headerBackAccessibilityLabel,
        testID: headerBackTestID,
        allowFontScaling: headerBackAllowFontScaling,
        onPress: onGoBack,
        label: headerBackTitle,
        truncatedLabel: headerTruncatedBackTitle,
        labelStyle: [leftLabelStyle, headerBackTitleStyle],
        onLabelLayout: handleLeftLabelLayout,
        screenLayout: layout,
        titleLayout: titleLayout,
        canGoBack: Boolean(onGoBack)
      }));
    } : undefined;
    var headerRight = right ? function (props) {
      return right((0, _extends2.default)({}, props, {
        canGoBack: Boolean(onGoBack)
      }));
    } : undefined;
    var headerTitle = typeof title !== 'function' ? function (props) {
      return React.createElement(_$$_REQUIRE(_dependencyMap[7]).HeaderTitle, (0, _extends2.default)({}, props, {
        onLayout: handleTitleLayout
      }));
    } : function (props) {
      return title((0, _extends2.default)({}, props, {
        onLayout: handleTitleLayout
      }));
    };
    return React.createElement(_$$_REQUIRE(_dependencyMap[7]).Header, (0, _extends2.default)({
      modal: modal,
      layout: layout,
      headerTitle: headerTitle,
      headerLeft: headerLeft,
      headerLeftLabelVisible: headerBackTitleVisible,
      headerRight: headerRight,
      headerTitleContainerStyle: [titleStyle, headerTitleContainerStyle],
      headerLeftContainerStyle: [leftButtonStyle, headerLeftContainerStyle],
      headerRightContainerStyle: [rightButtonStyle, headerRightContainerStyle],
      headerBackgroundContainerStyle: [backgroundStyle, headerBackgroundContainerStyle],
      headerStyle: customHeaderStyle,
      headerStatusBarHeight: headerStatusBarHeight
    }, rest));
  }
},"node_modules/@react-navigation/stack/src/views/Header/HeaderSegment.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@react-navigation/stack/src/utils/memoize.tsx","node_modules/@react-navigation/elements/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = memoize;

  function memoize(callback) {
    var previous;
    var result;
    return function () {
      var hasChanged = false;

      for (var _len = arguments.length, dependencies = new Array(_len), _key = 0; _key < _len; _key++) {
        dependencies[_key] = arguments[_key];
      }

      if (previous) {
        if (previous.length !== dependencies.length) {
          hasChanged = true;
        } else {
          for (var i = 0; i < previous.length; i++) {
            if (previous[i] !== dependencies[i]) {
              hasChanged = true;
              break;
            }
          }
        }
      } else {
        hasChanged = true;
      }

      previous = dependencies;

      if (hasChanged || result === undefined) {
        result = callback.apply(undefined, dependencies);
      }

      return result;
    };
  }
},"node_modules/@react-navigation/stack/src/utils/memoize.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    Assets: true,
    Background: true,
    getDefaultHeaderHeight: true,
    getHeaderTitle: true,
    Header: true,
    HeaderBackButton: true,
    HeaderBackContext: true,
    HeaderBackground: true,
    HeaderHeightContext: true,
    HeaderShownContext: true,
    HeaderTitle: true,
    useHeaderHeight: true,
    MissingIcon: true,
    PlatformPressable: true,
    ResourceSavingView: true,
    SafeAreaProviderCompat: true,
    Screen: true
  };
  exports.Assets = undefined;
  Object.defineProperty(exports, "Background", {
    enumerable: true,
    get: function get() {
      return _Background.default;
    }
  });
  Object.defineProperty(exports, "Header", {
    enumerable: true,
    get: function get() {
      return _Header.default;
    }
  });
  Object.defineProperty(exports, "HeaderBackButton", {
    enumerable: true,
    get: function get() {
      return _HeaderBackButton.default;
    }
  });
  Object.defineProperty(exports, "HeaderBackContext", {
    enumerable: true,
    get: function get() {
      return _HeaderBackContext.default;
    }
  });
  Object.defineProperty(exports, "HeaderBackground", {
    enumerable: true,
    get: function get() {
      return _HeaderBackground.default;
    }
  });
  Object.defineProperty(exports, "HeaderHeightContext", {
    enumerable: true,
    get: function get() {
      return _HeaderHeightContext.default;
    }
  });
  Object.defineProperty(exports, "HeaderShownContext", {
    enumerable: true,
    get: function get() {
      return _HeaderShownContext.default;
    }
  });
  Object.defineProperty(exports, "HeaderTitle", {
    enumerable: true,
    get: function get() {
      return _HeaderTitle.default;
    }
  });
  Object.defineProperty(exports, "MissingIcon", {
    enumerable: true,
    get: function get() {
      return _MissingIcon.default;
    }
  });
  Object.defineProperty(exports, "PlatformPressable", {
    enumerable: true,
    get: function get() {
      return _PlatformPressable.default;
    }
  });
  Object.defineProperty(exports, "ResourceSavingView", {
    enumerable: true,
    get: function get() {
      return _ResourceSavingView.default;
    }
  });
  Object.defineProperty(exports, "SafeAreaProviderCompat", {
    enumerable: true,
    get: function get() {
      return _SafeAreaProviderCompat.default;
    }
  });
  Object.defineProperty(exports, "Screen", {
    enumerable: true,
    get: function get() {
      return _Screen.default;
    }
  });
  Object.defineProperty(exports, "getDefaultHeaderHeight", {
    enumerable: true,
    get: function get() {
      return _getDefaultHeaderHeight.default;
    }
  });
  Object.defineProperty(exports, "getHeaderTitle", {
    enumerable: true,
    get: function get() {
      return _getHeaderTitle.default;
    }
  });
  Object.defineProperty(exports, "useHeaderHeight", {
    enumerable: true,
    get: function get() {
      return _useHeaderHeight.default;
    }
  });

  var _Background = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _getDefaultHeaderHeight = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _getHeaderTitle = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _Header = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _HeaderBackButton = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _HeaderBackContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _HeaderBackground = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _HeaderHeightContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _HeaderShownContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _HeaderTitle = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _useHeaderHeight = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _MissingIcon = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var _PlatformPressable = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[13]));

  var _ResourceSavingView = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[14]));

  var _SafeAreaProviderCompat = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[15]));

  var _Screen = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[16]));

  Object.keys(_$$_REQUIRE(_dependencyMap[17])).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[17])[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[17])[key];
      }
    });
  });
  var Assets = [_$$_REQUIRE(_dependencyMap[18]), _$$_REQUIRE(_dependencyMap[19])];
  exports.Assets = Assets;
},"node_modules/@react-navigation/elements/src/index.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/elements/src/Background.tsx","node_modules/@react-navigation/elements/src/Header/getDefaultHeaderHeight.tsx","node_modules/@react-navigation/elements/src/Header/getHeaderTitle.tsx","node_modules/@react-navigation/elements/src/Header/Header.tsx","node_modules/@react-navigation/elements/src/Header/HeaderBackButton.tsx","node_modules/@react-navigation/elements/src/Header/HeaderBackContext.tsx","node_modules/@react-navigation/elements/src/Header/HeaderBackground.tsx","node_modules/@react-navigation/elements/src/Header/HeaderHeightContext.tsx","node_modules/@react-navigation/elements/src/Header/HeaderShownContext.tsx","node_modules/@react-navigation/elements/src/Header/HeaderTitle.tsx","node_modules/@react-navigation/elements/src/Header/useHeaderHeight.tsx","node_modules/@react-navigation/elements/src/MissingIcon.tsx","node_modules/@react-navigation/elements/src/PlatformPressable.tsx","node_modules/@react-navigation/elements/src/ResourceSavingView.tsx","node_modules/@react-navigation/elements/src/SafeAreaProviderCompat.tsx","node_modules/@react-navigation/elements/src/Screen.tsx","node_modules/@react-navigation/elements/src/types.tsx","node_modules/@react-navigation/elements/src/assets/back-icon.png","node_modules/@react-navigation/elements/src/assets/back-icon-mask.png"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = Background;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[4]);

  var _excluded = ["style"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function Background(_ref) {
    var style = _ref.style,
        rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);

    var _useTheme = (0, _$$_REQUIRE(_dependencyMap[5]).useTheme)(),
        colors = _useTheme.colors;

    return React.createElement(_reactNative.View, (0, _extends2.default)({}, rest, {
      style: [{
        flex: 1,
        backgroundColor: colors.background
      }, style]
    }));
  }
},"node_modules/@react-navigation/elements/src/Background.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@react-navigation/native/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getDefaultHeaderHeight;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0]);

  function getDefaultHeaderHeight(layout, modalPresentation, statusBarHeight) {
    var headerHeight;
    var isLandscape = layout.width > layout.height;

    if (_reactNative.Platform.OS === 'ios') {
      if (_reactNative.Platform.isPad || _reactNative.Platform.isTVOS) {
        if (modalPresentation) {
          headerHeight = 56;
        } else {
          headerHeight = 50;
        }
      } else {
        if (isLandscape) {
          headerHeight = 32;
        } else {
          if (modalPresentation) {
            headerHeight = 56;
          } else {
            headerHeight = 44;
          }
        }
      }
    } else if (_reactNative.Platform.OS === 'android') {
      headerHeight = 56;
    } else {
      headerHeight = 64;
    }

    return headerHeight + statusBarHeight;
  }
},"node_modules/@react-navigation/elements/src/Header/getDefaultHeaderHeight.tsx",["node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getHeaderTitle;

  function getHeaderTitle(options, fallback) {
    return typeof options.headerTitle === 'string' ? options.headerTitle : options.title !== undefined ? options.title : fallback;
  }
},"node_modules/@react-navigation/elements/src/Header/getHeaderTitle.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = Header;

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[3]);

  var _getDefaultHeaderHeight = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _HeaderBackground = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _HeaderShownContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _HeaderTitle = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _excluded = ["height", "minHeight", "maxHeight", "backgroundColor", "borderBottomColor", "borderBottomEndRadius", "borderBottomLeftRadius", "borderBottomRightRadius", "borderBottomStartRadius", "borderBottomWidth", "borderColor", "borderEndColor", "borderEndWidth", "borderLeftColor", "borderLeftWidth", "borderRadius", "borderRightColor", "borderRightWidth", "borderStartColor", "borderStartWidth", "borderStyle", "borderTopColor", "borderTopEndRadius", "borderTopLeftRadius", "borderTopRightRadius", "borderTopStartRadius", "borderTopWidth", "borderWidth", "boxShadow", "elevation", "shadowColor", "shadowOffset", "shadowOpacity", "shadowRadius", "opacity", "transform"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function Header(props) {
    var insets = (0, _$$_REQUIRE(_dependencyMap[8]).useSafeAreaInsets)();
    var frame = (0, _$$_REQUIRE(_dependencyMap[8]).useSafeAreaFrame)();
    var isParentHeaderShown = React.useContext(_HeaderShownContext.default);
    var _props$layout = props.layout,
        layout = _props$layout === undefined ? frame : _props$layout,
        _props$modal = props.modal,
        modal = _props$modal === undefined ? false : _props$modal,
        title = props.title,
        customTitle = props.headerTitle,
        _props$headerTitleAli = props.headerTitleAlign,
        headerTitleAlign = _props$headerTitleAli === undefined ? _reactNative.Platform.select({
      ios: 'center',
      default: 'left'
    }) : _props$headerTitleAli,
        headerLeft = props.headerLeft,
        headerLeftLabelVisible = props.headerLeftLabelVisible,
        headerTransparent = props.headerTransparent,
        headerTintColor = props.headerTintColor,
        headerBackground = props.headerBackground,
        headerRight = props.headerRight,
        titleAllowFontScaling = props.headerTitleAllowFontScaling,
        titleStyle = props.headerTitleStyle,
        leftContainerStyle = props.headerLeftContainerStyle,
        rightContainerStyle = props.headerRightContainerStyle,
        titleContainerStyle = props.headerTitleContainerStyle,
        backgroundContainerStyle = props.headerBackgroundContainerStyle,
        customHeaderStyle = props.headerStyle,
        headerShadowVisible = props.headerShadowVisible,
        headerPressColor = props.headerPressColor,
        headerPressOpacity = props.headerPressOpacity,
        _props$headerStatusBa = props.headerStatusBarHeight,
        headerStatusBarHeight = _props$headerStatusBa === undefined ? isParentHeaderShown ? 0 : insets.top : _props$headerStatusBa;
    var defaultHeight = (0, _getDefaultHeaderHeight.default)(layout, modal, headerStatusBarHeight);

    var _ref = _reactNative.StyleSheet.flatten(customHeaderStyle || {}),
        _ref$height = _ref.height,
        height = _ref$height === undefined ? defaultHeight : _ref$height,
        minHeight = _ref.minHeight,
        maxHeight = _ref.maxHeight,
        backgroundColor = _ref.backgroundColor,
        borderBottomColor = _ref.borderBottomColor,
        borderBottomEndRadius = _ref.borderBottomEndRadius,
        borderBottomLeftRadius = _ref.borderBottomLeftRadius,
        borderBottomRightRadius = _ref.borderBottomRightRadius,
        borderBottomStartRadius = _ref.borderBottomStartRadius,
        borderBottomWidth = _ref.borderBottomWidth,
        borderColor = _ref.borderColor,
        borderEndColor = _ref.borderEndColor,
        borderEndWidth = _ref.borderEndWidth,
        borderLeftColor = _ref.borderLeftColor,
        borderLeftWidth = _ref.borderLeftWidth,
        borderRadius = _ref.borderRadius,
        borderRightColor = _ref.borderRightColor,
        borderRightWidth = _ref.borderRightWidth,
        borderStartColor = _ref.borderStartColor,
        borderStartWidth = _ref.borderStartWidth,
        borderStyle = _ref.borderStyle,
        borderTopColor = _ref.borderTopColor,
        borderTopEndRadius = _ref.borderTopEndRadius,
        borderTopLeftRadius = _ref.borderTopLeftRadius,
        borderTopRightRadius = _ref.borderTopRightRadius,
        borderTopStartRadius = _ref.borderTopStartRadius,
        borderTopWidth = _ref.borderTopWidth,
        borderWidth = _ref.borderWidth,
        boxShadow = _ref.boxShadow,
        elevation = _ref.elevation,
        shadowColor = _ref.shadowColor,
        shadowOffset = _ref.shadowOffset,
        shadowOpacity = _ref.shadowOpacity,
        shadowRadius = _ref.shadowRadius,
        opacity = _ref.opacity,
        transform = _ref.transform,
        unsafeStyles = (0, _objectWithoutProperties2.default)(_ref, _excluded);

    var safeStyles = {
      backgroundColor: backgroundColor,
      borderBottomColor: borderBottomColor,
      borderBottomEndRadius: borderBottomEndRadius,
      borderBottomLeftRadius: borderBottomLeftRadius,
      borderBottomRightRadius: borderBottomRightRadius,
      borderBottomStartRadius: borderBottomStartRadius,
      borderBottomWidth: borderBottomWidth,
      borderColor: borderColor,
      borderEndColor: borderEndColor,
      borderEndWidth: borderEndWidth,
      borderLeftColor: borderLeftColor,
      borderLeftWidth: borderLeftWidth,
      borderRadius: borderRadius,
      borderRightColor: borderRightColor,
      borderRightWidth: borderRightWidth,
      borderStartColor: borderStartColor,
      borderStartWidth: borderStartWidth,
      borderStyle: borderStyle,
      borderTopColor: borderTopColor,
      borderTopEndRadius: borderTopEndRadius,
      borderTopLeftRadius: borderTopLeftRadius,
      borderTopRightRadius: borderTopRightRadius,
      borderTopStartRadius: borderTopStartRadius,
      borderTopWidth: borderTopWidth,
      borderWidth: borderWidth,
      boxShadow: boxShadow,
      elevation: elevation,
      shadowColor: shadowColor,
      shadowOffset: shadowOffset,
      shadowOpacity: shadowOpacity,
      shadowRadius: shadowRadius,
      opacity: opacity,
      transform: transform
    };

    for (var styleProp in safeStyles) {
      if (safeStyles[styleProp] === undefined) {
        delete safeStyles[styleProp];
      }
    }

    var backgroundStyle = [safeStyles, headerShadowVisible === false && {
      elevation: 0,
      shadowOpacity: 0,
      borderBottomWidth: 0
    }];
    var leftButton = headerLeft ? headerLeft({
      tintColor: headerTintColor,
      pressColor: headerPressColor,
      pressOpacity: headerPressOpacity,
      labelVisible: headerLeftLabelVisible
    }) : null;
    var rightButton = headerRight ? headerRight({
      tintColor: headerTintColor,
      pressColor: headerPressColor,
      pressOpacity: headerPressOpacity
    }) : null;
    var headerTitle = typeof customTitle !== 'function' ? function (props) {
      return React.createElement(_HeaderTitle.default, props);
    } : customTitle;
    return React.createElement(React.Fragment, null, React.createElement(_reactNative.Animated.View, {
      pointerEvents: "box-none",
      style: [_reactNative.StyleSheet.absoluteFill, {
        zIndex: 0
      }, backgroundContainerStyle]
    }, headerBackground ? headerBackground({
      style: backgroundStyle
    }) : headerTransparent ? null : React.createElement(_HeaderBackground.default, {
      style: backgroundStyle
    })), React.createElement(_reactNative.Animated.View, {
      pointerEvents: "box-none",
      style: [{
        height: height,
        minHeight: minHeight,
        maxHeight: maxHeight,
        opacity: opacity,
        transform: transform
      }]
    }, React.createElement(_reactNative.View, {
      pointerEvents: "none",
      style: {
        height: headerStatusBarHeight
      }
    }), React.createElement(_reactNative.View, {
      pointerEvents: "box-none",
      style: styles.content
    }, React.createElement(_reactNative.Animated.View, {
      pointerEvents: "box-none",
      style: [styles.left, headerTitleAlign === 'center' && styles.expand, {
        marginStart: insets.left
      }, leftContainerStyle]
    }, leftButton), React.createElement(_reactNative.Animated.View, {
      pointerEvents: "box-none",
      style: [styles.title, {
        maxWidth: headerTitleAlign === 'center' ? layout.width - ((leftButton ? headerLeftLabelVisible !== false ? 80 : 32 : 16) + Math.max(insets.left, insets.right)) * 2 : layout.width - ((leftButton ? 72 : 16) + (rightButton ? 72 : 16) + insets.left - insets.right)
      }, titleContainerStyle]
    }, headerTitle({
      children: title,
      allowFontScaling: titleAllowFontScaling,
      tintColor: headerTintColor,
      style: titleStyle
    })), React.createElement(_reactNative.Animated.View, {
      pointerEvents: "box-none",
      style: [styles.right, styles.expand, {
        marginEnd: insets.right
      }, rightContainerStyle]
    }, rightButton))));
  }

  var styles = _reactNative.StyleSheet.create({
    content: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'stretch'
    },
    title: {
      marginHorizontal: 16,
      justifyContent: 'center'
    },
    left: {
      justifyContent: 'center',
      alignItems: 'flex-start'
    },
    right: {
      justifyContent: 'center',
      alignItems: 'flex-end'
    },
    expand: {
      flexGrow: 1,
      flexBasis: 0
    }
  });
},"node_modules/@react-navigation/elements/src/Header/Header.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@react-navigation/elements/src/Header/getDefaultHeaderHeight.tsx","node_modules/@react-navigation/elements/src/Header/HeaderBackground.tsx","node_modules/@react-navigation/elements/src/Header/HeaderShownContext.tsx","node_modules/@react-navigation/elements/src/Header/HeaderTitle.tsx","node_modules/react-native-safe-area-context/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = HeaderBackground;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[4]);

  var _excluded = ["style"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function HeaderBackground(_ref) {
    var style = _ref.style,
        rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);

    var _useTheme = (0, _$$_REQUIRE(_dependencyMap[5]).useTheme)(),
        colors = _useTheme.colors;

    return React.createElement(_reactNative.Animated.View, (0, _extends2.default)({
      style: [styles.container, {
        backgroundColor: colors.card,
        borderBottomColor: colors.border,
        shadowColor: colors.border
      }, style]
    }, rest));
  }

  var styles = _reactNative.StyleSheet.create({
    container: (0, _extends2.default)({
      flex: 1
    }, _reactNative.Platform.select({
      android: {
        elevation: 4
      },
      ios: {
        shadowOpacity: 0.85,
        shadowRadius: 0,
        shadowOffset: {
          width: 0,
          height: _reactNative.StyleSheet.hairlineWidth
        }
      },
      default: {
        borderBottomWidth: _reactNative.StyleSheet.hairlineWidth
      }
    }))
  });
},"node_modules/@react-navigation/elements/src/Header/HeaderBackground.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@react-navigation/native/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _getNamedContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var HeaderShownContext = (0, _getNamedContext.default)('HeaderShownContext', false);
  var _default = HeaderShownContext;
  exports.default = _default;
},"node_modules/@react-navigation/elements/src/Header/HeaderShownContext.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/elements/src/getNamedContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getNamedContext;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _global$contexts;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var contexts = '__react_navigation__elements_contexts';
  global[contexts] = (_global$contexts = global[contexts]) != null ? _global$contexts : new Map();

  function getNamedContext(name, initialValue) {
    var context = global[contexts].get(name);

    if (context) {
      return context;
    }

    context = React.createContext(initialValue);
    context.displayName = name;
    global[contexts].set(name, context);
    return context;
  }
},"node_modules/@react-navigation/elements/src/getNamedContext.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = HeaderTitle;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[4]);

  var _excluded = ["tintColor", "style"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function HeaderTitle(_ref) {
    var tintColor = _ref.tintColor,
        style = _ref.style,
        rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);

    var _useTheme = (0, _$$_REQUIRE(_dependencyMap[5]).useTheme)(),
        colors = _useTheme.colors;

    return React.createElement(_reactNative.Animated.Text, (0, _extends2.default)({
      accessibilityRole: "header",
      "aria-level": "1",
      numberOfLines: 1
    }, rest, {
      style: [styles.title, {
        color: tintColor === undefined ? colors.text : tintColor
      }, style]
    }));
  }

  var styles = _reactNative.StyleSheet.create({
    title: _reactNative.Platform.select({
      ios: {
        fontSize: 17,
        fontWeight: '600'
      },
      android: {
        fontSize: 20,
        fontFamily: 'sans-serif-medium',
        fontWeight: 'normal'
      },
      default: {
        fontSize: 18,
        fontWeight: '500'
      }
    })
  });
},"node_modules/@react-navigation/elements/src/Header/HeaderTitle.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@react-navigation/native/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.keys(_$$_REQUIRE(_dependencyMap[0])).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[0])[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[0])[key];
      }
    });
  });
  Object.keys(_$$_REQUIRE(_dependencyMap[1])).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[1])[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[1])[key];
      }
    });
  });
  Object.keys(_$$_REQUIRE(_dependencyMap[2])).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[2])[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[2])[key];
      }
    });
  });
  Object.keys(_$$_REQUIRE(_dependencyMap[3])).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[3])[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[3])[key];
      }
    });
  });
},"node_modules/react-native-safe-area-context/src/index.tsx",["node_modules/react-native-safe-area-context/src/SafeAreaContext.tsx","node_modules/react-native-safe-area-context/src/SafeAreaView.tsx","node_modules/react-native-safe-area-context/src/InitialWindow.native.ts","node_modules/react-native-safe-area-context/src/SafeArea.types.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SafeAreaInsetsContext = exports.SafeAreaFrameContext = exports.SafeAreaContext = exports.SafeAreaConsumer = undefined;
  exports.SafeAreaProvider = SafeAreaProvider;
  exports.useSafeArea = useSafeArea;
  exports.useSafeAreaFrame = useSafeAreaFrame;
  exports.useSafeAreaInsets = useSafeAreaInsets;
  exports.withSafeAreaInsets = withSafeAreaInsets;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[5]);

  var _excluded = ["children", "initialMetrics", "initialSafeAreaInsets", "style"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var isDev = false;
  var SafeAreaInsetsContext = React.createContext(null);
  exports.SafeAreaInsetsContext = SafeAreaInsetsContext;
  var SafeAreaFrameContext = React.createContext(null);
  exports.SafeAreaFrameContext = SafeAreaFrameContext;

  function SafeAreaProvider(_ref) {
    var _ref2, _ref3, _initialMetrics$inset, _ref4, _initialMetrics$frame;

    var children = _ref.children,
        initialMetrics = _ref.initialMetrics,
        initialSafeAreaInsets = _ref.initialSafeAreaInsets,
        style = _ref.style,
        others = (0, _objectWithoutProperties2.default)(_ref, _excluded);
    var parentInsets = useParentSafeAreaInsets();
    var parentFrame = useParentSafeAreaFrame();

    var _React$useState = React.useState((_ref2 = (_ref3 = (_initialMetrics$inset = initialMetrics == null ? undefined : initialMetrics.insets) != null ? _initialMetrics$inset : initialSafeAreaInsets) != null ? _ref3 : parentInsets) != null ? _ref2 : null),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
        insets = _React$useState2[0],
        setInsets = _React$useState2[1];

    var _React$useState3 = React.useState((_ref4 = (_initialMetrics$frame = initialMetrics == null ? undefined : initialMetrics.frame) != null ? _initialMetrics$frame : parentFrame) != null ? _ref4 : {
      x: 0,
      y: 0,
      width: _reactNative.Dimensions.get('window').width,
      height: _reactNative.Dimensions.get('window').height
    }),
        _React$useState4 = (0, _slicedToArray2.default)(_React$useState3, 2),
        frame = _React$useState4[0],
        setFrame = _React$useState4[1];

    var onInsetsChange = React.useCallback(function (event) {
      var _event$nativeEvent = event.nativeEvent,
          nextFrame = _event$nativeEvent.frame,
          nextInsets = _event$nativeEvent.insets;

      if (nextFrame && (nextFrame.height !== frame.height || nextFrame.width !== frame.width || nextFrame.x !== frame.x || nextFrame.y !== frame.y)) {
        setFrame(nextFrame);
      }

      if (!insets || nextInsets.bottom !== insets.bottom || nextInsets.left !== insets.left || nextInsets.right !== insets.right || nextInsets.top !== insets.top) {
        setInsets(nextInsets);
      }
    }, [frame, insets]);
    return React.createElement(_$$_REQUIRE(_dependencyMap[6]).NativeSafeAreaProvider, (0, _extends2.default)({
      style: [styles.fill, style],
      onInsetsChange: onInsetsChange
    }, others), insets != null ? React.createElement(SafeAreaFrameContext.Provider, {
      value: frame
    }, React.createElement(SafeAreaInsetsContext.Provider, {
      value: insets
    }, children)) : null);
  }

  var styles = _reactNative.StyleSheet.create({
    fill: {
      flex: 1
    }
  });

  function useParentSafeAreaInsets() {
    return React.useContext(SafeAreaInsetsContext);
  }

  function useParentSafeAreaFrame() {
    return React.useContext(SafeAreaFrameContext);
  }

  var NO_INSETS_ERROR = 'No safe area value available. Make sure you are rendering `<SafeAreaProvider>` at the top of your app.';

  function useSafeAreaInsets() {
    var safeArea = React.useContext(SafeAreaInsetsContext);

    if (safeArea == null) {
      throw new Error(NO_INSETS_ERROR);
    }

    return safeArea;
  }

  function useSafeAreaFrame() {
    var frame = React.useContext(SafeAreaFrameContext);

    if (frame == null) {
      throw new Error(NO_INSETS_ERROR);
    }

    return frame;
  }

  function withSafeAreaInsets(WrappedComponent) {
    return React.forwardRef(function (props, ref) {
      return React.createElement(SafeAreaInsetsContext.Consumer, null, function (insets) {
        if (insets == null) {
          throw new Error(NO_INSETS_ERROR);
        }

        return React.createElement(WrappedComponent, (0, _extends2.default)({}, props, {
          insets: insets,
          ref: ref
        }));
      });
    });
  }

  function useSafeArea() {
    return useSafeAreaInsets();
  }

  var SafeAreaConsumer = SafeAreaInsetsContext.Consumer;
  exports.SafeAreaConsumer = SafeAreaConsumer;
  var SafeAreaContext = SafeAreaInsetsContext;
  exports.SafeAreaContext = SafeAreaContext;
},"node_modules/react-native-safe-area-context/src/SafeAreaContext.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/react-native-safe-area-context/src/NativeSafeAreaProvider.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NativeSafeAreaProvider", {
    enumerable: true,
    get: function get() {
      return _NativeSafeAreaProvider.default;
    }
  });

  var _NativeSafeAreaProvider = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));
},"node_modules/react-native-safe-area-context/src/NativeSafeAreaProvider.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native-safe-area-context/src/specs/NativeSafeAreaProvider.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _default = (0, _codegenNativeComponent.default)('RNCSafeAreaProvider');

  exports.default = _default;
},"node_modules/react-native-safe-area-context/src/specs/NativeSafeAreaProvider.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SafeAreaView = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _NativeSafeAreaView = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _excluded = ["edges"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var SafeAreaView = React.forwardRef(function (_ref, ref) {
    var edges = _ref.edges,
        props = (0, _objectWithoutProperties2.default)(_ref, _excluded);
    return React.createElement(_NativeSafeAreaView.default, (0, _extends2.default)({}, props, {
      edges: edges != null ? edges : ['bottom', 'left', 'right', 'top'],
      ref: ref
    }));
  });
  exports.SafeAreaView = SafeAreaView;
},"node_modules/react-native-safe-area-context/src/SafeAreaView.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/react-native-safe-area-context/src/specs/NativeSafeAreaView.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _default = (0, _codegenNativeComponent.default)('RNCSafeAreaView', {
    interfaceOnly: true
  });

  exports.default = _default;
},"node_modules/react-native-safe-area-context/src/specs/NativeSafeAreaView.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.initialWindowSafeAreaInsets = exports.initialWindowMetrics = undefined;

  var _NativeSafeAreaContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _NativeSafeAreaContex, _NativeSafeAreaContex2;

  var initialWindowMetrics = (_NativeSafeAreaContex = _NativeSafeAreaContext.default == null ? undefined : (_NativeSafeAreaContex2 = _NativeSafeAreaContext.default.getConstants()) == null ? undefined : _NativeSafeAreaContex2.initialWindowMetrics) != null ? _NativeSafeAreaContex : null;
  exports.initialWindowMetrics = initialWindowMetrics;
  var initialWindowSafeAreaInsets = initialWindowMetrics == null ? undefined : initialWindowMetrics.insets;
  exports.initialWindowSafeAreaInsets = initialWindowSafeAreaInsets;
},"node_modules/react-native-safe-area-context/src/InitialWindow.native.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native-safe-area-context/src/specs/NativeSafeAreaContext.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var TurboModuleRegistry = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = TurboModuleRegistry.get('RNCSafeAreaContext');

  exports.default = _default;
},"node_modules/react-native-safe-area-context/src/specs/NativeSafeAreaContext.js",["node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},"node_modules/react-native-safe-area-context/src/SafeArea.types.ts",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = HeaderBackButton;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[4]);

  var _MaskedView = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _PlatformPressable = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function HeaderBackButton(_ref) {
    var disabled = _ref.disabled,
        allowFontScaling = _ref.allowFontScaling,
        backImage = _ref.backImage,
        label = _ref.label,
        labelStyle = _ref.labelStyle,
        labelVisible = _ref.labelVisible,
        onLabelLayout = _ref.onLabelLayout,
        onPress = _ref.onPress,
        pressColor = _ref.pressColor,
        pressOpacity = _ref.pressOpacity,
        screenLayout = _ref.screenLayout,
        customTintColor = _ref.tintColor,
        titleLayout = _ref.titleLayout,
        _ref$truncatedLabel = _ref.truncatedLabel,
        truncatedLabel = _ref$truncatedLabel === undefined ? 'Back' : _ref$truncatedLabel,
        _ref$accessibilityLab = _ref.accessibilityLabel,
        accessibilityLabel = _ref$accessibilityLab === undefined ? label && label !== 'Back' ? label + ", back" : 'Go back' : _ref$accessibilityLab,
        testID = _ref.testID,
        style = _ref.style;

    var _useTheme = (0, _$$_REQUIRE(_dependencyMap[7]).useTheme)(),
        colors = _useTheme.colors;

    var _React$useState = React.useState(undefined),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
        initialLabelWidth = _React$useState2[0],
        setInitialLabelWidth = _React$useState2[1];

    var tintColor = customTintColor !== undefined ? customTintColor : _reactNative.Platform.select({
      ios: colors.primary,
      default: colors.text
    });

    var handleLabelLayout = function handleLabelLayout(e) {
      onLabelLayout == null ? undefined : onLabelLayout(e);
      setInitialLabelWidth(e.nativeEvent.layout.x + e.nativeEvent.layout.width);
    };

    var shouldTruncateLabel = function shouldTruncateLabel() {
      return !label || initialLabelWidth && titleLayout && screenLayout && (screenLayout.width - titleLayout.width) / 2 < initialLabelWidth + 26;
    };

    var renderBackImage = function renderBackImage() {
      if (backImage) {
        return backImage({
          tintColor: tintColor
        });
      } else {
        return React.createElement(_reactNative.Image, {
          style: [styles.icon, Boolean(labelVisible) && styles.iconWithLabel, Boolean(tintColor) && {
            tintColor: tintColor
          }],
          source: _$$_REQUIRE(_dependencyMap[8]),
          fadeDuration: 0
        });
      }
    };

    var renderLabel = function renderLabel() {
      var leftLabelText = shouldTruncateLabel() ? truncatedLabel : label;

      if (!labelVisible || leftLabelText === undefined) {
        return null;
      }

      var labelElement = React.createElement(_reactNative.View, {
        style: screenLayout ? [styles.labelWrapper, {
          minWidth: screenLayout.width / 2 - 27
        }] : null
      }, React.createElement(_reactNative.Animated.Text, {
        accessible: false,
        onLayout: leftLabelText === label ? handleLabelLayout : undefined,
        style: [styles.label, tintColor ? {
          color: tintColor
        } : null, labelStyle],
        numberOfLines: 1,
        allowFontScaling: !!allowFontScaling
      }, leftLabelText));

      if (backImage || _reactNative.Platform.OS !== 'ios') {
        return labelElement;
      }

      return React.createElement(_MaskedView.default, {
        maskElement: React.createElement(_reactNative.View, {
          style: styles.iconMaskContainer
        }, React.createElement(_reactNative.Image, {
          source: _$$_REQUIRE(_dependencyMap[9]),
          style: styles.iconMask
        }), React.createElement(_reactNative.View, {
          style: styles.iconMaskFillerRect
        }))
      }, labelElement);
    };

    var handlePress = function handlePress() {
      return onPress && requestAnimationFrame(onPress);
    };

    return React.createElement(_PlatformPressable.default, {
      disabled: disabled,
      accessible: true,
      accessibilityRole: "button",
      accessibilityLabel: accessibilityLabel,
      testID: testID,
      onPress: disabled ? undefined : handlePress,
      pressColor: pressColor,
      pressOpacity: pressOpacity,
      android_ripple: {
        borderless: true
      },
      style: [styles.container, disabled && styles.disabled, style],
      hitSlop: _reactNative.Platform.select({
        ios: undefined,
        default: {
          top: 16,
          right: 16,
          bottom: 16,
          left: 16
        }
      })
    }, React.createElement(React.Fragment, null, renderBackImage(), renderLabel()));
  }

  var styles = _reactNative.StyleSheet.create({
    container: (0, _extends2.default)({
      alignItems: 'center',
      flexDirection: 'row',
      minWidth: _reactNative.StyleSheet.hairlineWidth
    }, _reactNative.Platform.select({
      ios: null,
      default: {
        marginVertical: 3,
        marginHorizontal: 11
      }
    })),
    disabled: {
      opacity: 0.5
    },
    label: {
      fontSize: 17,
      letterSpacing: 0.35
    },
    labelWrapper: {
      flexDirection: 'row',
      alignItems: 'flex-start'
    },
    icon: _reactNative.Platform.select({
      ios: {
        height: 21,
        width: 13,
        marginLeft: 8,
        marginRight: 22,
        marginVertical: 12,
        resizeMode: 'contain',
        transform: [{
          scaleX: _reactNative.I18nManager.isRTL ? -1 : 1
        }]
      },
      default: {
        height: 24,
        width: 24,
        margin: 3,
        resizeMode: 'contain',
        transform: [{
          scaleX: _reactNative.I18nManager.isRTL ? -1 : 1
        }]
      }
    }),
    iconWithLabel: _reactNative.Platform.OS === 'ios' ? {
      marginRight: 6
    } : {},
    iconMaskContainer: {
      flex: 1,
      flexDirection: 'row',
      justifyContent: 'center'
    },
    iconMaskFillerRect: {
      flex: 1,
      backgroundColor: '#000'
    },
    iconMask: {
      height: 21,
      width: 13,
      marginLeft: -14.5,
      marginVertical: 12,
      alignSelf: 'center',
      resizeMode: 'contain',
      transform: [{
        scaleX: _reactNative.I18nManager.isRTL ? -1 : 1
      }]
    }
  });
},"node_modules/@react-navigation/elements/src/Header/HeaderBackButton.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@react-navigation/elements/src/MaskedView.ios.tsx","node_modules/@react-navigation/elements/src/PlatformPressable.tsx","node_modules/@react-navigation/native/src/index.tsx","node_modules/@react-navigation/elements/src/assets/back-icon.png","node_modules/@react-navigation/elements/src/assets/back-icon-mask.png"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get() {
      return _MaskedViewNative.default;
    }
  });

  var _MaskedViewNative = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));
},"node_modules/@react-navigation/elements/src/MaskedView.ios.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/elements/src/MaskedViewNative.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = MaskedView;

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[3]);

  var _excluded = ["children"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var RNCMaskedView;

  try {
    RNCMaskedView = _$$_REQUIRE(_dependencyMap[4]).default;
  } catch (e) {}

  var isMaskedViewAvailable = _reactNative.UIManager.getViewManagerConfig('RNCMaskedView') != null;

  function MaskedView(_ref) {
    var children = _ref.children,
        rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);

    if (isMaskedViewAvailable && RNCMaskedView) {
      return React.createElement(RNCMaskedView, rest, children);
    }

    return children;
  }
},"node_modules/@react-navigation/elements/src/MaskedViewNative.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = PlatformPressable;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[5]);

  var _excluded = ["onPressIn", "onPressOut", "android_ripple", "pressColor", "pressOpacity", "style"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var AnimatedPressable = _reactNative.Animated.createAnimatedComponent(_reactNative.Pressable);

  var ANDROID_VERSION_LOLLIPOP = 21;
  var ANDROID_SUPPORTS_RIPPLE = _reactNative.Platform.OS === 'android' && _reactNative.Platform.Version >= ANDROID_VERSION_LOLLIPOP;

  function PlatformPressable(_ref) {
    var onPressIn = _ref.onPressIn,
        onPressOut = _ref.onPressOut,
        android_ripple = _ref.android_ripple,
        pressColor = _ref.pressColor,
        _ref$pressOpacity = _ref.pressOpacity,
        pressOpacity = _ref$pressOpacity === undefined ? 0.3 : _ref$pressOpacity,
        style = _ref.style,
        rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);

    var _useTheme = (0, _$$_REQUIRE(_dependencyMap[6]).useTheme)(),
        dark = _useTheme.dark;

    var _React$useState = React.useState(function () {
      return new _reactNative.Animated.Value(1);
    }),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 1),
        opacity = _React$useState2[0];

    var animateTo = function animateTo(toValue, duration) {
      if (ANDROID_SUPPORTS_RIPPLE) {
        return;
      }

      _reactNative.Animated.timing(opacity, {
        toValue: toValue,
        duration: duration,
        easing: _reactNative.Easing.inOut(_reactNative.Easing.quad),
        useNativeDriver: true
      }).start();
    };

    var handlePressIn = function handlePressIn(e) {
      animateTo(pressOpacity, 0);
      onPressIn == null ? undefined : onPressIn(e);
    };

    var handlePressOut = function handlePressOut(e) {
      animateTo(1, 200);
      onPressOut == null ? undefined : onPressOut(e);
    };

    return React.createElement(AnimatedPressable, (0, _extends2.default)({
      onPressIn: handlePressIn,
      onPressOut: handlePressOut,
      android_ripple: ANDROID_SUPPORTS_RIPPLE ? (0, _extends2.default)({
        color: pressColor !== undefined ? pressColor : dark ? 'rgba(255, 255, 255, .32)' : 'rgba(0, 0, 0, .32)'
      }, android_ripple) : undefined,
      style: [{
        opacity: !ANDROID_SUPPORTS_RIPPLE ? opacity : 1
      }, style]
    }, rest));
  }
},"node_modules/@react-navigation/elements/src/PlatformPressable.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@react-navigation/native/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/@react-navigation/elements/src/assets",
    "width": 12,
    "height": 21,
    "scales": [1, 1.5, 2, 3, 4],
    "hash": "c90fb4585dd852a3d67af39baf923f67",
    "name": "back-icon",
    "type": "png"
  });
},"node_modules/@react-navigation/elements/src/assets/back-icon.png",["node_modules/react-native/Libraries/Image/AssetRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = _$$_REQUIRE(_dependencyMap[0]);
},"node_modules/react-native/Libraries/Image/AssetRegistry.js",["node_modules/@react-native/assets/registry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]).registerAsset({
    "__packager_asset": true,
    "httpServerLocation": "/assets/node_modules/@react-navigation/elements/src/assets",
    "width": 50,
    "height": 85,
    "scales": [1],
    "hash": "5223c8d9b0d08b82a5670fb5f71faf78",
    "name": "back-icon-mask",
    "type": "png"
  });
},"node_modules/@react-navigation/elements/src/assets/back-icon-mask.png",["node_modules/react-native/Libraries/Image/AssetRegistry.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _getNamedContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var HeaderBackContext = (0, _getNamedContext.default)('HeaderBackContext', undefined);
  var _default = HeaderBackContext;
  exports.default = _default;
},"node_modules/@react-navigation/elements/src/Header/HeaderBackContext.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/elements/src/getNamedContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _getNamedContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var HeaderHeightContext = (0, _getNamedContext.default)('HeaderHeightContext', undefined);
  var _default = HeaderHeightContext;
  exports.default = _default;
},"node_modules/@react-navigation/elements/src/Header/HeaderHeightContext.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/elements/src/getNamedContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useHeaderHeight;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _HeaderHeightContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useHeaderHeight() {
    var height = React.useContext(_HeaderHeightContext.default);

    if (height === undefined) {
      throw new Error("Couldn't find the header height. Are you inside a screen in a navigator with a header?");
    }

    return height;
  }
},"node_modules/@react-navigation/elements/src/Header/useHeaderHeight.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/elements/src/Header/HeaderHeightContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = MissingIcon;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[1]);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function MissingIcon(_ref) {
    var color = _ref.color,
        size = _ref.size,
        style = _ref.style;
    return React.createElement(_reactNative.Text, {
      style: [styles.icon, {
        color: color,
        fontSize: size
      }, style]
    }, "\u23F7");
  }

  var styles = _reactNative.StyleSheet.create({
    icon: {
      backgroundColor: 'transparent'
    }
  });
},"node_modules/@react-navigation/elements/src/MissingIcon.tsx",["node_modules/react/index.js","node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ResourceSavingScene;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[4]);

  var _excluded = ["visible", "children", "style"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var FAR_FAR_AWAY = 30000;

  function ResourceSavingScene(_ref) {
    var visible = _ref.visible,
        children = _ref.children,
        style = _ref.style,
        rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);

    if (_reactNative.Platform.OS === 'web') {
      return React.createElement(_reactNative.View, (0, _extends2.default)({
        hidden: !visible,
        style: [{
          display: visible ? 'flex' : 'none'
        }, styles.container, style],
        pointerEvents: visible ? 'auto' : 'none'
      }, rest), children);
    }

    return React.createElement(_reactNative.View, {
      style: [styles.container, style],
      pointerEvents: visible ? 'auto' : 'none'
    }, React.createElement(_reactNative.View, {
      collapsable: false,
      removeClippedSubviews: _reactNative.Platform.OS === 'ios' || _reactNative.Platform.OS === 'macos' ? !visible : true,
      pointerEvents: visible ? 'auto' : 'none',
      style: visible ? styles.attached : styles.detached
    }, children));
  }

  var styles = _reactNative.StyleSheet.create({
    container: {
      flex: 1,
      overflow: 'hidden'
    },
    attached: {
      flex: 1
    },
    detached: {
      flex: 1,
      top: FAR_FAR_AWAY
    }
  });
},"node_modules/@react-navigation/elements/src/ResourceSavingView.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = SafeAreaProviderCompat;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[1]);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _Dimensions$get = _reactNative.Dimensions.get('window'),
      _Dimensions$get$width = _Dimensions$get.width,
      width = _Dimensions$get$width === undefined ? 0 : _Dimensions$get$width,
      _Dimensions$get$heigh = _Dimensions$get.height,
      height = _Dimensions$get$heigh === undefined ? 0 : _Dimensions$get$heigh;

  var initialMetrics = _reactNative.Platform.OS === 'web' || _$$_REQUIRE(_dependencyMap[2]).initialWindowMetrics == null ? {
    frame: {
      x: 0,
      y: 0,
      width: width,
      height: height
    },
    insets: {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    }
  } : _$$_REQUIRE(_dependencyMap[2]).initialWindowMetrics;

  function SafeAreaProviderCompat(_ref) {
    var children = _ref.children,
        style = _ref.style;
    return React.createElement(_$$_REQUIRE(_dependencyMap[2]).SafeAreaInsetsContext.Consumer, null, function (insets) {
      if (insets) {
        return React.createElement(_reactNative.View, {
          style: [styles.container, style]
        }, children);
      }

      return React.createElement(_$$_REQUIRE(_dependencyMap[2]).SafeAreaProvider, {
        initialMetrics: initialMetrics,
        style: style
      }, children);
    });
  }

  SafeAreaProviderCompat.initialMetrics = initialMetrics;

  var styles = _reactNative.StyleSheet.create({
    container: {
      flex: 1
    }
  });
},"node_modules/@react-navigation/elements/src/SafeAreaProviderCompat.tsx",["node_modules/react/index.js","node_modules/react-native/index.js","node_modules/react-native-safe-area-context/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = Screen;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[3]);

  var _Background = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getDefaultHeaderHeight = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _HeaderHeightContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _HeaderShownContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function Screen(props) {
    var dimensions = (0, _$$_REQUIRE(_dependencyMap[8]).useSafeAreaFrame)();
    var insets = (0, _$$_REQUIRE(_dependencyMap[8]).useSafeAreaInsets)();
    var isParentHeaderShown = React.useContext(_HeaderShownContext.default);
    var parentHeaderHeight = React.useContext(_HeaderHeightContext.default);
    var focused = props.focused,
        _props$modal = props.modal,
        modal = _props$modal === undefined ? false : _props$modal,
        header = props.header,
        _props$headerShown = props.headerShown,
        headerShown = _props$headerShown === undefined ? true : _props$headerShown,
        headerTransparent = props.headerTransparent,
        _props$headerStatusBa = props.headerStatusBarHeight,
        headerStatusBarHeight = _props$headerStatusBa === undefined ? isParentHeaderShown ? 0 : insets.top : _props$headerStatusBa,
        navigation = props.navigation,
        route = props.route,
        children = props.children,
        style = props.style;

    var _React$useState = React.useState(function () {
      return (0, _getDefaultHeaderHeight.default)(dimensions, modal, headerStatusBarHeight);
    }),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
        headerHeight = _React$useState2[0],
        setHeaderHeight = _React$useState2[1];

    return React.createElement(_Background.default, {
      accessibilityElementsHidden: !focused,
      importantForAccessibility: focused ? 'auto' : 'no-hide-descendants',
      style: [styles.container, style]
    }, React.createElement(_reactNative.View, {
      style: styles.content
    }, React.createElement(_HeaderShownContext.default.Provider, {
      value: isParentHeaderShown || headerShown !== false
    }, React.createElement(_HeaderHeightContext.default.Provider, {
      value: headerShown ? headerHeight : parentHeaderHeight != null ? parentHeaderHeight : 0
    }, children))), headerShown ? React.createElement(_$$_REQUIRE(_dependencyMap[9]).NavigationContext.Provider, {
      value: navigation
    }, React.createElement(_$$_REQUIRE(_dependencyMap[9]).NavigationRouteContext.Provider, {
      value: route
    }, React.createElement(_reactNative.View, {
      onLayout: function onLayout(e) {
        var height = e.nativeEvent.layout.height;
        setHeaderHeight(height);
      },
      style: headerTransparent ? styles.absolute : null
    }, header))) : null);
  }

  var styles = _reactNative.StyleSheet.create({
    container: {
      flex: 1,
      flexDirection: 'column-reverse'
    },
    content: {
      flex: 1
    },
    absolute: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0
    }
  });
},"node_modules/@react-navigation/elements/src/Screen.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@react-navigation/elements/src/Background.tsx","node_modules/@react-navigation/elements/src/Header/getDefaultHeaderHeight.tsx","node_modules/@react-navigation/elements/src/Header/HeaderHeightContext.tsx","node_modules/@react-navigation/elements/src/Header/HeaderShownContext.tsx","node_modules/react-native-safe-area-context/src/index.tsx","node_modules/@react-navigation/native/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},"node_modules/@react-navigation/elements/src/types.tsx",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _defineProperty2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends3 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _color = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[9]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[10]);

  var _getDistanceForDirection = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _CardContainer = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var EPSILON = 0.01;
  var STATE_INACTIVE = 0;
  var STATE_TRANSITIONING_OR_BELOW_TOP = 1;
  var STATE_ON_TOP = 2;
  var FALLBACK_DESCRIPTOR = Object.freeze({
    options: {}
  });

  var getInterpolationIndex = function getInterpolationIndex(scenes, index) {
    var cardStyleInterpolator = scenes[index].descriptor.options.cardStyleInterpolator;
    var interpolationIndex = 0;

    for (var i = index - 1; i >= 0; i--) {
      var _scenes$i;

      var cardStyleInterpolatorCurrent = (_scenes$i = scenes[i]) == null ? undefined : _scenes$i.descriptor.options.cardStyleInterpolator;

      if (cardStyleInterpolatorCurrent !== cardStyleInterpolator) {
        break;
      }

      interpolationIndex++;
    }

    return interpolationIndex;
  };

  var getIsModal = function getIsModal(scene, interpolationIndex, isParentModal) {
    if (isParentModal) {
      return true;
    }

    var cardStyleInterpolator = scene.descriptor.options.cardStyleInterpolator;
    var isModalPresentation = (0, _$$_REQUIRE(_dependencyMap[13]).getIsModalPresentation)(cardStyleInterpolator);
    var isModal = isModalPresentation && interpolationIndex !== 0;
    return isModal;
  };

  var getHeaderHeights = function getHeaderHeights(scenes, insets, isParentHeaderShown, isParentModal, layout, previous) {
    return scenes.reduce(function (acc, curr, index) {
      var _curr$descriptor$opti = curr.descriptor.options,
          _curr$descriptor$opti2 = _curr$descriptor$opti.headerStatusBarHeight,
          headerStatusBarHeight = _curr$descriptor$opti2 === undefined ? isParentHeaderShown ? 0 : insets.top : _curr$descriptor$opti2,
          headerStyle = _curr$descriptor$opti.headerStyle;

      var style = _reactNative.StyleSheet.flatten(headerStyle || {});

      var height = 'height' in style && typeof style.height === 'number' ? style.height : previous[curr.route.key];
      var interpolationIndex = getInterpolationIndex(scenes, index);
      var isModal = getIsModal(curr, interpolationIndex, isParentModal);
      acc[curr.route.key] = typeof height === 'number' ? height : (0, _$$_REQUIRE(_dependencyMap[14]).getDefaultHeaderHeight)(layout, isModal, headerStatusBarHeight);
      return acc;
    }, {});
  };

  var getDistanceFromOptions = function getDistanceFromOptions(layout, descriptor) {
    var _ref = (descriptor == null ? undefined : descriptor.options) || {},
        presentation = _ref.presentation,
        _ref$gestureDirection = _ref.gestureDirection,
        gestureDirection = _ref$gestureDirection === undefined ? presentation === 'modal' ? _$$_REQUIRE(_dependencyMap[15]).ModalTransition.gestureDirection : _$$_REQUIRE(_dependencyMap[15]).DefaultTransition.gestureDirection : _ref$gestureDirection;

    return (0, _getDistanceForDirection.default)(layout, gestureDirection);
  };

  var getProgressFromGesture = function getProgressFromGesture(gesture, layout, descriptor) {
    var distance = getDistanceFromOptions({
      width: Math.max(1, layout.width),
      height: Math.max(1, layout.height)
    }, descriptor);

    if (distance > 0) {
      return gesture.interpolate({
        inputRange: [0, distance],
        outputRange: [1, 0]
      });
    }

    return gesture.interpolate({
      inputRange: [distance, 0],
      outputRange: [0, 1]
    });
  };

  var CardStack = function (_React$Component) {
    (0, _inherits2.default)(CardStack, _React$Component);

    var _super = _createSuper(CardStack);

    function CardStack(_props) {
      var _this;

      (0, _classCallCheck2.default)(this, CardStack);
      _this = _super.call(this, _props);

      _this.handleLayout = function (e) {
        var _e$nativeEvent$layout = e.nativeEvent.layout,
            height = _e$nativeEvent$layout.height,
            width = _e$nativeEvent$layout.width;
        var layout = {
          width: width,
          height: height
        };

        _this.setState(function (state, props) {
          if (height === state.layout.height && width === state.layout.width) {
            return null;
          }

          return {
            layout: layout,
            headerHeights: getHeaderHeights(state.scenes, props.insets, props.isParentHeaderShown, props.isParentModal, layout, state.headerHeights)
          };
        });
      };

      _this.handleHeaderLayout = function (_ref2) {
        var route = _ref2.route,
            height = _ref2.height;

        _this.setState(function (_ref3) {
          var headerHeights = _ref3.headerHeights;
          var previousHeight = headerHeights[route.key];

          if (previousHeight === height) {
            return null;
          }

          return {
            headerHeights: (0, _extends3.default)({}, headerHeights, (0, _defineProperty2.default)({}, route.key, height))
          };
        });
      };

      _this.getFocusedRoute = function () {
        var state = _this.props.state;
        return state.routes[state.index];
      };

      _this.getPreviousScene = function (_ref4) {
        var route = _ref4.route;
        var getPreviousRoute = _this.props.getPreviousRoute;
        var scenes = _this.state.scenes;
        var previousRoute = getPreviousRoute({
          route: route
        });

        if (previousRoute) {
          var previousScene = scenes.find(function (scene) {
            return scene.descriptor.route.key === previousRoute.key;
          });
          return previousScene;
        }

        return undefined;
      };

      _this.state = {
        routes: [],
        scenes: [],
        gestures: {},
        layout: _$$_REQUIRE(_dependencyMap[14]).SafeAreaProviderCompat.initialMetrics.frame,
        descriptors: _this.props.descriptors,
        headerHeights: {}
      };
      return _this;
    }

    (0, _createClass2.default)(CardStack, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            insets = _this$props.insets,
            state = _this$props.state,
            routes = _this$props.routes,
            closingRouteKeys = _this$props.closingRouteKeys,
            onOpenRoute = _this$props.onOpenRoute,
            onCloseRoute = _this$props.onCloseRoute,
            renderHeader = _this$props.renderHeader,
            renderScene = _this$props.renderScene,
            isParentHeaderShown = _this$props.isParentHeaderShown,
            isParentModal = _this$props.isParentModal,
            onTransitionStart = _this$props.onTransitionStart,
            onTransitionEnd = _this$props.onTransitionEnd,
            onGestureStart = _this$props.onGestureStart,
            onGestureEnd = _this$props.onGestureEnd,
            onGestureCancel = _this$props.onGestureCancel,
            _this$props$detachIna = _this$props.detachInactiveScreens,
            detachInactiveScreens = _this$props$detachIna === undefined ? _reactNative.Platform.OS === 'web' || _reactNative.Platform.OS === 'android' || _reactNative.Platform.OS === 'ios' : _this$props$detachIna;
        var _this$state = this.state,
            scenes = _this$state.scenes,
            layout = _this$state.layout,
            gestures = _this$state.gestures,
            headerHeights = _this$state.headerHeights;
        var focusedRoute = state.routes[state.index];
        var focusedHeaderHeight = headerHeights[focusedRoute.key];
        var isFloatHeaderAbsolute = this.state.scenes.slice(-2).some(function (scene) {
          var _scene$descriptor$opt;

          var options = (_scene$descriptor$opt = scene.descriptor.options) != null ? _scene$descriptor$opt : {};
          var headerMode = options.headerMode,
              headerTransparent = options.headerTransparent,
              _options$headerShown = options.headerShown,
              headerShown = _options$headerShown === undefined ? true : _options$headerShown;

          if (headerTransparent || headerShown === false || headerMode === 'screen') {
            return true;
          }

          return false;
        });
        var activeScreensLimit = 1;

        for (var i = scenes.length - 1; i >= 0; i--) {
          var options = scenes[i].descriptor.options;
          var _options$detachPrevio = options.detachPreviousScreen,
              detachPreviousScreen = _options$detachPrevio === undefined ? options.presentation === 'transparentModal' ? false : (0, _$$_REQUIRE(_dependencyMap[13]).getIsModalPresentation)(options.cardStyleInterpolator) ? i !== scenes.map(function (scene) {
            return scene.descriptor.options.cardStyleInterpolator;
          }).lastIndexOf(_$$_REQUIRE(_dependencyMap[16]).forModalPresentationIOS) : true : _options$detachPrevio;

          if (detachPreviousScreen === false) {
            activeScreensLimit++;
          } else {
            if (i <= scenes.length - 2) {
              break;
            }
          }
        }

        var floatingHeader = React.createElement(React.Fragment, {
          key: "header"
        }, renderHeader({
          mode: 'float',
          layout: layout,
          scenes: scenes,
          getPreviousScene: this.getPreviousScene,
          getFocusedRoute: this.getFocusedRoute,
          onContentHeightChange: this.handleHeaderLayout,
          style: [styles.floating, isFloatHeaderAbsolute && [{
            height: focusedHeaderHeight
          }, styles.absolute]]
        }));
        return React.createElement(_$$_REQUIRE(_dependencyMap[14]).Background, null, isFloatHeaderAbsolute ? null : floatingHeader, React.createElement(_$$_REQUIRE(_dependencyMap[17]).MaybeScreenContainer, {
          enabled: detachInactiveScreens,
          style: styles.container,
          onLayout: this.handleLayout
        }, routes.map(function (route, index, self) {
          var _scenes, _scenes2;

          var focused = focusedRoute.key === route.key;
          var gesture = gestures[route.key];
          var scene = scenes[index];
          var isScreenActive = 1;

          if (index < self.length - activeScreensLimit - 1) {
            isScreenActive = STATE_INACTIVE;
          } else {
            var sceneForActivity = scenes[self.length - 1];
            var outputValue = index === self.length - 1 ? STATE_ON_TOP : index >= self.length - activeScreensLimit ? STATE_TRANSITIONING_OR_BELOW_TOP : STATE_INACTIVE;
            isScreenActive = sceneForActivity ? sceneForActivity.progress.current.interpolate({
              inputRange: [0, 0.99, 1],
              outputRange: [1, 1, outputValue],
              extrapolate: 'clamp'
            }) : STATE_TRANSITIONING_OR_BELOW_TOP;
          }

          var _scene$descriptor$opt2 = scene.descriptor.options,
              _scene$descriptor$opt3 = _scene$descriptor$opt2.headerShown,
              headerShown = _scene$descriptor$opt3 === undefined ? true : _scene$descriptor$opt3,
              headerTransparent = _scene$descriptor$opt2.headerTransparent,
              headerStyle = _scene$descriptor$opt2.headerStyle,
              headerTintColor = _scene$descriptor$opt2.headerTintColor;
          var safeAreaInsetTop = insets.top;
          var safeAreaInsetRight = insets.right;
          var safeAreaInsetBottom = insets.bottom;
          var safeAreaInsetLeft = insets.left;
          var headerHeight = headerShown !== false ? headerHeights[route.key] : 0;
          var headerDarkContent;

          if (headerShown) {
            if (typeof headerTintColor === 'string') {
              headerDarkContent = (0, _color.default)(headerTintColor).isDark();
            } else {
              var flattenedHeaderStyle = _reactNative.StyleSheet.flatten(headerStyle);

              if (flattenedHeaderStyle && 'backgroundColor' in flattenedHeaderStyle && typeof flattenedHeaderStyle.backgroundColor === 'string') {
                headerDarkContent = !(0, _color.default)(flattenedHeaderStyle.backgroundColor).isDark();
              }
            }
          }

          var interpolationIndex = getInterpolationIndex(scenes, index);
          var isModal = getIsModal(scene, interpolationIndex, isParentModal);
          var isNextScreenTransparent = ((_scenes = scenes[index + 1]) == null ? undefined : _scenes.descriptor.options.presentation) === 'transparentModal';
          var detachCurrentScreen = ((_scenes2 = scenes[index + 1]) == null ? undefined : _scenes2.descriptor.options.detachPreviousScreen) !== false;
          return React.createElement(_$$_REQUIRE(_dependencyMap[17]).MaybeScreen, {
            key: route.key,
            style: _reactNative.StyleSheet.absoluteFill,
            enabled: detachInactiveScreens,
            active: isScreenActive,
            pointerEvents: "box-none"
          }, React.createElement(_CardContainer.default, {
            index: index,
            interpolationIndex: interpolationIndex,
            modal: isModal,
            active: index === self.length - 1,
            focused: focused,
            closing: closingRouteKeys.includes(route.key),
            layout: layout,
            gesture: gesture,
            scene: scene,
            safeAreaInsetTop: safeAreaInsetTop,
            safeAreaInsetRight: safeAreaInsetRight,
            safeAreaInsetBottom: safeAreaInsetBottom,
            safeAreaInsetLeft: safeAreaInsetLeft,
            onGestureStart: onGestureStart,
            onGestureCancel: onGestureCancel,
            onGestureEnd: onGestureEnd,
            headerHeight: headerHeight,
            isParentHeaderShown: isParentHeaderShown,
            onHeaderHeightChange: _this2.handleHeaderLayout,
            getPreviousScene: _this2.getPreviousScene,
            getFocusedRoute: _this2.getFocusedRoute,
            headerDarkContent: headerDarkContent,
            hasAbsoluteFloatHeader: isFloatHeaderAbsolute && !headerTransparent,
            renderHeader: renderHeader,
            renderScene: renderScene,
            onOpenRoute: onOpenRoute,
            onCloseRoute: onCloseRoute,
            onTransitionStart: onTransitionStart,
            onTransitionEnd: onTransitionEnd,
            isNextScreenTransparent: isNextScreenTransparent,
            detachCurrentScreen: detachCurrentScreen
          }));
        })), isFloatHeaderAbsolute ? floatingHeader : null);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(props, state) {
        if (props.routes === state.routes && props.descriptors === state.descriptors) {
          return null;
        }

        var gestures = props.routes.reduce(function (acc, curr) {
          var descriptor = props.descriptors[curr.key];

          var _ref5 = (descriptor == null ? undefined : descriptor.options) || {},
              animationEnabled = _ref5.animationEnabled;

          acc[curr.key] = state.gestures[curr.key] || new _reactNative.Animated.Value(props.openingRouteKeys.includes(curr.key) && animationEnabled !== false ? getDistanceFromOptions(state.layout, descriptor) : 0);
          return acc;
        }, {});
        var scenes = props.routes.map(function (route, index, self) {
          var _descriptor$options$h;

          var previousRoute = self[index - 1];
          var nextRoute = self[index + 1];
          var oldScene = state.scenes[index];
          var currentGesture = gestures[route.key];
          var previousGesture = previousRoute ? gestures[previousRoute.key] : undefined;
          var nextGesture = nextRoute ? gestures[nextRoute.key] : undefined;
          var descriptor = props.descriptors[route.key] || state.descriptors[route.key] || (oldScene ? oldScene.descriptor : FALLBACK_DESCRIPTOR);
          var nextDescriptor = props.descriptors[nextRoute == null ? undefined : nextRoute.key] || state.descriptors[nextRoute == null ? undefined : nextRoute.key];
          var previousDescriptor = props.descriptors[previousRoute == null ? undefined : previousRoute.key] || state.descriptors[previousRoute == null ? undefined : previousRoute.key];
          var optionsForTransitionConfig = index !== self.length - 1 && nextDescriptor && nextDescriptor.options.presentation !== 'transparentModal' ? nextDescriptor.options : descriptor.options;
          var defaultTransitionPreset = optionsForTransitionConfig.presentation === 'modal' ? _$$_REQUIRE(_dependencyMap[15]).ModalTransition : optionsForTransitionConfig.presentation === 'transparentModal' ? _$$_REQUIRE(_dependencyMap[15]).ModalFadeTransition : _$$_REQUIRE(_dependencyMap[15]).DefaultTransition;
          var _optionsForTransition = optionsForTransitionConfig.animationEnabled,
              animationEnabled = _optionsForTransition === undefined ? _reactNative.Platform.OS !== 'web' && _reactNative.Platform.OS !== 'windows' && _reactNative.Platform.OS !== 'macos' : _optionsForTransition,
              _optionsForTransition2 = optionsForTransitionConfig.gestureEnabled,
              gestureEnabled = _optionsForTransition2 === undefined ? _reactNative.Platform.OS === 'ios' && animationEnabled : _optionsForTransition2,
              _optionsForTransition3 = optionsForTransitionConfig.gestureDirection,
              gestureDirection = _optionsForTransition3 === undefined ? defaultTransitionPreset.gestureDirection : _optionsForTransition3,
              _optionsForTransition4 = optionsForTransitionConfig.transitionSpec,
              transitionSpec = _optionsForTransition4 === undefined ? defaultTransitionPreset.transitionSpec : _optionsForTransition4,
              _optionsForTransition5 = optionsForTransitionConfig.cardStyleInterpolator,
              cardStyleInterpolator = _optionsForTransition5 === undefined ? animationEnabled === false ? _$$_REQUIRE(_dependencyMap[16]).forNoAnimation : defaultTransitionPreset.cardStyleInterpolator : _optionsForTransition5,
              _optionsForTransition6 = optionsForTransitionConfig.headerStyleInterpolator,
              headerStyleInterpolator = _optionsForTransition6 === undefined ? defaultTransitionPreset.headerStyleInterpolator : _optionsForTransition6,
              _optionsForTransition7 = optionsForTransitionConfig.cardOverlayEnabled,
              cardOverlayEnabled = _optionsForTransition7 === undefined ? _reactNative.Platform.OS !== 'ios' && optionsForTransitionConfig.presentation !== 'transparentModal' || (0, _$$_REQUIRE(_dependencyMap[13]).getIsModalPresentation)(cardStyleInterpolator) : _optionsForTransition7;
          var headerMode = (_descriptor$options$h = descriptor.options.headerMode) != null ? _descriptor$options$h : !(optionsForTransitionConfig.presentation === 'modal' || optionsForTransitionConfig.presentation === 'transparentModal' || (nextDescriptor == null ? undefined : nextDescriptor.options.presentation) === 'modal' || (nextDescriptor == null ? undefined : nextDescriptor.options.presentation) === 'transparentModal' || (0, _$$_REQUIRE(_dependencyMap[13]).getIsModalPresentation)(cardStyleInterpolator)) && _reactNative.Platform.OS === 'ios' && descriptor.options.header === undefined ? 'float' : 'screen';
          var scene = {
            route: route,
            descriptor: (0, _extends3.default)({}, descriptor, {
              options: (0, _extends3.default)({}, descriptor.options, {
                animationEnabled: animationEnabled,
                cardOverlayEnabled: cardOverlayEnabled,
                cardStyleInterpolator: cardStyleInterpolator,
                gestureDirection: gestureDirection,
                gestureEnabled: gestureEnabled,
                headerStyleInterpolator: headerStyleInterpolator,
                transitionSpec: transitionSpec,
                headerMode: headerMode
              })
            }),
            progress: {
              current: getProgressFromGesture(currentGesture, state.layout, descriptor),
              next: nextGesture && (nextDescriptor == null ? undefined : nextDescriptor.options.presentation) !== 'transparentModal' ? getProgressFromGesture(nextGesture, state.layout, nextDescriptor) : undefined,
              previous: previousGesture ? getProgressFromGesture(previousGesture, state.layout, previousDescriptor) : undefined
            },
            __memo: [state.layout, descriptor, nextDescriptor, previousDescriptor, currentGesture, nextGesture, previousGesture]
          };

          if (oldScene && scene.__memo.every(function (it, i) {
            return oldScene.__memo[i] === it;
          })) {
            return oldScene;
          }

          return scene;
        });
        return {
          routes: props.routes,
          scenes: scenes,
          gestures: gestures,
          descriptors: props.descriptors,
          headerHeights: getHeaderHeights(scenes, props.insets, props.isParentHeaderShown, props.isParentModal, state.layout, state.headerHeights)
        };
      }
    }]);
    return CardStack;
  }(React.Component);

  exports.default = CardStack;

  var styles = _reactNative.StyleSheet.create({
    container: {
      flex: 1
    },
    absolute: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0
    },
    floating: {
      zIndex: 1
    }
  });
},"node_modules/@react-navigation/stack/src/views/Stack/CardStack.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/defineProperty.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/color/index.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@react-navigation/stack/src/utils/getDistanceForDirection.tsx","node_modules/@react-navigation/stack/src/views/Stack/CardContainer.tsx","node_modules/@react-navigation/stack/src/views/Stack/Card.tsx","node_modules/@react-navigation/elements/src/index.tsx","node_modules/@react-navigation/stack/src/TransitionConfigs/TransitionPresets.tsx","node_modules/@react-navigation/stack/src/TransitionConfigs/CardStyleInterpolators.tsx","node_modules/@react-navigation/stack/src/views/Screens.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var _slice = [].slice;
  var skippedModels = ['keyword', 'gray', 'hex'];
  var hashedModelKeys = {};
  Object.keys(_$$_REQUIRE(_dependencyMap[0])).forEach(function (model) {
    hashedModelKeys[_slice.call(_$$_REQUIRE(_dependencyMap[0])[model].labels).sort().join('')] = model;
  });
  var limiters = {};

  function Color(obj, model) {
    if (!(this instanceof Color)) {
      return new Color(obj, model);
    }

    if (model && model in skippedModels) {
      model = null;
    }

    if (model && !(model in _$$_REQUIRE(_dependencyMap[0]))) {
      throw new Error('Unknown model: ' + model);
    }

    var i;
    var channels;

    if (obj == null) {
      this.model = 'rgb';
      this.color = [0, 0, 0];
      this.valpha = 1;
    } else if (obj instanceof Color) {
      this.model = obj.model;
      this.color = obj.color.slice();
      this.valpha = obj.valpha;
    } else if (typeof obj === 'string') {
      var result = _$$_REQUIRE(_dependencyMap[1]).get(obj);

      if (result === null) {
        throw new Error('Unable to parse color from string: ' + obj);
      }

      this.model = result.model;
      channels = _$$_REQUIRE(_dependencyMap[0])[this.model].channels;
      this.color = result.value.slice(0, channels);
      this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
    } else if (obj.length) {
      this.model = model || 'rgb';
      channels = _$$_REQUIRE(_dependencyMap[0])[this.model].channels;

      var newArr = _slice.call(obj, 0, channels);

      this.color = zeroArray(newArr, channels);
      this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
    } else if (typeof obj === 'number') {
      obj &= 0xFFFFFF;
      this.model = 'rgb';
      this.color = [obj >> 16 & 0xFF, obj >> 8 & 0xFF, obj & 0xFF];
      this.valpha = 1;
    } else {
      this.valpha = 1;
      var keys = Object.keys(obj);

      if ('alpha' in obj) {
        keys.splice(keys.indexOf('alpha'), 1);
        this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
      }

      var hashedKeys = keys.sort().join('');

      if (!(hashedKeys in hashedModelKeys)) {
        throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
      }

      this.model = hashedModelKeys[hashedKeys];

      var labels = _$$_REQUIRE(_dependencyMap[0])[this.model].labels;

      var color = [];

      for (i = 0; i < labels.length; i++) {
        color.push(obj[labels[i]]);
      }

      this.color = zeroArray(color);
    }

    if (limiters[this.model]) {
      channels = _$$_REQUIRE(_dependencyMap[0])[this.model].channels;

      for (i = 0; i < channels; i++) {
        var limit = limiters[this.model][i];

        if (limit) {
          this.color[i] = limit(this.color[i]);
        }
      }
    }

    this.valpha = Math.max(0, Math.min(1, this.valpha));

    if (Object.freeze) {
      Object.freeze(this);
    }
  }

  Color.prototype = {
    toString: function toString() {
      return this.string();
    },
    toJSON: function toJSON() {
      return this[this.model]();
    },
    string: function string(places) {
      var self = this.model in _$$_REQUIRE(_dependencyMap[1]).to ? this : this.rgb();
      self = self.round(typeof places === 'number' ? places : 1);
      var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
      return _$$_REQUIRE(_dependencyMap[1]).to[self.model](args);
    },
    percentString: function percentString(places) {
      var self = this.rgb().round(typeof places === 'number' ? places : 1);
      var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
      return _$$_REQUIRE(_dependencyMap[1]).to.rgb.percent(args);
    },
    array: function array() {
      return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
    },
    object: function object() {
      var result = {};

      var channels = _$$_REQUIRE(_dependencyMap[0])[this.model].channels;

      var labels = _$$_REQUIRE(_dependencyMap[0])[this.model].labels;

      for (var i = 0; i < channels; i++) {
        result[labels[i]] = this.color[i];
      }

      if (this.valpha !== 1) {
        result.alpha = this.valpha;
      }

      return result;
    },
    unitArray: function unitArray() {
      var rgb = this.rgb().color;
      rgb[0] /= 255;
      rgb[1] /= 255;
      rgb[2] /= 255;

      if (this.valpha !== 1) {
        rgb.push(this.valpha);
      }

      return rgb;
    },
    unitObject: function unitObject() {
      var rgb = this.rgb().object();
      rgb.r /= 255;
      rgb.g /= 255;
      rgb.b /= 255;

      if (this.valpha !== 1) {
        rgb.alpha = this.valpha;
      }

      return rgb;
    },
    round: function round(places) {
      places = Math.max(places || 0, 0);
      return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
    },
    alpha: function alpha(val) {
      if (arguments.length) {
        return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
      }

      return this.valpha;
    },
    red: getset('rgb', 0, maxfn(255)),
    green: getset('rgb', 1, maxfn(255)),
    blue: getset('rgb', 2, maxfn(255)),
    hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) {
      return (val % 360 + 360) % 360;
    }),
    saturationl: getset('hsl', 1, maxfn(100)),
    lightness: getset('hsl', 2, maxfn(100)),
    saturationv: getset('hsv', 1, maxfn(100)),
    value: getset('hsv', 2, maxfn(100)),
    chroma: getset('hcg', 1, maxfn(100)),
    gray: getset('hcg', 2, maxfn(100)),
    white: getset('hwb', 1, maxfn(100)),
    wblack: getset('hwb', 2, maxfn(100)),
    cyan: getset('cmyk', 0, maxfn(100)),
    magenta: getset('cmyk', 1, maxfn(100)),
    yellow: getset('cmyk', 2, maxfn(100)),
    black: getset('cmyk', 3, maxfn(100)),
    x: getset('xyz', 0, maxfn(100)),
    y: getset('xyz', 1, maxfn(100)),
    z: getset('xyz', 2, maxfn(100)),
    l: getset('lab', 0, maxfn(100)),
    a: getset('lab', 1),
    b: getset('lab', 2),
    keyword: function keyword(val) {
      if (arguments.length) {
        return new Color(val);
      }

      return _$$_REQUIRE(_dependencyMap[0])[this.model].keyword(this.color);
    },
    hex: function hex(val) {
      if (arguments.length) {
        return new Color(val);
      }

      return _$$_REQUIRE(_dependencyMap[1]).to.hex(this.rgb().round().color);
    },
    rgbNumber: function rgbNumber() {
      var rgb = this.rgb().color;
      return (rgb[0] & 0xFF) << 16 | (rgb[1] & 0xFF) << 8 | rgb[2] & 0xFF;
    },
    luminosity: function luminosity() {
      var rgb = this.rgb().color;
      var lum = [];

      for (var i = 0; i < rgb.length; i++) {
        var chan = rgb[i] / 255;
        lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
      }

      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast: function contrast(color2) {
      var lum1 = this.luminosity();
      var lum2 = color2.luminosity();

      if (lum1 > lum2) {
        return (lum1 + 0.05) / (lum2 + 0.05);
      }

      return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level: function level(color2) {
      var contrastRatio = this.contrast(color2);

      if (contrastRatio >= 7.1) {
        return 'AAA';
      }

      return contrastRatio >= 4.5 ? 'AA' : '';
    },
    isDark: function isDark() {
      var rgb = this.rgb().color;
      var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
      return yiq < 128;
    },
    isLight: function isLight() {
      return !this.isDark();
    },
    negate: function negate() {
      var rgb = this.rgb();

      for (var i = 0; i < 3; i++) {
        rgb.color[i] = 255 - rgb.color[i];
      }

      return rgb;
    },
    lighten: function lighten(ratio) {
      var hsl = this.hsl();
      hsl.color[2] += hsl.color[2] * ratio;
      return hsl;
    },
    darken: function darken(ratio) {
      var hsl = this.hsl();
      hsl.color[2] -= hsl.color[2] * ratio;
      return hsl;
    },
    saturate: function saturate(ratio) {
      var hsl = this.hsl();
      hsl.color[1] += hsl.color[1] * ratio;
      return hsl;
    },
    desaturate: function desaturate(ratio) {
      var hsl = this.hsl();
      hsl.color[1] -= hsl.color[1] * ratio;
      return hsl;
    },
    whiten: function whiten(ratio) {
      var hwb = this.hwb();
      hwb.color[1] += hwb.color[1] * ratio;
      return hwb;
    },
    blacken: function blacken(ratio) {
      var hwb = this.hwb();
      hwb.color[2] += hwb.color[2] * ratio;
      return hwb;
    },
    grayscale: function grayscale() {
      var rgb = this.rgb().color;
      var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      return Color.rgb(val, val, val);
    },
    fade: function fade(ratio) {
      return this.alpha(this.valpha - this.valpha * ratio);
    },
    opaquer: function opaquer(ratio) {
      return this.alpha(this.valpha + this.valpha * ratio);
    },
    rotate: function rotate(degrees) {
      var hsl = this.hsl();
      var hue = hsl.color[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      hsl.color[0] = hue;
      return hsl;
    },
    mix: function mix(mixinColor, weight) {
      if (!mixinColor || !mixinColor.rgb) {
        throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
      }

      var color1 = mixinColor.rgb();
      var color2 = this.rgb();
      var p = weight === undefined ? 0.5 : weight;
      var w = 2 * p - 1;
      var a = color1.alpha() - color2.alpha();
      var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
      var w2 = 1 - w1;
      return Color.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));
    }
  };
  Object.keys(_$$_REQUIRE(_dependencyMap[0])).forEach(function (model) {
    if (skippedModels.indexOf(model) !== -1) {
      return;
    }

    var channels = _$$_REQUIRE(_dependencyMap[0])[model].channels;

    Color.prototype[model] = function () {
      if (this.model === model) {
        return new Color(this);
      }

      if (arguments.length) {
        return new Color(arguments, model);
      }

      var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
      return new Color(assertArray(_$$_REQUIRE(_dependencyMap[0])[this.model][model].raw(this.color)).concat(newAlpha), model);
    };

    Color[model] = function (color) {
      if (typeof color === 'number') {
        color = zeroArray(_slice.call(arguments), channels);
      }

      return new Color(color, model);
    };
  });

  function roundTo(num, places) {
    return Number(num.toFixed(places));
  }

  function roundToPlace(places) {
    return function (num) {
      return roundTo(num, places);
    };
  }

  function getset(model, channel, modifier) {
    model = Array.isArray(model) ? model : [model];
    model.forEach(function (m) {
      (limiters[m] || (limiters[m] = []))[channel] = modifier;
    });
    model = model[0];
    return function (val) {
      var result;

      if (arguments.length) {
        if (modifier) {
          val = modifier(val);
        }

        result = this[model]();
        result.color[channel] = val;
        return result;
      }

      result = this[model]().color[channel];

      if (modifier) {
        result = modifier(result);
      }

      return result;
    };
  }

  function maxfn(max) {
    return function (v) {
      return Math.max(0, Math.min(max, v));
    };
  }

  function assertArray(val) {
    return Array.isArray(val) ? val : [val];
  }

  function zeroArray(arr, length) {
    for (var i = 0; i < length; i++) {
      if (typeof arr[i] !== 'number') {
        arr[i] = 0;
      }
    }

    return arr;
  }

  module.exports = Color;
},"node_modules/color/index.js",["node_modules/color/node_modules/color-convert/index.js","node_modules/color-string/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var convert = {};
  var models = Object.keys(_$$_REQUIRE(_dependencyMap[0]));

  function wrapRaw(fn) {
    var wrappedFn = function wrappedFn(args) {
      if (args === undefined || args === null) {
        return args;
      }

      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }

      return fn(args);
    };

    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  function wrapRounded(fn) {
    var wrappedFn = function wrappedFn(args) {
      if (args === undefined || args === null) {
        return args;
      }

      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }

      var result = fn(args);

      if (typeof result === 'object') {
        for (var len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }

      return result;
    };

    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  models.forEach(function (fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], 'channels', {
      value: _$$_REQUIRE(_dependencyMap[0])[fromModel].channels
    });
    Object.defineProperty(convert[fromModel], 'labels', {
      value: _$$_REQUIRE(_dependencyMap[0])[fromModel].labels
    });

    var routes = _$$_REQUIRE(_dependencyMap[1])(fromModel);

    var routeModels = Object.keys(routes);
    routeModels.forEach(function (toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module.exports = convert;
},"node_modules/color/node_modules/color-convert/index.js",["node_modules/color/node_modules/color-convert/conversions.js","node_modules/color/node_modules/color-convert/route.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var reverseKeywords = {};

  for (var key in _$$_REQUIRE(_dependencyMap[0])) {
    if (_$$_REQUIRE(_dependencyMap[0]).hasOwnProperty(key)) {
      reverseKeywords[_$$_REQUIRE(_dependencyMap[0])[key]] = key;
    }
  }

  var convert = module.exports = {
    rgb: {
      channels: 3,
      labels: 'rgb'
    },
    hsl: {
      channels: 3,
      labels: 'hsl'
    },
    hsv: {
      channels: 3,
      labels: 'hsv'
    },
    hwb: {
      channels: 3,
      labels: 'hwb'
    },
    cmyk: {
      channels: 4,
      labels: 'cmyk'
    },
    xyz: {
      channels: 3,
      labels: 'xyz'
    },
    lab: {
      channels: 3,
      labels: 'lab'
    },
    lch: {
      channels: 3,
      labels: 'lch'
    },
    hex: {
      channels: 1,
      labels: ['hex']
    },
    keyword: {
      channels: 1,
      labels: ['keyword']
    },
    ansi16: {
      channels: 1,
      labels: ['ansi16']
    },
    ansi256: {
      channels: 1,
      labels: ['ansi256']
    },
    hcg: {
      channels: 3,
      labels: ['h', 'c', 'g']
    },
    apple: {
      channels: 3,
      labels: ['r16', 'g16', 'b16']
    },
    gray: {
      channels: 1,
      labels: ['gray']
    }
  };

  for (var model in convert) {
    if (convert.hasOwnProperty(model)) {
      if (!('channels' in convert[model])) {
        throw new Error('missing channels property: ' + model);
      }

      if (!('labels' in convert[model])) {
        throw new Error('missing channel labels property: ' + model);
      }

      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error('channel and label counts mismatch: ' + model);
      }

      var channels = convert[model].channels;
      var labels = convert[model].labels;
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], 'channels', {
        value: channels
      });
      Object.defineProperty(convert[model], 'labels', {
        value: labels
      });
    }
  }

  convert.rgb.hsl = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h;
    var s;
    var l;

    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }

    h = Math.min(h * 60, 360);

    if (h < 0) {
      h += 360;
    }

    l = (min + max) / 2;

    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }

    return [h, s * 100, l * 100];
  };

  convert.rgb.hsv = function (rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h;
    var s;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff = v - Math.min(r, g, b);

    var diffc = function diffc(c) {
      return (v - c) / 6 / diff + 0.5;
    };

    if (diff === 0) {
      h = s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);

      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 0.3333333333333333 + rdif - bdif;
      } else if (b === v) {
        h = 0.6666666666666666 + gdif - rdif;
      }

      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }

    return [h * 360, s * 100, v * 100];
  };

  convert.rgb.hwb = function (rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h = convert.rgb.hsl(rgb)[0];
    var w = 0.00392156862745098 * Math.min(r, Math.min(g, b));
    b = 1 - 0.00392156862745098 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };

  convert.rgb.cmyk = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var c;
    var m;
    var y;
    var k;
    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m = (1 - g - k) / (1 - k) || 0;
    y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };

  function comparativeDistance(x, y) {
    return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
  }

  convert.rgb.keyword = function (rgb) {
    var reversed = reverseKeywords[rgb];

    if (reversed) {
      return reversed;
    }

    var currentClosestDistance = Infinity;
    var currentClosestKeyword;

    for (var keyword in _$$_REQUIRE(_dependencyMap[0])) {
      if (_$$_REQUIRE(_dependencyMap[0]).hasOwnProperty(keyword)) {
        var value = _$$_REQUIRE(_dependencyMap[0])[keyword];

        var distance = comparativeDistance(rgb, value);

        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
    }

    return currentClosestKeyword;
  };

  convert.keyword.rgb = function (keyword) {
    return _$$_REQUIRE(_dependencyMap[0])[keyword];
  };

  convert.rgb.xyz = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };

  convert.rgb.lab = function (rgb) {
    var xyz = convert.rgb.xyz(rgb);
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 0.3333333333333333) : 7.787 * x + 0.13793103448275862;
    y = y > 0.008856 ? Math.pow(y, 0.3333333333333333) : 7.787 * y + 0.13793103448275862;
    z = z > 0.008856 ? Math.pow(z, 0.3333333333333333) : 7.787 * z + 0.13793103448275862;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };

  convert.hsl.rgb = function (hsl) {
    var h = hsl[0] / 360;
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;

    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }

    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }

    t1 = 2 * l - t2;
    rgb = [0, 0, 0];

    for (var i = 0; i < 3; i++) {
      t3 = h + 0.3333333333333333 * -(i - 1);

      if (t3 < 0) {
        t3++;
      }

      if (t3 > 1) {
        t3--;
      }

      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (0.6666666666666666 - t3) * 6;
      } else {
        val = t1;
      }

      rgb[i] = val * 255;
    }

    return rgb;
  };

  convert.hsl.hsv = function (hsl) {
    var h = hsl[0];
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s;
    var lmin = Math.max(l, 0.01);
    var sv;
    var v;
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v = (l + s) / 2;
    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };

  convert.hsv.rgb = function (hsv) {
    var h = hsv[0] / 60;
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h) % 6;
    var f = h - Math.floor(h);
    var p = 255 * v * (1 - s);
    var q = 255 * v * (1 - s * f);
    var t = 255 * v * (1 - s * (1 - f));
    v *= 255;

    switch (hi) {
      case 0:
        return [v, t, p];

      case 1:
        return [q, v, p];

      case 2:
        return [p, v, t];

      case 3:
        return [p, q, v];

      case 4:
        return [t, p, v];

      case 5:
        return [v, p, q];
    }
  };

  convert.hsv.hsl = function (hsv) {
    var h = hsv[0];
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var lmin;
    var sl;
    var l;
    l = (2 - s) * v;
    lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };

  convert.hwb.rgb = function (hwb) {
    var h = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i;
    var v;
    var f;
    var n;

    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }

    i = Math.floor(6 * h);
    v = 1 - bl;
    f = 6 * h - i;

    if ((i & 0x01) !== 0) {
      f = 1 - f;
    }

    n = wh + f * (v - wh);
    var r;
    var g;
    var b;

    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;

      case 1:
        r = n;
        g = v;
        b = wh;
        break;

      case 2:
        r = wh;
        g = v;
        b = n;
        break;

      case 3:
        r = wh;
        g = n;
        b = v;
        break;

      case 4:
        r = n;
        g = wh;
        b = v;
        break;

      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }

    return [r * 255, g * 255, b * 255];
  };

  convert.cmyk.rgb = function (cmyk) {
    var c = cmyk[0] / 100;
    var m = cmyk[1] / 100;
    var y = cmyk[2] / 100;
    var k = cmyk[3] / 100;
    var r;
    var g;
    var b;
    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };

  convert.xyz.rgb = function (xyz) {
    var x = xyz[0] / 100;
    var y = xyz[1] / 100;
    var z = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.0570;
    r = r > 0.0031308 ? 1.055 * Math.pow(r, 0.4166666666666667) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 0.4166666666666667) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 0.4166666666666667) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };

  convert.xyz.lab = function (xyz) {
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 0.3333333333333333) : 7.787 * x + 0.13793103448275862;
    y = y > 0.008856 ? Math.pow(y, 0.3333333333333333) : 7.787 * y + 0.13793103448275862;
    z = z > 0.008856 ? Math.pow(z, 0.3333333333333333) : 7.787 * z + 0.13793103448275862;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };

  convert.lab.xyz = function (lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y;
    var z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    var y2 = Math.pow(y, 3);
    var x2 = Math.pow(x, 3);
    var z2 = Math.pow(z, 3);
    y = y2 > 0.008856 ? y2 : (y - 0.13793103448275862) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 0.13793103448275862) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 0.13793103448275862) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };

  convert.lab.lch = function (lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var hr;
    var h;
    var c;
    hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;

    if (h < 0) {
      h += 360;
    }

    c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };

  convert.lch.lab = function (lch) {
    var l = lch[0];
    var c = lch[1];
    var h = lch[2];
    var a;
    var b;
    var hr;
    hr = h / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  };

  convert.rgb.ansi16 = function (args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
    value = Math.round(value / 50);

    if (value === 0) {
      return 30;
    }

    var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

    if (value === 2) {
      ansi += 60;
    }

    return ansi;
  };

  convert.hsv.ansi16 = function (args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };

  convert.rgb.ansi256 = function (args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];

    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }

      if (r > 248) {
        return 231;
      }

      return Math.round((r - 8) / 247 * 24) + 232;
    }

    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };

  convert.ansi16.rgb = function (args) {
    var color = args % 10;

    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }

      color = color / 10.5 * 255;
      return [color, color, color];
    }

    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g = (color >> 1 & 1) * mult * 255;
    var b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };

  convert.ansi256.rgb = function (args) {
    if (args >= 232) {
      var c = (args - 232) * 10 + 8;
      return [c, c, c];
    }

    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };

  convert.rgb.hex = function (args) {
    var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
    var string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  convert.hex.rgb = function (args) {
    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

    if (!match) {
      return [0, 0, 0];
    }

    var colorString = match[0];

    if (match[0].length === 3) {
      colorString = colorString.split('').map(function (char) {
        return char + char;
      }).join('');
    }

    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 0xFF;
    var g = integer >> 8 & 0xFF;
    var b = integer & 0xFF;
    return [r, g, b];
  };

  convert.rgb.hcg = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max = Math.max(Math.max(r, g), b);
    var min = Math.min(Math.min(r, g), b);
    var chroma = max - min;
    var grayscale;
    var hue;

    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }

    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma + 4;
    }

    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };

  convert.hsl.hcg = function (hsl) {
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = 1;
    var f = 0;

    if (l < 0.5) {
      c = 2.0 * s * l;
    } else {
      c = 2.0 * s * (1.0 - l);
    }

    if (c < 1.0) {
      f = (l - 0.5 * c) / (1.0 - c);
    }

    return [hsl[0], c * 100, f * 100];
  };

  convert.hsv.hcg = function (hsv) {
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s * v;
    var f = 0;

    if (c < 1.0) {
      f = (v - c) / (1 - c);
    }

    return [hsv[0], c * 100, f * 100];
  };

  convert.hcg.rgb = function (hcg) {
    var h = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;

    if (c === 0.0) {
      return [g * 255, g * 255, g * 255];
    }

    var pure = [0, 0, 0];
    var hi = h % 1 * 6;
    var v = hi % 1;
    var w = 1 - v;
    var mg = 0;

    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;

      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;

      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;

      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;

      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;

      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }

    mg = (1.0 - c) * g;
    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
  };

  convert.hcg.hsv = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1.0 - c);
    var f = 0;

    if (v > 0.0) {
      f = c / v;
    }

    return [hcg[0], f * 100, v * 100];
  };

  convert.hcg.hsl = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1.0 - c) + 0.5 * c;
    var s = 0;

    if (l > 0.0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1.0) {
      s = c / (2 * (1 - l));
    }

    return [hcg[0], s * 100, l * 100];
  };

  convert.hcg.hwb = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1.0 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };

  convert.hwb.hcg = function (hwb) {
    var w = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w;
    var g = 0;

    if (c < 1) {
      g = (v - c) / (1 - c);
    }

    return [hwb[0], c * 100, g * 100];
  };

  convert.apple.rgb = function (apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };

  convert.rgb.apple = function (rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };

  convert.gray.rgb = function (args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };

  convert.gray.hsl = convert.gray.hsv = function (args) {
    return [0, 0, args[0]];
  };

  convert.gray.hwb = function (gray) {
    return [0, 100, gray[0]];
  };

  convert.gray.cmyk = function (gray) {
    return [0, 0, 0, gray[0]];
  };

  convert.gray.lab = function (gray) {
    return [gray[0], 0, 0];
  };

  convert.gray.hex = function (gray) {
    var val = Math.round(gray[0] / 100 * 255) & 0xFF;
    var integer = (val << 16) + (val << 8) + val;
    var string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  convert.rgb.gray = function (rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
},"node_modules/color/node_modules/color-convert/conversions.js",["node_modules/color/node_modules/color-name/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
},"node_modules/color/node_modules/color-name/index.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function buildGraph() {
    var graph = {};
    var models = Object.keys(_$$_REQUIRE(_dependencyMap[0]));

    for (var len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }

    return graph;
  }

  function deriveBFS(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;

    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(_$$_REQUIRE(_dependencyMap[0])[current]);

      for (var len = adjacents.length, i = 0; i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];

        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }

    return graph;
  }

  function link(from, to) {
    return function (args) {
      return to(from(args));
    };
  }

  function wrapConversion(toModel, graph) {
    var path = [graph[toModel].parent, toModel];

    var fn = _$$_REQUIRE(_dependencyMap[0])[graph[toModel].parent][toModel];

    var cur = graph[toModel].parent;

    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(_$$_REQUIRE(_dependencyMap[0])[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }

    fn.conversion = path;
    return fn;
  }

  module.exports = function (fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);

    for (var len = models.length, i = 0; i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];

      if (node.parent === null) {
        continue;
      }

      conversion[toModel] = wrapConversion(toModel, graph);
    }

    return conversion;
  };
},"node_modules/color/node_modules/color-convert/route.js",["node_modules/color/node_modules/color-convert/conversions.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var hasOwnProperty = Object.hasOwnProperty;
  var reverseNames = Object.create(null);

  for (var name in _$$_REQUIRE(_dependencyMap[0])) {
    if (hasOwnProperty.call(_$$_REQUIRE(_dependencyMap[0]), name)) {
      reverseNames[_$$_REQUIRE(_dependencyMap[0])[name]] = name;
    }
  }

  var cs = module.exports = {
    to: {},
    get: {}
  };

  cs.get = function (string) {
    var prefix = string.substring(0, 3).toLowerCase();
    var val;
    var model;

    switch (prefix) {
      case 'hsl':
        val = cs.get.hsl(string);
        model = 'hsl';
        break;

      case 'hwb':
        val = cs.get.hwb(string);
        model = 'hwb';
        break;

      default:
        val = cs.get.rgb(string);
        model = 'rgb';
        break;
    }

    if (!val) {
      return null;
    }

    return {
      model: model,
      value: val
    };
  };

  cs.get.rgb = function (string) {
    if (!string) {
      return null;
    }

    var abbr = /^#([a-f0-9]{3,4})$/i;
    var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
    var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
    var keyword = /^(\w+)$/;
    var rgb = [0, 0, 0, 1];
    var match;
    var i;
    var hexAlpha;

    if (match = string.match(hex)) {
      hexAlpha = match[2];
      match = match[1];

      for (i = 0; i < 3; i++) {
        var i2 = i * 2;
        rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
      }

      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha, 16) / 255;
      }
    } else if (match = string.match(abbr)) {
      match = match[1];
      hexAlpha = match[3];

      for (i = 0; i < 3; i++) {
        rgb[i] = parseInt(match[i] + match[i], 16);
      }

      if (hexAlpha) {
        rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
      }
    } else if (match = string.match(rgba)) {
      for (i = 0; i < 3; i++) {
        rgb[i] = parseInt(match[i + 1], 0);
      }

      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(per)) {
      for (i = 0; i < 3; i++) {
        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }

      if (match[4]) {
        if (match[5]) {
          rgb[3] = parseFloat(match[4]) * 0.01;
        } else {
          rgb[3] = parseFloat(match[4]);
        }
      }
    } else if (match = string.match(keyword)) {
      if (match[1] === 'transparent') {
        return [0, 0, 0, 0];
      }

      if (!hasOwnProperty.call(_$$_REQUIRE(_dependencyMap[0]), match[1])) {
        return null;
      }

      rgb = _$$_REQUIRE(_dependencyMap[0])[match[1]];
      rgb[3] = 1;
      return rgb;
    } else {
      return null;
    }

    for (i = 0; i < 3; i++) {
      rgb[i] = clamp(rgb[i], 0, 255);
    }

    rgb[3] = clamp(rgb[3], 0, 1);
    return rgb;
  };

  cs.get.hsl = function (string) {
    if (!string) {
      return null;
    }

    var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hsl);

    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var s = clamp(parseFloat(match[2]), 0, 100);
      var l = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
    }

    return null;
  };

  cs.get.hwb = function (string) {
    if (!string) {
      return null;
    }

    var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    var match = string.match(hwb);

    if (match) {
      var alpha = parseFloat(match[4]);
      var h = (parseFloat(match[1]) % 360 + 360) % 360;
      var w = clamp(parseFloat(match[2]), 0, 100);
      var b = clamp(parseFloat(match[3]), 0, 100);
      var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
    }

    return null;
  };

  cs.to.hex = function () {
    var rgba = _$$_REQUIRE(_dependencyMap[1])(arguments);

    return '#' + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : '');
  };

  cs.to.rgb = function () {
    var rgba = _$$_REQUIRE(_dependencyMap[1])(arguments);

    return rgba.length < 4 || rgba[3] === 1 ? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')' : 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
  };

  cs.to.rgb.percent = function () {
    var rgba = _$$_REQUIRE(_dependencyMap[1])(arguments);

    var r = Math.round(rgba[0] / 255 * 100);
    var g = Math.round(rgba[1] / 255 * 100);
    var b = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)' : 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
  };

  cs.to.hsl = function () {
    var hsla = _$$_REQUIRE(_dependencyMap[1])(arguments);

    return hsla.length < 4 || hsla[3] === 1 ? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)' : 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
  };

  cs.to.hwb = function () {
    var hwba = _$$_REQUIRE(_dependencyMap[1])(arguments);

    var a = '';

    if (hwba.length >= 4 && hwba[3] !== 1) {
      a = ', ' + hwba[3];
    }

    return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
  };

  cs.to.keyword = function (rgb) {
    return reverseNames[rgb.slice(0, 3)];
  };

  function clamp(num, min, max) {
    return Math.min(Math.max(min, num), max);
  }

  function hexDouble(num) {
    var str = Math.round(num).toString(16).toUpperCase();
    return str.length < 2 ? '0' + str : str;
  }
},"node_modules/color-string/index.js",["node_modules/color-name/index.js","node_modules/simple-swizzle/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  module.exports = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
},"node_modules/color-name/index.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var concat = Array.prototype.concat;
  var slice = Array.prototype.slice;

  var swizzle = module.exports = function swizzle(args) {
    var results = [];

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];

      if (_$$_REQUIRE(_dependencyMap[0])(arg)) {
        results = concat.call(results, slice.call(arg));
      } else {
        results.push(arg);
      }
    }

    return results;
  };

  swizzle.wrap = function (fn) {
    return function () {
      return fn(swizzle(arguments));
    };
  };
},"node_modules/simple-swizzle/index.js",["node_modules/simple-swizzle/node_modules/is-arrayish/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = function isArrayish(obj) {
    if (!obj || typeof obj === 'string') {
      return false;
    }

    return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== 'String');
  };
},"node_modules/simple-swizzle/node_modules/is-arrayish/index.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getDistanceForDirection;

  var _getInvertedMultiplier = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  function getDistanceForDirection(layout, gestureDirection) {
    var multiplier = (0, _getInvertedMultiplier.default)(gestureDirection);

    switch (gestureDirection) {
      case 'vertical':
      case 'vertical-inverted':
        return layout.height * multiplier;

      case 'horizontal':
      case 'horizontal-inverted':
        return layout.width * multiplier;
    }
  }
},"node_modules/@react-navigation/stack/src/utils/getDistanceForDirection.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/stack/src/utils/getInvertedMultiplier.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getInvertedMultiplier;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0]);

  function getInvertedMultiplier(gestureDirection) {
    switch (gestureDirection) {
      case 'vertical':
        return 1;

      case 'vertical-inverted':
        return -1;

      case 'horizontal':
        return _reactNative.I18nManager.isRTL ? -1 : 1;

      case 'horizontal-inverted':
        return _reactNative.I18nManager.isRTL ? 1 : -1;
    }
  }
},"node_modules/@react-navigation/stack/src/utils/getInvertedMultiplier.tsx",["node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[3]);

  var _ModalPresentationContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _useKeyboardManager2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _Card = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var EPSILON = 0.1;

  function CardContainer(_ref) {
    var interpolationIndex = _ref.interpolationIndex,
        index = _ref.index,
        active = _ref.active,
        closing = _ref.closing,
        gesture = _ref.gesture,
        focused = _ref.focused,
        modal = _ref.modal,
        getPreviousScene = _ref.getPreviousScene,
        getFocusedRoute = _ref.getFocusedRoute,
        headerDarkContent = _ref.headerDarkContent,
        hasAbsoluteFloatHeader = _ref.hasAbsoluteFloatHeader,
        headerHeight = _ref.headerHeight,
        onHeaderHeightChange = _ref.onHeaderHeightChange,
        isParentHeaderShown = _ref.isParentHeaderShown,
        isNextScreenTransparent = _ref.isNextScreenTransparent,
        detachCurrentScreen = _ref.detachCurrentScreen,
        layout = _ref.layout,
        onCloseRoute = _ref.onCloseRoute,
        onOpenRoute = _ref.onOpenRoute,
        onGestureCancel = _ref.onGestureCancel,
        onGestureEnd = _ref.onGestureEnd,
        onGestureStart = _ref.onGestureStart,
        onTransitionEnd = _ref.onTransitionEnd,
        onTransitionStart = _ref.onTransitionStart,
        renderHeader = _ref.renderHeader,
        renderScene = _ref.renderScene,
        safeAreaInsetBottom = _ref.safeAreaInsetBottom,
        safeAreaInsetLeft = _ref.safeAreaInsetLeft,
        safeAreaInsetRight = _ref.safeAreaInsetRight,
        safeAreaInsetTop = _ref.safeAreaInsetTop,
        scene = _ref.scene;
    var parentHeaderHeight = React.useContext(_$$_REQUIRE(_dependencyMap[7]).HeaderHeightContext);

    var _useKeyboardManager = (0, _useKeyboardManager2.default)(React.useCallback(function () {
      var _scene$descriptor = scene.descriptor,
          options = _scene$descriptor.options,
          navigation = _scene$descriptor.navigation;
      return navigation.isFocused() && options.keyboardHandlingEnabled !== false;
    }, [scene.descriptor])),
        onPageChangeStart = _useKeyboardManager.onPageChangeStart,
        onPageChangeCancel = _useKeyboardManager.onPageChangeCancel,
        onPageChangeConfirm = _useKeyboardManager.onPageChangeConfirm;

    var handleOpen = function handleOpen() {
      var route = scene.descriptor.route;
      onTransitionEnd({
        route: route
      }, false);
      onOpenRoute({
        route: route
      });
    };

    var handleClose = function handleClose() {
      var route = scene.descriptor.route;
      onTransitionEnd({
        route: route
      }, true);
      onCloseRoute({
        route: route
      });
    };

    var handleGestureBegin = function handleGestureBegin() {
      var route = scene.descriptor.route;
      onPageChangeStart();
      onGestureStart({
        route: route
      });
    };

    var handleGestureCanceled = function handleGestureCanceled() {
      var route = scene.descriptor.route;
      onPageChangeCancel();
      onGestureCancel({
        route: route
      });
    };

    var handleGestureEnd = function handleGestureEnd() {
      var route = scene.descriptor.route;
      onGestureEnd({
        route: route
      });
    };

    var handleTransition = function handleTransition(_ref2) {
      var closing = _ref2.closing,
          gesture = _ref2.gesture;
      var route = scene.descriptor.route;

      if (!gesture) {
        onPageChangeConfirm == null ? undefined : onPageChangeConfirm(true);
      } else if (active && closing) {
        onPageChangeConfirm == null ? undefined : onPageChangeConfirm(false);
      } else {
        onPageChangeCancel == null ? undefined : onPageChangeCancel();
      }

      onTransitionStart == null ? undefined : onTransitionStart({
        route: route
      }, closing);
    };

    var insets = {
      top: safeAreaInsetTop,
      right: safeAreaInsetRight,
      bottom: safeAreaInsetBottom,
      left: safeAreaInsetLeft
    };

    var _useTheme = (0, _$$_REQUIRE(_dependencyMap[8]).useTheme)(),
        colors = _useTheme.colors;

    var _React$useState = React.useState('box-none'),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
        pointerEvents = _React$useState2[0],
        setPointerEvents = _React$useState2[1];

    React.useEffect(function () {
      var _scene$progress$next;

      var listener = (_scene$progress$next = scene.progress.next) == null ? undefined : _scene$progress$next.addListener == null ? undefined : _scene$progress$next.addListener(function (_ref3) {
        var value = _ref3.value;
        setPointerEvents(value <= EPSILON ? 'box-none' : 'none');
      });
      return function () {
        if (listener) {
          var _scene$progress$next2;

          (_scene$progress$next2 = scene.progress.next) == null ? undefined : _scene$progress$next2.removeListener == null ? undefined : _scene$progress$next2.removeListener(listener);
        }
      };
    }, [pointerEvents, scene.progress.next]);
    var _scene$descriptor$opt = scene.descriptor.options,
        presentation = _scene$descriptor$opt.presentation,
        animationEnabled = _scene$descriptor$opt.animationEnabled,
        cardOverlay = _scene$descriptor$opt.cardOverlay,
        cardOverlayEnabled = _scene$descriptor$opt.cardOverlayEnabled,
        cardShadowEnabled = _scene$descriptor$opt.cardShadowEnabled,
        cardStyle = _scene$descriptor$opt.cardStyle,
        cardStyleInterpolator = _scene$descriptor$opt.cardStyleInterpolator,
        gestureDirection = _scene$descriptor$opt.gestureDirection,
        gestureEnabled = _scene$descriptor$opt.gestureEnabled,
        gestureResponseDistance = _scene$descriptor$opt.gestureResponseDistance,
        gestureVelocityImpact = _scene$descriptor$opt.gestureVelocityImpact,
        headerMode = _scene$descriptor$opt.headerMode,
        headerShown = _scene$descriptor$opt.headerShown,
        transitionSpec = _scene$descriptor$opt.transitionSpec;
    var previousScene = getPreviousScene({
      route: scene.descriptor.route
    });
    var backTitle;

    if (previousScene) {
      var _previousScene$descri = previousScene.descriptor,
          options = _previousScene$descri.options,
          route = _previousScene$descri.route;
      backTitle = (0, _$$_REQUIRE(_dependencyMap[7]).getHeaderTitle)(options, route.name);
    }

    var headerBack = React.useMemo(function () {
      return backTitle !== undefined ? {
        title: backTitle
      } : undefined;
    }, [backTitle]);
    return React.createElement(_Card.default, {
      interpolationIndex: interpolationIndex,
      gestureDirection: gestureDirection,
      layout: layout,
      insets: insets,
      gesture: gesture,
      current: scene.progress.current,
      next: scene.progress.next,
      closing: closing,
      onOpen: handleOpen,
      onClose: handleClose,
      overlay: cardOverlay,
      overlayEnabled: cardOverlayEnabled,
      shadowEnabled: cardShadowEnabled,
      onTransition: handleTransition,
      onGestureBegin: handleGestureBegin,
      onGestureCanceled: handleGestureCanceled,
      onGestureEnd: handleGestureEnd,
      gestureEnabled: index === 0 ? false : gestureEnabled,
      gestureResponseDistance: gestureResponseDistance,
      gestureVelocityImpact: gestureVelocityImpact,
      transitionSpec: transitionSpec,
      styleInterpolator: cardStyleInterpolator,
      accessibilityElementsHidden: !focused,
      importantForAccessibility: focused ? 'auto' : 'no-hide-descendants',
      pointerEvents: active ? 'box-none' : pointerEvents,
      pageOverflowEnabled: headerMode !== 'float' && presentation !== 'modal',
      headerDarkContent: headerDarkContent,
      containerStyle: hasAbsoluteFloatHeader && headerMode !== 'screen' ? {
        marginTop: headerHeight
      } : null,
      contentStyle: [{
        backgroundColor: presentation === 'transparentModal' ? 'transparent' : colors.background
      }, cardStyle],
      style: [{
        overflow: active ? undefined : 'hidden',
        display: animationEnabled === false && isNextScreenTransparent === false && detachCurrentScreen !== false && !focused ? 'none' : 'flex'
      }, _reactNative.StyleSheet.absoluteFill]
    }, React.createElement(_reactNative.View, {
      style: styles.container
    }, React.createElement(_ModalPresentationContext.default.Provider, {
      value: modal
    }, React.createElement(_reactNative.View, {
      style: styles.scene
    }, React.createElement(_$$_REQUIRE(_dependencyMap[7]).HeaderBackContext.Provider, {
      value: headerBack
    }, React.createElement(_$$_REQUIRE(_dependencyMap[7]).HeaderShownContext.Provider, {
      value: isParentHeaderShown || headerShown !== false
    }, React.createElement(_$$_REQUIRE(_dependencyMap[7]).HeaderHeightContext.Provider, {
      value: headerShown ? headerHeight : parentHeaderHeight != null ? parentHeaderHeight : 0
    }, renderScene({
      route: scene.descriptor.route
    }))))), headerMode !== 'float' ? renderHeader({
      mode: 'screen',
      layout: layout,
      scenes: [previousScene, scene],
      getPreviousScene: getPreviousScene,
      getFocusedRoute: getFocusedRoute,
      onContentHeightChange: onHeaderHeightChange
    }) : null)));
  }

  var _default = React.memo(CardContainer);

  exports.default = _default;

  var styles = _reactNative.StyleSheet.create({
    container: {
      flex: 1,
      flexDirection: 'column-reverse'
    },
    scene: {
      flex: 1
    }
  });
},"node_modules/@react-navigation/stack/src/views/Stack/CardContainer.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@react-navigation/stack/src/utils/ModalPresentationContext.tsx","node_modules/@react-navigation/stack/src/utils/useKeyboardManager.tsx","node_modules/@react-navigation/stack/src/views/Stack/Card.tsx","node_modules/@react-navigation/elements/src/index.tsx","node_modules/@react-navigation/native/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useKeyboardManager;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[1]);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useKeyboardManager(isEnabled) {
    var previouslyFocusedTextInputRef = React.useRef(undefined);
    var startTimestampRef = React.useRef(0);
    var keyboardTimeoutRef = React.useRef();
    var clearKeyboardTimeout = React.useCallback(function () {
      if (keyboardTimeoutRef.current !== undefined) {
        clearTimeout(keyboardTimeoutRef.current);
        keyboardTimeoutRef.current = undefined;
      }
    }, []);
    var onPageChangeStart = React.useCallback(function () {
      if (!isEnabled()) {
        return;
      }

      clearKeyboardTimeout();

      var input = _reactNative.TextInput.State.currentlyFocusedInput();

      input == null ? undefined : input.blur();
      previouslyFocusedTextInputRef.current = input;
      startTimestampRef.current = Date.now();
    }, [clearKeyboardTimeout, isEnabled]);
    var onPageChangeConfirm = React.useCallback(function (force) {
      if (!isEnabled()) {
        return;
      }

      clearKeyboardTimeout();

      if (force) {
        _reactNative.Keyboard.dismiss();
      } else {
        var input = previouslyFocusedTextInputRef.current;
        input == null ? undefined : input.blur();
      }

      previouslyFocusedTextInputRef.current = undefined;
    }, [clearKeyboardTimeout, isEnabled]);
    var onPageChangeCancel = React.useCallback(function () {
      if (!isEnabled()) {
        return;
      }

      clearKeyboardTimeout();
      var input = previouslyFocusedTextInputRef.current;

      if (input) {
        if (Date.now() - startTimestampRef.current < 100) {
          keyboardTimeoutRef.current = setTimeout(function () {
            input == null ? undefined : input.focus();
            previouslyFocusedTextInputRef.current = undefined;
          }, 100);
        } else {
          input == null ? undefined : input.focus();
          previouslyFocusedTextInputRef.current = undefined;
        }
      }
    }, [clearKeyboardTimeout, isEnabled]);
    React.useEffect(function () {
      return function () {
        return clearKeyboardTimeout();
      };
    }, [clearKeyboardTimeout]);
    return {
      onPageChangeStart: onPageChangeStart,
      onPageChangeConfirm: onPageChangeConfirm,
      onPageChangeCancel: onPageChangeCancel
    };
  }
},"node_modules/@react-navigation/stack/src/utils/useKeyboardManager.tsx",["node_modules/react/index.js","node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getIsModalPresentation = exports.default = undefined;

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _color = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[9]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[10]);

  var _CardAnimationContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _getDistanceForDirection = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var _getInvertedMultiplier = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[13]));

  var _memoize = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[14]));

  var _ModalStatusBarManager = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[15]));

  var _CardSheet = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[16]));

  var _excluded = ["styleInterpolator", "interpolationIndex", "current", "gesture", "next", "layout", "insets", "overlay", "overlayEnabled", "shadowEnabled", "gestureEnabled", "gestureDirection", "pageOverflowEnabled", "headerDarkContent", "children", "containerStyle", "contentStyle"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var GESTURE_VELOCITY_IMPACT = 0.3;
  var TRUE = 1;
  var FALSE = 0;
  var GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 50;
  var GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;
  var useNativeDriver = _reactNative.Platform.OS !== 'web';

  var hasOpacityStyle = function hasOpacityStyle(style) {
    if (style) {
      var flattenedStyle = _reactNative.StyleSheet.flatten(style);

      return flattenedStyle.opacity != null;
    }

    return false;
  };

  var Card = function (_React$Component) {
    (0, _inherits2.default)(Card, _React$Component);

    var _super = _createSuper(Card);

    function Card() {
      var _this;

      (0, _classCallCheck2.default)(this, Card);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.isCurrentlyMounted = false;
      _this.isClosing = new _reactNative.Animated.Value(FALSE);
      _this.inverted = new _reactNative.Animated.Value((0, _getInvertedMultiplier.default)(_this.props.gestureDirection));
      _this.layout = {
        width: new _reactNative.Animated.Value(_this.props.layout.width),
        height: new _reactNative.Animated.Value(_this.props.layout.height)
      };
      _this.isSwiping = new _reactNative.Animated.Value(FALSE);

      _this.animate = function (_ref) {
        var closing = _ref.closing,
            velocity = _ref.velocity;
        var _this$props = _this.props,
            gesture = _this$props.gesture,
            transitionSpec = _this$props.transitionSpec,
            onOpen = _this$props.onOpen,
            onClose = _this$props.onClose,
            onTransition = _this$props.onTransition;

        var toValue = _this.getAnimateToValue((0, _extends2.default)({}, _this.props, {
          closing: closing
        }));

        _this.lastToValue = toValue;

        _this.isClosing.setValue(closing ? TRUE : FALSE);

        var spec = closing ? transitionSpec.close : transitionSpec.open;
        var animation = spec.animation === 'spring' ? _reactNative.Animated.spring : _reactNative.Animated.timing;

        _this.setPointerEventsEnabled(!closing);

        _this.handleStartInteraction();

        clearTimeout(_this.pendingGestureCallback);
        onTransition == null ? undefined : onTransition({
          closing: closing,
          gesture: velocity !== undefined
        });
        animation(gesture, (0, _extends2.default)({}, spec.config, {
          velocity: velocity,
          toValue: toValue,
          useNativeDriver: useNativeDriver,
          isInteraction: false
        })).start(function (_ref2) {
          var finished = _ref2.finished;

          _this.handleEndInteraction();

          clearTimeout(_this.pendingGestureCallback);

          if (finished) {
            if (closing) {
              onClose();
            } else {
              onOpen();
            }

            if (_this.isCurrentlyMounted) {
              _this.forceUpdate();
            }
          }
        });
      };

      _this.getAnimateToValue = function (_ref3) {
        var closing = _ref3.closing,
            layout = _ref3.layout,
            gestureDirection = _ref3.gestureDirection;

        if (!closing) {
          return 0;
        }

        return (0, _getDistanceForDirection.default)(layout, gestureDirection);
      };

      _this.setPointerEventsEnabled = function (enabled) {
        var _this$contentRef$curr;

        var pointerEvents = enabled ? 'box-none' : 'none';
        (_this$contentRef$curr = _this.contentRef.current) == null ? undefined : _this$contentRef$curr.setNativeProps({
          pointerEvents: pointerEvents
        });
      };

      _this.handleStartInteraction = function () {
        if (_this.interactionHandle === undefined) {
          _this.interactionHandle = _reactNative.InteractionManager.createInteractionHandle();
        }
      };

      _this.handleEndInteraction = function () {
        if (_this.interactionHandle !== undefined) {
          _reactNative.InteractionManager.clearInteractionHandle(_this.interactionHandle);

          _this.interactionHandle = undefined;
        }
      };

      _this.handleGestureStateChange = function (_ref4) {
        var nativeEvent = _ref4.nativeEvent;
        var _this$props2 = _this.props,
            layout = _this$props2.layout,
            onClose = _this$props2.onClose,
            onGestureBegin = _this$props2.onGestureBegin,
            onGestureCanceled = _this$props2.onGestureCanceled,
            onGestureEnd = _this$props2.onGestureEnd,
            gestureDirection = _this$props2.gestureDirection,
            gestureVelocityImpact = _this$props2.gestureVelocityImpact;

        switch (nativeEvent.state) {
          case _$$_REQUIRE(_dependencyMap[17]).GestureState.ACTIVE:
            _this.isSwiping.setValue(TRUE);

            _this.handleStartInteraction();

            onGestureBegin == null ? undefined : onGestureBegin();
            break;

          case _$$_REQUIRE(_dependencyMap[17]).GestureState.CANCELLED:
            {
              _this.isSwiping.setValue(FALSE);

              _this.handleEndInteraction();

              var velocity = gestureDirection === 'vertical' || gestureDirection === 'vertical-inverted' ? nativeEvent.velocityY : nativeEvent.velocityX;

              _this.animate({
                closing: _this.props.closing,
                velocity: velocity
              });

              onGestureCanceled == null ? undefined : onGestureCanceled();
              break;
            }

          case _$$_REQUIRE(_dependencyMap[17]).GestureState.END:
            {
              _this.isSwiping.setValue(FALSE);

              var distance;
              var translation;

              var _velocity;

              if (gestureDirection === 'vertical' || gestureDirection === 'vertical-inverted') {
                distance = layout.height;
                translation = nativeEvent.translationY;
                _velocity = nativeEvent.velocityY;
              } else {
                distance = layout.width;
                translation = nativeEvent.translationX;
                _velocity = nativeEvent.velocityX;
              }

              var closing = (translation + _velocity * gestureVelocityImpact) * (0, _getInvertedMultiplier.default)(gestureDirection) > distance / 2 ? _velocity !== 0 || translation !== 0 : _this.props.closing;

              _this.animate({
                closing: closing,
                velocity: _velocity
              });

              if (closing) {
                _this.pendingGestureCallback = setTimeout(function () {
                  onClose();

                  _this.forceUpdate();
                }, 32);
              }

              onGestureEnd == null ? undefined : onGestureEnd();
              break;
            }
        }
      };

      _this.getInterpolatedStyle = (0, _memoize.default)(function (styleInterpolator, animation) {
        return styleInterpolator(animation);
      });
      _this.getCardAnimation = (0, _memoize.default)(function (interpolationIndex, current, next, layout, insetTop, insetRight, insetBottom, insetLeft) {
        return {
          index: interpolationIndex,
          current: {
            progress: current
          },
          next: next && {
            progress: next
          },
          closing: _this.isClosing,
          swiping: _this.isSwiping,
          inverted: _this.inverted,
          layouts: {
            screen: layout
          },
          insets: {
            top: insetTop,
            right: insetRight,
            bottom: insetBottom,
            left: insetLeft
          }
        };
      });
      _this.contentRef = React.createRef();
      return _this;
    }

    (0, _createClass2.default)(Card, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.animate({
          closing: this.props.closing
        });
        this.isCurrentlyMounted = true;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this$props3 = this.props,
            layout = _this$props3.layout,
            gestureDirection = _this$props3.gestureDirection,
            closing = _this$props3.closing;
        var width = layout.width,
            height = layout.height;

        if (width !== prevProps.layout.width) {
          this.layout.width.setValue(width);
        }

        if (height !== prevProps.layout.height) {
          this.layout.height.setValue(height);
        }

        if (gestureDirection !== prevProps.gestureDirection) {
          this.inverted.setValue((0, _getInvertedMultiplier.default)(gestureDirection));
        }

        var toValue = this.getAnimateToValue(this.props);

        if (this.getAnimateToValue(prevProps) !== toValue || this.lastToValue !== toValue) {
          this.animate({
            closing: closing
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.props.gesture.stopAnimation();
        this.isCurrentlyMounted = false;
        this.handleEndInteraction();
      }
    }, {
      key: "gestureActivationCriteria",
      value: function gestureActivationCriteria() {
        var _this$props4 = this.props,
            layout = _this$props4.layout,
            gestureDirection = _this$props4.gestureDirection,
            gestureResponseDistance = _this$props4.gestureResponseDistance;
        var enableTrackpadTwoFingerGesture = true;
        var distance = gestureResponseDistance !== undefined ? gestureResponseDistance : gestureDirection === 'vertical' || gestureDirection === 'vertical-inverted' ? GESTURE_RESPONSE_DISTANCE_VERTICAL : GESTURE_RESPONSE_DISTANCE_HORIZONTAL;

        if (gestureDirection === 'vertical') {
          return {
            maxDeltaX: 15,
            minOffsetY: 5,
            hitSlop: {
              bottom: -layout.height + distance
            },
            enableTrackpadTwoFingerGesture: enableTrackpadTwoFingerGesture
          };
        } else if (gestureDirection === 'vertical-inverted') {
          return {
            maxDeltaX: 15,
            minOffsetY: -5,
            hitSlop: {
              top: -layout.height + distance
            },
            enableTrackpadTwoFingerGesture: enableTrackpadTwoFingerGesture
          };
        } else {
          var hitSlop = -layout.width + distance;
          var invertedMultiplier = (0, _getInvertedMultiplier.default)(gestureDirection);

          if (invertedMultiplier === 1) {
            return {
              minOffsetX: 5,
              maxDeltaY: 20,
              hitSlop: {
                right: hitSlop
              },
              enableTrackpadTwoFingerGesture: enableTrackpadTwoFingerGesture
            };
          } else {
            return {
              minOffsetX: -5,
              maxDeltaY: 20,
              hitSlop: {
                left: hitSlop
              },
              enableTrackpadTwoFingerGesture: enableTrackpadTwoFingerGesture
            };
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props5 = this.props,
            styleInterpolator = _this$props5.styleInterpolator,
            interpolationIndex = _this$props5.interpolationIndex,
            current = _this$props5.current,
            gesture = _this$props5.gesture,
            next = _this$props5.next,
            layout = _this$props5.layout,
            insets = _this$props5.insets,
            overlay = _this$props5.overlay,
            overlayEnabled = _this$props5.overlayEnabled,
            shadowEnabled = _this$props5.shadowEnabled,
            gestureEnabled = _this$props5.gestureEnabled,
            gestureDirection = _this$props5.gestureDirection,
            pageOverflowEnabled = _this$props5.pageOverflowEnabled,
            headerDarkContent = _this$props5.headerDarkContent,
            children = _this$props5.children,
            customContainerStyle = _this$props5.containerStyle,
            contentStyle = _this$props5.contentStyle,
            rest = (0, _objectWithoutProperties2.default)(_this$props5, _excluded);
        var interpolationProps = this.getCardAnimation(interpolationIndex, current, next, layout, insets.top, insets.right, insets.bottom, insets.left);
        var interpolatedStyle = this.getInterpolatedStyle(styleInterpolator, interpolationProps);
        var containerStyle = interpolatedStyle.containerStyle,
            cardStyle = interpolatedStyle.cardStyle,
            overlayStyle = interpolatedStyle.overlayStyle,
            shadowStyle = interpolatedStyle.shadowStyle;
        var handleGestureEvent = gestureEnabled ? _reactNative.Animated.event([{
          nativeEvent: gestureDirection === 'vertical' || gestureDirection === 'vertical-inverted' ? {
            translationY: gesture
          } : {
            translationX: gesture
          }
        }], {
          useNativeDriver: useNativeDriver
        }) : undefined;

        var _StyleSheet$flatten = _reactNative.StyleSheet.flatten(contentStyle || {}),
            backgroundColor = _StyleSheet$flatten.backgroundColor;

        var isTransparent = typeof backgroundColor === 'string' ? (0, _color.default)(backgroundColor).alpha() === 0 : false;
        return React.createElement(_CardAnimationContext.default.Provider, {
          value: interpolationProps
        }, _reactNative.Platform.OS === 'ios' && overlayEnabled && next && getIsModalPresentation(styleInterpolator) ? React.createElement(_ModalStatusBarManager.default, {
          dark: headerDarkContent,
          layout: layout,
          insets: insets,
          style: cardStyle
        }) : null, React.createElement(_reactNative.Animated.View, {
          style: {
            opacity: current
          },
          collapsable: false
        }), React.createElement(_reactNative.View, (0, _extends2.default)({
          pointerEvents: "box-none"
        }, rest), overlayEnabled ? React.createElement(_reactNative.View, {
          pointerEvents: "box-none",
          style: _reactNative.StyleSheet.absoluteFill
        }, overlay({
          style: overlayStyle
        })) : null, React.createElement(_reactNative.Animated.View, {
          style: [styles.container, containerStyle, customContainerStyle],
          pointerEvents: "box-none"
        }, React.createElement(_$$_REQUIRE(_dependencyMap[17]).PanGestureHandler, (0, _extends2.default)({
          enabled: layout.width !== 0 && gestureEnabled,
          onGestureEvent: handleGestureEvent,
          onHandlerStateChange: this.handleGestureStateChange
        }, this.gestureActivationCriteria()), React.createElement(_reactNative.Animated.View, {
          needsOffscreenAlphaCompositing: hasOpacityStyle(cardStyle),
          style: [styles.container, cardStyle]
        }, shadowEnabled && shadowStyle && !isTransparent ? React.createElement(_reactNative.Animated.View, {
          style: [styles.shadow, gestureDirection === 'horizontal' ? [styles.shadowHorizontal, styles.shadowLeft] : gestureDirection === 'horizontal-inverted' ? [styles.shadowHorizontal, styles.shadowRight] : gestureDirection === 'vertical' ? [styles.shadowVertical, styles.shadowTop] : [styles.shadowVertical, styles.shadowBottom], {
            backgroundColor: backgroundColor
          }, shadowStyle],
          pointerEvents: "none"
        }) : null, React.createElement(_CardSheet.default, {
          ref: this.contentRef,
          enabled: pageOverflowEnabled,
          layout: layout,
          style: contentStyle
        }, children))))));
      }
    }]);
    return Card;
  }(React.Component);

  exports.default = Card;
  Card.defaultProps = {
    shadowEnabled: false,
    gestureEnabled: true,
    gestureVelocityImpact: GESTURE_VELOCITY_IMPACT,
    overlay: function overlay(_ref5) {
      var style = _ref5.style;
      return style ? React.createElement(_reactNative.Animated.View, {
        pointerEvents: "none",
        style: [styles.overlay, style]
      }) : null;
    }
  };

  var getIsModalPresentation = function getIsModalPresentation(cardStyleInterpolator) {
    return cardStyleInterpolator === _$$_REQUIRE(_dependencyMap[18]).forModalPresentationIOS || cardStyleInterpolator.name === 'forModalPresentationIOS';
  };

  exports.getIsModalPresentation = getIsModalPresentation;

  var styles = _reactNative.StyleSheet.create({
    container: {
      flex: 1
    },
    overlay: {
      flex: 1,
      backgroundColor: '#000'
    },
    shadow: {
      position: 'absolute',
      shadowRadius: 5,
      shadowColor: '#000',
      shadowOpacity: 0.3
    },
    shadowHorizontal: {
      top: 0,
      bottom: 0,
      width: 3,
      shadowOffset: {
        width: -1,
        height: 1
      }
    },
    shadowLeft: {
      left: 0
    },
    shadowRight: {
      right: 0
    },
    shadowVertical: {
      left: 0,
      right: 0,
      height: 3,
      shadowOffset: {
        width: 1,
        height: -1
      }
    },
    shadowTop: {
      top: 0
    },
    shadowBottom: {
      bottom: 0
    }
  });
},"node_modules/@react-navigation/stack/src/views/Stack/Card.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/color/index.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@react-navigation/stack/src/utils/CardAnimationContext.tsx","node_modules/@react-navigation/stack/src/utils/getDistanceForDirection.tsx","node_modules/@react-navigation/stack/src/utils/getInvertedMultiplier.tsx","node_modules/@react-navigation/stack/src/utils/memoize.tsx","node_modules/@react-navigation/stack/src/views/ModalStatusBarManager.tsx","node_modules/@react-navigation/stack/src/views/Stack/CardSheet.tsx","node_modules/@react-navigation/stack/src/views/GestureHandler.ios.tsx","node_modules/@react-navigation/stack/src/TransitionConfigs/CardStyleInterpolators.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = React.createContext(undefined);

  exports.default = _default;
},"node_modules/@react-navigation/stack/src/utils/CardAnimationContext.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ModalStatusBarManager;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[3]);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function ModalStatusBarManager(_ref) {
    var _flattenedStyle$trans, _flattenedStyle$trans2;

    var dark = _ref.dark,
        layout = _ref.layout,
        insets = _ref.insets,
        style = _ref.style;

    var _useTheme = (0, _$$_REQUIRE(_dependencyMap[4]).useTheme)(),
        darkTheme = _useTheme.dark;

    var _React$useState = React.useState(true),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
        overlapping = _React$useState2[0],
        setOverlapping = _React$useState2[1];

    var scale = 1 - 20 / layout.width;
    var offset = (insets.top - 34) * scale;

    var flattenedStyle = _reactNative.StyleSheet.flatten(style);

    var translateY = flattenedStyle == null ? undefined : (_flattenedStyle$trans = flattenedStyle.transform) == null ? undefined : (_flattenedStyle$trans2 = _flattenedStyle$trans.find(function (s) {
      return s.translateY !== undefined;
    })) == null ? undefined : _flattenedStyle$trans2.translateY;
    React.useEffect(function () {
      var listener = function listener(_ref2) {
        var value = _ref2.value;
        setOverlapping(value < offset);
      };

      var sub = translateY == null ? undefined : translateY.addListener(listener);
      return function () {
        return translateY == null ? undefined : translateY.removeListener(sub);
      };
    }, [offset, translateY]);
    var darkContent = dark != null ? dark : !darkTheme;
    return React.createElement(_reactNative.StatusBar, {
      animated: true,
      barStyle: overlapping && darkContent ? 'dark-content' : 'light-content'
    });
  }
},"node_modules/@react-navigation/stack/src/views/ModalStatusBarManager.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@react-navigation/native/src/index.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[4]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[5]);

  var _excluded = ["enabled", "layout", "style"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = React.forwardRef(function CardSheet(_ref, ref) {
    var enabled = _ref.enabled,
        layout = _ref.layout,
        style = _ref.style,
        rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);

    var _React$useState = React.useState(false),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
        fill = _React$useState2[0],
        setFill = _React$useState2[1];

    React.useEffect(function () {
      if (typeof document === 'undefined' || !document.body) {
        return;
      }

      var width = document.body.clientWidth;
      var height = document.body.clientHeight;
      setFill(width === layout.width && height === layout.height);
    }, [layout.height, layout.width]);
    return React.createElement(_reactNative.View, (0, _extends2.default)({}, rest, {
      ref: ref,
      style: [enabled && fill ? styles.page : styles.card, style]
    }));
  });

  exports.default = _default;

  var styles = _reactNative.StyleSheet.create({
    page: {
      minHeight: '100%'
    },
    card: {
      flex: 1,
      overflow: 'hidden'
    }
  });
},"node_modules/@react-navigation/stack/src/views/Stack/CardSheet.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.keys(_$$_REQUIRE(_dependencyMap[0])).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[0])[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[0])[key];
      }
    });
  });
},"node_modules/@react-navigation/stack/src/views/GestureHandler.ios.tsx",["node_modules/@react-navigation/stack/src/views/GestureHandlerNative.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "GestureHandlerRootView", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[0]).GestureHandlerRootView;
    }
  });
  Object.defineProperty(exports, "GestureState", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[0]).State;
    }
  });
  exports.PanGestureHandler = PanGestureHandler;
  Object.defineProperty(exports, "PanGestureHandlerGestureEvent", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[0]).PanGestureHandlerGestureEvent;
    }
  });

  var _extends2 = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _GestureHandlerRefContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[4]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function PanGestureHandler(props) {
    var gestureRef = React.useRef(null);
    return React.createElement(_GestureHandlerRefContext.default.Provider, {
      value: gestureRef
    }, React.createElement(_$$_REQUIRE(_dependencyMap[0]).PanGestureHandler, (0, _extends2.default)({}, props, {
      ref: gestureRef
    })));
  }
},"node_modules/@react-navigation/stack/src/views/GestureHandlerNative.tsx",["node_modules/react-native-gesture-handler/src/index.ts","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/@react-navigation/stack/src/utils/GestureHandlerRefContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "BaseButton", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[0]).BaseButton;
    }
  });
  Object.defineProperty(exports, "BorderlessButton", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[0]).BorderlessButton;
    }
  });
  Object.defineProperty(exports, "Directions", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1]).Directions;
    }
  });
  Object.defineProperty(exports, "DrawerLayout", {
    enumerable: true,
    get: function get() {
      return _DrawerLayout.default;
    }
  });
  Object.defineProperty(exports, "DrawerLayoutAndroid", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[2]).DrawerLayoutAndroid;
    }
  });
  Object.defineProperty(exports, "FlatList", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[2]).FlatList;
    }
  });
  Object.defineProperty(exports, "FlingGestureHandler", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[3]).FlingGestureHandler;
    }
  });
  Object.defineProperty(exports, "ForceTouchGestureHandler", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[4]).ForceTouchGestureHandler;
    }
  });
  Object.defineProperty(exports, "Gesture", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[5]).GestureObjects;
    }
  });
  Object.defineProperty(exports, "GestureDetector", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[6]).GestureDetector;
    }
  });
  Object.defineProperty(exports, "GestureHandlerRootView", {
    enumerable: true,
    get: function get() {
      return _GestureHandlerRootView.default;
    }
  });
  Object.defineProperty(exports, "LongPressGestureHandler", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[7]).LongPressGestureHandler;
    }
  });
  Object.defineProperty(exports, "NativeViewGestureHandler", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[8]).NativeViewGestureHandler;
    }
  });
  Object.defineProperty(exports, "PanGestureHandler", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[9]).PanGestureHandler;
    }
  });
  Object.defineProperty(exports, "PinchGestureHandler", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[10]).PinchGestureHandler;
    }
  });
  Object.defineProperty(exports, "RawButton", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[0]).RawButton;
    }
  });
  Object.defineProperty(exports, "RectButton", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[0]).RectButton;
    }
  });
  Object.defineProperty(exports, "RotationGestureHandler", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[11]).RotationGestureHandler;
    }
  });
  Object.defineProperty(exports, "ScrollView", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[2]).ScrollView;
    }
  });
  Object.defineProperty(exports, "State", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[12]).State;
    }
  });
  Object.defineProperty(exports, "Swipeable", {
    enumerable: true,
    get: function get() {
      return _Swipeable.default;
    }
  });
  Object.defineProperty(exports, "Switch", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[2]).Switch;
    }
  });
  Object.defineProperty(exports, "TapGestureHandler", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[13]).TapGestureHandler;
    }
  });
  Object.defineProperty(exports, "TextInput", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[2]).TextInput;
    }
  });
  Object.defineProperty(exports, "TouchableHighlight", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[14]).TouchableHighlight;
    }
  });
  Object.defineProperty(exports, "TouchableNativeFeedback", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[14]).TouchableNativeFeedback;
    }
  });
  Object.defineProperty(exports, "TouchableOpacity", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[14]).TouchableOpacity;
    }
  });
  Object.defineProperty(exports, "TouchableWithoutFeedback", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[14]).TouchableWithoutFeedback;
    }
  });
  Object.defineProperty(exports, "createNativeWrapper", {
    enumerable: true,
    get: function get() {
      return _createNativeWrapper.default;
    }
  });
  Object.defineProperty(exports, "gestureHandlerRootHOC", {
    enumerable: true,
    get: function get() {
      return _gestureHandlerRootHOC.default;
    }
  });

  var _gestureHandlerRootHOC = _$$_REQUIRE(_dependencyMap[15])(_$$_REQUIRE(_dependencyMap[16]));

  var _GestureHandlerRootView = _$$_REQUIRE(_dependencyMap[15])(_$$_REQUIRE(_dependencyMap[17]));

  var _createNativeWrapper = _$$_REQUIRE(_dependencyMap[15])(_$$_REQUIRE(_dependencyMap[18]));

  var _Swipeable = _$$_REQUIRE(_dependencyMap[15])(_$$_REQUIRE(_dependencyMap[19]));

  var _DrawerLayout = _$$_REQUIRE(_dependencyMap[15])(_$$_REQUIRE(_dependencyMap[20]));

  (0, _$$_REQUIRE(_dependencyMap[21]).initialize)();
},"node_modules/react-native-gesture-handler/src/index.ts",["node_modules/react-native-gesture-handler/src/components/GestureButtons.tsx","node_modules/react-native-gesture-handler/src/Directions.ts","node_modules/react-native-gesture-handler/src/components/GestureComponents.tsx","node_modules/react-native-gesture-handler/src/handlers/FlingGestureHandler.ts","node_modules/react-native-gesture-handler/src/handlers/ForceTouchGestureHandler.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/gestureObjects.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/GestureDetector.tsx","node_modules/react-native-gesture-handler/src/handlers/LongPressGestureHandler.ts","node_modules/react-native-gesture-handler/src/handlers/NativeViewGestureHandler.ts","node_modules/react-native-gesture-handler/src/handlers/PanGestureHandler.ts","node_modules/react-native-gesture-handler/src/handlers/PinchGestureHandler.ts","node_modules/react-native-gesture-handler/src/handlers/RotationGestureHandler.ts","node_modules/react-native-gesture-handler/src/State.ts","node_modules/react-native-gesture-handler/src/handlers/TapGestureHandler.ts","node_modules/react-native-gesture-handler/src/components/touchables/index.ts","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native-gesture-handler/src/gestureHandlerRootHOC.tsx","node_modules/react-native-gesture-handler/src/GestureHandlerRootView.tsx","node_modules/react-native-gesture-handler/src/handlers/createNativeWrapper.tsx","node_modules/react-native-gesture-handler/src/components/Swipeable.tsx","node_modules/react-native-gesture-handler/src/components/DrawerLayout.tsx","node_modules/react-native-gesture-handler/src/init.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.BorderlessButton = exports.BaseButton = undefined;
  Object.defineProperty(exports, "PureNativeButton", {
    enumerable: true,
    get: function get() {
      return _GestureHandlerButton.default;
    }
  });
  exports.RectButton = exports.RawButton = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[8]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[9]);

  var _createNativeWrapper = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[10]));

  var _GestureHandlerButton = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _excluded = ["rippleColor"],
      _excluded2 = ["children", "style"],
      _excluded3 = ["children", "style"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var RawButton = (0, _createNativeWrapper.default)(_GestureHandlerButton.default, {
    shouldCancelWhenOutside: false,
    shouldActivateOnStart: false
  });
  exports.RawButton = RawButton;

  var BaseButton = function (_React$Component) {
    (0, _inherits2.default)(BaseButton, _React$Component);

    var _super = _createSuper(BaseButton);

    function BaseButton(props) {
      var _this;

      (0, _classCallCheck2.default)(this, BaseButton);
      _this = _super.call(this, props);

      _this.handleEvent = function (_ref) {
        var nativeEvent = _ref.nativeEvent;
        var state = nativeEvent.state,
            oldState = nativeEvent.oldState,
            pointerInside = nativeEvent.pointerInside;

        var active = pointerInside && state === _$$_REQUIRE(_dependencyMap[12]).State.ACTIVE;

        if (active !== _this.lastActive && _this.props.onActiveStateChange) {
          _this.props.onActiveStateChange(active);
        }

        if (oldState === _$$_REQUIRE(_dependencyMap[12]).State.ACTIVE && state !== _$$_REQUIRE(_dependencyMap[12]).State.CANCELLED && _this.lastActive && _this.props.onPress) {
          _this.props.onPress(active);
        }

        _this.lastActive = active;
      };

      _this.onHandlerStateChange = function (e) {
        _this.props.onHandlerStateChange == null ? undefined : _this.props.onHandlerStateChange(e);

        _this.handleEvent(e);
      };

      _this.onGestureEvent = function (e) {
        _this.props.onGestureEvent == null ? undefined : _this.props.onGestureEvent(e);

        _this.handleEvent(e);
      };

      _this.lastActive = false;
      return _this;
    }

    (0, _createClass2.default)(BaseButton, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            rippleColor = _this$props.rippleColor,
            rest = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
        return React.createElement(RawButton, (0, _extends2.default)({
          rippleColor: (0, _reactNative.processColor)(rippleColor)
        }, rest, {
          onGestureEvent: this.onGestureEvent,
          onHandlerStateChange: this.onHandlerStateChange
        }));
      }
    }]);
    return BaseButton;
  }(React.Component);

  exports.BaseButton = BaseButton;

  var AnimatedBaseButton = _reactNative.Animated.createAnimatedComponent(BaseButton);

  var btnStyles = _reactNative.StyleSheet.create({
    underlay: {
      position: 'absolute',
      left: 0,
      right: 0,
      bottom: 0,
      top: 0
    }
  });

  var RectButton = function (_React$Component2) {
    (0, _inherits2.default)(RectButton, _React$Component2);

    var _super2 = _createSuper(RectButton);

    function RectButton(props) {
      var _this2;

      (0, _classCallCheck2.default)(this, RectButton);
      _this2 = _super2.call(this, props);

      _this2.onActiveStateChange = function (active) {
        if (_reactNative.Platform.OS !== 'android') {
          _this2.opacity.setValue(active ? _this2.props.activeOpacity : 0);
        }

        _this2.props.onActiveStateChange == null ? undefined : _this2.props.onActiveStateChange(active);
      };

      _this2.opacity = new _reactNative.Animated.Value(0);
      return _this2;
    }

    (0, _createClass2.default)(RectButton, [{
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            children = _this$props2.children,
            style = _this$props2.style,
            rest = (0, _objectWithoutProperties2.default)(_this$props2, _excluded2);

        var resolvedStyle = _reactNative.StyleSheet.flatten(style != null ? style : {});

        return React.createElement(BaseButton, (0, _extends2.default)({}, rest, {
          style: resolvedStyle,
          onActiveStateChange: this.onActiveStateChange
        }), React.createElement(_reactNative.Animated.View, {
          style: [btnStyles.underlay, {
            opacity: this.opacity,
            backgroundColor: this.props.underlayColor,
            borderRadius: resolvedStyle.borderRadius,
            borderTopLeftRadius: resolvedStyle.borderTopLeftRadius,
            borderTopRightRadius: resolvedStyle.borderTopRightRadius,
            borderBottomLeftRadius: resolvedStyle.borderBottomLeftRadius,
            borderBottomRightRadius: resolvedStyle.borderBottomRightRadius
          }]
        }), children);
      }
    }]);
    return RectButton;
  }(React.Component);

  exports.RectButton = RectButton;
  RectButton.defaultProps = {
    activeOpacity: 0.105,
    underlayColor: 'black'
  };

  var BorderlessButton = function (_React$Component3) {
    (0, _inherits2.default)(BorderlessButton, _React$Component3);

    var _super3 = _createSuper(BorderlessButton);

    function BorderlessButton(props) {
      var _this3;

      (0, _classCallCheck2.default)(this, BorderlessButton);
      _this3 = _super3.call(this, props);

      _this3.onActiveStateChange = function (active) {
        if (_reactNative.Platform.OS !== 'android') {
          _this3.opacity.setValue(active ? _this3.props.activeOpacity : 1);
        }

        _this3.props.onActiveStateChange == null ? undefined : _this3.props.onActiveStateChange(active);
      };

      _this3.opacity = new _reactNative.Animated.Value(1);
      return _this3;
    }

    (0, _createClass2.default)(BorderlessButton, [{
      key: "render",
      value: function render() {
        var _this$props3 = this.props,
            children = _this$props3.children,
            style = _this$props3.style,
            rest = (0, _objectWithoutProperties2.default)(_this$props3, _excluded3);
        return React.createElement(AnimatedBaseButton, (0, _extends2.default)({}, rest, {
          onActiveStateChange: this.onActiveStateChange,
          style: [style, _reactNative.Platform.OS === 'ios' && {
            opacity: this.opacity
          }]
        }), children);
      }
    }]);
    return BorderlessButton;
  }(React.Component);

  exports.BorderlessButton = BorderlessButton;
  BorderlessButton.defaultProps = {
    activeOpacity: 0.3,
    borderless: true
  };
},"node_modules/react-native-gesture-handler/src/components/GestureButtons.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/react-native-gesture-handler/src/handlers/createNativeWrapper.tsx","node_modules/react-native-gesture-handler/src/components/GestureHandlerButton.tsx","node_modules/react-native-gesture-handler/src/State.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createNativeWrapper;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var NATIVE_WRAPPER_PROPS_FILTER = [].concat((0, _toConsumableArray2.default)(_$$_REQUIRE(_dependencyMap[4]).nativeViewProps), ['onGestureHandlerEvent', 'onGestureHandlerStateChange']);

  function createNativeWrapper(Component) {
    var _Component$render;

    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var ComponentWrapper = React.forwardRef(function (props, ref) {
      var gestureHandlerProps = Object.keys(props).reduce(function (res, key) {
        var allowedKeys = NATIVE_WRAPPER_PROPS_FILTER;

        if (allowedKeys.includes(key)) {
          res[key] = props[key];
        }

        return res;
      }, (0, _extends2.default)({}, config));

      var _ref = (0, React.useRef)();

      var _gestureHandlerRef = (0, React.useRef)();

      (0, React.useImperativeHandle)(ref, function () {
        var node = _gestureHandlerRef.current;

        if (_ref.current && node) {
          _ref.current.handlerTag = node.handlerTag;
          return _ref.current;
        }

        return null;
      }, [_ref, _gestureHandlerRef]);
      return React.createElement(_$$_REQUIRE(_dependencyMap[4]).NativeViewGestureHandler, (0, _extends2.default)({}, gestureHandlerProps, {
        ref: _gestureHandlerRef
      }), React.createElement(Component, (0, _extends2.default)({}, props, {
        ref: _ref
      })));
    });
    ComponentWrapper.displayName = (Component == null ? undefined : Component.displayName) || (Component == null ? undefined : (_Component$render = Component.render) == null ? undefined : _Component$render.name) || typeof Component === 'string' && Component || 'ComponentWrapper';
    return ComponentWrapper;
  }
},"node_modules/react-native-gesture-handler/src/handlers/createNativeWrapper.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/react/index.js","node_modules/react-native-gesture-handler/src/handlers/NativeViewGestureHandler.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.nativeViewProps = exports.nativeViewHandlerName = exports.nativeViewGestureHandlerProps = exports.NativeViewGestureHandler = undefined;

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createHandler = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var nativeViewGestureHandlerProps = ['shouldActivateOnStart', 'disallowInterruption'];
  exports.nativeViewGestureHandlerProps = nativeViewGestureHandlerProps;
  var nativeViewProps = [].concat((0, _toConsumableArray2.default)(_$$_REQUIRE(_dependencyMap[3]).baseGestureHandlerProps), nativeViewGestureHandlerProps);
  exports.nativeViewProps = nativeViewProps;
  var nativeViewHandlerName = 'NativeViewGestureHandler';
  exports.nativeViewHandlerName = nativeViewHandlerName;
  var NativeViewGestureHandler = (0, _createHandler.default)({
    name: nativeViewHandlerName,
    allowedProps: nativeViewProps,
    config: {}
  });
  exports.NativeViewGestureHandler = NativeViewGestureHandler;
},"node_modules/react-native-gesture-handler/src/handlers/NativeViewGestureHandler.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/react-native-gesture-handler/src/handlers/createHandler.ts","node_modules/react-native-gesture-handler/src/handlers/gestureHandlerCommon.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createHandler;

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _defineProperty2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[9]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[10]);

  var _isEqual = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _RNGestureHandlerModule = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var _UIManagerAny$getView, _stateToPropMappings;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var UIManagerAny = _reactNative.UIManager;
  var customGHEventsConfigFabricAndroid = {
    topOnGestureHandlerEvent: {
      registrationName: 'onGestureHandlerEvent'
    },
    topOnGestureHandlerStateChange: {
      registrationName: 'onGestureHandlerStateChange'
    }
  };
  var customGHEventsConfig = (0, _extends2.default)({
    onGestureHandlerEvent: {
      registrationName: 'onGestureHandlerEvent'
    },
    onGestureHandlerStateChange: {
      registrationName: 'onGestureHandlerStateChange'
    }
  }, (0, _$$_REQUIRE(_dependencyMap[13]).isFabric)() && _reactNative.Platform.OS === 'android' && customGHEventsConfigFabricAndroid);
  UIManagerAny.genericDirectEventTypes = (0, _extends2.default)({}, UIManagerAny.genericDirectEventTypes, customGHEventsConfig);
  var UIManagerConstants = (_UIManagerAny$getView = UIManagerAny.getViewManagerConfig == null ? undefined : UIManagerAny.getViewManagerConfig('getConstants')) != null ? _UIManagerAny$getView : UIManagerAny.getConstants == null ? undefined : UIManagerAny.getConstants();

  if (UIManagerConstants) {
    UIManagerConstants.genericDirectEventTypes = (0, _extends2.default)({}, UIManagerConstants.genericDirectEventTypes, customGHEventsConfig);
  }

  var _UIManagerAny$setJSRe = UIManagerAny.setJSResponder,
      oldSetJSResponder = _UIManagerAny$setJSRe === undefined ? function () {} : _UIManagerAny$setJSRe,
      _UIManagerAny$clearJS = UIManagerAny.clearJSResponder,
      oldClearJSResponder = _UIManagerAny$clearJS === undefined ? function () {} : _UIManagerAny$clearJS;

  UIManagerAny.setJSResponder = function (tag, blockNativeResponder) {
    _RNGestureHandlerModule.default.handleSetJSResponder(tag, blockNativeResponder);

    oldSetJSResponder(tag, blockNativeResponder);
  };

  UIManagerAny.clearJSResponder = function () {
    _RNGestureHandlerModule.default.handleClearJSResponder();

    oldClearJSResponder();
  };

  var allowTouches = true;
  var DEV_ON_ANDROID = false;

  function hasUnresolvedRefs(props) {
    var extract = function extract(refs) {
      if (!Array.isArray(refs)) {
        return refs && refs.current === null;
      }

      return refs.some(function (r) {
        return r && r.current === null;
      });
    };

    return extract(props['simultaneousHandlers']) || extract(props['waitFor']);
  }

  var stateToPropMappings = (_stateToPropMappings = {}, (0, _defineProperty2.default)(_stateToPropMappings, _$$_REQUIRE(_dependencyMap[14]).State.UNDETERMINED, undefined), (0, _defineProperty2.default)(_stateToPropMappings, _$$_REQUIRE(_dependencyMap[14]).State.BEGAN, 'onBegan'), (0, _defineProperty2.default)(_stateToPropMappings, _$$_REQUIRE(_dependencyMap[14]).State.FAILED, 'onFailed'), (0, _defineProperty2.default)(_stateToPropMappings, _$$_REQUIRE(_dependencyMap[14]).State.CANCELLED, 'onCancelled'), (0, _defineProperty2.default)(_stateToPropMappings, _$$_REQUIRE(_dependencyMap[14]).State.ACTIVE, 'onActivated'), (0, _defineProperty2.default)(_stateToPropMappings, _$$_REQUIRE(_dependencyMap[14]).State.END, 'onEnded'), _stateToPropMappings);
  var UNRESOLVED_REFS_RETRY_LIMIT = 1;

  function createHandler(_ref) {
    var name = _ref.name,
        _ref$allowedProps = _ref.allowedProps,
        allowedProps = _ref$allowedProps === undefined ? [] : _ref$allowedProps,
        _ref$config = _ref.config,
        config = _ref$config === undefined ? {} : _ref$config,
        transformProps = _ref.transformProps,
        _ref$customNativeProp = _ref.customNativeProps,
        customNativeProps = _ref$customNativeProp === undefined ? [] : _ref$customNativeProp;

    var Handler = function (_React$Component) {
      (0, _inherits2.default)(Handler, _React$Component);

      var _super = _createSuper(Handler);

      function Handler(props) {
        var _this;

        (0, _classCallCheck2.default)(this, Handler);
        _this = _super.call(this, props);
        _this.updateEnqueued = null;

        _this.onGestureHandlerEvent = function (event) {
          if (event.nativeEvent.handlerTag === _this.handlerTag) {
            if (typeof _this.props.onGestureEvent === 'function') {
              _this.props.onGestureEvent == null ? undefined : _this.props.onGestureEvent(event);
            }
          } else {
            _this.props.onGestureHandlerEvent == null ? undefined : _this.props.onGestureHandlerEvent(event);
          }
        };

        _this.onGestureHandlerStateChange = function (event) {
          if (event.nativeEvent.handlerTag === _this.handlerTag) {
            if (typeof _this.props.onHandlerStateChange === 'function') {
              _this.props.onHandlerStateChange == null ? undefined : _this.props.onHandlerStateChange(event);
            }

            var state = event.nativeEvent.state;
            var stateEventName = stateToPropMappings[state];
            var eventHandler = stateEventName && _this.props[stateEventName];

            if (eventHandler && typeof eventHandler === 'function') {
              eventHandler(event);
            }
          } else {
            _this.props.onGestureHandlerStateChange == null ? undefined : _this.props.onGestureHandlerStateChange(event);
          }
        };

        _this.refHandler = function (node) {
          _this.viewNode = node;
          var child = React.Children.only(_this.props.children);
          var ref = child.ref;

          if (ref !== null) {
            if (typeof ref === 'function') {
              ref(node);
            } else {
              ref.current = node;
            }
          }
        };

        _this.createGestureHandler = function (newConfig) {
          _this.config = newConfig;

          _RNGestureHandlerModule.default.createGestureHandler(name, _this.handlerTag, newConfig);
        };

        _this.attachGestureHandler = function (newViewTag) {
          _this.viewTag = newViewTag;

          if (_reactNative.Platform.OS === 'web') {
            _RNGestureHandlerModule.default.attachGestureHandler(_this.handlerTag, newViewTag, _$$_REQUIRE(_dependencyMap[15]).ActionType.JS_FUNCTION_OLD_API, _this.propsRef);
          } else {
            (0, _$$_REQUIRE(_dependencyMap[16]).registerOldGestureHandler)(_this.handlerTag, {
              onGestureEvent: _this.onGestureHandlerEvent,
              onGestureStateChange: _this.onGestureHandlerStateChange
            });

            var actionType = function () {
              var _this$props, _this$props2;

              if ((_this$props = _this.props) != null && _this$props.onGestureEvent && 'current' in _this.props.onGestureEvent) {
                return _$$_REQUIRE(_dependencyMap[15]).ActionType.REANIMATED_WORKLET;
              } else if ((_this$props2 = _this.props) != null && _this$props2.onGestureEvent && '__isNative' in _this.props.onGestureEvent) {
                return _$$_REQUIRE(_dependencyMap[15]).ActionType.NATIVE_ANIMATED_EVENT;
              } else {
                return _$$_REQUIRE(_dependencyMap[15]).ActionType.JS_FUNCTION_OLD_API;
              }
            }();

            _RNGestureHandlerModule.default.attachGestureHandler(_this.handlerTag, newViewTag, actionType);
          }

          (0, _$$_REQUIRE(_dependencyMap[17]).scheduleFlushOperations)();
        };

        _this.updateGestureHandler = function (newConfig) {
          _this.config = newConfig;

          _RNGestureHandlerModule.default.updateGestureHandler(_this.handlerTag, newConfig);

          (0, _$$_REQUIRE(_dependencyMap[17]).scheduleFlushOperations)();
        };

        _this.handlerTag = (0, _$$_REQUIRE(_dependencyMap[16]).getNextHandlerTag)();
        _this.config = {};
        _this.propsRef = React.createRef();
        _this.state = {
          allowTouches: allowTouches
        };

        if (props.id) {
          if (_$$_REQUIRE(_dependencyMap[16]).handlerIDToTag[props.id] !== undefined) {
            throw new Error("Handler with ID \"" + props.id + "\" already registered");
          }

          _$$_REQUIRE(_dependencyMap[16]).handlerIDToTag[props.id] = _this.handlerTag;
        }

        return _this;
      }

      (0, _createClass2.default)(Handler, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this2 = this;

          var props = this.props;

          if (hasUnresolvedRefs(props)) {
            this.updateEnqueued = setImmediate(function () {
              _this2.updateEnqueued = null;

              _this2.update(UNRESOLVED_REFS_RETRY_LIMIT);
            });
          }

          this.createGestureHandler((0, _$$_REQUIRE(_dependencyMap[17]).filterConfig)(transformProps ? transformProps(this.props) : this.props, [].concat((0, _toConsumableArray2.default)(allowedProps), (0, _toConsumableArray2.default)(customNativeProps)), config));
          this.attachGestureHandler((0, _$$_REQUIRE(_dependencyMap[17]).findNodeHandle)(this.viewNode));
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          var viewTag = (0, _$$_REQUIRE(_dependencyMap[17]).findNodeHandle)(this.viewNode);

          if (this.viewTag !== viewTag) {
            this.attachGestureHandler(viewTag);
          }

          this.update(UNRESOLVED_REFS_RETRY_LIMIT);
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          var _this$inspectorToggle;

          (_this$inspectorToggle = this.inspectorToggleListener) == null ? undefined : _this$inspectorToggle.remove();

          _RNGestureHandlerModule.default.dropGestureHandler(this.handlerTag);

          (0, _$$_REQUIRE(_dependencyMap[17]).scheduleFlushOperations)();

          if (this.updateEnqueued) {
            clearImmediate(this.updateEnqueued);
          }

          var handlerID = this.props.id;

          if (handlerID) {
            delete _$$_REQUIRE(_dependencyMap[16]).handlerIDToTag[handlerID];
          }
        }
      }, {
        key: "update",
        value: function update(remainingTries) {
          var _this3 = this;

          var props = this.props;

          if (hasUnresolvedRefs(props) && remainingTries > 0) {
            this.updateEnqueued = setImmediate(function () {
              _this3.updateEnqueued = null;

              _this3.update(remainingTries - 1);
            });
          } else {
            var newConfig = (0, _$$_REQUIRE(_dependencyMap[17]).filterConfig)(transformProps ? transformProps(this.props) : this.props, [].concat((0, _toConsumableArray2.default)(allowedProps), (0, _toConsumableArray2.default)(customNativeProps)), config);

            if (!(0, _isEqual.default)(this.config, newConfig)) {
              this.updateGestureHandler(newConfig);
            }
          }
        }
      }, {
        key: "setNativeProps",
        value: function setNativeProps(updates) {
          var mergedProps = (0, _extends2.default)({}, this.props, updates);
          var newConfig = (0, _$$_REQUIRE(_dependencyMap[17]).filterConfig)(transformProps ? transformProps(mergedProps) : mergedProps, [].concat((0, _toConsumableArray2.default)(allowedProps), (0, _toConsumableArray2.default)(customNativeProps)), config);
          this.updateGestureHandler(newConfig);
        }
      }, {
        key: "render",
        value: function render() {
          var _this$props$testID;

          var gestureEventHandler = this.onGestureHandlerEvent;
          var _this$props3 = this.props,
              onGestureEvent = _this$props3.onGestureEvent,
              onGestureHandlerEvent = _this$props3.onGestureHandlerEvent;

          if (onGestureEvent && typeof onGestureEvent !== 'function') {
            if (onGestureHandlerEvent) {
              throw new Error('Nesting touch handlers with native animated driver is not supported yet');
            }

            gestureEventHandler = onGestureEvent;
          } else {
            if (onGestureHandlerEvent && typeof onGestureHandlerEvent !== 'function') {
              throw new Error('Nesting touch handlers with native animated driver is not supported yet');
            }
          }

          var gestureStateEventHandler = this.onGestureHandlerStateChange;
          var _this$props4 = this.props,
              onHandlerStateChange = _this$props4.onHandlerStateChange,
              onGestureHandlerStateChange = _this$props4.onGestureHandlerStateChange;

          if (onHandlerStateChange && typeof onHandlerStateChange !== 'function') {
            if (onGestureHandlerStateChange) {
              throw new Error('Nesting touch handlers with native animated driver is not supported yet');
            }

            gestureStateEventHandler = onHandlerStateChange;
          } else {
            if (onGestureHandlerStateChange && typeof onGestureHandlerStateChange !== 'function') {
              throw new Error('Nesting touch handlers with native animated driver is not supported yet');
            }
          }

          var events = {
            onGestureHandlerEvent: this.state.allowTouches ? gestureEventHandler : undefined,
            onGestureHandlerStateChange: this.state.allowTouches ? gestureStateEventHandler : undefined
          };
          this.propsRef.current = events;
          var child = React.Children.only(this.props.children);
          var grandChildren = child.props.children;

          if (_reactNative.Touchable.TOUCH_TARGET_DEBUG && child.type && (child.type === 'RNGestureHandlerButton' || child.type.name === 'View' || child.type.displayName === 'View')) {
            grandChildren = React.Children.toArray(grandChildren);
            grandChildren.push(_reactNative.Touchable.renderDebugView({
              color: 'mediumspringgreen',
              hitSlop: child.props.hitSlop
            }));
          }

          return React.cloneElement(child, (0, _extends2.default)({
            ref: this.refHandler,
            collapsable: false
          }, (0, _$$_REQUIRE(_dependencyMap[13]).isJestEnv)() ? {
            handlerType: name,
            handlerTag: this.handlerTag
          } : {}, {
            testID: (_this$props$testID = this.props.testID) != null ? _this$props$testID : child.props.testID
          }, events), grandChildren);
        }
      }]);
      return Handler;
    }(React.Component);

    Handler.displayName = name;
    return Handler;
  }
},"node_modules/react-native-gesture-handler/src/handlers/createHandler.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/defineProperty.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/lodash/isEqual.js","node_modules/react-native-gesture-handler/src/RNGestureHandlerModule.ts","node_modules/react-native-gesture-handler/src/utils.ts","node_modules/react-native-gesture-handler/src/State.ts","node_modules/react-native-gesture-handler/src/ActionType.ts","node_modules/react-native-gesture-handler/src/handlers/handlersRegistry.ts","node_modules/react-native-gesture-handler/src/handlers/gestureHandlerCommon.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function isEqual(value, other) {
    return _$$_REQUIRE(_dependencyMap[0])(value, other);
  }

  module.exports = isEqual;
},"node_modules/lodash/isEqual.js",["node_modules/lodash/_baseIsEqual.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !_$$_REQUIRE(_dependencyMap[0])(value) && !_$$_REQUIRE(_dependencyMap[0])(other)) {
      return value !== value && other !== other;
    }

    return _$$_REQUIRE(_dependencyMap[1])(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  module.exports = baseIsEqual;
},"node_modules/lodash/_baseIsEqual.js",["node_modules/lodash/isObjectLike.js","node_modules/lodash/_baseIsEqualDeep.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  module.exports = isObjectLike;
},"node_modules/lodash/isObjectLike.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      objectTag = '[object Object]';
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = _$$_REQUIRE(_dependencyMap[0])(object),
        othIsArr = _$$_REQUIRE(_dependencyMap[0])(other),
        objTag = objIsArr ? arrayTag : _$$_REQUIRE(_dependencyMap[1])(object),
        othTag = othIsArr ? arrayTag : _$$_REQUIRE(_dependencyMap[1])(other);

    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    if (isSameTag && _$$_REQUIRE(_dependencyMap[2])(object)) {
      if (!_$$_REQUIRE(_dependencyMap[2])(other)) {
        return false;
      }

      objIsArr = true;
      objIsObj = false;
    }

    if (isSameTag && !objIsObj) {
      stack || (stack = new (_$$_REQUIRE(_dependencyMap[3]))());
      return objIsArr || _$$_REQUIRE(_dependencyMap[4])(object) ? _$$_REQUIRE(_dependencyMap[5])(object, other, bitmask, customizer, equalFunc, stack) : _$$_REQUIRE(_dependencyMap[6])(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }

    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new (_$$_REQUIRE(_dependencyMap[3]))());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }

    if (!isSameTag) {
      return false;
    }

    stack || (stack = new (_$$_REQUIRE(_dependencyMap[3]))());
    return _$$_REQUIRE(_dependencyMap[7])(object, other, bitmask, customizer, equalFunc, stack);
  }

  module.exports = baseIsEqualDeep;
},"node_modules/lodash/_baseIsEqualDeep.js",["node_modules/lodash/isArray.js","node_modules/lodash/_getTag.js","node_modules/lodash/isBuffer.js","node_modules/lodash/_Stack.js","node_modules/lodash/isTypedArray.js","node_modules/lodash/_equalArrays.js","node_modules/lodash/_equalByTag.js","node_modules/lodash/_equalObjects.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isArray = Array.isArray;
  module.exports = isArray;
},"node_modules/lodash/isArray.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var mapTag = '[object Map]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      setTag = '[object Set]',
      weakMapTag = '[object WeakMap]';
  var dataViewTag = '[object DataView]';

  var dataViewCtorString = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1])),
      mapCtorString = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2])),
      promiseCtorString = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3])),
      setCtorString = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4])),
      weakMapCtorString = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var getTag = _$$_REQUIRE(_dependencyMap[6]);

  if (_$$_REQUIRE(_dependencyMap[1]) && getTag(new (_$$_REQUIRE(_dependencyMap[1]))(new ArrayBuffer(1))) != dataViewTag || _$$_REQUIRE(_dependencyMap[2]) && getTag(new (_$$_REQUIRE(_dependencyMap[2]))()) != mapTag || _$$_REQUIRE(_dependencyMap[3]) && getTag(_$$_REQUIRE(_dependencyMap[3]).resolve()) != promiseTag || _$$_REQUIRE(_dependencyMap[4]) && getTag(new (_$$_REQUIRE(_dependencyMap[4]))()) != setTag || _$$_REQUIRE(_dependencyMap[5]) && getTag(new (_$$_REQUIRE(_dependencyMap[5]))()) != weakMapTag) {
    getTag = function getTag(value) {
      var result = _$$_REQUIRE(_dependencyMap[6])(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? _$$_REQUIRE(_dependencyMap[0])(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;

          case mapCtorString:
            return mapTag;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag;

          case weakMapCtorString:
            return weakMapTag;
        }
      }

      return result;
    };
  }

  module.exports = getTag;
},"node_modules/lodash/_getTag.js",["node_modules/lodash/_toSource.js","node_modules/lodash/_DataView.js","node_modules/lodash/_Map.js","node_modules/lodash/_Promise.js","node_modules/lodash/_Set.js","node_modules/lodash/_WeakMap.js","node_modules/lodash/_baseGetTag.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  module.exports = toSource;
},"node_modules/lodash/_toSource.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var DataView = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]), 'DataView');

  module.exports = DataView;
},"node_modules/lodash/_DataView.js",["node_modules/lodash/_getNative.js","node_modules/lodash/_root.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function getNative(object, key) {
    var value = _$$_REQUIRE(_dependencyMap[0])(object, key);

    return _$$_REQUIRE(_dependencyMap[1])(value) ? value : undefined;
  }

  module.exports = getNative;
},"node_modules/lodash/_getNative.js",["node_modules/lodash/_getValue.js","node_modules/lodash/_baseIsNative.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  module.exports = getValue;
},"node_modules/lodash/_getValue.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype,
      objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  function baseIsNative(value) {
    if (!_$$_REQUIRE(_dependencyMap[0])(value) || _$$_REQUIRE(_dependencyMap[1])(value)) {
      return false;
    }

    var pattern = _$$_REQUIRE(_dependencyMap[2])(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_$$_REQUIRE(_dependencyMap[3])(value));
  }

  module.exports = baseIsNative;
},"node_modules/lodash/_baseIsNative.js",["node_modules/lodash/isObject.js","node_modules/lodash/_isMasked.js","node_modules/lodash/isFunction.js","node_modules/lodash/_toSource.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  module.exports = isObject;
},"node_modules/lodash/isObject.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(_$$_REQUIRE(_dependencyMap[0]) && _$$_REQUIRE(_dependencyMap[0]).keys && _$$_REQUIRE(_dependencyMap[0]).keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  module.exports = isMasked;
},"node_modules/lodash/_isMasked.js",["node_modules/lodash/_coreJsData.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0])['__core-js_shared__'];
},"node_modules/lodash/_coreJsData.js",["node_modules/lodash/_root.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  var root = _$$_REQUIRE(_dependencyMap[0]) || freeSelf || Function('return this')();
  module.exports = root;
},"node_modules/lodash/_root.js",["node_modules/lodash/_freeGlobal.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  module.exports = freeGlobal;
},"node_modules/lodash/_freeGlobal.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  function isFunction(value) {
    if (!_$$_REQUIRE(_dependencyMap[0])(value)) {
      return false;
    }

    var tag = _$$_REQUIRE(_dependencyMap[1])(value);

    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  module.exports = isFunction;
},"node_modules/lodash/isFunction.js",["node_modules/lodash/isObject.js","node_modules/lodash/_baseGetTag.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  var symToStringTag = _$$_REQUIRE(_dependencyMap[0]) ? _$$_REQUIRE(_dependencyMap[0]).toStringTag : undefined;

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag && symToStringTag in Object(value) ? _$$_REQUIRE(_dependencyMap[1])(value) : _$$_REQUIRE(_dependencyMap[2])(value);
  }

  module.exports = baseGetTag;
},"node_modules/lodash/_baseGetTag.js",["node_modules/lodash/_Symbol.js","node_modules/lodash/_getRawTag.js","node_modules/lodash/_objectToString.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]).Symbol;
},"node_modules/lodash/_Symbol.js",["node_modules/lodash/_root.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = _$$_REQUIRE(_dependencyMap[0]) ? _$$_REQUIRE(_dependencyMap[0]).toStringTag : undefined;

  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  module.exports = getRawTag;
},"node_modules/lodash/_getRawTag.js",["node_modules/lodash/_Symbol.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;

  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  module.exports = objectToString;
},"node_modules/lodash/_objectToString.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Map = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]), 'Map');

  module.exports = Map;
},"node_modules/lodash/_Map.js",["node_modules/lodash/_getNative.js","node_modules/lodash/_root.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Promise = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]), 'Promise');

  module.exports = Promise;
},"node_modules/lodash/_Promise.js",["node_modules/lodash/_getNative.js","node_modules/lodash/_root.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Set = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]), 'Set');

  module.exports = Set;
},"node_modules/lodash/_Set.js",["node_modules/lodash/_getNative.js","node_modules/lodash/_root.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var WeakMap = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]), 'WeakMap');

  module.exports = WeakMap;
},"node_modules/lodash/_WeakMap.js",["node_modules/lodash/_getNative.js","node_modules/lodash/_root.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? _$$_REQUIRE(_dependencyMap[0]).Buffer : undefined;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  var isBuffer = nativeIsBuffer || _$$_REQUIRE(_dependencyMap[1]);

  module.exports = isBuffer;
},"node_modules/lodash/isBuffer.js",["node_modules/lodash/_root.js","node_modules/lodash/stubFalse.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function stubFalse() {
    return false;
  }

  module.exports = stubFalse;
},"node_modules/lodash/stubFalse.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function Stack(entries) {
    var data = this.__data__ = new (_$$_REQUIRE(_dependencyMap[0]))(entries);
    this.size = data.size;
  }

  Stack.prototype.clear = _$$_REQUIRE(_dependencyMap[1]);
  Stack.prototype['delete'] = _$$_REQUIRE(_dependencyMap[2]);
  Stack.prototype.get = _$$_REQUIRE(_dependencyMap[3]);
  Stack.prototype.has = _$$_REQUIRE(_dependencyMap[4]);
  Stack.prototype.set = _$$_REQUIRE(_dependencyMap[5]);
  module.exports = Stack;
},"node_modules/lodash/_Stack.js",["node_modules/lodash/_ListCache.js","node_modules/lodash/_stackClear.js","node_modules/lodash/_stackDelete.js","node_modules/lodash/_stackGet.js","node_modules/lodash/_stackHas.js","node_modules/lodash/_stackSet.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  ListCache.prototype.clear = _$$_REQUIRE(_dependencyMap[0]);
  ListCache.prototype['delete'] = _$$_REQUIRE(_dependencyMap[1]);
  ListCache.prototype.get = _$$_REQUIRE(_dependencyMap[2]);
  ListCache.prototype.has = _$$_REQUIRE(_dependencyMap[3]);
  ListCache.prototype.set = _$$_REQUIRE(_dependencyMap[4]);
  module.exports = ListCache;
},"node_modules/lodash/_ListCache.js",["node_modules/lodash/_listCacheClear.js","node_modules/lodash/_listCacheDelete.js","node_modules/lodash/_listCacheGet.js","node_modules/lodash/_listCacheHas.js","node_modules/lodash/_listCacheSet.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  module.exports = listCacheClear;
},"node_modules/lodash/_listCacheClear.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;

  function listCacheDelete(key) {
    var data = this.__data__,
        index = _$$_REQUIRE(_dependencyMap[0])(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    --this.size;
    return true;
  }

  module.exports = listCacheDelete;
},"node_modules/lodash/_listCacheDelete.js",["node_modules/lodash/_assocIndexOf.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (_$$_REQUIRE(_dependencyMap[0])(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  module.exports = assocIndexOf;
},"node_modules/lodash/_assocIndexOf.js",["node_modules/lodash/eq.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  module.exports = eq;
},"node_modules/lodash/eq.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function listCacheGet(key) {
    var data = this.__data__,
        index = _$$_REQUIRE(_dependencyMap[0])(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  module.exports = listCacheGet;
},"node_modules/lodash/_listCacheGet.js",["node_modules/lodash/_assocIndexOf.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function listCacheHas(key) {
    return _$$_REQUIRE(_dependencyMap[0])(this.__data__, key) > -1;
  }

  module.exports = listCacheHas;
},"node_modules/lodash/_listCacheHas.js",["node_modules/lodash/_assocIndexOf.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = _$$_REQUIRE(_dependencyMap[0])(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  module.exports = listCacheSet;
},"node_modules/lodash/_listCacheSet.js",["node_modules/lodash/_assocIndexOf.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function stackClear() {
    this.__data__ = new (_$$_REQUIRE(_dependencyMap[0]))();
    this.size = 0;
  }

  module.exports = stackClear;
},"node_modules/lodash/_stackClear.js",["node_modules/lodash/_ListCache.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);
    this.size = data.size;
    return result;
  }

  module.exports = stackDelete;
},"node_modules/lodash/_stackDelete.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function stackGet(key) {
    return this.__data__.get(key);
  }

  module.exports = stackGet;
},"node_modules/lodash/_stackGet.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function stackHas(key) {
    return this.__data__.has(key);
  }

  module.exports = stackHas;
},"node_modules/lodash/_stackHas.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var LARGE_ARRAY_SIZE = 200;

  function stackSet(key, value) {
    var data = this.__data__;

    if (data instanceof _$$_REQUIRE(_dependencyMap[0])) {
      var pairs = data.__data__;

      if (!_$$_REQUIRE(_dependencyMap[1]) || pairs.length < 199) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }

      data = this.__data__ = new (_$$_REQUIRE(_dependencyMap[2]))(pairs);
    }

    data.set(key, value);
    this.size = data.size;
    return this;
  }

  module.exports = stackSet;
},"node_modules/lodash/_stackSet.js",["node_modules/lodash/_ListCache.js","node_modules/lodash/_Map.js","node_modules/lodash/_MapCache.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  MapCache.prototype.clear = _$$_REQUIRE(_dependencyMap[0]);
  MapCache.prototype['delete'] = _$$_REQUIRE(_dependencyMap[1]);
  MapCache.prototype.get = _$$_REQUIRE(_dependencyMap[2]);
  MapCache.prototype.has = _$$_REQUIRE(_dependencyMap[3]);
  MapCache.prototype.set = _$$_REQUIRE(_dependencyMap[4]);
  module.exports = MapCache;
},"node_modules/lodash/_MapCache.js",["node_modules/lodash/_mapCacheClear.js","node_modules/lodash/_mapCacheDelete.js","node_modules/lodash/_mapCacheGet.js","node_modules/lodash/_mapCacheHas.js","node_modules/lodash/_mapCacheSet.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new (_$$_REQUIRE(_dependencyMap[0]))(),
      'map': new (_$$_REQUIRE(_dependencyMap[1]) || _$$_REQUIRE(_dependencyMap[2]))(),
      'string': new (_$$_REQUIRE(_dependencyMap[0]))()
    };
  }

  module.exports = mapCacheClear;
},"node_modules/lodash/_mapCacheClear.js",["node_modules/lodash/_Hash.js","node_modules/lodash/_Map.js","node_modules/lodash/_ListCache.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  Hash.prototype.clear = _$$_REQUIRE(_dependencyMap[0]);
  Hash.prototype['delete'] = _$$_REQUIRE(_dependencyMap[1]);
  Hash.prototype.get = _$$_REQUIRE(_dependencyMap[2]);
  Hash.prototype.has = _$$_REQUIRE(_dependencyMap[3]);
  Hash.prototype.set = _$$_REQUIRE(_dependencyMap[4]);
  module.exports = Hash;
},"node_modules/lodash/_Hash.js",["node_modules/lodash/_hashClear.js","node_modules/lodash/_hashDelete.js","node_modules/lodash/_hashGet.js","node_modules/lodash/_hashHas.js","node_modules/lodash/_hashSet.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function hashClear() {
    this.__data__ = _$$_REQUIRE(_dependencyMap[0]) ? _$$_REQUIRE(_dependencyMap[0])(null) : {};
    this.size = 0;
  }

  module.exports = hashClear;
},"node_modules/lodash/_hashClear.js",["node_modules/lodash/_nativeCreate.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var nativeCreate = _$$_REQUIRE(_dependencyMap[0])(Object, 'create');

  module.exports = nativeCreate;
},"node_modules/lodash/_nativeCreate.js",["node_modules/lodash/_getNative.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  module.exports = hashDelete;
},"node_modules/lodash/_hashDelete.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function hashGet(key) {
    var data = this.__data__;

    if (_$$_REQUIRE(_dependencyMap[0])) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  module.exports = hashGet;
},"node_modules/lodash/_hashGet.js",["node_modules/lodash/_nativeCreate.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function hashHas(key) {
    var data = this.__data__;
    return _$$_REQUIRE(_dependencyMap[0]) ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  module.exports = hashHas;
},"node_modules/lodash/_hashHas.js",["node_modules/lodash/_nativeCreate.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = _$$_REQUIRE(_dependencyMap[0]) && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }

  module.exports = hashSet;
},"node_modules/lodash/_hashSet.js",["node_modules/lodash/_nativeCreate.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function mapCacheDelete(key) {
    var result = _$$_REQUIRE(_dependencyMap[0])(this, key)['delete'](key);

    this.size -= result ? 1 : 0;
    return result;
  }

  module.exports = mapCacheDelete;
},"node_modules/lodash/_mapCacheDelete.js",["node_modules/lodash/_getMapData.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function getMapData(map, key) {
    var data = map.__data__;
    return _$$_REQUIRE(_dependencyMap[0])(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  module.exports = getMapData;
},"node_modules/lodash/_getMapData.js",["node_modules/lodash/_isKeyable.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  module.exports = isKeyable;
},"node_modules/lodash/_isKeyable.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function mapCacheGet(key) {
    return _$$_REQUIRE(_dependencyMap[0])(this, key).get(key);
  }

  module.exports = mapCacheGet;
},"node_modules/lodash/_mapCacheGet.js",["node_modules/lodash/_getMapData.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function mapCacheHas(key) {
    return _$$_REQUIRE(_dependencyMap[0])(this, key).has(key);
  }

  module.exports = mapCacheHas;
},"node_modules/lodash/_mapCacheHas.js",["node_modules/lodash/_getMapData.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function mapCacheSet(key, value) {
    var data = _$$_REQUIRE(_dependencyMap[0])(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  module.exports = mapCacheSet;
},"node_modules/lodash/_mapCacheSet.js",["node_modules/lodash/_getMapData.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var nodeIsTypedArray = _$$_REQUIRE(_dependencyMap[0]) && _$$_REQUIRE(_dependencyMap[0]).isTypedArray;

  var isTypedArray = nodeIsTypedArray ? _$$_REQUIRE(_dependencyMap[1])(nodeIsTypedArray) : _$$_REQUIRE(_dependencyMap[2]);
  module.exports = isTypedArray;
},"node_modules/lodash/isTypedArray.js",["node_modules/lodash/_nodeUtil.js","node_modules/lodash/_baseUnary.js","node_modules/lodash/_baseIsTypedArray.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;

  var freeProcess = moduleExports && _$$_REQUIRE(_dependencyMap[0]).process;

  var nodeUtil = function () {
    try {
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();

  module.exports = nodeUtil;
},"node_modules/lodash/_nodeUtil.js",["node_modules/lodash/_freeGlobal.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  module.exports = baseUnary;
},"node_modules/lodash/_baseUnary.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  function baseIsTypedArray(value) {
    return _$$_REQUIRE(_dependencyMap[0])(value) && _$$_REQUIRE(_dependencyMap[1])(value.length) && !!typedArrayTags[_$$_REQUIRE(_dependencyMap[2])(value)];
  }

  module.exports = baseIsTypedArray;
},"node_modules/lodash/_baseIsTypedArray.js",["node_modules/lodash/isObjectLike.js","node_modules/lodash/isLength.js","node_modules/lodash/_baseGetTag.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var MAX_SAFE_INTEGER = 9007199254740991;

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  module.exports = isLength;
},"node_modules/lodash/isLength.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }

    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);

    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }

    var index = -1,
        result = true,
        seen = bitmask & COMPARE_UNORDERED_FLAG ? new (_$$_REQUIRE(_dependencyMap[0]))() : undefined;
    stack.set(array, other);
    stack.set(other, array);

    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }

      if (compared !== undefined) {
        if (compared) {
          continue;
        }

        result = false;
        break;
      }

      if (seen) {
        if (!_$$_REQUIRE(_dependencyMap[1])(other, function (othValue, othIndex) {
          if (!_$$_REQUIRE(_dependencyMap[2])(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }

    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  module.exports = equalArrays;
},"node_modules/lodash/_equalArrays.js",["node_modules/lodash/_SetCache.js","node_modules/lodash/_arraySome.js","node_modules/lodash/_cacheHas.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;
    this.__data__ = new (_$$_REQUIRE(_dependencyMap[0]))();

    while (++index < length) {
      this.add(values[index]);
    }
  }

  SetCache.prototype.add = SetCache.prototype.push = _$$_REQUIRE(_dependencyMap[1]);
  SetCache.prototype.has = _$$_REQUIRE(_dependencyMap[2]);
  module.exports = SetCache;
},"node_modules/lodash/_SetCache.js",["node_modules/lodash/_MapCache.js","node_modules/lodash/_setCacheAdd.js","node_modules/lodash/_setCacheHas.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);

    return this;
  }

  module.exports = setCacheAdd;
},"node_modules/lodash/_setCacheAdd.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  module.exports = setCacheHas;
},"node_modules/lodash/_setCacheHas.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }

    return false;
  }

  module.exports = arraySome;
},"node_modules/lodash/_arraySome.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  module.exports = cacheHas;
},"node_modules/lodash/_cacheHas.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;
  var boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]';
  var symbolProto = _$$_REQUIRE(_dependencyMap[0]) ? _$$_REQUIRE(_dependencyMap[0]).prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }

        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new (_$$_REQUIRE(_dependencyMap[1]))(object), new (_$$_REQUIRE(_dependencyMap[1]))(other))) {
          return false;
        }

        return true;

      case boolTag:
      case dateTag:
      case numberTag:
        return _$$_REQUIRE(_dependencyMap[2])(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag:
        return object == other + '';

      case mapTag:
        var convert = _$$_REQUIRE(_dependencyMap[3]);

      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = _$$_REQUIRE(_dependencyMap[4]));

        if (object.size != other.size && !isPartial) {
          return false;
        }

        var stacked = stack.get(object);

        if (stacked) {
          return stacked == other;
        }

        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);

        var result = _$$_REQUIRE(_dependencyMap[5])(convert(object), convert(other), bitmask, customizer, equalFunc, stack);

        stack['delete'](object);
        return result;

      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }

    }

    return false;
  }

  module.exports = equalByTag;
},"node_modules/lodash/_equalByTag.js",["node_modules/lodash/_Symbol.js","node_modules/lodash/_Uint8Array.js","node_modules/lodash/eq.js","node_modules/lodash/_mapToArray.js","node_modules/lodash/_setToArray.js","node_modules/lodash/_equalArrays.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = _$$_REQUIRE(_dependencyMap[0]).Uint8Array;
},"node_modules/lodash/_Uint8Array.js",["node_modules/lodash/_root.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  module.exports = mapToArray;
},"node_modules/lodash/_mapToArray.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  module.exports = setToArray;
},"node_modules/lodash/_setToArray.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var COMPARE_PARTIAL_FLAG = 1;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        objProps = _$$_REQUIRE(_dependencyMap[0])(object),
        objLength = objProps.length,
        othProps = _$$_REQUIRE(_dependencyMap[0])(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }

    var index = objLength;

    while (index--) {
      var key = objProps[index];

      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }

    var objStacked = stack.get(object);
    var othStacked = stack.get(other);

    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }

    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;

    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }

      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }

      skipCtor || (skipCtor = key == 'constructor');
    }

    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }

    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  module.exports = equalObjects;
},"node_modules/lodash/_equalObjects.js",["node_modules/lodash/_getAllKeys.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function getAllKeys(object) {
    return _$$_REQUIRE(_dependencyMap[0])(object, _$$_REQUIRE(_dependencyMap[1]), _$$_REQUIRE(_dependencyMap[2]));
  }

  module.exports = getAllKeys;
},"node_modules/lodash/_getAllKeys.js",["node_modules/lodash/_baseGetAllKeys.js","node_modules/lodash/keys.js","node_modules/lodash/_getSymbols.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return _$$_REQUIRE(_dependencyMap[0])(object) ? result : _$$_REQUIRE(_dependencyMap[1])(result, symbolsFunc(object));
  }

  module.exports = baseGetAllKeys;
},"node_modules/lodash/_baseGetAllKeys.js",["node_modules/lodash/isArray.js","node_modules/lodash/_arrayPush.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }

  module.exports = arrayPush;
},"node_modules/lodash/_arrayPush.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function keys(object) {
    return _$$_REQUIRE(_dependencyMap[0])(object) ? _$$_REQUIRE(_dependencyMap[1])(object) : _$$_REQUIRE(_dependencyMap[2])(object);
  }

  module.exports = keys;
},"node_modules/lodash/keys.js",["node_modules/lodash/isArrayLike.js","node_modules/lodash/_arrayLikeKeys.js","node_modules/lodash/_baseKeys.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function isArrayLike(value) {
    return value != null && _$$_REQUIRE(_dependencyMap[0])(value.length) && !_$$_REQUIRE(_dependencyMap[1])(value);
  }

  module.exports = isArrayLike;
},"node_modules/lodash/isArrayLike.js",["node_modules/lodash/isLength.js","node_modules/lodash/isFunction.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function arrayLikeKeys(value, inherited) {
    var isArr = _$$_REQUIRE(_dependencyMap[0])(value),
        isArg = !isArr && _$$_REQUIRE(_dependencyMap[1])(value),
        isBuff = !isArr && !isArg && _$$_REQUIRE(_dependencyMap[2])(value),
        isType = !isArr && !isArg && !isBuff && _$$_REQUIRE(_dependencyMap[3])(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? _$$_REQUIRE(_dependencyMap[4])(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || _$$_REQUIRE(_dependencyMap[5])(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }

  module.exports = arrayLikeKeys;
},"node_modules/lodash/_arrayLikeKeys.js",["node_modules/lodash/isArray.js","node_modules/lodash/isArguments.js","node_modules/lodash/isBuffer.js","node_modules/lodash/isTypedArray.js","node_modules/lodash/_baseTimes.js","node_modules/lodash/_isIndex.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var isArguments = _$$_REQUIRE(_dependencyMap[0])(function () {
    return arguments;
  }()) ? _$$_REQUIRE(_dependencyMap[0]) : function (value) {
    return _$$_REQUIRE(_dependencyMap[1])(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };
  module.exports = isArguments;
},"node_modules/lodash/isArguments.js",["node_modules/lodash/_baseIsArguments.js","node_modules/lodash/isObjectLike.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var argsTag = '[object Arguments]';

  function baseIsArguments(value) {
    return _$$_REQUIRE(_dependencyMap[0])(value) && _$$_REQUIRE(_dependencyMap[1])(value) == argsTag;
  }

  module.exports = baseIsArguments;
},"node_modules/lodash/_baseIsArguments.js",["node_modules/lodash/isObjectLike.js","node_modules/lodash/_baseGetTag.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }

  module.exports = baseTimes;
},"node_modules/lodash/_baseTimes.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  module.exports = isIndex;
},"node_modules/lodash/_isIndex.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;

  function baseKeys(object) {
    if (!_$$_REQUIRE(_dependencyMap[0])(object)) {
      return _$$_REQUIRE(_dependencyMap[1])(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }

  module.exports = baseKeys;
},"node_modules/lodash/_baseKeys.js",["node_modules/lodash/_isPrototype.js","node_modules/lodash/_nativeKeys.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var objectProto = Object.prototype;

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
  }

  module.exports = isPrototype;
},"node_modules/lodash/_isPrototype.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var nativeKeys = _$$_REQUIRE(_dependencyMap[0])(Object.keys, Object);

  module.exports = nativeKeys;
},"node_modules/lodash/_nativeKeys.js",["node_modules/lodash/_overArg.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  module.exports = overArg;
},"node_modules/lodash/_overArg.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var objectProto = Object.prototype;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? _$$_REQUIRE(_dependencyMap[0]) : function (object) {
    if (object == null) {
      return [];
    }

    object = Object(object);
    return _$$_REQUIRE(_dependencyMap[1])(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  module.exports = getSymbols;
},"node_modules/lodash/_getSymbols.js",["node_modules/lodash/stubArray.js","node_modules/lodash/_arrayFilter.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function stubArray() {
    return [];
  }

  module.exports = stubArray;
},"node_modules/lodash/stubArray.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }

    return result;
  }

  module.exports = arrayFilter;
},"node_modules/lodash/_arrayFilter.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0]);

  var RNGestureHandlerModule = _reactNative.NativeModules.RNGestureHandlerModule;

  if (RNGestureHandlerModule == null) {
    console.error((0, _$$_REQUIRE(_dependencyMap[1]).tagMessage)("react-native-gesture-handler module was not found. Make sure you're running your app on the native platform and your code is linked properly (cd ios && pod install && cd ..).\n\n      For installation instructions, please refer to https://docs.swmansion.com/react-native-gesture-handler/docs/#installation".split('\n').map(function (line) {
      return line.trim();
    }).join('\n')));
  }

  if (RNGestureHandlerModule.flushOperations === undefined) {
    RNGestureHandlerModule.flushOperations = function () {};
  }

  var _default = RNGestureHandlerModule;
  exports.default = _default;
},"node_modules/react-native-gesture-handler/src/RNGestureHandlerModule.ts",["node_modules/react-native/index.js","node_modules/react-native-gesture-handler/src/utils.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.hasProperty = hasProperty;
  exports.isFabric = isFabric;
  exports.isJestEnv = isJestEnv;
  exports.isRemoteDebuggingEnabled = isRemoteDebuggingEnabled;
  exports.shouldUseCodegenNativeComponent = shouldUseCodegenNativeComponent;
  exports.tagMessage = tagMessage;
  exports.toArray = toArray;
  exports.withPrevAndCurrent = withPrevAndCurrent;

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  function toArray(object) {
    if (!Array.isArray(object)) {
      return [object];
    }

    return object;
  }

  function withPrevAndCurrent(array, mapFn) {
    var previousArr = [null];
    var currentArr = (0, _toConsumableArray2.default)(array);
    var transformedArr = [];
    currentArr.forEach(function (current, i) {
      var previous = previousArr[i];
      var transformed = mapFn(previous, current);
      previousArr.push(transformed);
      transformedArr.push(transformed);
    });
    return transformedArr;
  }

  function hasProperty(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
  }

  function isJestEnv() {
    return hasProperty(global, 'process') && !!process.env.JEST_WORKER_ID;
  }

  function tagMessage(msg) {
    return "[react-native-gesture-handler] " + msg;
  }

  function isFabric() {
    var _global;

    return !!((_global = global) != null && _global.nativeFabricUIManager);
  }

  function shouldUseCodegenNativeComponent() {
    var _rnVersion$split = _$$_REQUIRE(_dependencyMap[3]).version.split('.'),
        _rnVersion$split2 = (0, _slicedToArray2.default)(_rnVersion$split, 2),
        majorStr = _rnVersion$split2[0],
        minorStr = _rnVersion$split2[1];

    var major = Number.parseInt(majorStr);
    var minor = Number.parseInt(minorStr);
    return minor >= 68 || major > 0;
  }

  function isRemoteDebuggingEnabled() {
    return !global.nativeCallSyncHook || global.__REMOTEDEV__;
  }
},"node_modules/react-native-gesture-handler/src/utils.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/react-native/package.json"]);
__d(function(global, require, _importDefaultUnused, _importAllUnused, module, exports, _dependencyMapUnused) {
  module.exports = {
  "_args": [
    [
      "react-native@0.68.2",
      "/Users/xiaolongli/study-project/ReactNativeApp"
    ]
  ],
  "_from": "react-native@0.68.2",
  "_id": "react-native@0.68.2",
  "_inBundle": false,
  "_integrity": "sha512-qNMz+mdIirCEmlrhapAtAG+SWVx6MAiSfCbFNhfHqiqu1xw1OKXdzIrjaBEPihRC2pcORCoCHduHGQe/Pz9Yuw==",
  "_location": "/react-native",
  "_phantomChildren": {
    "@react-native-community/cli-debugger-ui": "7.0.3",
    "@react-native-community/cli-hermes": "6.3.0",
    "@react-native-community/cli-plugin-metro": "7.0.3",
    "@react-native-community/cli-server-api": "7.0.3",
    "@react-native-community/cli-tools": "6.2.0",
    "@react-native-community/cli-types": "6.0.0",
    "appdirsjs": "1.2.6",
    "chalk": "4.1.2",
    "command-exists": "1.2.9",
    "commander": "2.20.3",
    "cosmiconfig": "5.2.1",
    "deepmerge": "3.3.0",
    "envinfo": "7.8.1",
    "execa": "1.0.0",
    "find-up": "4.1.0",
    "fs-extra": "8.1.0",
    "glob": "7.2.3",
    "graceful-fs": "4.2.10",
    "joi": "17.6.0",
    "leven": "3.1.0",
    "lodash": "4.17.21",
    "minimist": "1.2.6",
    "node-stream-zip": "1.15.0",
    "ora": "3.4.0",
    "pretty-format": "26.6.2",
    "prompts": "2.4.2",
    "semver": "6.3.0",
    "serve-static": "1.15.0",
    "sudo-prompt": "9.2.1",
    "wcwidth": "1.0.1"
  },
  "_requested": {
    "type": "version",
    "registry": true,
    "raw": "react-native@0.68.2",
    "name": "react-native",
    "escapedName": "react-native",
    "rawSpec": "0.68.2",
    "saveSpec": null,
    "fetchSpec": "0.68.2"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://npm.shopee.io/react-native/-/react-native-0.68.2.tgz",
  "_spec": "0.68.2",
  "_where": "/Users/xiaolongli/study-project/ReactNativeApp",
  "bin": {
    "react-native": "cli.js"
  },
  "bugs": {
    "url": "https://github.com/facebook/react-native/issues"
  },
  "codegenConfig": {
    "libraries": [
      {
        "name": "FBReactNativeSpec",
        "type": "modules",
        "ios": {},
        "android": {},
        "jsSrcsDir": "Libraries"
      },
      {
        "name": "rncore",
        "type": "components",
        "ios": {},
        "android": {},
        "jsSrcsDir": "Libraries"
      }
    ]
  },
  "dependencies": {
    "@jest/create-cache-key-function": "^27.0.1",
    "@react-native-community/cli": "^7.0.3",
    "@react-native-community/cli-platform-android": "^7.0.1",
    "@react-native-community/cli-platform-ios": "^7.0.1",
    "@react-native/assets": "1.0.0",
    "@react-native/normalize-color": "2.0.0",
    "@react-native/polyfills": "2.0.0",
    "abort-controller": "^3.0.0",
    "anser": "^1.4.9",
    "base64-js": "^1.1.2",
    "deprecated-react-native-prop-types": "^2.3.0",
    "event-target-shim": "^5.0.1",
    "hermes-engine": "~0.11.0",
    "invariant": "^2.2.4",
    "jsc-android": "^250230.2.1",
    "metro-react-native-babel-transformer": "0.67.0",
    "metro-runtime": "0.67.0",
    "metro-source-map": "0.67.0",
    "nullthrows": "^1.1.1",
    "pretty-format": "^26.5.2",
    "promise": "^8.0.3",
    "react-devtools-core": "^4.23.0",
    "react-native-codegen": "^0.0.17",
    "react-native-gradle-plugin": "^0.0.6",
    "react-refresh": "^0.4.0",
    "react-shallow-renderer": "16.14.1",
    "regenerator-runtime": "^0.13.2",
    "scheduler": "^0.20.2",
    "stacktrace-parser": "^0.1.3",
    "use-subscription": ">=1.0.0 <1.6.0",
    "whatwg-fetch": "^3.0.0",
    "ws": "^6.1.4"
  },
  "description": "A framework for building native apps using React",
  "devDependencies": {
    "@babel/core": "^7.14.0",
    "@babel/generator": "^7.14.0",
    "@react-native-community/eslint-plugin": "*",
    "@react-native/eslint-plugin-specs": ">0.0.2",
    "@reactions/component": "^2.0.2",
    "async": "^2.4.0",
    "babel-eslint": "^10.1.0",
    "clang-format": "^1.2.4",
    "connect": "^3.6.5",
    "coveralls": "^3.0.2",
    "eslint": "^7.32.0",
    "eslint-config-fb-strict": "^26.0.0",
    "eslint-config-fbjs": "^3.1.1",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-babel": "^5.3.1",
    "eslint-plugin-eslint-comments": "^3.2.0",
    "eslint-plugin-flowtype": "^7.0.0",
    "eslint-plugin-jest": "^25.2.4",
    "eslint-plugin-jsx-a11y": "^6.4.1",
    "eslint-plugin-prettier": "^4.0.0",
    "eslint-plugin-react": "^7.26.1",
    "eslint-plugin-react-hooks": "^4.2.0",
    "eslint-plugin-react-native": "^3.11.0",
    "eslint-plugin-relay": "^1.8.2",
    "flow-bin": "^0.170.0",
    "inquirer": "^7.1.0",
    "jest": "^26.6.3",
    "jest-junit": "^10.0.0",
    "jscodeshift": "^0.13.1",
    "metro-babel-register": "0.67.0",
    "mkdirp": "^0.5.1",
    "prettier": "^2.4.1",
    "react": "17.0.2",
    "react-test-renderer": "17.0.2",
    "shelljs": "^0.8.4",
    "signedsource": "^1.0.0",
    "ws": "^6.1.4",
    "yargs": "^15.3.1"
  },
  "engines": {
    "node": ">=14"
  },
  "files": [
    "!template/node_modules",
    "!template/package-lock.json",
    "!template/yarn.lock",
    "android",
    "cli.js",
    "flow",
    "flow-typed",
    "index.js",
    "interface.js",
    "jest-preset.js",
    "jest",
    "Libraries",
    "LICENSE",
    "local-cli",
    "React-Core.podspec",
    "react-native.config.js",
    "react.gradle",
    "React.podspec",
    "React",
    "ReactAndroid",
    "ReactCommon",
    "README.md",
    "rn-get-polyfills.js",
    "scripts/compose-source-maps.js",
    "scripts/find-node.sh",
    "scripts/generate-artifacts.js",
    "scripts/generate-provider-cli.js",
    "scripts/generate-specs-cli.js",
    "scripts/ios-configure-glog.sh",
    "scripts/launchPackager.bat",
    "scripts/launchPackager.command",
    "scripts/node-binary.sh",
    "scripts/packager.sh",
    "scripts/packager-reporter.js",
    "scripts/react_native_pods_utils/script_phases.rb",
    "scripts/react_native_pods_utils/script_phases.sh",
    "scripts/react_native_pods.rb",
    "scripts/react-native-xcode.sh",
    "template.config.js",
    "template",
    "third-party-podspecs"
  ],
  "homepage": "https://github.com/facebook/react-native#readme",
  "jest-junit": {
    "outputDirectory": "reports/junit",
    "outputName": "js-test-results.xml"
  },
  "license": "MIT",
  "name": "react-native",
  "peerDependencies": {
    "react": "17.0.2"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/facebook/react-native.git"
  },
  "scripts": {
    "clang-format": "clang-format -i --glob=*/**/*.{h,cpp,m,mm}",
    "docker-build-android": "docker build -t reactnativeci/android -f .circleci/Dockerfiles/Dockerfile.android .",
    "docker-setup-android": "docker pull reactnativecommunity/react-native-android:5.2",
    "flow": "flow",
    "flow-check-android": "flow check --flowconfig-name .flowconfig.android",
    "flow-check-ios": "flow check",
    "format": "npm run prettier && npm run clang-format",
    "format-check": "prettier --list-different \"./**/*.{js,md,yml}\"",
    "lint": "eslint .",
    "lint-ci": "./scripts/circleci/analyze_code.sh && yarn shellcheck",
    "lint-java": "node ./scripts/lint-java.js",
    "prettier": "prettier --write \"./**/*.{js,md,yml}\"",
    "shellcheck": "./scripts/circleci/analyze_scripts.sh",
    "start": "react-native start",
    "test": "jest",
    "test-android-all": "yarn run docker-build-android && yarn run test-android-run-unit && yarn run test-android-run-instrumentation && yarn run test-android-run-e2e",
    "test-android-e2e": "yarn run docker-build-android && yarn run test-android-run-e2e",
    "test-android-instrumentation": "yarn run docker-build-android && yarn run test-android-run-instrumentation",
    "test-android-run-e2e": "docker run --privileged -it reactnativeci/android bash .circleci/Dockerfiles/scripts/run-ci-e2e-tests.sh --android --js",
    "test-android-run-instrumentation": "docker run --cap-add=SYS_ADMIN -it reactnativeci/android bash .circleci/Dockerfiles/scripts/run-android-docker-instrumentation-tests.sh",
    "test-android-run-unit": "docker run --cap-add=SYS_ADMIN -it reactnativeci/android bash .circleci/Dockerfiles/scripts/run-android-docker-unit-tests.sh",
    "test-android-unit": "yarn run docker-build-android && yarn run test-android-run-unit",
    "test-ci": "jest --maxWorkers=2 --ci --reporters=\"default\" --reporters=\"jest-junit\"",
    "test-ios": "./scripts/objc-test.sh test",
    "update-lock": "npx yarn-deduplicate"
  },
  "version": "0.68.2"
}
;
},"node_modules/react-native/package.json",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.State = undefined;
  var State = {
    UNDETERMINED: 0,
    FAILED: 1,
    BEGAN: 2,
    CANCELLED: 3,
    ACTIVE: 4,
    END: 5
  };
  exports.State = State;
},"node_modules/react-native-gesture-handler/src/State.ts",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ActionType = undefined;
  var ActionType = {
    REANIMATED_WORKLET: 1,
    NATIVE_ANIMATED_EVENT: 2,
    JS_FUNCTION_OLD_API: 3,
    JS_FUNCTION_NEW_API: 4
  };
  exports.ActionType = ActionType;
},"node_modules/react-native-gesture-handler/src/ActionType.ts",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.findHandler = findHandler;
  exports.findHandlerByTestID = findHandlerByTestID;
  exports.findOldGestureHandler = findOldGestureHandler;
  exports.getNextHandlerTag = getNextHandlerTag;
  exports.handlerIDToTag = undefined;
  exports.registerHandler = registerHandler;
  exports.registerOldGestureHandler = registerOldGestureHandler;
  exports.unregisterHandler = unregisterHandler;
  var handlerIDToTag = {};
  exports.handlerIDToTag = handlerIDToTag;
  var gestures = new Map();
  var oldHandlers = new Map();
  var testIDs = new Map();
  var handlerTag = 1;

  function getNextHandlerTag() {
    return handlerTag++;
  }

  function registerHandler(handlerTag, handler, testID) {
    gestures.set(handlerTag, handler);

    if ((0, _$$_REQUIRE(_dependencyMap[0]).isJestEnv)() && testID) {
      testIDs.set(testID, handlerTag);
    }
  }

  function registerOldGestureHandler(handlerTag, handler) {
    oldHandlers.set(handlerTag, handler);
  }

  function unregisterHandler(handlerTag, testID) {
    gestures.delete(handlerTag);

    if ((0, _$$_REQUIRE(_dependencyMap[0]).isJestEnv)() && testID) {
      testIDs.delete(testID);
    }
  }

  function findHandler(handlerTag) {
    return gestures.get(handlerTag);
  }

  function findOldGestureHandler(handlerTag) {
    return oldHandlers.get(handlerTag);
  }

  function findHandlerByTestID(testID) {
    var handlerTag = testIDs.get(testID);

    if (handlerTag !== undefined) {
      var _findHandler;

      return (_findHandler = findHandler(handlerTag)) != null ? _findHandler : null;
    }

    return null;
  }
},"node_modules/react-native-gesture-handler/src/handlers/handlersRegistry.ts",["node_modules/react-native-gesture-handler/src/utils.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.baseGestureHandlerWithMonitorProps = exports.baseGestureHandlerProps = undefined;
  exports.filterConfig = filterConfig;
  exports.findNodeHandle = findNodeHandle;
  exports.scheduleFlushOperations = scheduleFlushOperations;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[2]);

  var _RNGestureHandlerModule = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var commonProps = ['id', 'enabled', 'shouldCancelWhenOutside', 'hitSlop', 'cancelsTouchesInView'];
  var componentInteractionProps = ['waitFor', 'simultaneousHandlers'];
  var baseGestureHandlerProps = [].concat(commonProps, componentInteractionProps, ['onBegan', 'onFailed', 'onCancelled', 'onActivated', 'onEnded', 'onGestureEvent', 'onHandlerStateChange']);
  exports.baseGestureHandlerProps = baseGestureHandlerProps;
  var baseGestureHandlerWithMonitorProps = [].concat(commonProps, ['needsPointerData', 'manualActivation']);
  exports.baseGestureHandlerWithMonitorProps = baseGestureHandlerWithMonitorProps;

  function isConfigParam(param, name) {
    return param !== undefined && (param !== Object(param) || !('__isNative' in param)) && name !== 'onHandlerStateChange' && name !== 'onGestureEvent';
  }

  function filterConfig(props, validProps) {
    var defaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var filteredConfig = (0, _extends2.default)({}, defaults);

    for (var _iterator = _createForOfIteratorHelperLoose(validProps), _step; !(_step = _iterator()).done;) {
      var key = _step.value;
      var value = props[key];

      if (isConfigParam(value, key)) {
        if (key === 'simultaneousHandlers' || key === 'waitFor') {
          value = transformIntoHandlerTags(props[key]);
        } else if (key === 'hitSlop' && typeof value !== 'object') {
          value = {
            top: value,
            left: value,
            bottom: value,
            right: value
          };
        }

        filteredConfig[key] = value;
      }
    }

    return filteredConfig;
  }

  function transformIntoHandlerTags(handlerIDs) {
    handlerIDs = (0, _$$_REQUIRE(_dependencyMap[4]).toArray)(handlerIDs);

    if (_reactNative.Platform.OS === 'web') {
      return handlerIDs.map(function (_ref) {
        var current = _ref.current;
        return current;
      }).filter(function (handle) {
        return handle;
      });
    }

    return handlerIDs.map(function (handlerID) {
      var _handlerID$current;

      return _$$_REQUIRE(_dependencyMap[5]).handlerIDToTag[handlerID] || ((_handlerID$current = handlerID.current) == null ? undefined : _handlerID$current.handlerTag) || -1;
    }).filter(function (handlerTag) {
      return handlerTag > 0;
    });
  }

  function findNodeHandle(node) {
    if (_reactNative.Platform.OS === 'web') return node;
    return (0, _reactNative.findNodeHandle)(node);
  }

  var scheduledFlushOperationsId = null;

  function scheduleFlushOperations() {
    if (scheduledFlushOperationsId === null) {
      scheduledFlushOperationsId = requestAnimationFrame(function () {
        _RNGestureHandlerModule.default.flushOperations();

        scheduledFlushOperationsId = null;
      });
    }
  }
},"node_modules/react-native-gesture-handler/src/handlers/gestureHandlerCommon.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native/index.js","node_modules/react-native-gesture-handler/src/RNGestureHandlerModule.ts","node_modules/react-native-gesture-handler/src/utils.ts","node_modules/react-native-gesture-handler/src/handlers/handlersRegistry.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0]);

  var RNGestureHandlerButtonNativeComponent = (0, _$$_REQUIRE(_dependencyMap[1]).shouldUseCodegenNativeComponent)() ? _$$_REQUIRE(_dependencyMap[2]).default : (0, _reactNative.requireNativeComponent)('RNGestureHandlerButton');
  var _default = RNGestureHandlerButtonNativeComponent;
  exports.default = _default;
},"node_modules/react-native-gesture-handler/src/components/GestureHandlerButton.tsx",["node_modules/react-native/index.js","node_modules/react-native-gesture-handler/src/utils.ts","node_modules/react-native-gesture-handler/src/fabric/RNGestureHandlerButtonNativeComponent.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var codegenNativeComponent = _codegenNativeComponent.default;

  var _default = codegenNativeComponent('RNGestureHandlerButton');

  exports.default = _default;
},"node_modules/react-native-gesture-handler/src/fabric/RNGestureHandlerButtonNativeComponent.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Directions = undefined;
  var Directions = {
    RIGHT: 1,
    LEFT: 2,
    UP: 4,
    DOWN: 8
  };
  exports.Directions = Directions;
},"node_modules/react-native-gesture-handler/src/Directions.ts",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TextInput = exports.Switch = exports.ScrollView = exports.FlatList = exports.DrawerLayoutAndroid = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[4]);

  var _createNativeWrapper = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var ScrollView = (0, _createNativeWrapper.default)(_reactNative.ScrollView, {
    disallowInterruption: true,
    shouldCancelWhenOutside: false
  });
  exports.ScrollView = ScrollView;
  var Switch = (0, _createNativeWrapper.default)(_reactNative.Switch, {
    shouldCancelWhenOutside: false,
    shouldActivateOnStart: true,
    disallowInterruption: true
  });
  exports.Switch = Switch;
  var TextInput = (0, _createNativeWrapper.default)(_reactNative.TextInput);
  exports.TextInput = TextInput;
  var DrawerLayoutAndroid = (0, _createNativeWrapper.default)(_reactNative.DrawerLayoutAndroid, {
    disallowInterruption: true
  });
  exports.DrawerLayoutAndroid = DrawerLayoutAndroid;
  var FlatList = React.forwardRef(function (props, ref) {
    var flatListProps = {};
    var scrollViewProps = {};

    for (var _i = 0, _Object$entries = Object.entries(props); _i < _Object$entries.length; _i++) {
      var _ref = _Object$entries[_i];

      var _ref2 = (0, _slicedToArray2.default)(_ref, 2);

      var propName = _ref2[0];
      var value = _ref2[1];

      if (_$$_REQUIRE(_dependencyMap[6]).nativeViewProps.includes(propName)) {
        scrollViewProps[propName] = value;
      } else {
        flatListProps[propName] = value;
      }
    }

    return React.createElement(_reactNative.FlatList, (0, _extends2.default)({
      ref: ref
    }, flatListProps, {
      renderScrollComponent: function renderScrollComponent(scrollProps) {
        return React.createElement(ScrollView, (0, _extends2.default)({}, scrollProps, scrollViewProps));
      }
    }));
  });
  exports.FlatList = FlatList;
},"node_modules/react-native-gesture-handler/src/components/GestureComponents.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/react-native-gesture-handler/src/handlers/createNativeWrapper.tsx","node_modules/react-native-gesture-handler/src/handlers/NativeViewGestureHandler.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.flingHandlerName = exports.flingGestureHandlerProps = exports.FlingGestureHandler = undefined;

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createHandler = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var flingGestureHandlerProps = ['numberOfPointers', 'direction'];
  exports.flingGestureHandlerProps = flingGestureHandlerProps;
  var flingHandlerName = 'FlingGestureHandler';
  exports.flingHandlerName = flingHandlerName;
  var FlingGestureHandler = (0, _createHandler.default)({
    name: flingHandlerName,
    allowedProps: [].concat((0, _toConsumableArray2.default)(_$$_REQUIRE(_dependencyMap[3]).baseGestureHandlerProps), flingGestureHandlerProps),
    config: {}
  });
  exports.FlingGestureHandler = FlingGestureHandler;
},"node_modules/react-native-gesture-handler/src/handlers/FlingGestureHandler.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/react-native-gesture-handler/src/handlers/createHandler.ts","node_modules/react-native-gesture-handler/src/handlers/gestureHandlerCommon.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.forceTouchHandlerName = exports.forceTouchGestureHandlerProps = exports.ForceTouchGestureHandler = undefined;

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _react = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _PlatformConstants = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _createHandler = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var forceTouchGestureHandlerProps = ['minForce', 'maxForce', 'feedbackOnActivation'];
  exports.forceTouchGestureHandlerProps = forceTouchGestureHandlerProps;

  var ForceTouchFallback = function (_React$Component) {
    (0, _inherits2.default)(ForceTouchFallback, _React$Component);

    var _super = _createSuper(ForceTouchFallback);

    function ForceTouchFallback() {
      (0, _classCallCheck2.default)(this, ForceTouchFallback);
      return _super.apply(this, arguments);
    }

    (0, _createClass2.default)(ForceTouchFallback, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        console.warn((0, _$$_REQUIRE(_dependencyMap[10]).tagMessage)('ForceTouchGestureHandler is not available on this platform. Please use ForceTouchGestureHandler.forceTouchAvailable to conditionally render other components that would provide a fallback behavior specific to your usecase'));
      }
    }, {
      key: "render",
      value: function render() {
        return this.props.children;
      }
    }]);
    return ForceTouchFallback;
  }(_react.default.Component);

  ForceTouchFallback.forceTouchAvailable = false;
  var forceTouchHandlerName = 'ForceTouchGestureHandler';
  exports.forceTouchHandlerName = forceTouchHandlerName;
  var ForceTouchGestureHandler = _PlatformConstants.default != null && _PlatformConstants.default.forceTouchAvailable ? (0, _createHandler.default)({
    name: forceTouchHandlerName,
    allowedProps: [].concat((0, _toConsumableArray2.default)(_$$_REQUIRE(_dependencyMap[11]).baseGestureHandlerProps), forceTouchGestureHandlerProps),
    config: {}
  }) : ForceTouchFallback;
  exports.ForceTouchGestureHandler = ForceTouchGestureHandler;
  ForceTouchGestureHandler.forceTouchAvailable = (_PlatformConstants.default == null ? undefined : _PlatformConstants.default.forceTouchAvailable) || false;
},"node_modules/react-native-gesture-handler/src/handlers/ForceTouchGestureHandler.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react/index.js","node_modules/react-native-gesture-handler/src/PlatformConstants.ts","node_modules/react-native-gesture-handler/src/handlers/createHandler.ts","node_modules/react-native-gesture-handler/src/utils.ts","node_modules/react-native-gesture-handler/src/handlers/gestureHandlerCommon.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0]);

  var _NativeModules$Platfo;

  var _default = (_NativeModules$Platfo = _reactNative.NativeModules == null ? undefined : _reactNative.NativeModules.PlatformConstants) != null ? _NativeModules$Platfo : _reactNative.Platform.constants;

  exports.default = _default;
},"node_modules/react-native-gesture-handler/src/PlatformConstants.ts",["node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.GestureObjects = undefined;

  var _construct2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var GestureObjects = {
    Tap: function Tap() {
      return new (_$$_REQUIRE(_dependencyMap[2]).TapGesture)();
    },
    Pan: function Pan() {
      return new (_$$_REQUIRE(_dependencyMap[3]).PanGesture)();
    },
    Pinch: function Pinch() {
      return new (_$$_REQUIRE(_dependencyMap[4]).PinchGesture)();
    },
    Rotation: function Rotation() {
      return new (_$$_REQUIRE(_dependencyMap[5]).RotationGesture)();
    },
    Fling: function Fling() {
      return new (_$$_REQUIRE(_dependencyMap[6]).FlingGesture)();
    },
    LongPress: function LongPress() {
      return new (_$$_REQUIRE(_dependencyMap[7]).LongPressGesture)();
    },
    ForceTouch: function ForceTouch() {
      return new (_$$_REQUIRE(_dependencyMap[8]).ForceTouchGesture)();
    },
    Native: function Native() {
      return new (_$$_REQUIRE(_dependencyMap[9]).NativeGesture)();
    },
    Manual: function Manual() {
      return new (_$$_REQUIRE(_dependencyMap[10]).ManualGesture)();
    },
    Race: function Race() {
      for (var _len = arguments.length, gestures = new Array(_len), _key = 0; _key < _len; _key++) {
        gestures[_key] = arguments[_key];
      }

      return (0, _construct2.default)(_$$_REQUIRE(_dependencyMap[11]).ComposedGesture, gestures);
    },
    Simultaneous: function Simultaneous() {
      for (var _len2 = arguments.length, gestures = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        gestures[_key2] = arguments[_key2];
      }

      return (0, _construct2.default)(_$$_REQUIRE(_dependencyMap[11]).SimultaneousGesture, gestures);
    },
    Exclusive: function Exclusive() {
      for (var _len3 = arguments.length, gestures = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        gestures[_key3] = arguments[_key3];
      }

      return (0, _construct2.default)(_$$_REQUIRE(_dependencyMap[11]).ExclusiveGesture, gestures);
    }
  };
  exports.GestureObjects = GestureObjects;
},"node_modules/react-native-gesture-handler/src/handlers/gestures/gestureObjects.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/construct.js","node_modules/react-native-gesture-handler/src/handlers/gestures/tapGesture.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/panGesture.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/pinchGesture.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/rotationGesture.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/flingGesture.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/longPressGesture.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/forceTouchGesture.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/nativeGesture.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/manualGesture.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/gestureComposition.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TapGesture = undefined;

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TapGesture = function (_BaseGesture) {
    (0, _inherits2.default)(TapGesture, _BaseGesture);

    var _super = _createSuper(TapGesture);

    function TapGesture() {
      var _this;

      (0, _classCallCheck2.default)(this, TapGesture);
      _this = _super.call(this);
      _this.config = {};
      _this.handlerName = 'TapGestureHandler';
      return _this;
    }

    (0, _createClass2.default)(TapGesture, [{
      key: "minPointers",
      value: function minPointers(_minPointers) {
        this.config.minPointers = _minPointers;
        return this;
      }
    }, {
      key: "numberOfTaps",
      value: function numberOfTaps(count) {
        this.config.numberOfTaps = count;
        return this;
      }
    }, {
      key: "maxDistance",
      value: function maxDistance(maxDist) {
        this.config.maxDist = maxDist;
        return this;
      }
    }, {
      key: "maxDuration",
      value: function maxDuration(duration) {
        this.config.maxDurationMs = duration;
        return this;
      }
    }, {
      key: "maxDelay",
      value: function maxDelay(delay) {
        this.config.maxDelayMs = delay;
        return this;
      }
    }, {
      key: "maxDeltaX",
      value: function maxDeltaX(delta) {
        this.config.maxDeltaX = delta;
        return this;
      }
    }, {
      key: "maxDeltaY",
      value: function maxDeltaY(delta) {
        this.config.maxDeltaY = delta;
        return this;
      }
    }]);
    return TapGesture;
  }(_$$_REQUIRE(_dependencyMap[6]).BaseGesture);

  exports.TapGesture = TapGesture;
},"node_modules/react-native-gesture-handler/src/handlers/gestures/tapGesture.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native-gesture-handler/src/handlers/gestures/gesture.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Gesture = exports.ContinousBaseGesture = exports.CALLBACK_TYPE = exports.BaseGesture = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var CALLBACK_TYPE = {
    UNDEFINED: 0,
    BEGAN: 1,
    START: 2,
    UPDATE: 3,
    CHANGE: 4,
    END: 5,
    FINALIZE: 6,
    TOUCHES_DOWN: 7,
    TOUCHES_MOVE: 8,
    TOUCHES_UP: 9,
    TOUCHES_CANCELLED: 10
  };
  exports.CALLBACK_TYPE = CALLBACK_TYPE;
  var Gesture = (0, _createClass2.default)(function Gesture() {
    (0, _classCallCheck2.default)(this, Gesture);
  });
  exports.Gesture = Gesture;
  var nextGestureId = 0;

  var BaseGesture = function (_Gesture) {
    (0, _inherits2.default)(BaseGesture, _Gesture);

    var _super = _createSuper(BaseGesture);

    function BaseGesture() {
      var _this;

      (0, _classCallCheck2.default)(this, BaseGesture);
      _this = _super.call(this);
      _this.gestureId = -1;
      _this.handlerTag = -1;
      _this.handlerName = '';
      _this.config = {};
      _this.handlers = {
        gestureId: -1,
        handlerTag: -1,
        isWorklet: []
      };
      _this.gestureId = nextGestureId++;
      _this.handlers.gestureId = _this.gestureId;
      return _this;
    }

    (0, _createClass2.default)(BaseGesture, [{
      key: "addDependency",
      value: function addDependency(key, gesture) {
        var value = this.config[key];
        this.config[key] = value ? Array().concat(value, gesture) : [gesture];
      }
    }, {
      key: "withRef",
      value: function withRef(ref) {
        this.config.ref = ref;
        return this;
      }
    }, {
      key: "isWorklet",
      value: function isWorklet(callback) {
        return callback.__workletHash !== undefined;
      }
    }, {
      key: "onBegin",
      value: function onBegin(callback) {
        this.handlers.onBegin = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.BEGAN] = this.isWorklet(callback);
        return this;
      }
    }, {
      key: "onStart",
      value: function onStart(callback) {
        this.handlers.onStart = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.START] = this.isWorklet(callback);
        return this;
      }
    }, {
      key: "onEnd",
      value: function onEnd(callback) {
        this.handlers.onEnd = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.END] = this.isWorklet(callback);
        return this;
      }
    }, {
      key: "onFinalize",
      value: function onFinalize(callback) {
        this.handlers.onFinalize = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.FINALIZE] = this.isWorklet(callback);
        return this;
      }
    }, {
      key: "onTouchesDown",
      value: function onTouchesDown(callback) {
        this.config.needsPointerData = true;
        this.handlers.onTouchesDown = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_DOWN] = this.isWorklet(callback);
        return this;
      }
    }, {
      key: "onTouchesMove",
      value: function onTouchesMove(callback) {
        this.config.needsPointerData = true;
        this.handlers.onTouchesMove = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_MOVE] = this.isWorklet(callback);
        return this;
      }
    }, {
      key: "onTouchesUp",
      value: function onTouchesUp(callback) {
        this.config.needsPointerData = true;
        this.handlers.onTouchesUp = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_UP] = this.isWorklet(callback);
        return this;
      }
    }, {
      key: "onTouchesCancelled",
      value: function onTouchesCancelled(callback) {
        this.config.needsPointerData = true;
        this.handlers.onTouchesCancelled = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.TOUCHES_CANCELLED] = this.isWorklet(callback);
        return this;
      }
    }, {
      key: "enabled",
      value: function enabled(_enabled) {
        this.config.enabled = _enabled;
        return this;
      }
    }, {
      key: "shouldCancelWhenOutside",
      value: function shouldCancelWhenOutside(value) {
        this.config.shouldCancelWhenOutside = value;
        return this;
      }
    }, {
      key: "hitSlop",
      value: function hitSlop(_hitSlop) {
        this.config.hitSlop = _hitSlop;
        return this;
      }
    }, {
      key: "runOnJS",
      value: function runOnJS(_runOnJS) {
        this.config.runOnJS = _runOnJS;
        return this;
      }
    }, {
      key: "simultaneousWithExternalGesture",
      value: function simultaneousWithExternalGesture() {
        for (var _len = arguments.length, gestures = new Array(_len), _key = 0; _key < _len; _key++) {
          gestures[_key] = arguments[_key];
        }

        for (var _i = 0, _gestures = gestures; _i < _gestures.length; _i++) {
          var gesture = _gestures[_i];
          this.addDependency('simultaneousWith', gesture);
        }

        return this;
      }
    }, {
      key: "requireExternalGestureToFail",
      value: function requireExternalGestureToFail() {
        for (var _len2 = arguments.length, gestures = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          gestures[_key2] = arguments[_key2];
        }

        for (var _i2 = 0, _gestures2 = gestures; _i2 < _gestures2.length; _i2++) {
          var gesture = _gestures2[_i2];
          this.addDependency('requireToFail', gesture);
        }

        return this;
      }
    }, {
      key: "withTestId",
      value: function withTestId(id) {
        this.config.testId = id;
        return this;
      }
    }, {
      key: "cancelsTouchesInView",
      value: function cancelsTouchesInView(value) {
        this.config.cancelsTouchesInView = value;
        return this;
      }
    }, {
      key: "initialize",
      value: function initialize() {
        this.handlerTag = (0, _$$_REQUIRE(_dependencyMap[7]).getNextHandlerTag)();
        this.handlers = (0, _extends2.default)({}, this.handlers, {
          handlerTag: this.handlerTag
        });

        if (this.config.ref) {
          this.config.ref.current = this;
        }
      }
    }, {
      key: "toGestureArray",
      value: function toGestureArray() {
        return [this];
      }
    }, {
      key: "prepare",
      value: function prepare() {}
    }, {
      key: "shouldUseReanimated",
      get: function get() {
        return this.config.runOnJS !== true && !this.handlers.isWorklet.includes(false) && !(0, _$$_REQUIRE(_dependencyMap[8]).isRemoteDebuggingEnabled)();
      }
    }]);
    return BaseGesture;
  }(Gesture);

  exports.BaseGesture = BaseGesture;

  var ContinousBaseGesture = function (_BaseGesture) {
    (0, _inherits2.default)(ContinousBaseGesture, _BaseGesture);

    var _super2 = _createSuper(ContinousBaseGesture);

    function ContinousBaseGesture() {
      (0, _classCallCheck2.default)(this, ContinousBaseGesture);
      return _super2.apply(this, arguments);
    }

    (0, _createClass2.default)(ContinousBaseGesture, [{
      key: "onUpdate",
      value: function onUpdate(callback) {
        this.handlers.onUpdate = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.UPDATE] = this.isWorklet(callback);
        return this;
      }
    }, {
      key: "onChange",
      value: function onChange(callback) {
        this.handlers.onChange = callback;
        this.handlers.isWorklet[CALLBACK_TYPE.CHANGE] = this.isWorklet(callback);
        return this;
      }
    }, {
      key: "manualActivation",
      value: function manualActivation(_manualActivation) {
        this.config.manualActivation = _manualActivation;
        return this;
      }
    }]);
    return ContinousBaseGesture;
  }(BaseGesture);

  exports.ContinousBaseGesture = ContinousBaseGesture;
},"node_modules/react-native-gesture-handler/src/handlers/gestures/gesture.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/react-native-gesture-handler/src/handlers/handlersRegistry.ts","node_modules/react-native-gesture-handler/src/utils.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PanGesture = undefined;

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _get2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function changeEventCalculator(current, previous) {
    'worklet';

    var changePayload;

    if (previous === undefined) {
      changePayload = {
        changeX: current.translationX,
        changeY: current.translationY
      };
    } else {
      changePayload = {
        changeX: current.translationX - previous.translationX,
        changeY: current.translationY - previous.translationY
      };
    }

    return (0, _extends2.default)({}, current, changePayload);
  }

  var PanGesture = function (_ContinousBaseGesture) {
    (0, _inherits2.default)(PanGesture, _ContinousBaseGesture);

    var _super = _createSuper(PanGesture);

    function PanGesture() {
      var _this;

      (0, _classCallCheck2.default)(this, PanGesture);
      _this = _super.call(this);
      _this.config = {};
      _this.handlerName = 'PanGestureHandler';
      return _this;
    }

    (0, _createClass2.default)(PanGesture, [{
      key: "activeOffsetY",
      value: function activeOffsetY(offset) {
        if (Array.isArray(offset)) {
          this.config.activeOffsetYStart = offset[0];
          this.config.activeOffsetYEnd = offset[1];
        } else if (offset < 0) {
          this.config.activeOffsetYStart = offset;
        } else {
          this.config.activeOffsetYEnd = offset;
        }

        return this;
      }
    }, {
      key: "activeOffsetX",
      value: function activeOffsetX(offset) {
        if (Array.isArray(offset)) {
          this.config.activeOffsetXStart = offset[0];
          this.config.activeOffsetXEnd = offset[1];
        } else if (offset < 0) {
          this.config.activeOffsetXStart = offset;
        } else {
          this.config.activeOffsetXEnd = offset;
        }

        return this;
      }
    }, {
      key: "failOffsetY",
      value: function failOffsetY(offset) {
        if (Array.isArray(offset)) {
          this.config.failOffsetYStart = offset[0];
          this.config.failOffsetYEnd = offset[1];
        } else if (offset < 0) {
          this.config.failOffsetYStart = offset;
        } else {
          this.config.failOffsetYEnd = offset;
        }

        return this;
      }
    }, {
      key: "failOffsetX",
      value: function failOffsetX(offset) {
        if (Array.isArray(offset)) {
          this.config.failOffsetXStart = offset[0];
          this.config.failOffsetXEnd = offset[1];
        } else if (offset < 0) {
          this.config.failOffsetXStart = offset;
        } else {
          this.config.failOffsetXEnd = offset;
        }

        return this;
      }
    }, {
      key: "minPointers",
      value: function minPointers(_minPointers) {
        this.config.minPointers = _minPointers;
        return this;
      }
    }, {
      key: "maxPointers",
      value: function maxPointers(_maxPointers) {
        this.config.maxPointers = _maxPointers;
        return this;
      }
    }, {
      key: "minDistance",
      value: function minDistance(distance) {
        this.config.minDist = distance;
        return this;
      }
    }, {
      key: "minVelocity",
      value: function minVelocity(velocity) {
        this.config.minVelocity = velocity;
        return this;
      }
    }, {
      key: "minVelocityX",
      value: function minVelocityX(velocity) {
        this.config.minVelocityX = velocity;
        return this;
      }
    }, {
      key: "minVelocityY",
      value: function minVelocityY(velocity) {
        this.config.minVelocityY = velocity;
        return this;
      }
    }, {
      key: "averageTouches",
      value: function averageTouches(value) {
        this.config.avgTouches = value;
        return this;
      }
    }, {
      key: "enableTrackpadTwoFingerGesture",
      value: function enableTrackpadTwoFingerGesture(value) {
        this.config.enableTrackpadTwoFingerGesture = value;
        return this;
      }
    }, {
      key: "onChange",
      value: function onChange(callback) {
        this.handlers.changeEventCalculator = changeEventCalculator;
        return (0, _get2.default)((0, _getPrototypeOf2.default)(PanGesture.prototype), "onChange", this).call(this, callback);
      }
    }]);
    return PanGesture;
  }(_$$_REQUIRE(_dependencyMap[8]).ContinousBaseGesture);

  exports.PanGesture = PanGesture;
},"node_modules/react-native-gesture-handler/src/handlers/gestures/panGesture.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native-gesture-handler/src/handlers/gestures/gesture.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PinchGesture = undefined;

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _get2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function changeEventCalculator(current, previous) {
    'worklet';

    var changePayload;

    if (previous === undefined) {
      changePayload = {
        scaleChange: current.scale
      };
    } else {
      changePayload = {
        scaleChange: current.scale / previous.scale
      };
    }

    return (0, _extends2.default)({}, current, changePayload);
  }

  var PinchGesture = function (_ContinousBaseGesture) {
    (0, _inherits2.default)(PinchGesture, _ContinousBaseGesture);

    var _super = _createSuper(PinchGesture);

    function PinchGesture() {
      var _this;

      (0, _classCallCheck2.default)(this, PinchGesture);
      _this = _super.call(this);
      _this.handlerName = 'PinchGestureHandler';
      return _this;
    }

    (0, _createClass2.default)(PinchGesture, [{
      key: "onChange",
      value: function onChange(callback) {
        this.handlers.changeEventCalculator = changeEventCalculator;
        return (0, _get2.default)((0, _getPrototypeOf2.default)(PinchGesture.prototype), "onChange", this).call(this, callback);
      }
    }]);
    return PinchGesture;
  }(_$$_REQUIRE(_dependencyMap[8]).ContinousBaseGesture);

  exports.PinchGesture = PinchGesture;
},"node_modules/react-native-gesture-handler/src/handlers/gestures/pinchGesture.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native-gesture-handler/src/handlers/gestures/gesture.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.RotationGesture = undefined;

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _get2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function changeEventCalculator(current, previous) {
    'worklet';

    var changePayload;

    if (previous === undefined) {
      changePayload = {
        rotationChange: current.rotation
      };
    } else {
      changePayload = {
        rotationChange: current.rotation - previous.rotation
      };
    }

    return (0, _extends2.default)({}, current, changePayload);
  }

  var RotationGesture = function (_ContinousBaseGesture) {
    (0, _inherits2.default)(RotationGesture, _ContinousBaseGesture);

    var _super = _createSuper(RotationGesture);

    function RotationGesture() {
      var _this;

      (0, _classCallCheck2.default)(this, RotationGesture);
      _this = _super.call(this);
      _this.handlerName = 'RotationGestureHandler';
      return _this;
    }

    (0, _createClass2.default)(RotationGesture, [{
      key: "onChange",
      value: function onChange(callback) {
        this.handlers.changeEventCalculator = changeEventCalculator;
        return (0, _get2.default)((0, _getPrototypeOf2.default)(RotationGesture.prototype), "onChange", this).call(this, callback);
      }
    }]);
    return RotationGesture;
  }(_$$_REQUIRE(_dependencyMap[8]).ContinousBaseGesture);

  exports.RotationGesture = RotationGesture;
},"node_modules/react-native-gesture-handler/src/handlers/gestures/rotationGesture.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native-gesture-handler/src/handlers/gestures/gesture.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.FlingGesture = undefined;

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var FlingGesture = function (_BaseGesture) {
    (0, _inherits2.default)(FlingGesture, _BaseGesture);

    var _super = _createSuper(FlingGesture);

    function FlingGesture() {
      var _this;

      (0, _classCallCheck2.default)(this, FlingGesture);
      _this = _super.call(this);
      _this.config = {};
      _this.handlerName = 'FlingGestureHandler';
      return _this;
    }

    (0, _createClass2.default)(FlingGesture, [{
      key: "numberOfPointers",
      value: function numberOfPointers(pointers) {
        this.config.numberOfPointers = pointers;
        return this;
      }
    }, {
      key: "direction",
      value: function direction(_direction) {
        this.config.direction = _direction;
        return this;
      }
    }]);
    return FlingGesture;
  }(_$$_REQUIRE(_dependencyMap[6]).BaseGesture);

  exports.FlingGesture = FlingGesture;
},"node_modules/react-native-gesture-handler/src/handlers/gestures/flingGesture.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native-gesture-handler/src/handlers/gestures/gesture.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LongPressGesture = undefined;

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var LongPressGesture = function (_BaseGesture) {
    (0, _inherits2.default)(LongPressGesture, _BaseGesture);

    var _super = _createSuper(LongPressGesture);

    function LongPressGesture() {
      var _this;

      (0, _classCallCheck2.default)(this, LongPressGesture);
      _this = _super.call(this);
      _this.config = {};
      _this.handlerName = 'LongPressGestureHandler';
      return _this;
    }

    (0, _createClass2.default)(LongPressGesture, [{
      key: "minDuration",
      value: function minDuration(duration) {
        this.config.minDurationMs = duration;
        return this;
      }
    }, {
      key: "maxDistance",
      value: function maxDistance(distance) {
        this.config.maxDist = distance;
        return this;
      }
    }]);
    return LongPressGesture;
  }(_$$_REQUIRE(_dependencyMap[6]).BaseGesture);

  exports.LongPressGesture = LongPressGesture;
},"node_modules/react-native-gesture-handler/src/handlers/gestures/longPressGesture.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native-gesture-handler/src/handlers/gestures/gesture.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ForceTouchGesture = undefined;

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _get2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function changeEventCalculator(current, previous) {
    'worklet';

    var changePayload;

    if (previous === undefined) {
      changePayload = {
        forceChange: current.force
      };
    } else {
      changePayload = {
        forceChange: current.force - previous.force
      };
    }

    return (0, _extends2.default)({}, current, changePayload);
  }

  var ForceTouchGesture = function (_ContinousBaseGesture) {
    (0, _inherits2.default)(ForceTouchGesture, _ContinousBaseGesture);

    var _super = _createSuper(ForceTouchGesture);

    function ForceTouchGesture() {
      var _this;

      (0, _classCallCheck2.default)(this, ForceTouchGesture);
      _this = _super.call(this);
      _this.config = {};
      _this.handlerName = 'ForceTouchGestureHandler';
      return _this;
    }

    (0, _createClass2.default)(ForceTouchGesture, [{
      key: "minForce",
      value: function minForce(force) {
        this.config.minForce = force;
        return this;
      }
    }, {
      key: "maxForce",
      value: function maxForce(force) {
        this.config.maxForce = force;
        return this;
      }
    }, {
      key: "feedbackOnActivation",
      value: function feedbackOnActivation(value) {
        this.config.feedbackOnActivation = value;
        return this;
      }
    }, {
      key: "onChange",
      value: function onChange(callback) {
        this.handlers.changeEventCalculator = changeEventCalculator;
        return (0, _get2.default)((0, _getPrototypeOf2.default)(ForceTouchGesture.prototype), "onChange", this).call(this, callback);
      }
    }]);
    return ForceTouchGesture;
  }(_$$_REQUIRE(_dependencyMap[8]).ContinousBaseGesture);

  exports.ForceTouchGesture = ForceTouchGesture;
},"node_modules/react-native-gesture-handler/src/handlers/gestures/forceTouchGesture.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react-native-gesture-handler/src/handlers/gestures/gesture.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.NativeGesture = undefined;

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var NativeGesture = function (_BaseGesture) {
    (0, _inherits2.default)(NativeGesture, _BaseGesture);

    var _super = _createSuper(NativeGesture);

    function NativeGesture() {
      var _this;

      (0, _classCallCheck2.default)(this, NativeGesture);
      _this = _super.call(this);
      _this.config = {};
      _this.handlerName = 'NativeViewGestureHandler';
      return _this;
    }

    (0, _createClass2.default)(NativeGesture, [{
      key: "shouldActivateOnStart",
      value: function shouldActivateOnStart(value) {
        this.config.shouldActivateOnStart = value;
        return this;
      }
    }, {
      key: "disallowInterruption",
      value: function disallowInterruption(value) {
        this.config.disallowInterruption = value;
        return this;
      }
    }]);
    return NativeGesture;
  }(_$$_REQUIRE(_dependencyMap[6]).BaseGesture);

  exports.NativeGesture = NativeGesture;
},"node_modules/react-native-gesture-handler/src/handlers/gestures/nativeGesture.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native-gesture-handler/src/handlers/gestures/gesture.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ManualGesture = undefined;

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _get2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function changeEventCalculator(current, _previous) {
    'worklet';

    return current;
  }

  var ManualGesture = function (_ContinousBaseGesture) {
    (0, _inherits2.default)(ManualGesture, _ContinousBaseGesture);

    var _super = _createSuper(ManualGesture);

    function ManualGesture() {
      var _this;

      (0, _classCallCheck2.default)(this, ManualGesture);
      _this = _super.call(this);
      _this.handlerName = 'ManualGestureHandler';
      return _this;
    }

    (0, _createClass2.default)(ManualGesture, [{
      key: "onChange",
      value: function onChange(callback) {
        this.handlers.changeEventCalculator = changeEventCalculator;
        return (0, _get2.default)((0, _getPrototypeOf2.default)(ManualGesture.prototype), "onChange", this).call(this, callback);
      }
    }]);
    return ManualGesture;
  }(_$$_REQUIRE(_dependencyMap[7]).ContinousBaseGesture);

  exports.ManualGesture = ManualGesture;
},"node_modules/react-native-gesture-handler/src/handlers/gestures/manualGesture.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/get.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native-gesture-handler/src/handlers/gestures/gesture.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SimultaneousGesture = exports.ExclusiveGesture = exports.ComposedGesture = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function extendRelation(currentRelation, extendWith) {
    if (currentRelation === undefined) {
      return (0, _toConsumableArray2.default)(extendWith);
    } else {
      return [].concat((0, _toConsumableArray2.default)(currentRelation), (0, _toConsumableArray2.default)(extendWith));
    }
  }

  var ComposedGesture = function (_Gesture) {
    (0, _inherits2.default)(ComposedGesture, _Gesture);

    var _super = _createSuper(ComposedGesture);

    function ComposedGesture() {
      var _this;

      (0, _classCallCheck2.default)(this, ComposedGesture);
      _this = _super.call(this);
      _this.gestures = [];
      _this.simultaneousGestures = [];
      _this.requireGesturesToFail = [];

      for (var _len = arguments.length, gestures = new Array(_len), _key = 0; _key < _len; _key++) {
        gestures[_key] = arguments[_key];
      }

      _this.gestures = gestures;
      return _this;
    }

    (0, _createClass2.default)(ComposedGesture, [{
      key: "prepareSingleGesture",
      value: function prepareSingleGesture(gesture, simultaneousGestures, requireGesturesToFail) {
        if (gesture instanceof _$$_REQUIRE(_dependencyMap[8]).BaseGesture) {
          var newConfig = (0, _extends2.default)({}, gesture.config);
          newConfig.simultaneousWith = extendRelation(newConfig.simultaneousWith, simultaneousGestures);
          newConfig.requireToFail = extendRelation(newConfig.requireToFail, requireGesturesToFail);
          gesture.config = newConfig;
        } else if (gesture instanceof ComposedGesture) {
          gesture.simultaneousGestures = simultaneousGestures;
          gesture.requireGesturesToFail = requireGesturesToFail;
          gesture.prepare();
        }
      }
    }, {
      key: "prepare",
      value: function prepare() {
        for (var _iterator = _createForOfIteratorHelperLoose(this.gestures), _step; !(_step = _iterator()).done;) {
          var gesture = _step.value;
          this.prepareSingleGesture(gesture, this.simultaneousGestures, this.requireGesturesToFail);
        }
      }
    }, {
      key: "initialize",
      value: function initialize() {
        for (var _iterator2 = _createForOfIteratorHelperLoose(this.gestures), _step2; !(_step2 = _iterator2()).done;) {
          var gesture = _step2.value;
          gesture.initialize();
        }
      }
    }, {
      key: "toGestureArray",
      value: function toGestureArray() {
        return this.gestures.flatMap(function (gesture) {
          return gesture.toGestureArray();
        });
      }
    }]);
    return ComposedGesture;
  }(_$$_REQUIRE(_dependencyMap[8]).Gesture);

  exports.ComposedGesture = ComposedGesture;

  var SimultaneousGesture = function (_ComposedGesture) {
    (0, _inherits2.default)(SimultaneousGesture, _ComposedGesture);

    var _super2 = _createSuper(SimultaneousGesture);

    function SimultaneousGesture() {
      (0, _classCallCheck2.default)(this, SimultaneousGesture);
      return _super2.apply(this, arguments);
    }

    (0, _createClass2.default)(SimultaneousGesture, [{
      key: "prepare",
      value: function prepare() {
        var simultaneousArray = this.gestures.flatMap(function (gesture) {
          return gesture.toGestureArray();
        }).concat(this.simultaneousGestures);

        for (var _iterator3 = _createForOfIteratorHelperLoose(this.gestures), _step3; !(_step3 = _iterator3()).done;) {
          var gesture = _step3.value;
          this.prepareSingleGesture(gesture, simultaneousArray, this.requireGesturesToFail);
        }
      }
    }]);
    return SimultaneousGesture;
  }(ComposedGesture);

  exports.SimultaneousGesture = SimultaneousGesture;

  var ExclusiveGesture = function (_ComposedGesture2) {
    (0, _inherits2.default)(ExclusiveGesture, _ComposedGesture2);

    var _super3 = _createSuper(ExclusiveGesture);

    function ExclusiveGesture() {
      (0, _classCallCheck2.default)(this, ExclusiveGesture);
      return _super3.apply(this, arguments);
    }

    (0, _createClass2.default)(ExclusiveGesture, [{
      key: "prepare",
      value: function prepare() {
        var gestureArrays = this.gestures.map(function (gesture) {
          return gesture.toGestureArray();
        });
        var requireToFail = [];

        for (var i = 0; i < this.gestures.length; i++) {
          this.prepareSingleGesture(this.gestures[i], this.simultaneousGestures, this.requireGesturesToFail.concat(requireToFail));
          requireToFail = requireToFail.concat(gestureArrays[i]);
        }
      }
    }]);
    return ExclusiveGesture;
  }(ComposedGesture);

  exports.ExclusiveGesture = ExclusiveGesture;
},"node_modules/react-native-gesture-handler/src/handlers/gestures/gestureComposition.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/react-native-gesture-handler/src/handlers/gestures/gesture.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.GestureDetector = undefined;

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[7]));

  var _RNGestureHandlerModule = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[9]);

  var _Reanimated$default$c, _Reanimated$default;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var ALLOWED_PROPS = [].concat((0, _toConsumableArray2.default)(_$$_REQUIRE(_dependencyMap[10]).baseGestureHandlerWithMonitorProps), (0, _toConsumableArray2.default)(_$$_REQUIRE(_dependencyMap[11]).tapGestureHandlerProps), (0, _toConsumableArray2.default)(_$$_REQUIRE(_dependencyMap[12]).panGestureHandlerProps), (0, _toConsumableArray2.default)(_$$_REQUIRE(_dependencyMap[12]).panGestureHandlerCustomNativeProps), (0, _toConsumableArray2.default)(_$$_REQUIRE(_dependencyMap[13]).longPressGestureHandlerProps), (0, _toConsumableArray2.default)(_$$_REQUIRE(_dependencyMap[14]).forceTouchGestureHandlerProps), (0, _toConsumableArray2.default)(_$$_REQUIRE(_dependencyMap[15]).flingGestureHandlerProps));

  function convertToHandlerTag(ref) {
    if (typeof ref === 'number') {
      return ref;
    } else if (ref instanceof _$$_REQUIRE(_dependencyMap[16]).BaseGesture) {
      return ref.handlerTag;
    } else {
      var _ref$current$handlerT, _ref$current;

      return (_ref$current$handlerT = (_ref$current = ref.current) == null ? undefined : _ref$current.handlerTag) != null ? _ref$current$handlerT : -1;
    }
  }

  function extractValidHandlerTags(interactionGroup) {
    var _interactionGroup$map, _interactionGroup$map2;

    return (_interactionGroup$map = interactionGroup == null ? undefined : (_interactionGroup$map2 = interactionGroup.map(convertToHandlerTag)) == null ? undefined : _interactionGroup$map2.filter(function (tag) {
      return tag > 0;
    })) != null ? _interactionGroup$map : [];
  }

  function dropHandlers(preparedGesture) {
    for (var _iterator = _createForOfIteratorHelperLoose(preparedGesture.config), _step; !(_step = _iterator()).done;) {
      var handler = _step.value;

      _RNGestureHandlerModule.default.dropGestureHandler(handler.handlerTag);

      (0, _$$_REQUIRE(_dependencyMap[17]).unregisterHandler)(handler.handlerTag, handler.config.testId);
    }

    (0, _$$_REQUIRE(_dependencyMap[10]).scheduleFlushOperations)();
  }

  function checkGestureCallbacksForWorklets(gesture) {
    if (gesture.config.runOnJS) {
      return;
    }

    var areSomeNotWorklets = gesture.handlers.isWorklet.includes(false);
    var areSomeWorklets = gesture.handlers.isWorklet.includes(true);

    if (areSomeNotWorklets && areSomeWorklets) {
      console.error((0, _$$_REQUIRE(_dependencyMap[18]).tagMessage)("Some of the callbacks in the gesture are worklets and some are not. Either make sure that all calbacks are marked as 'worklet' if you wish to run them on the UI thread or use '.runOnJS(true)' modifier on the gesture explicitly to run all callbacks on the JS thread."));
    }
  }

  function attachHandlers(_ref) {
    var preparedGesture = _ref.preparedGesture,
        gestureConfig = _ref.gestureConfig,
        gesture = _ref.gesture,
        viewTag = _ref.viewTag,
        webEventHandlersRef = _ref.webEventHandlersRef;

    if (!preparedGesture.firstExecution) {
      gestureConfig == null ? undefined : gestureConfig.initialize();
    } else {
      preparedGesture.firstExecution = false;
    }

    setImmediate(function () {
      gestureConfig == null ? undefined : gestureConfig.prepare();
    });

    for (var _iterator2 = _createForOfIteratorHelperLoose(gesture), _step2; !(_step2 = _iterator2()).done;) {
      var handler = _step2.value;
      checkGestureCallbacksForWorklets(handler);

      _RNGestureHandlerModule.default.createGestureHandler(handler.handlerName, handler.handlerTag, (0, _$$_REQUIRE(_dependencyMap[10]).filterConfig)(handler.config, ALLOWED_PROPS));

      (0, _$$_REQUIRE(_dependencyMap[17]).registerHandler)(handler.handlerTag, handler, handler.config.testId);
    }

    setImmediate(function () {
      for (var _iterator3 = _createForOfIteratorHelperLoose(gesture), _step3; !(_step3 = _iterator3()).done;) {
        var _handler = _step3.value;
        var requireToFail = [];

        if (_handler.config.requireToFail) {
          requireToFail = extractValidHandlerTags(_handler.config.requireToFail);
        }

        var simultaneousWith = [];

        if (_handler.config.simultaneousWith) {
          simultaneousWith = extractValidHandlerTags(_handler.config.simultaneousWith);
        }

        _RNGestureHandlerModule.default.updateGestureHandler(_handler.handlerTag, (0, _$$_REQUIRE(_dependencyMap[10]).filterConfig)(_handler.config, ALLOWED_PROPS, {
          simultaneousHandlers: simultaneousWith,
          waitFor: requireToFail
        }));
      }

      (0, _$$_REQUIRE(_dependencyMap[10]).scheduleFlushOperations)();
    });
    preparedGesture.config = gesture;

    for (var _iterator4 = _createForOfIteratorHelperLoose(preparedGesture.config), _step4; !(_step4 = _iterator4()).done;) {
      var _gesture = _step4.value;
      var actionType = _gesture.shouldUseReanimated ? _$$_REQUIRE(_dependencyMap[19]).ActionType.REANIMATED_WORKLET : _$$_REQUIRE(_dependencyMap[19]).ActionType.JS_FUNCTION_NEW_API;

      if (_reactNative.Platform.OS === 'web') {
        _RNGestureHandlerModule.default.attachGestureHandler(_gesture.handlerTag, viewTag, _$$_REQUIRE(_dependencyMap[19]).ActionType.JS_FUNCTION_OLD_API, webEventHandlersRef);
      } else {
        _RNGestureHandlerModule.default.attachGestureHandler(_gesture.handlerTag, viewTag, actionType);
      }
    }

    if (preparedGesture.animatedHandlers) {
      var isAnimatedGesture = function isAnimatedGesture(g) {
        return g.shouldUseReanimated;
      };

      preparedGesture.animatedHandlers.value = gesture.filter(isAnimatedGesture).map(function (g) {
        return g.handlers;
      });
    }
  }

  function updateHandlers(preparedGesture, gestureConfig, gesture) {
    gestureConfig == null ? undefined : gestureConfig.prepare();

    for (var i = 0; i < gesture.length; i++) {
      var handler = preparedGesture.config[i];
      checkGestureCallbacksForWorklets(handler);

      if (gesture[i].handlerTag !== handler.handlerTag) {
        gesture[i].handlerTag = handler.handlerTag;
        gesture[i].handlers.handlerTag = handler.handlerTag;
      }
    }

    setImmediate(function () {
      for (var _i = 0; _i < gesture.length; _i++) {
        var _handler2 = preparedGesture.config[_i];
        _handler2.config = gesture[_i].config;
        _handler2.handlers = gesture[_i].handlers;
        var requireToFail = extractValidHandlerTags(_handler2.config.requireToFail);
        var simultaneousWith = extractValidHandlerTags(_handler2.config.simultaneousWith);

        _RNGestureHandlerModule.default.updateGestureHandler(_handler2.handlerTag, (0, _$$_REQUIRE(_dependencyMap[10]).filterConfig)(_handler2.config, ALLOWED_PROPS, {
          simultaneousHandlers: simultaneousWith,
          waitFor: requireToFail
        }));

        (0, _$$_REQUIRE(_dependencyMap[17]).registerHandler)(_handler2.handlerTag, _handler2, _handler2.config.testId);
      }

      if (preparedGesture.animatedHandlers) {
        var _preparedGesture$anim;

        var previousHandlersValue = (_preparedGesture$anim = preparedGesture.animatedHandlers.value) != null ? _preparedGesture$anim : [];
        var newHandlersValue = preparedGesture.config.filter(function (g) {
          return g.shouldUseReanimated;
        }).map(function (g) {
          return g.handlers;
        });
        var shouldUpdateSharedValue = previousHandlersValue.length !== newHandlersValue.length;

        if (!shouldUpdateSharedValue) {
          for (var _i2 = 0; _i2 < newHandlersValue.length; _i2++) {
            if (newHandlersValue[_i2].gestureId !== previousHandlersValue[_i2].gestureId) {
              shouldUpdateSharedValue = true;
              break;
            }
          }
        }

        if (shouldUpdateSharedValue) {
          preparedGesture.animatedHandlers.value = newHandlersValue;
        }
      }

      (0, _$$_REQUIRE(_dependencyMap[10]).scheduleFlushOperations)();
    });
  }

  function needsToReattach(preparedGesture, gesture) {
    if (gesture.length !== preparedGesture.config.length) {
      return true;
    }

    for (var i = 0; i < gesture.length; i++) {
      if (gesture[i].handlerName !== preparedGesture.config[i].handlerName || gesture[i].shouldUseReanimated !== preparedGesture.config[i].shouldUseReanimated) {
        return true;
      }
    }

    return false;
  }

  function isStateChangeEvent(event) {
    'worklet';

    return event.oldState != null;
  }

  function isTouchEvent(event) {
    'worklet';

    return event.eventType != null;
  }

  function getHandler(type, gesture) {
    'worklet';

    switch (type) {
      case _$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.BEGAN:
        return gesture.onBegin;

      case _$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.START:
        return gesture.onStart;

      case _$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.UPDATE:
        return gesture.onUpdate;

      case _$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.CHANGE:
        return gesture.onChange;

      case _$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.END:
        return gesture.onEnd;

      case _$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.FINALIZE:
        return gesture.onFinalize;

      case _$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.TOUCHES_DOWN:
        return gesture.onTouchesDown;

      case _$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.TOUCHES_MOVE:
        return gesture.onTouchesMove;

      case _$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.TOUCHES_UP:
        return gesture.onTouchesUp;

      case _$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.TOUCHES_CANCELLED:
        return gesture.onTouchesCancelled;
    }
  }

  function touchEventTypeToCallbackType(eventType) {
    'worklet';

    switch (eventType) {
      case _$$_REQUIRE(_dependencyMap[20]).TouchEventType.TOUCHES_DOWN:
        return _$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.TOUCHES_DOWN;

      case _$$_REQUIRE(_dependencyMap[20]).TouchEventType.TOUCHES_MOVE:
        return _$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.TOUCHES_MOVE;

      case _$$_REQUIRE(_dependencyMap[20]).TouchEventType.TOUCHES_UP:
        return _$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.TOUCHES_UP;

      case _$$_REQUIRE(_dependencyMap[20]).TouchEventType.TOUCHES_CANCELLED:
        return _$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.TOUCHES_CANCELLED;
    }

    return _$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.UNDEFINED;
  }

  function runWorklet(type, gesture, event) {
    'worklet';

    var handler = getHandler(type, gesture);

    if (gesture.isWorklet[type]) {
      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        args[_key - 3] = arguments[_key];
      }

      handler == null ? undefined : handler.apply(undefined, [event].concat(args));
    } else if (handler) {
      console.warn((0, _$$_REQUIRE(_dependencyMap[18]).tagMessage)('Animated gesture callback must be a worklet'));
    }
  }

  function useAnimatedGesture(preparedGesture, needsRebuild) {
    if (!_$$_REQUIRE(_dependencyMap[21]).Reanimated) {
      return;
    }

    var sharedHandlersCallbacks = _$$_REQUIRE(_dependencyMap[21]).Reanimated.useSharedValue(null);

    var lastUpdateEvent = _$$_REQUIRE(_dependencyMap[21]).Reanimated.useSharedValue([]);

    var stateControllers = [];

    var callback = function callback(event) {
      'worklet';

      var currentCallback = sharedHandlersCallbacks.value;

      if (!currentCallback) {
        return;
      }

      for (var i = 0; i < currentCallback.length; i++) {
        var gesture = currentCallback[i];

        if (event.handlerTag === gesture.handlerTag) {
          if (isStateChangeEvent(event)) {
            if (event.oldState === _$$_REQUIRE(_dependencyMap[22]).State.UNDETERMINED && event.state === _$$_REQUIRE(_dependencyMap[22]).State.BEGAN) {
              runWorklet(_$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.BEGAN, gesture, event);
            } else if ((event.oldState === _$$_REQUIRE(_dependencyMap[22]).State.BEGAN || event.oldState === _$$_REQUIRE(_dependencyMap[22]).State.UNDETERMINED) && event.state === _$$_REQUIRE(_dependencyMap[22]).State.ACTIVE) {
              runWorklet(_$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.START, gesture, event);
              lastUpdateEvent.value[gesture.handlerTag] = undefined;
            } else if (event.oldState !== event.state && event.state === _$$_REQUIRE(_dependencyMap[22]).State.END) {
              if (event.oldState === _$$_REQUIRE(_dependencyMap[22]).State.ACTIVE) {
                runWorklet(_$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.END, gesture, event, true);
              }

              runWorklet(_$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.FINALIZE, gesture, event, true);
            } else if ((event.state === _$$_REQUIRE(_dependencyMap[22]).State.FAILED || event.state === _$$_REQUIRE(_dependencyMap[22]).State.CANCELLED) && event.state !== event.oldState) {
              if (event.oldState === _$$_REQUIRE(_dependencyMap[22]).State.ACTIVE) {
                runWorklet(_$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.END, gesture, event, false);
              }

              runWorklet(_$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.FINALIZE, gesture, event, false);
            }
          } else if (isTouchEvent(event)) {
            if (!stateControllers[i]) {
              stateControllers[i] = _$$_REQUIRE(_dependencyMap[23]).GestureStateManager.create(event.handlerTag);
            }

            if (event.eventType !== _$$_REQUIRE(_dependencyMap[20]).TouchEventType.UNDETERMINED) {
              runWorklet(touchEventTypeToCallbackType(event.eventType), gesture, event, stateControllers[i]);
            }
          } else {
            runWorklet(_$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.UPDATE, gesture, event);

            if (gesture.onChange && gesture.changeEventCalculator) {
              runWorklet(_$$_REQUIRE(_dependencyMap[16]).CALLBACK_TYPE.CHANGE, gesture, gesture.changeEventCalculator == null ? undefined : gesture.changeEventCalculator(event, lastUpdateEvent.value[gesture.handlerTag]));
              lastUpdateEvent.value[gesture.handlerTag] = event;
            }
          }
        }
      }
    };

    var event = _$$_REQUIRE(_dependencyMap[21]).Reanimated.useEvent(callback, ['onGestureHandlerStateChange', 'onGestureHandlerEvent'], needsRebuild);

    preparedGesture.animatedEventHandler = event;
    preparedGesture.animatedHandlers = sharedHandlersCallbacks;
  }

  var GestureDetector = function GestureDetector(props) {
    var _gestureConfig$toGest;

    var gestureConfig = props.gesture;
    var gesture = (_gestureConfig$toGest = gestureConfig == null ? undefined : gestureConfig.toGestureArray == null ? undefined : gestureConfig.toGestureArray()) != null ? _gestureConfig$toGest : [];
    var useReanimatedHook = gesture.some(function (g) {
      return g.shouldUseReanimated;
    });
    var viewRef = (0, _react.useRef)(null);
    var firstRenderRef = (0, _react.useRef)(true);
    var webEventHandlersRef = (0, _react.useRef)({
      onGestureHandlerEvent: function onGestureHandlerEvent(e) {
        (0, _$$_REQUIRE(_dependencyMap[24]).onGestureHandlerEvent)(e.nativeEvent);
      }
    });

    var preparedGesture = _react.default.useRef({
      config: gesture,
      animatedEventHandler: null,
      animatedHandlers: null,
      firstExecution: true,
      useReanimatedHook: useReanimatedHook
    }).current;

    if (useReanimatedHook !== preparedGesture.useReanimatedHook) {
      throw new Error((0, _$$_REQUIRE(_dependencyMap[18]).tagMessage)('You cannot change the thread the callbacks are ran on while the app is running'));
    }

    var needsToRebuildReanimatedEvent = preparedGesture.firstExecution || needsToReattach(preparedGesture, gesture);

    if (preparedGesture.firstExecution) {
      gestureConfig == null ? undefined : gestureConfig.initialize == null ? undefined : gestureConfig.initialize();
    }

    if (useReanimatedHook) {
      useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);
    }

    (0, _react.useEffect)(function () {
      firstRenderRef.current = true;
      var viewTag = (0, _$$_REQUIRE(_dependencyMap[10]).findNodeHandle)(viewRef.current);
      attachHandlers({
        preparedGesture: preparedGesture,
        gestureConfig: gestureConfig,
        gesture: gesture,
        viewTag: viewTag,
        webEventHandlersRef: webEventHandlersRef
      });
      return function () {
        dropHandlers(preparedGesture);
      };
    }, []);
    (0, _react.useEffect)(function () {
      if (!firstRenderRef.current) {
        var viewTag = (0, _$$_REQUIRE(_dependencyMap[10]).findNodeHandle)(viewRef.current);

        if (needsToReattach(preparedGesture, gesture)) {
          dropHandlers(preparedGesture);
          attachHandlers({
            preparedGesture: preparedGesture,
            gestureConfig: gestureConfig,
            gesture: gesture,
            viewTag: viewTag,
            webEventHandlersRef: webEventHandlersRef
          });
        } else {
          updateHandlers(preparedGesture, gestureConfig, gesture);
        }
      } else {
        firstRenderRef.current = false;
      }
    }, [props]);

    var refFunction = function refFunction(ref) {
      if (ref !== null) {
        viewRef.current = ref;

        if ((0, _$$_REQUIRE(_dependencyMap[18]).isFabric)()) {
          var _node = (0, _$$_REQUIRE(_dependencyMap[25]).getShadowNodeFromRef)(ref);

          if (global.isFormsStackingContext(_node) === false) {
            console.error((0, _$$_REQUIRE(_dependencyMap[18]).tagMessage)("GestureDetector has received a child that may get view-flattened. \nTo prevent it from misbehaving you need to wrap the child with a `<View collapsable={false}>`."));
          }
        }
      }
    };

    if (useReanimatedHook) {
      return _react.default.createElement(AnimatedWrap, {
        ref: refFunction,
        onGestureHandlerEvent: preparedGesture.animatedEventHandler
      }, props.children);
    } else {
      return _react.default.createElement(Wrap, {
        ref: refFunction
      }, props.children);
    }
  };

  exports.GestureDetector = GestureDetector;

  var Wrap = function (_React$Component) {
    (0, _inherits2.default)(Wrap, _React$Component);

    var _super = _createSuper(Wrap);

    function Wrap() {
      (0, _classCallCheck2.default)(this, Wrap);
      return _super.apply(this, arguments);
    }

    (0, _createClass2.default)(Wrap, [{
      key: "render",
      value: function render() {
        var child = _react.default.Children.only(this.props.children);

        return _react.default.cloneElement(child, {
          collapsable: false
        }, child.props.children);
      }
    }]);
    return Wrap;
  }(_react.default.Component);

  var AnimatedWrap = (_Reanimated$default$c = _$$_REQUIRE(_dependencyMap[21]).Reanimated == null ? undefined : (_Reanimated$default = _$$_REQUIRE(_dependencyMap[21]).Reanimated.default) == null ? undefined : _Reanimated$default.createAnimatedComponent(Wrap)) != null ? _Reanimated$default$c : Wrap;
},"node_modules/react-native-gesture-handler/src/handlers/gestures/GestureDetector.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/react/index.js","node_modules/react-native-gesture-handler/src/RNGestureHandlerModule.ts","node_modules/react-native/index.js","node_modules/react-native-gesture-handler/src/handlers/gestureHandlerCommon.ts","node_modules/react-native-gesture-handler/src/handlers/TapGestureHandler.ts","node_modules/react-native-gesture-handler/src/handlers/PanGestureHandler.ts","node_modules/react-native-gesture-handler/src/handlers/LongPressGestureHandler.ts","node_modules/react-native-gesture-handler/src/handlers/ForceTouchGestureHandler.ts","node_modules/react-native-gesture-handler/src/handlers/FlingGestureHandler.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/gesture.ts","node_modules/react-native-gesture-handler/src/handlers/handlersRegistry.ts","node_modules/react-native-gesture-handler/src/utils.ts","node_modules/react-native-gesture-handler/src/ActionType.ts","node_modules/react-native-gesture-handler/src/TouchEventType.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/reanimatedWrapper.ts","node_modules/react-native-gesture-handler/src/State.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/gestureStateManager.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/eventReceiver.ts","node_modules/react-native-gesture-handler/src/getShadowNodeFromRef.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.tapHandlerName = exports.tapGestureHandlerProps = exports.TapGestureHandler = undefined;

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createHandler = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var tapGestureHandlerProps = ['maxDurationMs', 'maxDelayMs', 'numberOfTaps', 'maxDeltaX', 'maxDeltaY', 'maxDist', 'minPointers'];
  exports.tapGestureHandlerProps = tapGestureHandlerProps;
  var tapHandlerName = 'TapGestureHandler';
  exports.tapHandlerName = tapHandlerName;
  var TapGestureHandler = (0, _createHandler.default)({
    name: tapHandlerName,
    allowedProps: [].concat((0, _toConsumableArray2.default)(_$$_REQUIRE(_dependencyMap[3]).baseGestureHandlerProps), tapGestureHandlerProps),
    config: {}
  });
  exports.TapGestureHandler = TapGestureHandler;
},"node_modules/react-native-gesture-handler/src/handlers/TapGestureHandler.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/react-native-gesture-handler/src/handlers/createHandler.ts","node_modules/react-native-gesture-handler/src/handlers/gestureHandlerCommon.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.PanGestureHandler = undefined;
  exports.managePanProps = managePanProps;
  exports.panHandlerName = exports.panGestureHandlerProps = exports.panGestureHandlerCustomNativeProps = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createHandler = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var panGestureHandlerProps = ['activeOffsetY', 'activeOffsetX', 'failOffsetY', 'failOffsetX', 'minDist', 'minVelocity', 'minVelocityX', 'minVelocityY', 'minPointers', 'maxPointers', 'avgTouches', 'enableTrackpadTwoFingerGesture'];
  exports.panGestureHandlerProps = panGestureHandlerProps;
  var panGestureHandlerCustomNativeProps = ['activeOffsetYStart', 'activeOffsetYEnd', 'activeOffsetXStart', 'activeOffsetXEnd', 'failOffsetYStart', 'failOffsetYEnd', 'failOffsetXStart', 'failOffsetXEnd'];
  exports.panGestureHandlerCustomNativeProps = panGestureHandlerCustomNativeProps;
  var panHandlerName = 'PanGestureHandler';
  exports.panHandlerName = panHandlerName;
  var PanGestureHandler = (0, _createHandler.default)({
    name: panHandlerName,
    allowedProps: [].concat((0, _toConsumableArray2.default)(_$$_REQUIRE(_dependencyMap[4]).baseGestureHandlerProps), panGestureHandlerProps),
    config: {},
    transformProps: managePanProps,
    customNativeProps: panGestureHandlerCustomNativeProps
  });
  exports.PanGestureHandler = PanGestureHandler;

  function transformPanGestureHandlerProps(props) {
    var res = (0, _extends2.default)({}, props);

    if (props.activeOffsetX !== undefined) {
      delete res.activeOffsetX;

      if (Array.isArray(props.activeOffsetX)) {
        res.activeOffsetXStart = props.activeOffsetX[0];
        res.activeOffsetXEnd = props.activeOffsetX[1];
      } else if (props.activeOffsetX < 0) {
        res.activeOffsetXStart = props.activeOffsetX;
      } else {
        res.activeOffsetXEnd = props.activeOffsetX;
      }
    }

    if (props.activeOffsetY !== undefined) {
      delete res.activeOffsetY;

      if (Array.isArray(props.activeOffsetY)) {
        res.activeOffsetYStart = props.activeOffsetY[0];
        res.activeOffsetYEnd = props.activeOffsetY[1];
      } else if (props.activeOffsetY < 0) {
        res.activeOffsetYStart = props.activeOffsetY;
      } else {
        res.activeOffsetYEnd = props.activeOffsetY;
      }
    }

    if (props.failOffsetX !== undefined) {
      delete res.failOffsetX;

      if (Array.isArray(props.failOffsetX)) {
        res.failOffsetXStart = props.failOffsetX[0];
        res.failOffsetXEnd = props.failOffsetX[1];
      } else if (props.failOffsetX < 0) {
        res.failOffsetXStart = props.failOffsetX;
      } else {
        res.failOffsetXEnd = props.failOffsetX;
      }
    }

    if (props.failOffsetY !== undefined) {
      delete res.failOffsetY;

      if (Array.isArray(props.failOffsetY)) {
        res.failOffsetYStart = props.failOffsetY[0];
        res.failOffsetYEnd = props.failOffsetY[1];
      } else if (props.failOffsetY < 0) {
        res.failOffsetYStart = props.failOffsetY;
      } else {
        res.failOffsetYEnd = props.failOffsetY;
      }
    }

    return res;
  }

  function managePanProps(props) {
    return transformPanGestureHandlerProps(props);
  }
},"node_modules/react-native-gesture-handler/src/handlers/PanGestureHandler.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/react-native-gesture-handler/src/handlers/createHandler.ts","node_modules/react-native-gesture-handler/src/handlers/gestureHandlerCommon.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.longPressHandlerName = exports.longPressGestureHandlerProps = exports.LongPressGestureHandler = undefined;

  var _toConsumableArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _createHandler = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var longPressGestureHandlerProps = ['minDurationMs', 'maxDist'];
  exports.longPressGestureHandlerProps = longPressGestureHandlerProps;
  var longPressHandlerName = 'LongPressGestureHandler';
  exports.longPressHandlerName = longPressHandlerName;
  var LongPressGestureHandler = (0, _createHandler.default)({
    name: longPressHandlerName,
    allowedProps: [].concat((0, _toConsumableArray2.default)(_$$_REQUIRE(_dependencyMap[3]).baseGestureHandlerProps), longPressGestureHandlerProps),
    config: {}
  });
  exports.LongPressGestureHandler = LongPressGestureHandler;
},"node_modules/react-native-gesture-handler/src/handlers/LongPressGestureHandler.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/toConsumableArray.js","node_modules/react-native-gesture-handler/src/handlers/createHandler.ts","node_modules/react-native-gesture-handler/src/handlers/gestureHandlerCommon.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TouchEventType = undefined;
  var TouchEventType = {
    UNDETERMINED: 0,
    TOUCHES_DOWN: 1,
    TOUCHES_MOVE: 2,
    TOUCHES_UP: 3,
    TOUCHES_CANCELLED: 4
  };
  exports.TouchEventType = TouchEventType;
},"node_modules/react-native-gesture-handler/src/TouchEventType.ts",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Reanimated = undefined;
  var Reanimated;
  exports.Reanimated = Reanimated;

  try {
    exports.Reanimated = Reanimated = _$$_REQUIRE(_dependencyMap[0]);

    if (!Reanimated.setGestureState) {
      Reanimated.setGestureState = function () {
        'worklet';

        console.warn((0, _$$_REQUIRE(_dependencyMap[1]).tagMessage)('Please use newer version of react-native-reanimated in order to control state of the gestures.'));
      };
    }
  } catch (e) {}
},"node_modules/react-native-gesture-handler/src/handlers/gestures/reanimatedWrapper.ts",["node_modules/react-native-gesture-handler/src/utils.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.GestureStateManager = undefined;
  var warningMessage = (0, _$$_REQUIRE(_dependencyMap[0]).tagMessage)('react-native-reanimated is required in order to use synchronous state management');
  var GestureStateManager = {
    create: function create(handlerTag) {
      'worklet';

      return {
        begin: function begin() {
          'worklet';

          if (_$$_REQUIRE(_dependencyMap[1]).Reanimated) {
            _$$_REQUIRE(_dependencyMap[1]).Reanimated.setGestureState(handlerTag, _$$_REQUIRE(_dependencyMap[2]).State.BEGAN);
          } else {
            console.warn(warningMessage);
          }
        },
        activate: function activate() {
          'worklet';

          if (_$$_REQUIRE(_dependencyMap[1]).Reanimated) {
            _$$_REQUIRE(_dependencyMap[1]).Reanimated.setGestureState(handlerTag, _$$_REQUIRE(_dependencyMap[2]).State.ACTIVE);
          } else {
            console.warn(warningMessage);
          }
        },
        fail: function fail() {
          'worklet';

          if (_$$_REQUIRE(_dependencyMap[1]).Reanimated) {
            _$$_REQUIRE(_dependencyMap[1]).Reanimated.setGestureState(handlerTag, _$$_REQUIRE(_dependencyMap[2]).State.FAILED);
          } else {
            console.warn(warningMessage);
          }
        },
        end: function end() {
          'worklet';

          if (_$$_REQUIRE(_dependencyMap[1]).Reanimated) {
            _$$_REQUIRE(_dependencyMap[1]).Reanimated.setGestureState(handlerTag, _$$_REQUIRE(_dependencyMap[2]).State.END);
          } else {
            console.warn(warningMessage);
          }
        }
      };
    }
  };
  exports.GestureStateManager = GestureStateManager;
},"node_modules/react-native-gesture-handler/src/handlers/gestures/gestureStateManager.ts",["node_modules/react-native-gesture-handler/src/utils.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/reanimatedWrapper.ts","node_modules/react-native-gesture-handler/src/State.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.onGestureHandlerEvent = onGestureHandlerEvent;
  exports.startListening = startListening;
  exports.stopListening = stopListening;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0]);

  var gestureHandlerEventSubscription = null;
  var gestureHandlerStateChangeEventSubscription = null;
  var warningMessage = (0, _$$_REQUIRE(_dependencyMap[1]).tagMessage)('You have to use react-native-reanimated in order to control the state of the gesture.');
  var dummyStateManager = {
    begin: function begin() {
      console.warn(warningMessage);
    },
    activate: function activate() {
      console.warn(warningMessage);
    },
    end: function end() {
      console.warn(warningMessage);
    },
    fail: function fail() {
      console.warn(warningMessage);
    }
  };
  var lastUpdateEvent = [];

  function isStateChangeEvent(event) {
    return event.oldState != null;
  }

  function isTouchEvent(event) {
    return event.eventType != null;
  }

  function onGestureHandlerEvent(event) {
    var _handler$handlers, _handler$handlers2, _handler$handlers3, _handler$handlers4;

    var handler = (0, _$$_REQUIRE(_dependencyMap[2]).findHandler)(event.handlerTag);

    if (handler) {
      if (isStateChangeEvent(event)) {
        if (event.oldState === _$$_REQUIRE(_dependencyMap[3]).State.UNDETERMINED && event.state === _$$_REQUIRE(_dependencyMap[3]).State.BEGAN) {
          handler.handlers.onBegin == null ? undefined : handler.handlers.onBegin(event);
        } else if ((event.oldState === _$$_REQUIRE(_dependencyMap[3]).State.BEGAN || event.oldState === _$$_REQUIRE(_dependencyMap[3]).State.UNDETERMINED) && event.state === _$$_REQUIRE(_dependencyMap[3]).State.ACTIVE) {
          handler.handlers.onStart == null ? undefined : handler.handlers.onStart(event);
          lastUpdateEvent[handler.handlers.handlerTag] = event;
        } else if (event.oldState !== event.state && event.state === _$$_REQUIRE(_dependencyMap[3]).State.END) {
          if (event.oldState === _$$_REQUIRE(_dependencyMap[3]).State.ACTIVE) {
            handler.handlers.onEnd == null ? undefined : handler.handlers.onEnd(event, true);
          }

          handler.handlers.onFinalize == null ? undefined : handler.handlers.onFinalize(event, true);
          lastUpdateEvent[handler.handlers.handlerTag] = undefined;
        } else if ((event.state === _$$_REQUIRE(_dependencyMap[3]).State.FAILED || event.state === _$$_REQUIRE(_dependencyMap[3]).State.CANCELLED) && event.oldState !== event.state) {
          if (event.oldState === _$$_REQUIRE(_dependencyMap[3]).State.ACTIVE) {
            handler.handlers.onEnd == null ? undefined : handler.handlers.onEnd(event, false);
          }

          handler.handlers.onFinalize == null ? undefined : handler.handlers.onFinalize(event, false);
          lastUpdateEvent[handler.handlers.handlerTag] = undefined;
        }
      } else if (isTouchEvent(event)) {
        switch (event.eventType) {
          case _$$_REQUIRE(_dependencyMap[4]).TouchEventType.TOUCHES_DOWN:
            (_handler$handlers = handler.handlers) == null ? undefined : _handler$handlers.onTouchesDown == null ? undefined : _handler$handlers.onTouchesDown(event, dummyStateManager);
            break;

          case _$$_REQUIRE(_dependencyMap[4]).TouchEventType.TOUCHES_MOVE:
            (_handler$handlers2 = handler.handlers) == null ? undefined : _handler$handlers2.onTouchesMove == null ? undefined : _handler$handlers2.onTouchesMove(event, dummyStateManager);
            break;

          case _$$_REQUIRE(_dependencyMap[4]).TouchEventType.TOUCHES_UP:
            (_handler$handlers3 = handler.handlers) == null ? undefined : _handler$handlers3.onTouchesUp == null ? undefined : _handler$handlers3.onTouchesUp(event, dummyStateManager);
            break;

          case _$$_REQUIRE(_dependencyMap[4]).TouchEventType.TOUCHES_CANCELLED:
            (_handler$handlers4 = handler.handlers) == null ? undefined : _handler$handlers4.onTouchesCancelled == null ? undefined : _handler$handlers4.onTouchesCancelled(event, dummyStateManager);
            break;
        }
      } else {
        handler.handlers.onUpdate == null ? undefined : handler.handlers.onUpdate(event);

        if (handler.handlers.onChange && handler.handlers.changeEventCalculator) {
          handler.handlers.onChange == null ? undefined : handler.handlers.onChange(handler.handlers.changeEventCalculator == null ? undefined : handler.handlers.changeEventCalculator(event, lastUpdateEvent[handler.handlers.handlerTag]));
          lastUpdateEvent[handler.handlers.handlerTag] = event;
        }
      }
    } else {
      var oldHandler = (0, _$$_REQUIRE(_dependencyMap[2]).findOldGestureHandler)(event.handlerTag);

      if (oldHandler) {
        var nativeEvent = {
          nativeEvent: event
        };

        if (isStateChangeEvent(event)) {
          oldHandler.onGestureStateChange(nativeEvent);
        } else {
          oldHandler.onGestureEvent(nativeEvent);
        }

        return;
      }
    }
  }

  function startListening() {
    stopListening();
    gestureHandlerEventSubscription = _reactNative.DeviceEventEmitter.addListener('onGestureHandlerEvent', onGestureHandlerEvent);
    gestureHandlerStateChangeEventSubscription = _reactNative.DeviceEventEmitter.addListener('onGestureHandlerStateChange', onGestureHandlerEvent);
  }

  function stopListening() {
    if (gestureHandlerEventSubscription) {
      gestureHandlerEventSubscription.remove();
      gestureHandlerEventSubscription = null;
    }

    if (gestureHandlerStateChangeEventSubscription) {
      gestureHandlerStateChangeEventSubscription.remove();
      gestureHandlerStateChangeEventSubscription = null;
    }
  }
},"node_modules/react-native-gesture-handler/src/handlers/gestures/eventReceiver.ts",["node_modules/react-native/index.js","node_modules/react-native-gesture-handler/src/utils.ts","node_modules/react-native-gesture-handler/src/handlers/handlersRegistry.ts","node_modules/react-native-gesture-handler/src/State.ts","node_modules/react-native-gesture-handler/src/TouchEventType.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getShadowNodeFromRef = getShadowNodeFromRef;
  var findHostInstance_DEPRECATED;

  function getShadowNodeFromRef(ref) {
    if (findHostInstance_DEPRECATED === undefined) {
      try {
        findHostInstance_DEPRECATED = _$$_REQUIRE(_dependencyMap[0]).findHostInstance_DEPRECATED;
      } catch (e) {
        findHostInstance_DEPRECATED = function findHostInstance_DEPRECATED(_ref) {
          return null;
        };
      }
    }

    return findHostInstance_DEPRECATED(ref)._internalInstanceHandle.stateNode.node;
  }
},"node_modules/react-native-gesture-handler/src/getShadowNodeFromRef.ts",["node_modules/react-native/Libraries/Renderer/shims/ReactFabric.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.pinchHandlerName = exports.PinchGestureHandler = undefined;

  var _createHandler = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var pinchHandlerName = 'PinchGestureHandler';
  exports.pinchHandlerName = pinchHandlerName;
  var PinchGestureHandler = (0, _createHandler.default)({
    name: pinchHandlerName,
    allowedProps: _$$_REQUIRE(_dependencyMap[2]).baseGestureHandlerProps,
    config: {}
  });
  exports.PinchGestureHandler = PinchGestureHandler;
},"node_modules/react-native-gesture-handler/src/handlers/PinchGestureHandler.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native-gesture-handler/src/handlers/createHandler.ts","node_modules/react-native-gesture-handler/src/handlers/gestureHandlerCommon.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.rotationHandlerName = exports.RotationGestureHandler = undefined;

  var _createHandler = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var rotationHandlerName = 'RotationGestureHandler';
  exports.rotationHandlerName = rotationHandlerName;
  var RotationGestureHandler = (0, _createHandler.default)({
    name: rotationHandlerName,
    allowedProps: _$$_REQUIRE(_dependencyMap[2]).baseGestureHandlerProps,
    config: {}
  });
  exports.RotationGestureHandler = RotationGestureHandler;
},"node_modules/react-native-gesture-handler/src/handlers/RotationGestureHandler.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native-gesture-handler/src/handlers/createHandler.ts","node_modules/react-native-gesture-handler/src/handlers/gestureHandlerCommon.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "TouchableHighlight", {
    enumerable: true,
    get: function get() {
      return _TouchableHighlight.default;
    }
  });
  Object.defineProperty(exports, "TouchableNativeFeedback", {
    enumerable: true,
    get: function get() {
      return _TouchableNativeFeedback.default;
    }
  });
  Object.defineProperty(exports, "TouchableOpacity", {
    enumerable: true,
    get: function get() {
      return _TouchableOpacity.default;
    }
  });
  Object.defineProperty(exports, "TouchableWithoutFeedback", {
    enumerable: true,
    get: function get() {
      return _TouchableWithoutFeedback.default;
    }
  });

  var _TouchableNativeFeedback = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _TouchableWithoutFeedback = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _TouchableOpacity = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _TouchableHighlight = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));
},"node_modules/react-native-gesture-handler/src/components/touchables/index.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native-gesture-handler/src/components/touchables/TouchableNativeFeedback.tsx","node_modules/react-native-gesture-handler/src/components/touchables/TouchableWithoutFeedback.tsx","node_modules/react-native-gesture-handler/src/components/touchables/TouchableOpacity.tsx","node_modules/react-native-gesture-handler/src/components/touchables/TouchableHighlight.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0]);

  var _default = _reactNative.TouchableNativeFeedback;
  exports.default = _default;
},"node_modules/react-native-gesture-handler/src/components/touchables/TouchableNativeFeedback.tsx",["node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2]));

  var _GenericTouchable = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var TouchableWithoutFeedback = React.forwardRef(function (props, ref) {
    return React.createElement(_GenericTouchable.default, (0, _extends2.default)({
      ref: ref
    }, props));
  });
  TouchableWithoutFeedback.defaultProps = _GenericTouchable.default.defaultProps;
  var _default = TouchableWithoutFeedback;
  exports.default = _default;
},"node_modules/react-native-gesture-handler/src/components/touchables/TouchableWithoutFeedback.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/react-native-gesture-handler/src/components/touchables/GenericTouchable.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = exports.TOUCHABLE_STATE = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[7]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[8]);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TOUCHABLE_STATE = {
    UNDETERMINED: 0,
    BEGAN: 1,
    MOVED_OUTSIDE: 2
  };
  exports.TOUCHABLE_STATE = TOUCHABLE_STATE;

  var GenericTouchable = function (_Component) {
    (0, _inherits2.default)(GenericTouchable, _Component);

    var _super = _createSuper(GenericTouchable);

    function GenericTouchable() {
      var _this;

      (0, _classCallCheck2.default)(this, GenericTouchable);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.longPressDetected = false;
      _this.pointerInside = true;
      _this.STATE = TOUCHABLE_STATE.UNDETERMINED;

      _this.onGestureEvent = function (_ref) {
        var pointerInside = _ref.nativeEvent.pointerInside;

        if (_this.pointerInside !== pointerInside) {
          if (pointerInside) {
            _this.onMoveIn();
          } else {
            _this.onMoveOut();
          }
        }

        _this.pointerInside = pointerInside;
      };

      _this.onHandlerStateChange = function (_ref2) {
        var nativeEvent = _ref2.nativeEvent;
        var state = nativeEvent.state;

        if (state === _$$_REQUIRE(_dependencyMap[9]).State.CANCELLED || state === _$$_REQUIRE(_dependencyMap[9]).State.FAILED) {
          _this.moveToState(TOUCHABLE_STATE.UNDETERMINED);
        } else if (state === (_reactNative.Platform.OS !== 'android' ? _$$_REQUIRE(_dependencyMap[9]).State.ACTIVE : _$$_REQUIRE(_dependencyMap[9]).State.BEGAN) && _this.STATE === TOUCHABLE_STATE.UNDETERMINED) {
          _this.handlePressIn();
        } else if (state === _$$_REQUIRE(_dependencyMap[9]).State.END) {
          var shouldCallOnPress = !_this.longPressDetected && _this.STATE !== TOUCHABLE_STATE.MOVED_OUTSIDE && _this.pressOutTimeout === null;

          _this.handleGoToUndetermined();

          if (shouldCallOnPress) {
            _this.props.onPress == null ? undefined : _this.props.onPress();
          }
        }
      };

      _this.onLongPressDetected = function () {
        _this.longPressDetected = true;
        _this.props.onLongPress == null ? undefined : _this.props.onLongPress();
      };

      return _this;
    }

    (0, _createClass2.default)(GenericTouchable, [{
      key: "handlePressIn",
      value: function handlePressIn() {
        var _this2 = this;

        if (this.props.delayPressIn) {
          this.pressInTimeout = setTimeout(function () {
            _this2.moveToState(TOUCHABLE_STATE.BEGAN);

            _this2.pressInTimeout = null;
          }, this.props.delayPressIn);
        } else {
          this.moveToState(TOUCHABLE_STATE.BEGAN);
        }

        if (this.props.onLongPress) {
          var time = (this.props.delayPressIn || 0) + (this.props.delayLongPress || 0);
          this.longPressTimeout = setTimeout(this.onLongPressDetected, time);
        }
      }
    }, {
      key: "handleMoveOutside",
      value: function handleMoveOutside() {
        var _this3 = this;

        if (this.props.delayPressOut) {
          this.pressOutTimeout = this.pressOutTimeout || setTimeout(function () {
            _this3.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);

            _this3.pressOutTimeout = null;
          }, this.props.delayPressOut);
        } else {
          this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);
        }
      }
    }, {
      key: "handleGoToUndetermined",
      value: function handleGoToUndetermined() {
        var _this4 = this;

        clearTimeout(this.pressOutTimeout);

        if (this.props.delayPressOut) {
          this.pressOutTimeout = setTimeout(function () {
            if (_this4.STATE === TOUCHABLE_STATE.UNDETERMINED) {
              _this4.moveToState(TOUCHABLE_STATE.BEGAN);
            }

            _this4.moveToState(TOUCHABLE_STATE.UNDETERMINED);

            _this4.pressOutTimeout = null;
          }, this.props.delayPressOut);
        } else {
          if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {
            this.moveToState(TOUCHABLE_STATE.BEGAN);
          }

          this.moveToState(TOUCHABLE_STATE.UNDETERMINED);
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this.reset();
      }
    }, {
      key: "reset",
      value: function reset() {
        this.longPressDetected = false;
        this.pointerInside = true;
        clearTimeout(this.pressInTimeout);
        clearTimeout(this.pressOutTimeout);
        clearTimeout(this.longPressTimeout);
        this.pressOutTimeout = null;
        this.longPressTimeout = null;
        this.pressInTimeout = null;
      }
    }, {
      key: "moveToState",
      value: function moveToState(newState) {
        var _this$props$onStateCh, _this$props4;

        if (newState === this.STATE) {
          return;
        }

        if (newState === TOUCHABLE_STATE.BEGAN) {
          var _this$props$onPressIn, _this$props;

          (_this$props$onPressIn = (_this$props = this.props).onPressIn) == null ? undefined : _this$props$onPressIn.call(_this$props);
        } else if (newState === TOUCHABLE_STATE.MOVED_OUTSIDE) {
          var _this$props$onPressOu, _this$props2;

          (_this$props$onPressOu = (_this$props2 = this.props).onPressOut) == null ? undefined : _this$props$onPressOu.call(_this$props2);
        } else if (newState === TOUCHABLE_STATE.UNDETERMINED) {
          this.reset();

          if (this.STATE === TOUCHABLE_STATE.BEGAN) {
            var _this$props$onPressOu2, _this$props3;

            (_this$props$onPressOu2 = (_this$props3 = this.props).onPressOut) == null ? undefined : _this$props$onPressOu2.call(_this$props3);
          }
        }

        (_this$props$onStateCh = (_this$props4 = this.props).onStateChange) == null ? undefined : _this$props$onStateCh.call(_this$props4, this.STATE, newState);
        this.STATE = newState;
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.reset();
      }
    }, {
      key: "onMoveIn",
      value: function onMoveIn() {
        if (this.STATE === TOUCHABLE_STATE.MOVED_OUTSIDE) {
          this.moveToState(TOUCHABLE_STATE.BEGAN);
        }
      }
    }, {
      key: "onMoveOut",
      value: function onMoveOut() {
        clearTimeout(this.longPressTimeout);
        this.longPressTimeout = null;

        if (this.STATE === TOUCHABLE_STATE.BEGAN) {
          this.handleMoveOutside();
        }
      }
    }, {
      key: "render",
      value: function render() {
        var coreProps = {
          accessible: this.props.accessible !== false,
          accessibilityLabel: this.props.accessibilityLabel,
          accessibilityHint: this.props.accessibilityHint,
          accessibilityRole: this.props.accessibilityRole,
          accessibilityState: this.props.accessibilityState,
          accessibilityActions: this.props.accessibilityActions,
          onAccessibilityAction: this.props.onAccessibilityAction,
          nativeID: this.props.nativeID,
          onLayout: this.props.onLayout,
          hitSlop: this.props.hitSlop
        };
        return React.createElement(_$$_REQUIRE(_dependencyMap[10]).BaseButton, (0, _extends2.default)({
          style: this.props.containerStyle,
          onHandlerStateChange: this.props.disabled ? undefined : this.onHandlerStateChange,
          onGestureEvent: this.onGestureEvent,
          hitSlop: this.props.hitSlop,
          shouldActivateOnStart: this.props.shouldActivateOnStart,
          disallowInterruption: this.props.disallowInterruption,
          testID: this.props.testID
        }, this.props.extraButtonProps), React.createElement(_reactNative.Animated.View, (0, _extends2.default)({}, coreProps, {
          style: this.props.style
        }), this.props.children));
      }
    }]);
    return GenericTouchable;
  }(React.Component);

  exports.default = GenericTouchable;
  GenericTouchable.defaultProps = {
    delayLongPress: 600,
    extraButtonProps: {
      rippleColor: 'transparent',
      exclusive: true
    }
  };
},"node_modules/react-native-gesture-handler/src/components/touchables/GenericTouchable.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/react-native-gesture-handler/src/State.ts","node_modules/react-native-gesture-handler/src/components/GestureButtons.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[8]);

  var _GenericTouchable = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[9]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[10]));

  var _excluded = ["style"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TouchableOpacity = function (_Component) {
    (0, _inherits2.default)(TouchableOpacity, _Component);

    var _super = _createSuper(TouchableOpacity);

    function TouchableOpacity() {
      var _this;

      (0, _classCallCheck2.default)(this, TouchableOpacity);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));

      _this.getChildStyleOpacityWithDefault = function () {
        var childStyle = _reactNative.StyleSheet.flatten(_this.props.style) || {};
        return childStyle.opacity == null ? 1 : childStyle.opacity;
      };

      _this.opacity = new _reactNative.Animated.Value(_this.getChildStyleOpacityWithDefault());

      _this.setOpacityTo = function (value, duration) {
        var _this$props$useNative;

        _reactNative.Animated.timing(_this.opacity, {
          toValue: value,
          duration: duration,
          easing: _reactNative.Easing.inOut(_reactNative.Easing.quad),
          useNativeDriver: (_this$props$useNative = _this.props.useNativeAnimations) != null ? _this$props$useNative : true
        }).start();
      };

      _this.onStateChange = function (_from, to) {
        if (to === _GenericTouchable.TOUCHABLE_STATE.BEGAN) {
          _this.setOpacityTo(_this.props.activeOpacity, 0);
        } else if (to === _GenericTouchable.TOUCHABLE_STATE.UNDETERMINED || to === _GenericTouchable.TOUCHABLE_STATE.MOVED_OUTSIDE) {
          _this.setOpacityTo(_this.getChildStyleOpacityWithDefault(), 150);
        }
      };

      return _this;
    }

    (0, _createClass2.default)(TouchableOpacity, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            _this$props$style = _this$props.style,
            style = _this$props$style === undefined ? {} : _this$props$style,
            rest = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
        return React.createElement(_GenericTouchable.default, (0, _extends2.default)({}, rest, {
          style: [style, {
            opacity: this.opacity
          }],
          onStateChange: this.onStateChange
        }), this.props.children ? this.props.children : React.createElement(_reactNative.View, null));
      }
    }]);
    return TouchableOpacity;
  }(React.Component);

  exports.default = TouchableOpacity;
  TouchableOpacity.defaultProps = (0, _extends2.default)({}, _GenericTouchable.default.defaultProps, {
    activeOpacity: 0.2
  });
},"node_modules/react-native-gesture-handler/src/components/touchables/TouchableOpacity.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react-native/index.js","node_modules/react-native-gesture-handler/src/components/touchables/GenericTouchable.tsx","node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[8]));

  var _GenericTouchable = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[9]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[10]);

  var _excluded = ["style"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TouchableHighlight = function (_Component) {
    (0, _inherits2.default)(TouchableHighlight, _Component);

    var _super = _createSuper(TouchableHighlight);

    function TouchableHighlight(props) {
      var _this;

      (0, _classCallCheck2.default)(this, TouchableHighlight);
      _this = _super.call(this, props);

      _this.showUnderlay = function () {
        if (!_this.hasPressHandler()) {
          return;
        }

        _this.setState({
          extraChildStyle: {
            opacity: _this.props.activeOpacity
          },
          extraUnderlayStyle: {
            backgroundColor: _this.props.underlayColor
          }
        });

        _this.props.onShowUnderlay == null ? undefined : _this.props.onShowUnderlay();
      };

      _this.hasPressHandler = function () {
        return _this.props.onPress || _this.props.onPressIn || _this.props.onPressOut || _this.props.onLongPress;
      };

      _this.hideUnderlay = function () {
        _this.setState({
          extraChildStyle: null,
          extraUnderlayStyle: null
        });

        _this.props.onHideUnderlay == null ? undefined : _this.props.onHideUnderlay();
      };

      _this.onStateChange = function (_from, to) {
        if (to === _GenericTouchable.TOUCHABLE_STATE.BEGAN) {
          _this.showUnderlay();
        } else if (to === _GenericTouchable.TOUCHABLE_STATE.UNDETERMINED || to === _GenericTouchable.TOUCHABLE_STATE.MOVED_OUTSIDE) {
          _this.hideUnderlay();
        }
      };

      _this.state = {
        extraChildStyle: null,
        extraUnderlayStyle: null
      };
      return _this;
    }

    (0, _createClass2.default)(TouchableHighlight, [{
      key: "renderChildren",
      value: function renderChildren() {
        if (!this.props.children) {
          return React.createElement(_reactNative.View, null);
        }

        var child = React.Children.only(this.props.children);
        return React.cloneElement(child, {
          style: _reactNative.StyleSheet.compose(child.props.style, this.state.extraChildStyle)
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            _this$props$style = _this$props.style,
            style = _this$props$style === undefined ? {} : _this$props$style,
            rest = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
        var extraUnderlayStyle = this.state.extraUnderlayStyle;
        return React.createElement(_GenericTouchable.default, (0, _extends2.default)({}, rest, {
          style: [style, extraUnderlayStyle],
          onStateChange: this.onStateChange
        }), this.renderChildren());
      }
    }]);
    return TouchableHighlight;
  }(React.Component);

  exports.default = TouchableHighlight;
  TouchableHighlight.defaultProps = (0, _extends2.default)({}, _GenericTouchable.default.defaultProps, {
    activeOpacity: 0.85,
    delayPressOut: 100,
    underlayColor: 'black'
  });
},"node_modules/react-native-gesture-handler/src/components/touchables/TouchableHighlight.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react/index.js","node_modules/react-native-gesture-handler/src/components/touchables/GenericTouchable.tsx","node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = gestureHandlerRootHOC;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[1]);

  var _hoistNonReactStatics = _$$_REQUIRE(_dependencyMap[2])(_$$_REQUIRE(_dependencyMap[3]));

  var _GestureHandlerRootView = _$$_REQUIRE(_dependencyMap[2])(_$$_REQUIRE(_dependencyMap[4]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function gestureHandlerRootHOC(Component, containerStyles) {
    function Wrapper(props) {
      return React.createElement(_GestureHandlerRootView.default, {
        style: [styles.container, containerStyles]
      }, React.createElement(Component, props));
    }

    Wrapper.displayName = "gestureHandlerRootHOC(" + (Component.displayName || Component.name) + ")";
    (0, _hoistNonReactStatics.default)(Wrapper, Component);
    return Wrapper;
  }

  var styles = _reactNative.StyleSheet.create({
    container: {
      flex: 1
    }
  });
},"node_modules/react-native-gesture-handler/src/gestureHandlerRootHOC.tsx",["node_modules/react/index.js","node_modules/react-native/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js","node_modules/react-native-gesture-handler/src/GestureHandlerRootView.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    '$$typeof': true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    '$$typeof': true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[_$$_REQUIRE(_dependencyMap[0]).ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[_$$_REQUIRE(_dependencyMap[0]).Memo] = MEMO_STATICS;

  function getStatics(component) {
    if (_$$_REQUIRE(_dependencyMap[0]).isMemo(component)) {
      return MEMO_STATICS;
    }

    return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
  }

  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;

  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf(sourceComponent);

        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
      }

      var keys = getOwnPropertyNames(sourceComponent);

      if (getOwnPropertySymbols) {
        keys = keys.concat(getOwnPropertySymbols(sourceComponent));
      }

      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);

      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];

        if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

          try {
            defineProperty(targetComponent, key, descriptor);
          } catch (e) {}
        }
      }
    }

    return targetComponent;
  }

  module.exports = hoistNonReactStatics;
},"node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js",["node_modules/hoist-non-react-statics/node_modules/react-is/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  {
    module.exports = _$$_REQUIRE(_dependencyMap[0]);
  }
},"node_modules/hoist-non-react-statics/node_modules/react-is/index.js",["node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  var b = "function" === typeof Symbol && Symbol.for,
      c = b ? Symbol.for("react.element") : 60103,
      d = b ? Symbol.for("react.portal") : 60106,
      e = b ? Symbol.for("react.fragment") : 60107,
      f = b ? Symbol.for("react.strict_mode") : 60108,
      g = b ? Symbol.for("react.profiler") : 60114,
      h = b ? Symbol.for("react.provider") : 60109,
      k = b ? Symbol.for("react.context") : 60110,
      l = b ? Symbol.for("react.async_mode") : 60111,
      m = b ? Symbol.for("react.concurrent_mode") : 60111,
      n = b ? Symbol.for("react.forward_ref") : 60112,
      p = b ? Symbol.for("react.suspense") : 60113,
      q = b ? Symbol.for("react.suspense_list") : 60120,
      r = b ? Symbol.for("react.memo") : 60115,
      t = b ? Symbol.for("react.lazy") : 60116,
      v = b ? Symbol.for("react.block") : 60121,
      w = b ? Symbol.for("react.fundamental") : 60117,
      x = b ? Symbol.for("react.responder") : 60118,
      y = b ? Symbol.for("react.scope") : 60119;

  function z(a) {
    if ("object" === typeof a && null !== a) {
      var u = a.$$typeof;

      switch (u) {
        case c:
          switch (a = a.type, a) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
              return a;

            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case n:
                case t:
                case r:
                case h:
                  return a;

                default:
                  return u;
              }

          }

        case d:
          return u;
      }
    }
  }

  function A(a) {
    return z(a) === m;
  }

  exports.AsyncMode = l;
  exports.ConcurrentMode = m;
  exports.ContextConsumer = k;
  exports.ContextProvider = h;
  exports.Element = c;
  exports.ForwardRef = n;
  exports.Fragment = e;
  exports.Lazy = t;
  exports.Memo = r;
  exports.Portal = d;
  exports.Profiler = g;
  exports.StrictMode = f;
  exports.Suspense = p;

  exports.isAsyncMode = function (a) {
    return A(a) || z(a) === l;
  };

  exports.isConcurrentMode = A;

  exports.isContextConsumer = function (a) {
    return z(a) === k;
  };

  exports.isContextProvider = function (a) {
    return z(a) === h;
  };

  exports.isElement = function (a) {
    return "object" === typeof a && null !== a && a.$$typeof === c;
  };

  exports.isForwardRef = function (a) {
    return z(a) === n;
  };

  exports.isFragment = function (a) {
    return z(a) === e;
  };

  exports.isLazy = function (a) {
    return z(a) === t;
  };

  exports.isMemo = function (a) {
    return z(a) === r;
  };

  exports.isPortal = function (a) {
    return z(a) === d;
  };

  exports.isProfiler = function (a) {
    return z(a) === g;
  };

  exports.isStrictMode = function (a) {
    return z(a) === f;
  };

  exports.isSuspense = function (a) {
    return z(a) === p;
  };

  exports.isValidElementType = function (a) {
    return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
  };

  exports.typeOf = z;
},"node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js",[]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = GestureHandlerRootView;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[1]);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function GestureHandlerRootView(props) {
    (0, _$$_REQUIRE(_dependencyMap[2]).maybeInitializeFabric)();
    return React.createElement(_reactNative.View, props);
  }
},"node_modules/react-native-gesture-handler/src/GestureHandlerRootView.tsx",["node_modules/react/index.js","node_modules/react-native/index.js","node_modules/react-native-gesture-handler/src/init.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.initialize = initialize;
  exports.maybeInitializeFabric = maybeInitializeFabric;

  var _RNGestureHandlerModule = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var fabricInitialized = false;

  function initialize() {
    (0, _$$_REQUIRE(_dependencyMap[2]).startListening)();
  }

  function maybeInitializeFabric() {
    if ((0, _$$_REQUIRE(_dependencyMap[3]).isFabric)() && !fabricInitialized) {
      _RNGestureHandlerModule.default.install();

      fabricInitialized = true;
    }
  }
},"node_modules/react-native-gesture-handler/src/init.ts",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native-gesture-handler/src/RNGestureHandlerModule.ts","node_modules/react-native-gesture-handler/src/handlers/gestures/eventReceiver.ts","node_modules/react-native-gesture-handler/src/utils.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[7]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[8]);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var DRAG_TOSS = 0.05;

  var Swipeable = function (_Component) {
    (0, _inherits2.default)(Swipeable, _Component);

    var _super = _createSuper(Swipeable);

    function Swipeable(_props) {
      var _this;

      (0, _classCallCheck2.default)(this, Swipeable);
      _this = _super.call(this, _props);

      _this.updateAnimatedEvent = function (props, state) {
        var friction = props.friction,
            overshootFriction = props.overshootFriction;
        var dragX = state.dragX,
            rowTranslation = state.rowTranslation,
            _state$leftWidth = state.leftWidth,
            leftWidth = _state$leftWidth === undefined ? 0 : _state$leftWidth,
            _state$rowWidth = state.rowWidth,
            rowWidth = _state$rowWidth === undefined ? 0 : _state$rowWidth;
        var _state$rightOffset = state.rightOffset,
            rightOffset = _state$rightOffset === undefined ? rowWidth : _state$rightOffset;
        var rightWidth = Math.max(0, rowWidth - rightOffset);
        var _props$overshootLeft = props.overshootLeft,
            overshootLeft = _props$overshootLeft === undefined ? leftWidth > 0 : _props$overshootLeft,
            _props$overshootRight = props.overshootRight,
            overshootRight = _props$overshootRight === undefined ? rightWidth > 0 : _props$overshootRight;

        var transX = _reactNative.Animated.add(rowTranslation, dragX.interpolate({
          inputRange: [0, friction],
          outputRange: [0, 1]
        })).interpolate({
          inputRange: [-rightWidth - 1, -rightWidth, leftWidth, leftWidth + 1],
          outputRange: [-rightWidth - (overshootRight ? 1 / overshootFriction : 0), -rightWidth, leftWidth, leftWidth + (overshootLeft ? 1 / overshootFriction : 0)]
        });

        _this.transX = transX;
        _this.showLeftAction = leftWidth > 0 ? transX.interpolate({
          inputRange: [-1, 0, leftWidth],
          outputRange: [0, 0, 1]
        }) : new _reactNative.Animated.Value(0);
        _this.leftActionTranslate = _this.showLeftAction.interpolate({
          inputRange: [0, Number.MIN_VALUE],
          outputRange: [-10000, 0],
          extrapolate: 'clamp'
        });
        _this.showRightAction = rightWidth > 0 ? transX.interpolate({
          inputRange: [-rightWidth, 0, 1],
          outputRange: [1, 0, 0]
        }) : new _reactNative.Animated.Value(0);
        _this.rightActionTranslate = _this.showRightAction.interpolate({
          inputRange: [0, Number.MIN_VALUE],
          outputRange: [-10000, 0],
          extrapolate: 'clamp'
        });
      };

      _this.onTapHandlerStateChange = function (_ref) {
        var nativeEvent = _ref.nativeEvent;

        if (nativeEvent.oldState === _$$_REQUIRE(_dependencyMap[9]).State.ACTIVE) {
          _this.close();
        }
      };

      _this.onHandlerStateChange = function (ev) {
        if (ev.nativeEvent.oldState === _$$_REQUIRE(_dependencyMap[9]).State.ACTIVE) {
          _this.handleRelease(ev);
        }
      };

      _this.handleRelease = function (ev) {
        var _ev$nativeEvent = ev.nativeEvent,
            velocityX = _ev$nativeEvent.velocityX,
            dragX = _ev$nativeEvent.translationX;
        var _this$state = _this.state,
            _this$state$leftWidth = _this$state.leftWidth,
            leftWidth = _this$state$leftWidth === undefined ? 0 : _this$state$leftWidth,
            _this$state$rowWidth = _this$state.rowWidth,
            rowWidth = _this$state$rowWidth === undefined ? 0 : _this$state$rowWidth,
            rowState = _this$state.rowState;
        var _this$state$rightOffs = _this.state.rightOffset,
            rightOffset = _this$state$rightOffs === undefined ? rowWidth : _this$state$rightOffs;
        var rightWidth = rowWidth - rightOffset;
        var _this$props = _this.props,
            friction = _this$props.friction,
            _this$props$leftThres = _this$props.leftThreshold,
            leftThreshold = _this$props$leftThres === undefined ? leftWidth / 2 : _this$props$leftThres,
            _this$props$rightThre = _this$props.rightThreshold,
            rightThreshold = _this$props$rightThre === undefined ? rightWidth / 2 : _this$props$rightThre;
        var startOffsetX = _this.currentOffset() + dragX / friction;
        var translationX = (dragX + DRAG_TOSS * velocityX) / friction;
        var toValue = 0;

        if (rowState === 0) {
          if (translationX > leftThreshold) {
            toValue = leftWidth;
          } else if (translationX < -rightThreshold) {
            toValue = -rightWidth;
          }
        } else if (rowState === 1) {
          if (translationX > -leftThreshold) {
            toValue = leftWidth;
          }
        } else {
          if (translationX < rightThreshold) {
            toValue = -rightWidth;
          }
        }

        _this.animateRow(startOffsetX, toValue, velocityX / friction);
      };

      _this.animateRow = function (fromValue, toValue, velocityX) {
        var _this$state2 = _this.state,
            dragX = _this$state2.dragX,
            rowTranslation = _this$state2.rowTranslation;
        dragX.setValue(0);
        rowTranslation.setValue(fromValue);

        _this.setState({
          rowState: Math.sign(toValue)
        });

        _reactNative.Animated.spring(rowTranslation, (0, _extends2.default)({
          restSpeedThreshold: 1.7,
          restDisplacementThreshold: 0.4,
          velocity: velocityX,
          bounciness: 0,
          toValue: toValue,
          useNativeDriver: _this.props.useNativeAnimations
        }, _this.props.animationOptions)).start(function (_ref2) {
          var finished = _ref2.finished;

          if (finished) {
            if (toValue > 0) {
              _this.props.onSwipeableLeftOpen == null ? undefined : _this.props.onSwipeableLeftOpen();
              _this.props.onSwipeableOpen == null ? undefined : _this.props.onSwipeableOpen('left');
            } else if (toValue < 0) {
              _this.props.onSwipeableRightOpen == null ? undefined : _this.props.onSwipeableRightOpen();
              _this.props.onSwipeableOpen == null ? undefined : _this.props.onSwipeableOpen('right');
            } else {
              var closingDirection = fromValue > 0 ? 'left' : 'right';
              _this.props.onSwipeableClose == null ? undefined : _this.props.onSwipeableClose(closingDirection);
            }
          }
        });

        if (toValue > 0) {
          _this.props.onSwipeableLeftWillOpen == null ? undefined : _this.props.onSwipeableLeftWillOpen();
          _this.props.onSwipeableWillOpen == null ? undefined : _this.props.onSwipeableWillOpen('left');
        } else if (toValue < 0) {
          _this.props.onSwipeableRightWillOpen == null ? undefined : _this.props.onSwipeableRightWillOpen();
          _this.props.onSwipeableWillOpen == null ? undefined : _this.props.onSwipeableWillOpen('right');
        } else {
          var closingDirection = fromValue > 0 ? 'left' : 'right';
          _this.props.onSwipeableWillClose == null ? undefined : _this.props.onSwipeableWillClose(closingDirection);
        }
      };

      _this.onRowLayout = function (_ref3) {
        var nativeEvent = _ref3.nativeEvent;

        _this.setState({
          rowWidth: nativeEvent.layout.width
        });
      };

      _this.currentOffset = function () {
        var _this$state3 = _this.state,
            _this$state3$leftWidt = _this$state3.leftWidth,
            leftWidth = _this$state3$leftWidt === undefined ? 0 : _this$state3$leftWidt,
            _this$state3$rowWidth = _this$state3.rowWidth,
            rowWidth = _this$state3$rowWidth === undefined ? 0 : _this$state3$rowWidth,
            rowState = _this$state3.rowState;
        var _this$state$rightOffs2 = _this.state.rightOffset,
            rightOffset = _this$state$rightOffs2 === undefined ? rowWidth : _this$state$rightOffs2;
        var rightWidth = rowWidth - rightOffset;

        if (rowState === 1) {
          return leftWidth;
        } else if (rowState === -1) {
          return -rightWidth;
        }

        return 0;
      };

      _this.close = function () {
        _this.animateRow(_this.currentOffset(), 0);
      };

      _this.openLeft = function () {
        var _this$state$leftWidth2 = _this.state.leftWidth,
            leftWidth = _this$state$leftWidth2 === undefined ? 0 : _this$state$leftWidth2;

        _this.animateRow(_this.currentOffset(), leftWidth);
      };

      _this.openRight = function () {
        var _this$state$rowWidth2 = _this.state.rowWidth,
            rowWidth = _this$state$rowWidth2 === undefined ? 0 : _this$state$rowWidth2;
        var _this$state$rightOffs3 = _this.state.rightOffset,
            rightOffset = _this$state$rightOffs3 === undefined ? rowWidth : _this$state$rightOffs3;
        var rightWidth = rowWidth - rightOffset;

        _this.animateRow(_this.currentOffset(), -rightWidth);
      };

      var _dragX = new _reactNative.Animated.Value(0);

      _this.state = {
        dragX: _dragX,
        rowTranslation: new _reactNative.Animated.Value(0),
        rowState: 0,
        leftWidth: undefined,
        rightOffset: undefined,
        rowWidth: undefined
      };

      _this.updateAnimatedEvent(_props, _this.state);

      _this.onGestureEvent = _reactNative.Animated.event([{
        nativeEvent: {
          translationX: _dragX
        }
      }], {
        useNativeDriver: _props.useNativeAnimations
      });
      return _this;
    }

    (0, _createClass2.default)(Swipeable, [{
      key: "UNSAFE_componentWillUpdate",
      value: function UNSAFE_componentWillUpdate(props, state) {
        if (this.props.friction !== props.friction || this.props.overshootLeft !== props.overshootLeft || this.props.overshootRight !== props.overshootRight || this.props.overshootFriction !== props.overshootFriction || this.state.leftWidth !== state.leftWidth || this.state.rightOffset !== state.rightOffset || this.state.rowWidth !== state.rowWidth) {
          this.updateAnimatedEvent(props, state);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var rowState = this.state.rowState;
        var _this$props2 = this.props,
            children = _this$props2.children,
            renderLeftActions = _this$props2.renderLeftActions,
            renderRightActions = _this$props2.renderRightActions;
        var left = renderLeftActions && React.createElement(_reactNative.Animated.View, {
          style: [styles.leftActions, {
            transform: [{
              translateX: this.leftActionTranslate
            }]
          }]
        }, renderLeftActions(this.showLeftAction, this.transX), React.createElement(_reactNative.View, {
          onLayout: function onLayout(_ref4) {
            var nativeEvent = _ref4.nativeEvent;
            return _this2.setState({
              leftWidth: nativeEvent.layout.x
            });
          }
        }));
        var right = renderRightActions && React.createElement(_reactNative.Animated.View, {
          style: [styles.rightActions, {
            transform: [{
              translateX: this.rightActionTranslate
            }]
          }]
        }, renderRightActions(this.showRightAction, this.transX), React.createElement(_reactNative.View, {
          onLayout: function onLayout(_ref5) {
            var nativeEvent = _ref5.nativeEvent;
            return _this2.setState({
              rightOffset: nativeEvent.layout.x
            });
          }
        }));
        return React.createElement(_$$_REQUIRE(_dependencyMap[10]).PanGestureHandler, (0, _extends2.default)({
          activeOffsetX: [-10, 10]
        }, this.props, {
          onGestureEvent: this.onGestureEvent,
          onHandlerStateChange: this.onHandlerStateChange
        }), React.createElement(_reactNative.Animated.View, {
          onLayout: this.onRowLayout,
          style: [styles.container, this.props.containerStyle]
        }, left, right, React.createElement(_$$_REQUIRE(_dependencyMap[11]).TapGestureHandler, {
          enabled: rowState !== 0,
          onHandlerStateChange: this.onTapHandlerStateChange
        }, React.createElement(_reactNative.Animated.View, {
          pointerEvents: rowState === 0 ? 'auto' : 'box-only',
          style: [{
            transform: [{
              translateX: this.transX
            }]
          }, this.props.childrenContainerStyle]
        }, children))));
      }
    }]);
    return Swipeable;
  }(React.Component);

  exports.default = Swipeable;
  Swipeable.defaultProps = {
    friction: 1,
    overshootFriction: 1,
    useNativeAnimations: true
  };

  var styles = _reactNative.StyleSheet.create({
    container: {
      overflow: 'hidden'
    },
    leftActions: (0, _extends2.default)({}, _reactNative.StyleSheet.absoluteFillObject, {
      flexDirection: _reactNative.I18nManager.isRTL ? 'row-reverse' : 'row'
    }),
    rightActions: (0, _extends2.default)({}, _reactNative.StyleSheet.absoluteFillObject, {
      flexDirection: _reactNative.I18nManager.isRTL ? 'row' : 'row-reverse'
    })
  });
},"node_modules/react-native-gesture-handler/src/components/Swipeable.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/react-native-gesture-handler/src/State.ts","node_modules/react-native-gesture-handler/src/handlers/PanGestureHandler.ts","node_modules/react-native-gesture-handler/src/handlers/TapGestureHandler.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[7]));

  var _invariant = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[9]);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var DRAG_TOSS = 0.05;
  var IDLE = 'Idle';
  var DRAGGING = 'Dragging';
  var SETTLING = 'Settling';

  var DrawerLayout = function (_Component) {
    (0, _inherits2.default)(DrawerLayout, _Component);

    var _super = _createSuper(DrawerLayout);

    function DrawerLayout(_props) {
      var _this;

      (0, _classCallCheck2.default)(this, DrawerLayout);
      _this = _super.call(this, _props);
      _this.accessibilityIsModalView = React.createRef();
      _this.pointerEventsView = React.createRef();
      _this.panGestureHandler = React.createRef();
      _this.drawerShown = false;

      _this.updateAnimatedEvent = function (props, state) {
        var drawerPosition = props.drawerPosition,
            drawerWidth = props.drawerWidth,
            drawerType = props.drawerType;
        var dragXValue = state.dragX,
            touchXValue = state.touchX,
            drawerTranslation = state.drawerTranslation,
            containerWidth = state.containerWidth;
        var dragX = dragXValue;
        var touchX = touchXValue;

        if (drawerPosition !== 'left') {
          dragX = _reactNative.Animated.multiply(new _reactNative.Animated.Value(-1), dragXValue);
          touchX = _reactNative.Animated.add(new _reactNative.Animated.Value(containerWidth), _reactNative.Animated.multiply(new _reactNative.Animated.Value(-1), touchXValue));
          touchXValue.setValue(containerWidth);
        } else {
          touchXValue.setValue(0);
        }

        var translationX = dragX;

        if (drawerType === 'front') {
          var startPositionX = _reactNative.Animated.add(touchX, _reactNative.Animated.multiply(new _reactNative.Animated.Value(-1), dragX));

          var dragOffsetFromOnStartPosition = startPositionX.interpolate({
            inputRange: [drawerWidth - 1, drawerWidth, drawerWidth + 1],
            outputRange: [0, 0, 1]
          });
          translationX = _reactNative.Animated.add(dragX, dragOffsetFromOnStartPosition);
        }

        _this.openValue = _reactNative.Animated.add(translationX, drawerTranslation).interpolate({
          inputRange: [0, drawerWidth],
          outputRange: [0, 1],
          extrapolate: 'clamp'
        });
        var gestureOptions = {
          useNativeDriver: props.useNativeAnimations
        };

        if (_this.props.onDrawerSlide) {
          gestureOptions.listener = function (ev) {
            var translationX = Math.floor(Math.abs(ev.nativeEvent.translationX));
            var position = translationX / _this.state.containerWidth;
            _this.props.onDrawerSlide == null ? undefined : _this.props.onDrawerSlide(position);
          };
        }

        _this.onGestureEvent = _reactNative.Animated.event([{
          nativeEvent: {
            translationX: dragXValue,
            x: touchXValue
          }
        }], gestureOptions);
      };

      _this.handleContainerLayout = function (_ref) {
        var nativeEvent = _ref.nativeEvent;

        _this.setState({
          containerWidth: nativeEvent.layout.width
        });
      };

      _this.emitStateChanged = function (newState, drawerWillShow) {
        _this.props.onDrawerStateChanged == null ? undefined : _this.props.onDrawerStateChanged(newState, drawerWillShow);
      };

      _this.openingHandlerStateChange = function (_ref2) {
        var nativeEvent = _ref2.nativeEvent;

        if (nativeEvent.oldState === _$$_REQUIRE(_dependencyMap[10]).State.ACTIVE) {
          _this.handleRelease({
            nativeEvent: nativeEvent
          });
        } else if (nativeEvent.state === _$$_REQUIRE(_dependencyMap[10]).State.ACTIVE) {
          _this.emitStateChanged(DRAGGING, false);

          _this.setState({
            drawerState: DRAGGING
          });

          if (_this.props.keyboardDismissMode === 'on-drag') {
            _reactNative.Keyboard.dismiss();
          }

          if (_this.props.hideStatusBar) {
            _reactNative.StatusBar.setHidden(true, _this.props.statusBarAnimation || 'slide');
          }
        }
      };

      _this.onTapHandlerStateChange = function (_ref3) {
        var nativeEvent = _ref3.nativeEvent;

        if (_this.drawerShown && nativeEvent.oldState === _$$_REQUIRE(_dependencyMap[10]).State.ACTIVE && _this.props.drawerLockMode !== 'locked-open') {
          _this.closeDrawer();
        }
      };

      _this.handleRelease = function (_ref4) {
        var nativeEvent = _ref4.nativeEvent;
        var _this$props = _this.props,
            drawerWidth = _this$props.drawerWidth,
            drawerPosition = _this$props.drawerPosition,
            drawerType = _this$props.drawerType;
        var containerWidth = _this.state.containerWidth;
        var dragX = nativeEvent.translationX,
            velocityX = nativeEvent.velocityX,
            touchX = nativeEvent.x;

        if (drawerPosition !== 'left') {
          dragX = -dragX;
          touchX = containerWidth - touchX;
          velocityX = -velocityX;
        }

        var gestureStartX = touchX - dragX;
        var dragOffsetBasedOnStart = 0;

        if (drawerType === 'front') {
          dragOffsetBasedOnStart = gestureStartX > drawerWidth ? gestureStartX - drawerWidth : 0;
        }

        var startOffsetX = dragX + dragOffsetBasedOnStart + (_this.drawerShown ? drawerWidth : 0);
        var projOffsetX = startOffsetX + DRAG_TOSS * velocityX;
        var shouldOpen = projOffsetX > drawerWidth / 2;

        if (shouldOpen) {
          _this.animateDrawer(startOffsetX, drawerWidth, velocityX);
        } else {
          _this.animateDrawer(startOffsetX, 0, velocityX);
        }
      };

      _this.updateShowing = function (showing) {
        var _this$accessibilityIs, _this$pointerEventsVi, _this$panGestureHandl;

        _this.drawerShown = showing;
        (_this$accessibilityIs = _this.accessibilityIsModalView.current) == null ? undefined : _this$accessibilityIs.setNativeProps({
          accessibilityViewIsModal: showing
        });
        (_this$pointerEventsVi = _this.pointerEventsView.current) == null ? undefined : _this$pointerEventsVi.setNativeProps({
          pointerEvents: showing ? 'auto' : 'none'
        });
        var _this$props2 = _this.props,
            drawerPosition = _this$props2.drawerPosition,
            minSwipeDistance = _this$props2.minSwipeDistance,
            edgeWidth = _this$props2.edgeWidth;
        var fromLeft = drawerPosition === 'left';
        var gestureOrientation = (fromLeft ? 1 : -1) * (_this.drawerShown ? -1 : 1);
        var hitSlop = fromLeft ? {
          left: 0,
          width: showing ? undefined : edgeWidth
        } : {
          right: 0,
          width: showing ? undefined : edgeWidth
        };
        (_this$panGestureHandl = _this.panGestureHandler.current) == null ? undefined : _this$panGestureHandl.setNativeProps({
          hitSlop: hitSlop,
          activeOffsetX: gestureOrientation * minSwipeDistance
        });
      };

      _this.animateDrawer = function (fromValue, toValue, velocity, speed) {
        _this.state.dragX.setValue(0);

        _this.state.touchX.setValue(_this.props.drawerPosition === 'left' ? 0 : _this.state.containerWidth);

        if (fromValue != null) {
          var nextFramePosition = fromValue;

          if (_this.props.useNativeAnimations) {
            if (fromValue < toValue && velocity > 0) {
              nextFramePosition = Math.min(fromValue + velocity / 60.0, toValue);
            } else if (fromValue > toValue && velocity < 0) {
              nextFramePosition = Math.max(fromValue + velocity / 60.0, toValue);
            }
          }

          _this.state.drawerTranslation.setValue(nextFramePosition);
        }

        var willShow = toValue !== 0;

        _this.updateShowing(willShow);

        _this.emitStateChanged(SETTLING, willShow);

        _this.setState({
          drawerState: SETTLING
        });

        if (_this.props.hideStatusBar) {
          _reactNative.StatusBar.setHidden(willShow, _this.props.statusBarAnimation || 'slide');
        }

        _reactNative.Animated.spring(_this.state.drawerTranslation, {
          velocity: velocity,
          bounciness: 0,
          toValue: toValue,
          useNativeDriver: _this.props.useNativeAnimations,
          speed: speed != null ? speed : undefined
        }).start(function (_ref5) {
          var finished = _ref5.finished;

          if (finished) {
            _this.emitStateChanged(IDLE, willShow);

            _this.setState({
              drawerOpened: willShow
            });

            if (_this.state.drawerState !== DRAGGING) {
              _this.setState({
                drawerState: IDLE
              });
            }

            if (willShow) {
              _this.props.onDrawerOpen == null ? undefined : _this.props.onDrawerOpen();
            } else {
              _this.props.onDrawerClose == null ? undefined : _this.props.onDrawerClose();
            }
          }
        });
      };

      _this.openDrawer = function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _this.animateDrawer(undefined, _this.props.drawerWidth, options.velocity ? options.velocity : 0, options.speed);

        _this.forceUpdate();
      };

      _this.closeDrawer = function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _this.animateDrawer(undefined, 0, options.velocity ? options.velocity : 0, options.speed);

        _this.forceUpdate();
      };

      _this.renderOverlay = function () {
        (0, _invariant.default)(_this.openValue, 'should be set');
        var overlayOpacity;

        if (_this.state.drawerState !== IDLE) {
          overlayOpacity = _this.openValue;
        } else {
          overlayOpacity = _this.state.drawerOpened ? 1 : 0;
        }

        var dynamicOverlayStyles = {
          opacity: overlayOpacity,
          backgroundColor: _this.props.overlayColor
        };
        return React.createElement(_$$_REQUIRE(_dependencyMap[11]).TapGestureHandler, {
          onHandlerStateChange: _this.onTapHandlerStateChange
        }, React.createElement(_reactNative.Animated.View, {
          pointerEvents: _this.drawerShown ? 'auto' : 'none',
          ref: _this.pointerEventsView,
          style: [styles.overlay, dynamicOverlayStyles]
        }));
      };

      _this.renderDrawer = function () {
        var _this$props3 = _this.props,
            drawerBackgroundColor = _this$props3.drawerBackgroundColor,
            drawerWidth = _this$props3.drawerWidth,
            drawerPosition = _this$props3.drawerPosition,
            drawerType = _this$props3.drawerType,
            drawerContainerStyle = _this$props3.drawerContainerStyle,
            contentContainerStyle = _this$props3.contentContainerStyle;
        var fromLeft = drawerPosition === 'left';
        var drawerSlide = drawerType !== 'back';
        var containerSlide = drawerType !== 'front';
        var reverseContentDirection = _reactNative.I18nManager.isRTL ? fromLeft : !fromLeft;
        var dynamicDrawerStyles = {
          backgroundColor: drawerBackgroundColor,
          width: drawerWidth
        };
        var openValue = _this.openValue;
        (0, _invariant.default)(openValue, 'should be set');
        var containerStyles;

        if (containerSlide) {
          var containerTranslateX = openValue.interpolate({
            inputRange: [0, 1],
            outputRange: fromLeft ? [0, drawerWidth] : [0, -drawerWidth],
            extrapolate: 'clamp'
          });
          containerStyles = {
            transform: [{
              translateX: containerTranslateX
            }]
          };
        }

        var drawerTranslateX = 0;

        if (drawerSlide) {
          var closedDrawerOffset = fromLeft ? -drawerWidth : drawerWidth;

          if (_this.state.drawerState !== IDLE) {
            drawerTranslateX = openValue.interpolate({
              inputRange: [0, 1],
              outputRange: [closedDrawerOffset, 0],
              extrapolate: 'clamp'
            });
          } else {
            drawerTranslateX = _this.state.drawerOpened ? 0 : closedDrawerOffset;
          }
        }

        var drawerStyles = {
          transform: [{
            translateX: drawerTranslateX
          }],
          flexDirection: reverseContentDirection ? 'row-reverse' : 'row'
        };
        return React.createElement(_reactNative.Animated.View, {
          style: styles.main,
          onLayout: _this.handleContainerLayout
        }, React.createElement(_reactNative.Animated.View, {
          style: [drawerType === 'front' ? styles.containerOnBack : styles.containerInFront, containerStyles, contentContainerStyle],
          importantForAccessibility: _this.drawerShown ? 'no-hide-descendants' : 'yes'
        }, typeof _this.props.children === 'function' ? _this.props.children(_this.openValue) : _this.props.children, _this.renderOverlay()), React.createElement(_reactNative.Animated.View, {
          pointerEvents: "box-none",
          ref: _this.accessibilityIsModalView,
          accessibilityViewIsModal: _this.drawerShown,
          style: [styles.drawerContainer, drawerStyles, drawerContainerStyle]
        }, React.createElement(_reactNative.View, {
          style: dynamicDrawerStyles
        }, _this.props.renderNavigationView(_this.openValue))));
      };

      _this.setPanGestureRef = function (ref) {
        _this.panGestureHandler.current = ref;
        _this.props.onGestureRef == null ? undefined : _this.props.onGestureRef(ref);
      };

      var _dragX = new _reactNative.Animated.Value(0);

      var _touchX = new _reactNative.Animated.Value(0);

      var _drawerTranslation = new _reactNative.Animated.Value(0);

      _this.state = {
        dragX: _dragX,
        touchX: _touchX,
        drawerTranslation: _drawerTranslation,
        containerWidth: 0,
        drawerState: IDLE,
        drawerOpened: false
      };

      _this.updateAnimatedEvent(_props, _this.state);

      return _this;
    }

    (0, _createClass2.default)(DrawerLayout, [{
      key: "UNSAFE_componentWillUpdate",
      value: function UNSAFE_componentWillUpdate(props, state) {
        if (this.props.drawerPosition !== props.drawerPosition || this.props.drawerWidth !== props.drawerWidth || this.props.drawerType !== props.drawerType || this.state.containerWidth !== state.containerWidth) {
          this.updateAnimatedEvent(props, state);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props4 = this.props,
            drawerPosition = _this$props4.drawerPosition,
            drawerLockMode = _this$props4.drawerLockMode,
            edgeWidth = _this$props4.edgeWidth,
            minSwipeDistance = _this$props4.minSwipeDistance;
        var fromLeft = drawerPosition === 'left';
        var gestureOrientation = (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);
        var hitSlop = fromLeft ? {
          left: 0,
          width: this.drawerShown ? undefined : edgeWidth
        } : {
          right: 0,
          width: this.drawerShown ? undefined : edgeWidth
        };
        return React.createElement(_$$_REQUIRE(_dependencyMap[12]).PanGestureHandler, {
          ref: this.setPanGestureRef,
          hitSlop: hitSlop,
          activeOffsetX: gestureOrientation * minSwipeDistance,
          failOffsetY: [-15, 15],
          onGestureEvent: this.onGestureEvent,
          onHandlerStateChange: this.openingHandlerStateChange,
          enableTrackpadTwoFingerGesture: this.props.enableTrackpadTwoFingerGesture,
          enabled: drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open'
        }, this.renderDrawer());
      }
    }]);
    return DrawerLayout;
  }(React.Component);

  exports.default = DrawerLayout;
  DrawerLayout.defaultProps = {
    drawerWidth: 200,
    drawerPosition: 'left',
    useNativeAnimations: true,
    drawerType: 'front',
    edgeWidth: 20,
    minSwipeDistance: 3,
    overlayColor: 'rgba(0, 0, 0, 0.7)',
    drawerLockMode: 'unlocked',
    enableTrackpadTwoFingerGesture: false
  };
  DrawerLayout.positions = {
    Left: 'left',
    Right: 'right'
  };

  var styles = _reactNative.StyleSheet.create({
    drawerContainer: (0, _extends2.default)({}, _reactNative.StyleSheet.absoluteFillObject, {
      zIndex: 1001,
      flexDirection: 'row'
    }),
    containerInFront: (0, _extends2.default)({}, _reactNative.StyleSheet.absoluteFillObject, {
      zIndex: 1002
    }),
    containerOnBack: (0, _extends2.default)({}, _reactNative.StyleSheet.absoluteFillObject),
    main: {
      flex: 1,
      zIndex: 0,
      overflow: 'hidden'
    },
    overlay: (0, _extends2.default)({}, _reactNative.StyleSheet.absoluteFillObject, {
      zIndex: 1000
    })
  });
},"node_modules/react-native-gesture-handler/src/components/DrawerLayout.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/react/index.js","node_modules/invariant/browser.js","node_modules/react-native/index.js","node_modules/react-native-gesture-handler/src/State.ts","node_modules/react-native-gesture-handler/src/handlers/TapGestureHandler.ts","node_modules/react-native-gesture-handler/src/handlers/PanGestureHandler.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = React.createContext(null);

  exports.default = _default;
},"node_modules/@react-navigation/stack/src/utils/GestureHandlerRefContext.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MaybeScreenContainer = exports.MaybeScreen = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[4]);

  var _excluded = ["enabled"],
      _excluded2 = ["enabled", "active"];

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var Screens;

  try {
    Screens = _$$_REQUIRE(_dependencyMap[5]);
  } catch (e) {}

  var MaybeScreenContainer = function MaybeScreenContainer(_ref) {
    var enabled = _ref.enabled,
        rest = (0, _objectWithoutProperties2.default)(_ref, _excluded);

    if (Screens != null) {
      return React.createElement(Screens.ScreenContainer, (0, _extends2.default)({
        enabled: enabled
      }, rest));
    }

    return React.createElement(_reactNative.View, rest);
  };

  exports.MaybeScreenContainer = MaybeScreenContainer;

  var MaybeScreen = function MaybeScreen(_ref2) {
    var enabled = _ref2.enabled,
        active = _ref2.active,
        rest = (0, _objectWithoutProperties2.default)(_ref2, _excluded2);

    if (Screens != null) {
      return React.createElement(Screens.Screen, (0, _extends2.default)({
        enabled: enabled,
        activityState: active
      }, rest));
    }

    return React.createElement(_reactNative.View, rest);
  };

  exports.MaybeScreen = MaybeScreen;
},"node_modules/@react-navigation/stack/src/views/Screens.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/react-native-screens/src/index.native.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _classCallCheck2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _createClass2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _inherits2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));

  var _possibleConstructorReturn2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[5]));

  var _getPrototypeOf2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[6]));

  var _objectWithoutProperties2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[7]));

  var _slicedToArray2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[8]));

  var _react = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[9]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[10]);

  var _processColor = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[11]));

  var _TransitionProgressContext = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[12]));

  var _useTransitionProgress = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[13]));

  var _excluded = ["children"],
      _excluded2 = ["enabled"],
      _excluded3 = ["active", "activityState", "children", "isNativeStack", "statusBarColor"],
      _excluded4 = ["active", "activityState", "style", "onComponentRef"],
      _excluded5 = ["enabled", "hasTwoStates"];

  var _global;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var isPlatformSupported = _reactNative.Platform.OS === 'ios' || _reactNative.Platform.OS === 'android' || _reactNative.Platform.OS === 'windows';
  var ENABLE_SCREENS = isPlatformSupported;
  var ENABLE_FABRIC = !!((_global = global) != null && _global.nativeFabricUIManager);
  var FabricComponents = ENABLE_FABRIC ? _$$_REQUIRE(_dependencyMap[14]) : {};

  function enableScreens() {
    var shouldEnableScreens = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    ENABLE_SCREENS = isPlatformSupported && shouldEnableScreens;

    if (ENABLE_SCREENS && !_reactNative.UIManager.getViewManagerConfig('RNSScreen')) {
      console.error("Screen native module hasn't been linked. Please check the react-native-screens README for more details");
    }
  }

  var ENABLE_FREEZE = false;

  function enableFreeze() {
    var shouldEnableReactFreeze = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    var minor = parseInt(_$$_REQUIRE(_dependencyMap[15]).version.split('.')[1]);

    if (!(minor === 0 || minor >= 64) && shouldEnableReactFreeze) {
      console.warn('react-freeze library requires at least react-native 0.64. Please upgrade your react-native version in order to use this feature.');
    }

    ENABLE_FREEZE = shouldEnableReactFreeze;
  }

  var shouldUseActivityState = true;

  function screensEnabled() {
    return ENABLE_SCREENS;
  }

  var NativeScreenValue;
  var NativeScreenContainerValue;
  var NativeScreenNavigationContainerValue;
  var NativeScreenStack;
  var NativeScreenStackHeaderConfig;
  var NativeScreenStackHeaderSubview;
  var AnimatedNativeScreen;
  var NativeSearchBar;
  var NativeFullWindowOverlay;
  var ScreensNativeModules = {
    get NativeScreen() {
      NativeScreenValue = NativeScreenValue || FabricComponents.Screen || (0, _reactNative.requireNativeComponent)('RNSScreen');
      return NativeScreenValue;
    },

    get NativeScreenContainer() {
      NativeScreenContainerValue = NativeScreenContainerValue || (0, _reactNative.requireNativeComponent)('RNSScreenContainer');
      return NativeScreenContainerValue;
    },

    get NativeScreenNavigationContainer() {
      NativeScreenNavigationContainerValue = NativeScreenNavigationContainerValue || (_reactNative.Platform.OS === 'ios' ? (0, _reactNative.requireNativeComponent)('RNSScreenNavigationContainer') : this.NativeScreenContainer);
      return NativeScreenNavigationContainerValue;
    },

    get NativeScreenStack() {
      NativeScreenStack = NativeScreenStack || FabricComponents.ScreenStack || (0, _reactNative.requireNativeComponent)('RNSScreenStack');
      return NativeScreenStack;
    },

    get NativeScreenStackHeaderConfig() {
      NativeScreenStackHeaderConfig = NativeScreenStackHeaderConfig || FabricComponents.ScreenStackHeaderConfig || (0, _reactNative.requireNativeComponent)('RNSScreenStackHeaderConfig');
      return NativeScreenStackHeaderConfig;
    },

    get NativeScreenStackHeaderSubview() {
      NativeScreenStackHeaderSubview = NativeScreenStackHeaderSubview || FabricComponents.ScreenStackHeaderSubview || (0, _reactNative.requireNativeComponent)('RNSScreenStackHeaderSubview');
      return NativeScreenStackHeaderSubview;
    },

    get NativeSearchBar() {
      NativeSearchBar = NativeSearchBar || (0, _reactNative.requireNativeComponent)('RNSSearchBar');
      return NativeSearchBar;
    },

    get NativeFullWindowOverlay() {
      NativeFullWindowOverlay = NativeFullWindowOverlay || (0, _reactNative.requireNativeComponent)('RNSFullWindowOverlay');
      return NativeFullWindowOverlay;
    }

  };

  function DelayedFreeze(_ref) {
    var freeze = _ref.freeze,
        children = _ref.children;

    var _React$useState = _react.default.useState(false),
        _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
        freezeState = _React$useState2[0],
        setFreezeState = _React$useState2[1];

    if (freeze !== freezeState) {
      setImmediate(function () {
        setFreezeState(freeze);
      });
    }

    return _react.default.createElement(_$$_REQUIRE(_dependencyMap[16]).Freeze, {
      freeze: freeze ? freezeState : false
    }, children);
  }

  function MaybeFreeze(_ref2) {
    var freeze = _ref2.freeze,
        children = _ref2.children;

    if (ENABLE_FREEZE) {
      return _react.default.createElement(DelayedFreeze, {
        freeze: freeze
      }, children);
    } else {
      return _react.default.createElement(_react.default.Fragment, null, children);
    }
  }

  function ScreenStack(props) {
    if (ENABLE_FREEZE) {
      var children = props.children,
          rest = (0, _objectWithoutProperties2.default)(props, _excluded);

      var size = _react.default.Children.count(children);

      var childrenWithFreeze = _react.default.Children.map(children, function (child, index) {
        return _react.default.createElement(DelayedFreeze, {
          freeze: size - index > 1
        }, child);
      });

      return _react.default.createElement(ScreensNativeModules.NativeScreenStack, rest, childrenWithFreeze);
    }

    return _react.default.createElement(ScreensNativeModules.NativeScreenStack, props);
  }

  var Screen = function (_React$Component) {
    (0, _inherits2.default)(Screen, _React$Component);

    var _super = _createSuper(Screen);

    function Screen() {
      var _this;

      (0, _classCallCheck2.default)(this, Screen);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.ref = null;
      _this.closing = new _reactNative.Animated.Value(0);
      _this.progress = new _reactNative.Animated.Value(0);
      _this.goingForward = new _reactNative.Animated.Value(0);

      _this.setRef = function (ref) {
        _this.ref = ref;
        _this.props.onComponentRef == null ? undefined : _this.props.onComponentRef(ref);
      };

      return _this;
    }

    (0, _createClass2.default)(Screen, [{
      key: "setNativeProps",
      value: function setNativeProps(props) {
        var _this$ref;

        (_this$ref = this.ref) == null ? undefined : _this$ref.setNativeProps(props);
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            _this$props$enabled = _this$props.enabled,
            enabled = _this$props$enabled === undefined ? ENABLE_SCREENS : _this$props$enabled,
            rest = (0, _objectWithoutProperties2.default)(_this$props, _excluded2);

        if (enabled && isPlatformSupported) {
          if (!AnimatedNativeScreen) {
            if (ENABLE_FABRIC) {
              AnimatedNativeScreen = ScreensNativeModules.NativeScreen;
            } else {
              AnimatedNativeScreen = _reactNative.Animated.createAnimatedComponent(ScreensNativeModules.NativeScreen);
            }
          }

          var active = rest.active,
              activityState = rest.activityState,
              children = rest.children,
              isNativeStack = rest.isNativeStack,
              statusBarColor = rest.statusBarColor,
              props = (0, _objectWithoutProperties2.default)(rest, _excluded3);

          if (active !== undefined && activityState === undefined) {
            console.warn('It appears that you are using old version of react-navigation library. Please update @react-navigation/bottom-tabs, @react-navigation/stack and @react-navigation/drawer to version 5.10.0 or above to take full advantage of new functionality added to react-native-screens');
            activityState = active !== 0 ? 2 : 0;
          }

          var processedColor = (0, _processColor.default)(statusBarColor);

          var handleRef = function handleRef(ref) {
            if (!ENABLE_FABRIC) {
              var _ref$viewConfig, _ref$viewConfig$valid;

              if (ref != null && (_ref$viewConfig = ref.viewConfig) != null && (_ref$viewConfig$valid = _ref$viewConfig.validAttributes) != null && _ref$viewConfig$valid.style) {
                ref.viewConfig.validAttributes.style = (0, _extends2.default)({}, ref.viewConfig.validAttributes.style, {
                  display: false
                });
              }

              _this2.setRef(ref);
            }
          };

          return _react.default.createElement(MaybeFreeze, {
            freeze: activityState === 0
          }, _react.default.createElement(AnimatedNativeScreen, (0, _extends2.default)({}, props, {
            statusBarColor: processedColor,
            activityState: activityState,
            ref: handleRef,
            onTransitionProgress: !isNativeStack ? undefined : _reactNative.Animated.event([{
              nativeEvent: {
                progress: this.progress,
                closing: this.closing,
                goingForward: this.goingForward
              }
            }], {
              useNativeDriver: true
            })
          }), !isNativeStack ? children : _react.default.createElement(_TransitionProgressContext.default.Provider, {
            value: {
              progress: this.progress,
              closing: this.closing,
              goingForward: this.goingForward
            }
          }, children)));
        } else {
          var _active = rest.active,
              _activityState = rest.activityState,
              style = rest.style,
              onComponentRef = rest.onComponentRef,
              _props = (0, _objectWithoutProperties2.default)(rest, _excluded4);

          if (_active !== undefined && _activityState === undefined) {
            _activityState = _active !== 0 ? 2 : 0;
          }

          return _react.default.createElement(_reactNative.Animated.View, (0, _extends2.default)({
            style: [style, {
              display: _activityState !== 0 ? 'flex' : 'none'
            }],
            ref: this.setRef
          }, _props));
        }
      }
    }]);
    return Screen;
  }(_react.default.Component);

  function ScreenContainer(props) {
    var _props$enabled = props.enabled,
        enabled = _props$enabled === undefined ? ENABLE_SCREENS : _props$enabled,
        hasTwoStates = props.hasTwoStates,
        rest = (0, _objectWithoutProperties2.default)(props, _excluded5);

    if (enabled && isPlatformSupported) {
      if (hasTwoStates) {
        return _react.default.createElement(ScreensNativeModules.NativeScreenNavigationContainer, rest);
      }

      return _react.default.createElement(ScreensNativeModules.NativeScreenContainer, rest);
    }

    return _react.default.createElement(_reactNative.View, rest);
  }

  var styles = _reactNative.StyleSheet.create({
    headerSubview: {
      position: 'absolute',
      top: 0,
      right: 0,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center'
    }
  });

  var ScreenStackHeaderBackButtonImage = function ScreenStackHeaderBackButtonImage(props) {
    return _react.default.createElement(ScreensNativeModules.NativeScreenStackHeaderSubview, {
      type: "back",
      style: styles.headerSubview
    }, _react.default.createElement(_reactNative.Image, (0, _extends2.default)({
      resizeMode: "center",
      fadeDuration: 0
    }, props)));
  };

  var ScreenStackHeaderRightView = function ScreenStackHeaderRightView(props) {
    return _react.default.createElement(ScreensNativeModules.NativeScreenStackHeaderSubview, (0, _extends2.default)({}, props, {
      type: "right",
      style: styles.headerSubview
    }));
  };

  var ScreenStackHeaderLeftView = function ScreenStackHeaderLeftView(props) {
    return _react.default.createElement(ScreensNativeModules.NativeScreenStackHeaderSubview, (0, _extends2.default)({}, props, {
      type: "left",
      style: styles.headerSubview
    }));
  };

  var ScreenStackHeaderCenterView = function ScreenStackHeaderCenterView(props) {
    return _react.default.createElement(ScreensNativeModules.NativeScreenStackHeaderSubview, (0, _extends2.default)({}, props, {
      type: "center",
      style: styles.headerSubview
    }));
  };

  var ScreenStackHeaderSearchBarView = function ScreenStackHeaderSearchBarView(props) {
    return _react.default.createElement(ScreensNativeModules.NativeScreenStackHeaderSubview, (0, _extends2.default)({}, props, {
      type: "searchBar",
      style: styles.headerSubview
    }));
  };

  var ScreenContext = _react.default.createContext(Screen);

  module.exports = {
    Screen: Screen,
    ScreenContainer: ScreenContainer,
    ScreenContext: ScreenContext,
    ScreenStack: ScreenStack,

    get NativeScreen() {
      return ScreensNativeModules.NativeScreen;
    },

    get NativeScreenContainer() {
      return ScreensNativeModules.NativeScreenContainer;
    },

    get NativeScreenNavigationContainer() {
      return ScreensNativeModules.NativeScreenNavigationContainer;
    },

    get ScreenStackHeaderConfig() {
      return ScreensNativeModules.NativeScreenStackHeaderConfig;
    },

    get ScreenStackHeaderSubview() {
      return ScreensNativeModules.NativeScreenStackHeaderSubview;
    },

    get SearchBar() {
      if (!_$$_REQUIRE(_dependencyMap[17]).isSearchBarAvailableForCurrentPlatform) {
        console.warn('Importing SearchBar is only valid on iOS and Android devices.');
        return _reactNative.View;
      }

      return ScreensNativeModules.NativeSearchBar;
    },

    get FullWindowOverlay() {
      if (_reactNative.Platform.OS !== 'ios') {
        console.warn('Importing FullWindowOverlay is only valid on iOS devices.');
        return _reactNative.View;
      }

      return ScreensNativeModules.NativeFullWindowOverlay;
    },

    ScreenStackHeaderBackButtonImage: ScreenStackHeaderBackButtonImage,
    ScreenStackHeaderRightView: ScreenStackHeaderRightView,
    ScreenStackHeaderLeftView: ScreenStackHeaderLeftView,
    ScreenStackHeaderCenterView: ScreenStackHeaderCenterView,
    ScreenStackHeaderSearchBarView: ScreenStackHeaderSearchBarView,
    enableScreens: enableScreens,
    enableFreeze: enableFreeze,
    screensEnabled: screensEnabled,
    shouldUseActivityState: shouldUseActivityState,
    useTransitionProgress: _useTransitionProgress.default,
    isSearchBarAvailableForCurrentPlatform: _$$_REQUIRE(_dependencyMap[17]).isSearchBarAvailableForCurrentPlatform,
    executeNativeBackPress: _$$_REQUIRE(_dependencyMap[17]).executeNativeBackPress
  };
},"node_modules/react-native-screens/src/index.native.tsx",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","node_modules/@babel/runtime/helpers/inherits.js","node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","node_modules/@babel/runtime/helpers/getPrototypeOf.js","node_modules/@babel/runtime/helpers/objectWithoutProperties.js","node_modules/@babel/runtime/helpers/slicedToArray.js","node_modules/react/index.js","node_modules/react-native/index.js","node_modules/react-native/Libraries/StyleSheet/processColor.js","node_modules/react-native-screens/src/TransitionProgressContext.tsx","node_modules/react-native-screens/src/useTransitionProgress.tsx","node_modules/react-native-screens/src/fabric/index.js","node_modules/react-native/package.json","node_modules/react-freeze/src/index.tsx","node_modules/react-native-screens/src/utils.ts"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = React.createContext(undefined);

  exports.default = _default;
},"node_modules/react-native-screens/src/TransitionProgressContext.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useTransitionProgress;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _TransitionProgressContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useTransitionProgress() {
    var progress = React.useContext(_TransitionProgressContext.default);

    if (progress === undefined) {
      throw new Error("Couldn't find values for transition progress. Are you inside a screen in Native Stack?");
    }

    return progress;
  }
},"node_modules/react-native-screens/src/useTransitionProgress.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native-screens/src/TransitionProgressContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "Screen", {
    enumerable: true,
    get: function get() {
      return _Screen.default;
    }
  });
  Object.defineProperty(exports, "ScreenStack", {
    enumerable: true,
    get: function get() {
      return _ScreenStack.default;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderConfig", {
    enumerable: true,
    get: function get() {
      return _ScreenStackHeaderConfigNativeComponent.default;
    }
  });
  Object.defineProperty(exports, "ScreenStackHeaderSubview", {
    enumerable: true,
    get: function get() {
      return _ScreenStackHeaderSubview.default;
    }
  });

  var _Screen = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _ScreenStackHeaderSubview = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _ScreenStackHeaderConfigNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _ScreenStack = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[4]));
},"node_modules/react-native-screens/src/fabric/index.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native-screens/src/fabric/Screen.js","node_modules/react-native-screens/src/fabric/ScreenStackHeaderSubview.js","node_modules/react-native-screens/src/fabric/ScreenStackHeaderConfigNativeComponent.js","node_modules/react-native-screens/src/fabric/ScreenStack.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _react = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _ScreenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[4]);

  function Screen(props, ref) {
    return _react.default.createElement(_ScreenNativeComponent.default, (0, _extends2.default)({
      ref: ref
    }, props, {
      style: [props.style, _reactNative.StyleSheet.absoluteFill]
    }));
  }

  var _default = _react.default.forwardRef(Screen);

  exports.default = _default;
},"node_modules/react-native-screens/src/fabric/Screen.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/react-native-screens/src/fabric/ScreenNativeComponent.js","node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _default = (0, _codegenNativeComponent.default)('RNSScreen', {
    interfaceOnly: true
  });

  exports.default = _default;
},"node_modules/react-native-screens/src/fabric/ScreenNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _react = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _ScreenStackHeaderSubviewNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  var _reactNative = _$$_REQUIRE(_dependencyMap[4]);

  var styles = _reactNative.StyleSheet.create({
    headerSubview: {
      position: 'absolute',
      top: 0,
      right: 0,
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center'
    }
  });

  function ScreenStackHeaderSubview(props) {
    return _react.default.createElement(_ScreenStackHeaderSubviewNativeComponent.default, (0, _extends2.default)({}, props, {
      style: styles.headerSubview
    }));
  }

  var _default = ScreenStackHeaderSubview;
  exports.default = _default;
},"node_modules/react-native-screens/src/fabric/ScreenStackHeaderSubview.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/react-native-screens/src/fabric/ScreenStackHeaderSubviewNativeComponent.js","node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = (0, _codegenNativeComponent.default)('RNSScreenStackHeaderSubview', {});

  exports.default = _default;
},"node_modules/react-native-screens/src/fabric/ScreenStackHeaderSubviewNativeComponent.js",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  var _default = (0, _codegenNativeComponent.default)('RNSScreenStackHeaderConfig', {});

  exports.default = _default;
},"node_modules/react-native-screens/src/fabric/ScreenStackHeaderConfigNativeComponent.js",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _extends2 = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _react = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[2]));

  var _ScreenStackNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[3]));

  function ScreenStack(props) {
    return _react.default.createElement(_ScreenStackNativeComponent.default, (0, _extends2.default)({}, props, {
      style: [{
        flex: 1
      }, props.style]
    }));
  }

  var _default = ScreenStack;
  exports.default = _default;
},"node_modules/react-native-screens/src/fabric/ScreenStack.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@babel/runtime/helpers/extends.js","node_modules/react/index.js","node_modules/react-native-screens/src/fabric/ScreenStackNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;

  var _codegenNativeComponent = _$$_REQUIRE(_dependencyMap[0])(_$$_REQUIRE(_dependencyMap[1]));

  var _default = (0, _codegenNativeComponent.default)('RNSScreenStack', {});

  exports.default = _default;
},"node_modules/react-native-screens/src/fabric/ScreenStackNativeComponent.js",["node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/react-native/Libraries/Utilities/codegenNativeComponent.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Freeze = Freeze;

  var _react = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function Suspender(_ref) {
    var freeze = _ref.freeze,
        children = _ref.children;
    var promiseCache = (0, _react.useRef)({}).current;

    if (freeze && !promiseCache.promise) {
      promiseCache.promise = new Promise(function (res) {
        promiseCache.resolve = res;
      });
      throw promiseCache.promise;
    } else if (freeze) {
      throw promiseCache.promise;
    } else if (promiseCache.promise) {
      promiseCache.resolve();
      promiseCache.promise = undefined;
    }

    return _react.default.createElement(_react.Fragment, null, children);
  }

  function Freeze(_ref2) {
    var freeze = _ref2.freeze,
        children = _ref2.children,
        _ref2$placeholder = _ref2.placeholder,
        placeholder = _ref2$placeholder === undefined ? null : _ref2$placeholder;
    return _react.default.createElement(_react.Suspense, {
      fallback: placeholder
    }, _react.default.createElement(Suspender, {
      freeze: freeze
    }, children));
  }
},"node_modules/react-freeze/src/index.tsx",["node_modules/react/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.executeNativeBackPress = executeNativeBackPress;
  exports.isSearchBarAvailableForCurrentPlatform = undefined;

  var _reactNative = _$$_REQUIRE(_dependencyMap[0]);

  var isSearchBarAvailableForCurrentPlatform = ['ios', 'android'].includes(_reactNative.Platform.OS);
  exports.isSearchBarAvailableForCurrentPlatform = isSearchBarAvailableForCurrentPlatform;

  function executeNativeBackPress() {
    _reactNative.BackHandler.exitApp();

    return true;
  }
},"node_modules/react-native-screens/src/utils.ts",["node_modules/react-native/index.js"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useCardAnimation;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _CardAnimationContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useCardAnimation() {
    var animation = React.useContext(_CardAnimationContext.default);

    if (animation === undefined) {
      throw new Error("Couldn't find values for card animation. Are you inside a screen in Stack?");
    }

    return animation;
  }
},"node_modules/@react-navigation/stack/src/utils/useCardAnimation.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/stack/src/utils/CardAnimationContext.tsx"]);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = useGestureHandlerRef;

  var React = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0]));

  var _GestureHandlerRefContext = _$$_REQUIRE(_dependencyMap[1])(_$$_REQUIRE(_dependencyMap[2]));

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function useGestureHandlerRef() {
    var ref = React.useContext(_GestureHandlerRefContext.default);

    if (ref === undefined) {
      throw new Error("Couldn't find a ref for gesture handler. Are you inside a screen in Stack?");
    }

    return ref;
  }
},"node_modules/@react-navigation/stack/src/utils/useGestureHandlerRef.tsx",["node_modules/react/index.js","node_modules/@babel/runtime/helpers/interopRequireDefault.js","node_modules/@react-navigation/stack/src/utils/GestureHandlerRefContext.tsx"]);
__r("node_modules/react-native/Libraries/Core/InitializeCore.js");
__r("common.bundle.js");
//# sourceMappingURL=index.ios.bundle.js.map